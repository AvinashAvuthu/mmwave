diff -Naru a/bindings/callbacks_list.py b/bindings/callbacks_list.py
--- a/bindings/callbacks_list.py	2018-08-03 16:38:46.499805375 +0200
+++ b/bindings/callbacks_list.py	2018-08-03 16:39:02.863957410 +0200
@@ -26,14 +26,22 @@
     ['void', 'ns3::Ptr<ns3::Socket>', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['bool', 'ns3::Ptr<ns3::Packet>', 'const ns3::Address &', 'const ns3::Address &', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'ns3::EpcUeNas::State', 'ns3::EpcUeNas::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned short', 'unsigned short', 'unsigned int', 'unsigned long', 'bool', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'const ns3::SpectrumValue &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned short', 'unsigned char', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned short', 'unsigned char', 'unsigned int', 'unsigned long', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned short', 'unsigned char', 'unsigned int', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned int', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'ns3::Time', 'ns3::Time', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'ns3::Ptr<const ns3::QueueDiscItem>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'ns3::Ptr<const ns3::QueueDiscItem>', 'const char *', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'bool', 'bool', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned long', 'unsigned short', 'unsigned short', 'ns3::UeManager::State', 'ns3::UeManager::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned long', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned long', 'unsigned short', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned long', 'unsigned short', 'unsigned short', 'ns3::LteRrcSap::MeasurementReport', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned long', 'unsigned short', 'long double', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'ns3::DlSchedulingCallbackInfo', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned int', 'unsigned int', 'unsigned short', 'unsigned char', 'unsigned short', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned long', 'unsigned short', 'unsigned short', 'ns3::LteUeRrc::State', 'ns3::LteUeRrc::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
diff -Naru a/bindings/modulegen__gcc_LP64.py b/bindings/modulegen__gcc_LP64.py
--- a/bindings/modulegen__gcc_LP64.py	2018-08-03 16:38:46.499805375 +0200
+++ b/bindings/modulegen__gcc_LP64.py	2018-08-03 16:39:02.867957448 +0200
@@ -20,6 +20,10 @@
 def register_types(module):
     root_module = module.get_root()
     
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDiscSizePolicy [enumeration]
+    module.add_enum('QueueDiscSizePolicy', ['SINGLE_INTERNAL_QUEUE', 'SINGLE_CHILD_QUEUE_DISC', 'MULTIPLE_QUEUES', 'NO_LIMITS'], import_from_module='ns.traffic-control')
+    ## queue-size.h (module 'network'): ns3::QueueSizeUnit [enumeration]
+    module.add_enum('QueueSizeUnit', ['PACKETS', 'BYTES'], import_from_module='ns.network')
     ## log.h (module 'core'): ns3::LogLevel [enumeration]
     module.add_enum('LogLevel', ['LOG_NONE', 'LOG_ERROR', 'LOG_LEVEL_ERROR', 'LOG_WARN', 'LOG_LEVEL_WARN', 'LOG_DEBUG', 'LOG_LEVEL_DEBUG', 'LOG_INFO', 'LOG_LEVEL_INFO', 'LOG_FUNCTION', 'LOG_LEVEL_FUNCTION', 'LOG_LOGIC', 'LOG_LEVEL_LOGIC', 'LOG_ALL', 'LOG_LEVEL_ALL', 'LOG_PREFIX_FUNC', 'LOG_PREFIX_TIME', 'LOG_PREFIX_NODE', 'LOG_PREFIX_LEVEL', 'LOG_PREFIX_ALL'], import_from_module='ns.core')
     ## ff-mac-common.h (module 'lte'): ns3::Result_e [enumeration]
@@ -109,6 +113,12 @@
     module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::NixVector'])
     ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::Packet> [struct]
     module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::Packet'])
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::QueueItem> [struct]
+    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::QueueItem'])
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::S1apConnectionInfo> [struct]
+    module.add_class('DefaultDeleter', template_parameters=['ns3::S1apConnectionInfo'])
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::S1apIfaceInfo> [struct]
+    module.add_class('DefaultDeleter', template_parameters=['ns3::S1apIfaceInfo'])
     ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::SpectrumModel> [struct]
     module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::SpectrumModel'])
     ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::SpectrumValue> [struct]
@@ -189,20 +199,24 @@
     module.add_class('ModifyBearerRequestMessage', parent=root_module['ns3::EpcS11Sap::GtpcMessage'], outer_class=root_module['ns3::EpcS11SapSgw'])
     ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap [class]
     module.add_class('EpcS1apSap')
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSetupItem [struct]
+    module.add_class('ErabSetupItem', outer_class=root_module['ns3::EpcS1apSap'])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInDownlinkItem [struct]
+    module.add_class('ErabSwitchedInDownlinkItem', outer_class=root_module['ns3::EpcS1apSap'])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInUplinkItem [struct]
+    module.add_class('ErabSwitchedInUplinkItem', outer_class=root_module['ns3::EpcS1apSap'])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeReleasedIndication [struct]
+    module.add_class('ErabToBeReleasedIndication', outer_class=root_module['ns3::EpcS1apSap'])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem [struct]
+    module.add_class('ErabToBeSetupItem', outer_class=root_module['ns3::EpcS1apSap'])
     ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb [class]
     module.add_class('EpcS1apSapEnb', parent=root_module['ns3::EpcS1apSap'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem [struct]
-    module.add_class('ErabSwitchedInUplinkItem', outer_class=root_module['ns3::EpcS1apSapEnb'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem [struct]
-    module.add_class('ErabToBeSetupItem', outer_class=root_module['ns3::EpcS1apSapEnb'])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnbProvider [class]
+    module.add_class('EpcS1apSapEnbProvider', parent=root_module['ns3::EpcS1apSap'])
     ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme [class]
     module.add_class('EpcS1apSapMme', parent=root_module['ns3::EpcS1apSap'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem [struct]
-    module.add_class('ErabSetupItem', outer_class=root_module['ns3::EpcS1apSapMme'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem [struct]
-    module.add_class('ErabSwitchedInDownlinkItem', outer_class=root_module['ns3::EpcS1apSapMme'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabToBeReleasedIndication [struct]
-    module.add_class('ErabToBeReleasedIndication', outer_class=root_module['ns3::EpcS1apSapMme'])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMmeProvider [class]
+    module.add_class('EpcS1apSapMmeProvider', parent=root_module['ns3::EpcS1apSap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap [class]
     module.add_class('EpcX2Sap')
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UlInterferenceOverloadIndicationItem [enumeration]
@@ -225,6 +239,8 @@
     module.add_class('ErabToBeSetupItem', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem [struct]
     module.add_class('ErabsSubjectToStatusTransferItem', outer_class=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams [struct]
+    module.add_class('HandoverFailedParams', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverPreparationFailureParams [struct]
     module.add_class('HandoverPreparationFailureParams', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestAckParams [struct]
@@ -237,12 +253,22 @@
     module.add_class('RelativeNarrowbandTxBand', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ResourceStatusUpdateParams [struct]
     module.add_class('ResourceStatusUpdateParams', outer_class=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest [struct]
+    module.add_class('RlcSetupRequest', outer_class=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams [struct]
+    module.add_class('SecondaryHandoverCompletedParams', outer_class=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverParams [struct]
+    module.add_class('SecondaryHandoverParams', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SnStatusTransferParams [struct]
     module.add_class('SnStatusTransferParams', outer_class=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams [struct]
+    module.add_class('SwitchConnectionParams', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeContextReleaseParams [struct]
     module.add_class('UeContextReleaseParams', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeDataParams [struct]
     module.add_class('UeDataParams', outer_class=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeImsiSinrParams [struct]
+    module.add_class('UeImsiSinrParams', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UlHighInterferenceInformationItem [struct]
     module.add_class('UlHighInterferenceInformationItem', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2SapProvider [class]
@@ -252,7 +278,7 @@
     ## eps-bearer.h (module 'lte'): ns3::EpsBearer [struct]
     module.add_class('EpsBearer')
     ## eps-bearer.h (module 'lte'): ns3::EpsBearer::Qci [enumeration]
-    module.add_enum('Qci', ['GBR_CONV_VOICE', 'GBR_CONV_VIDEO', 'GBR_GAMING', 'GBR_NON_CONV_VIDEO', 'NGBR_IMS', 'NGBR_VIDEO_TCP_OPERATOR', 'NGBR_VOICE_VIDEO_GAMING', 'NGBR_VIDEO_TCP_PREMIUM', 'NGBR_VIDEO_TCP_DEFAULT'], outer_class=root_module['ns3::EpsBearer'])
+    module.add_enum('Qci', ['GBR_CONV_VOICE', 'GBR_CONV_VIDEO', 'GBR_GAMING', 'GBR_NON_CONV_VIDEO', 'NGBR_IMS', 'NGBR_VIDEO_TCP_OPERATOR', 'NGBR_VOICE_VIDEO_GAMING', 'NGBR_VIDEO_TCP_PREMIUM', 'NGBR_VIDEO_TCP_DEFAULT', 'GBR_ULTRA_LOW_LAT'], outer_class=root_module['ns3::EpsBearer'])
     ## lte-common.h (module 'lte'): ns3::EutranMeasurementMapping [class]
     module.add_class('EutranMeasurementMapping')
     ## event-id.h (module 'core'): ns3::EventId [class]
@@ -429,7 +455,9 @@
     ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapProvider [class]
     module.add_class('LteEnbCphySapProvider', allow_subclassing=True)
     ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser [class]
-    module.add_class('LteEnbCphySapUser')
+    module.add_class('LteEnbCphySapUser', allow_subclassing=True)
+    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::UeAssociatedSinrInfo [struct]
+    module.add_class('UeAssociatedSinrInfo', outer_class=root_module['ns3::LteEnbCphySapUser'])
     ## lte-enb-phy-sap.h (module 'lte'): ns3::LteEnbPhySapProvider [class]
     module.add_class('LteEnbPhySapProvider', allow_subclassing=True)
     ## lte-enb-phy-sap.h (module 'lte'): ns3::LteEnbPhySapUser [class]
@@ -476,6 +504,8 @@
     module.add_class('TransmitPdcpPduParameters', outer_class=root_module['ns3::LteRlcSapProvider'])
     ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapUser [class]
     module.add_class('LteRlcSapUser', allow_subclassing=True)
+    ## lte-rlc.h (module 'lte'): ns3::LteRlcSpecificLteMacSapUser [class]
+    module.add_class('LteRlcSpecificLteMacSapUser', parent=root_module['ns3::LteMacSapUser'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap [class]
     module.add_class('LteRrcSap')
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReestablishmentCause [enumeration]
@@ -607,7 +637,7 @@
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RlcConfig [struct]
     module.add_class('RlcConfig', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RlcConfig::direction [enumeration]
-    module.add_enum('direction', ['AM', 'UM_BI_DIRECTIONAL', 'UM_UNI_DIRECTIONAL_UL', 'UM_UNI_DIRECTIONAL_DL'], outer_class=root_module['ns3::LteRrcSap::RlcConfig'])
+    module.add_enum('direction', ['AM', 'UM_BI_DIRECTIONAL', 'UM_UNI_DIRECTIONAL_UL', 'UM_UNI_DIRECTIONAL_DL', 'UM_BI_DIRECTIONAL_LOWLAT'], outer_class=root_module['ns3::LteRrcSap::RlcConfig'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration [struct]
     module.add_class('RrcConnectionReconfiguration', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfigurationCompleted [struct]
@@ -630,6 +660,8 @@
     module.add_class('RrcConnectionSetup', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetupCompleted [struct]
     module.add_class('RrcConnectionSetupCompleted', outer_class=root_module['ns3::LteRrcSap'])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch [struct]
+    module.add_class('RrcConnectionSwitch', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod [struct]
     module.add_class('SCellToAddMod', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon [struct]
@@ -777,6 +809,8 @@
     typehandlers.add_type_alias(u'void ( * ) ( ns3::PhyTransmissionStatParameters const )', u'ns3::PhyTransmissionStatParameters::TracedCallback')
     typehandlers.add_type_alias(u'void ( * ) ( ns3::PhyTransmissionStatParameters const )*', u'ns3::PhyTransmissionStatParameters::TracedCallback*')
     typehandlers.add_type_alias(u'void ( * ) ( ns3::PhyTransmissionStatParameters const )&', u'ns3::PhyTransmissionStatParameters::TracedCallback&')
+    ## queue-size.h (module 'network'): ns3::QueueSize [class]
+    module.add_class('QueueSize', import_from_module='ns.network')
     ## ff-mac-common.h (module 'lte'): ns3::RachListElement_s [struct]
     module.add_class('RachListElement_s')
     ## radio-bearer-stats-connector.h (module 'lte'): ns3::RadioBearerStatsConnector [class]
@@ -817,6 +851,10 @@
     module.add_class('TbStats_t')
     ## nstime.h (module 'core'): ns3::TimeWithUnit [class]
     module.add_class('TimeWithUnit', import_from_module='ns.core')
+    ## traced-value.h (module 'core'): ns3::TracedValue<bool> [class]
+    module.add_class('TracedValue', import_from_module='ns.core', template_parameters=['bool'])
+    ## traced-value.h (module 'core'): ns3::TracedValue<unsigned int> [class]
+    module.add_class('TracedValue', import_from_module='ns.core', template_parameters=['unsigned int'])
     ## lte-common.h (module 'lte'): ns3::TransmissionModesLayers [class]
     module.add_class('TransmissionModesLayers')
     ## type-id.h (module 'core'): ns3::TypeId [class]
@@ -880,6 +918,16 @@
     module.add_class('Chunk', import_from_module='ns.network', parent=root_module['ns3::ObjectBase'])
     ## lte-global-pathloss-database.h (module 'lte'): ns3::DownlinkLteGlobalPathlossDatabase [class]
     module.add_class('DownlinkLteGlobalPathlossDatabase', parent=root_module['ns3::LteGlobalPathlossDatabase'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2PdcpProvider [class]
+    module.add_class('EpcX2PdcpProvider', parent=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2PdcpUser [class]
+    module.add_class('EpcX2PdcpUser', parent=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2RlcProvider [class]
+    module.add_class('EpcX2RlcProvider', parent=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2RlcUser [class]
+    module.add_class('EpcX2RlcUser', parent=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-tag.h (module 'lte'): ns3::EpcX2Tag [class]
+    module.add_class('EpcX2Tag', parent=root_module['ns3::Tag'])
     ## eps-bearer-tag.h (module 'lte'): ns3::EpsBearerTag [class]
     module.add_class('EpsBearerTag', parent=root_module['ns3::Tag'])
     ## header.h (module 'network'): ns3::Header [class]
@@ -983,12 +1031,29 @@
     typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::PacketBurst const > )', u'ns3::PacketBurst::TracedCallback')
     typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::PacketBurst const > )*', u'ns3::PacketBurst::TracedCallback*')
     typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::PacketBurst const > )&', u'ns3::PacketBurst::TracedCallback&')
+    ## packet-filter.h (module 'traffic-control'): ns3::PacketFilter [class]
+    module.add_class('PacketFilter', import_from_module='ns.traffic_control', parent=root_module['ns3::Object'])
     ## lte-pdcp-tag.h (module 'lte'): ns3::PdcpTag [class]
     module.add_class('PdcpTag', parent=root_module['ns3::Tag'])
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc [class]
+    module.add_class('QueueDisc', import_from_module='ns.traffic_control', parent=root_module['ns3::Object'])
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::WakeMode [enumeration]
+    module.add_enum('WakeMode', ['WAKE_ROOT', 'WAKE_CHILD'], outer_class=root_module['ns3::QueueDisc'], import_from_module='ns.traffic-control')
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats [struct]
+    module.add_class('Stats', import_from_module='ns.traffic_control', outer_class=root_module['ns3::QueueDisc'])
+    typehandlers.add_type_alias(u'ns3::Queue< ns3::QueueDiscItem >', u'ns3::QueueDisc::InternalQueue')
+    typehandlers.add_type_alias(u'ns3::Queue< ns3::QueueDiscItem >*', u'ns3::QueueDisc::InternalQueue*')
+    typehandlers.add_type_alias(u'ns3::Queue< ns3::QueueDiscItem >&', u'ns3::QueueDisc::InternalQueue&')
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDiscClass [class]
+    module.add_class('QueueDiscClass', import_from_module='ns.traffic_control', parent=root_module['ns3::Object'])
     ## radio-environment-map-helper.h (module 'lte'): ns3::RadioEnvironmentMapHelper [class]
     module.add_class('RadioEnvironmentMapHelper', parent=root_module['ns3::Object'])
     ## random-variable-stream.h (module 'core'): ns3::RandomVariableStream [class]
     module.add_class('RandomVariableStream', import_from_module='ns.core', parent=root_module['ns3::Object'])
+    ## retx-stats-calculator.h (module 'lte'): ns3::RetxStatsCalculator [class]
+    module.add_class('RetxStatsCalculator', parent=root_module['ns3::Object'])
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo [class]
+    module.add_class('RlcBearerInfo', parent=root_module['ns3::Object'])
     ## lte-rlc-tag.h (module 'lte'): ns3::RlcTag [class]
     module.add_class('RlcTag', parent=root_module['ns3::Tag'])
     ## random-variable-stream.h (module 'core'): ns3::SequentialRandomVariable [class]
@@ -1023,6 +1088,12 @@
     module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::NixVector', 'ns3::empty', 'ns3::DefaultDeleter<ns3::NixVector>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
     ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> > [class]
     module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Packet', 'ns3::empty', 'ns3::DefaultDeleter<ns3::Packet>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::QueueItem, ns3::empty, ns3::DefaultDeleter<ns3::QueueItem> > [class]
+    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::QueueItem', 'ns3::empty', 'ns3::DefaultDeleter<ns3::QueueItem>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apConnectionInfo> > [class]
+    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::S1apConnectionInfo', 'ns3::empty', 'ns3::DefaultDeleter<ns3::S1apConnectionInfo>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apIfaceInfo> > [class]
+    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::S1apIfaceInfo', 'ns3::empty', 'ns3::DefaultDeleter<ns3::S1apIfaceInfo>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
     ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> > [class]
     module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::SpectrumModel', 'ns3::empty', 'ns3::DefaultDeleter<ns3::SpectrumModel>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
     ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> > [class]
@@ -1087,6 +1158,10 @@
     typehandlers.add_type_alias(u'std::pair< ns3::Ptr< ns3::MobilityModel const >, ns3::Ptr< ns3::MobilityModel const > >&', u'ns3::TraceFadingLossModel::ChannelRealizationId_t&')
     ## trace-source-accessor.h (module 'core'): ns3::TraceSourceAccessor [class]
     module.add_class('TraceSourceAccessor', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >'])
+    ## traced-value.h (module 'core'): ns3::TracedValue<ns3::Time> [class]
+    module.add_class('TracedValue', import_from_module='ns.core', template_parameters=['ns3::Time'])
+    ## traced-value.h (module 'core'): ns3::TracedValue<ns3::Time> [class]
+    root_module['ns3::TracedValue< ns3::Time >'].implicitly_converts_to(root_module['ns3::Time'])
     ## trailer.h (module 'network'): ns3::Trailer [class]
     module.add_class('Trailer', import_from_module='ns.network', parent=root_module['ns3::Chunk'])
     ## random-variable-stream.h (module 'core'): ns3::TriangularRandomVariable [class]
@@ -1094,10 +1169,13 @@
     ## lte-enb-rrc.h (module 'lte'): ns3::UeManager [class]
     module.add_class('UeManager', parent=root_module['ns3::Object'])
     ## lte-enb-rrc.h (module 'lte'): ns3::UeManager::State [enumeration]
-    module.add_enum('State', ['INITIAL_RANDOM_ACCESS', 'CONNECTION_SETUP', 'CONNECTION_REJECTED', 'CONNECTED_NORMALLY', 'CONNECTION_RECONFIGURATION', 'CONNECTION_REESTABLISHMENT', 'HANDOVER_PREPARATION', 'HANDOVER_JOINING', 'HANDOVER_PATH_SWITCH', 'HANDOVER_LEAVING', 'NUM_STATES'], outer_class=root_module['ns3::UeManager'])
+    module.add_enum('State', ['INITIAL_RANDOM_ACCESS', 'CONNECTION_SETUP', 'CONNECTION_REJECTED', 'CONNECTED_NORMALLY', 'CONNECTION_RECONFIGURATION', 'CONNECTION_REESTABLISHMENT', 'HANDOVER_PREPARATION', 'HANDOVER_JOINING', 'HANDOVER_PATH_SWITCH', 'HANDOVER_LEAVING', 'PREPARE_MC_CONNECTION_RECONFIGURATION', 'MC_CONNECTION_RECONFIGURATION', 'NUM_STATES'], outer_class=root_module['ns3::UeManager'])
     typehandlers.add_type_alias(u'void ( * ) ( uint64_t const, uint16_t const, uint16_t const, ns3::UeManager::State const, ns3::UeManager::State const )', u'ns3::UeManager::StateTracedCallback')
     typehandlers.add_type_alias(u'void ( * ) ( uint64_t const, uint16_t const, uint16_t const, ns3::UeManager::State const, ns3::UeManager::State const )*', u'ns3::UeManager::StateTracedCallback*')
     typehandlers.add_type_alias(u'void ( * ) ( uint64_t const, uint16_t const, uint16_t const, ns3::UeManager::State const, ns3::UeManager::State const )&', u'ns3::UeManager::StateTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( uint64_t, uint16_t, uint16_t )', u'ns3::UeManager::ImsiCidRntiTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( uint64_t, uint16_t, uint16_t )*', u'ns3::UeManager::ImsiCidRntiTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( uint64_t, uint16_t, uint16_t )&', u'ns3::UeManager::ImsiCidRntiTracedCallback&')
     ## random-variable-stream.h (module 'core'): ns3::UniformRandomVariable [class]
     module.add_class('UniformRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## ff-mac-common.h (module 'lte'): ns3::VendorSpecificValue [struct]
@@ -1114,12 +1192,6 @@
     module.add_class('ZipfRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## application.h (module 'network'): ns3::Application [class]
     module.add_class('Application', import_from_module='ns.network', parent=root_module['ns3::Object'])
-    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time const &, ns3::Address const & )', u'ns3::Application::DelayAddressCallback')
-    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time const &, ns3::Address const & )*', u'ns3::Application::DelayAddressCallback*')
-    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time const &, ns3::Address const & )&', u'ns3::Application::DelayAddressCallback&')
-    typehandlers.add_type_alias(u'void ( * ) ( std::string const &, std::string const & )', u'ns3::Application::StateTransitionCallback')
-    typehandlers.add_type_alias(u'void ( * ) ( std::string const &, std::string const & )*', u'ns3::Application::StateTransitionCallback*')
-    typehandlers.add_type_alias(u'void ( * ) ( std::string const &, std::string const & )&', u'ns3::Application::StateTransitionCallback&')
     ## lte-asn1-header.h (module 'lte'): ns3::Asn1Header [class]
     module.add_class('Asn1Header', parent=root_module['ns3::Header'])
     ## attribute.h (module 'core'): ns3::AttributeAccessor [class]
@@ -1142,6 +1214,10 @@
     module.add_class('CcHelper', parent=root_module['ns3::Object'])
     ## channel.h (module 'network'): ns3::Channel [class]
     module.add_class('Channel', import_from_module='ns.network', parent=root_module['ns3::Object'])
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::CoDelQueueDisc [class]
+    module.add_class('CoDelQueueDisc', import_from_module='ns.traffic_control', parent=root_module['ns3::QueueDisc'])
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::CoDelQueueDisc::QueueDiscMode [enumeration]
+    module.add_enum('QueueDiscMode', ['QUEUE_DISC_MODE_PACKETS', 'QUEUE_DISC_MODE_BYTES'], outer_class=root_module['ns3::CoDelQueueDisc'], import_from_module='ns.traffic-control')
     ## component-carrier.h (module 'lte'): ns3::ComponentCarrier [class]
     module.add_class('ComponentCarrier', parent=root_module['ns3::Object'])
     ## component-carrier-enb.h (module 'lte'): ns3::ComponentCarrierEnb [class]
@@ -1185,6 +1261,28 @@
     module.add_class('EpcHelper', parent=root_module['ns3::Object'])
     ## epc-mme.h (module 'lte'): ns3::EpcMme [class]
     module.add_class('EpcMme', parent=root_module['ns3::Object'])
+    ## epc-mme-application.h (module 'lte'): ns3::EpcMmeApplication [class]
+    module.add_class('EpcMmeApplication', parent=root_module['ns3::Application'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APErabReleaseIndicationHeader [class]
+    module.add_class('EpcS1APErabReleaseIndicationHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APHeader [class]
+    module.add_class('EpcS1APHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APHeader::ProcedureCode_t [enumeration]
+    module.add_enum('ProcedureCode_t', ['InitialUeMessage', 'PathSwitchRequest', 'ErabReleaseIndication', 'InitialContextSetupResponse', 'InitialContextSetupRequest', 'PathSwitchRequestAck'], outer_class=root_module['ns3::EpcS1APHeader'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialContextSetupRequestHeader [class]
+    module.add_class('EpcS1APInitialContextSetupRequestHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialContextSetupResponseHeader [class]
+    module.add_class('EpcS1APInitialContextSetupResponseHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialUeMessageHeader [class]
+    module.add_class('EpcS1APInitialUeMessageHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APPathSwitchRequestAcknowledgeHeader [class]
+    module.add_class('EpcS1APPathSwitchRequestAcknowledgeHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APPathSwitchRequestHeader [class]
+    module.add_class('EpcS1APPathSwitchRequestHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apEnb [class]
+    module.add_class('EpcS1apEnb', parent=root_module['ns3::Object'])
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apMme [class]
+    module.add_class('EpcS1apMme', parent=root_module['ns3::Object'])
     ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcSgwPgwApplication [class]
     module.add_class('EpcSgwPgwApplication', parent=root_module['ns3::Application'])
     typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet > )', u'ns3::EpcSgwPgwApplication::RxTracedCallback')
@@ -1207,6 +1305,11 @@
     typehandlers.add_type_alias(u'void ( * ) ( ns3::EpcUeNas::State const, ns3::EpcUeNas::State const )&', u'ns3::EpcUeNas::StateTracedCallback&')
     ## epc-x2.h (module 'lte'): ns3::EpcX2 [class]
     module.add_class('EpcX2', parent=root_module['ns3::Object'])
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint16_t, uint32_t, uint64_t, bool )', u'ns3::EpcX2::ReceiveTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint16_t, uint32_t, uint64_t, bool )*', u'ns3::EpcX2::ReceiveTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint16_t, uint32_t, uint64_t, bool )&', u'ns3::EpcX2::ReceiveTracedCallback&')
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ConnectionSwitchHeader [class]
+    module.add_class('EpcX2ConnectionSwitchHeader', parent=root_module['ns3::Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverPreparationFailureHeader [class]
     module.add_class('EpcX2HandoverPreparationFailureHeader', parent=root_module['ns3::Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestAckHeader [class]
@@ -1216,17 +1319,29 @@
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header [class]
     module.add_class('EpcX2Header', parent=root_module['ns3::Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header::ProcedureCode_t [enumeration]
-    module.add_enum('ProcedureCode_t', ['HandoverPreparation', 'LoadIndication', 'SnStatusTransfer', 'UeContextRelease', 'ResourceStatusReporting'], outer_class=root_module['ns3::EpcX2Header'])
+    module.add_enum('ProcedureCode_t', ['HandoverPreparation', 'LoadIndication', 'SnStatusTransfer', 'UeContextRelease', 'ResourceStatusReporting', 'RlcSetupRequest', 'RlcSetupCompleted', 'NotifyMcConnection', 'UpdateUeSinr', 'RequestMcHandover', 'NotifyMmWaveLteHandover', 'NotifyCoordinatorHandoverFailed', 'SwitchConnection', 'SecondaryCellHandoverCompleted'], outer_class=root_module['ns3::EpcX2Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header::TypeOfMessage_t [enumeration]
-    module.add_enum('TypeOfMessage_t', ['InitiatingMessage', 'SuccessfulOutcome', 'UnsuccessfulOutcome'], outer_class=root_module['ns3::EpcX2Header'])
+    module.add_enum('TypeOfMessage_t', ['InitiatingMessage', 'SuccessfulOutcome', 'UnsuccessfulOutcome', 'McForwardDownlinkData', 'McForwardUplinkData'], outer_class=root_module['ns3::EpcX2Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2LoadInformationHeader [class]
     module.add_class('EpcX2LoadInformationHeader', parent=root_module['ns3::Header'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2McHandoverHeader [class]
+    module.add_class('EpcX2McHandoverHeader', parent=root_module['ns3::Header'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2NotifyCoordinatorHandoverFailedHeader [class]
+    module.add_class('EpcX2NotifyCoordinatorHandoverFailedHeader', parent=root_module['ns3::Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2ResourceStatusUpdateHeader [class]
     module.add_class('EpcX2ResourceStatusUpdateHeader', parent=root_module['ns3::Header'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2RlcSetupCompletedHeader [class]
+    module.add_class('EpcX2RlcSetupCompletedHeader', parent=root_module['ns3::Header'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2RlcSetupRequestHeader [class]
+    module.add_class('EpcX2RlcSetupRequestHeader', parent=root_module['ns3::Header'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2SecondaryCellHandoverCompletedHeader [class]
+    module.add_class('EpcX2SecondaryCellHandoverCompletedHeader', parent=root_module['ns3::Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2SnStatusTransferHeader [class]
     module.add_class('EpcX2SnStatusTransferHeader', parent=root_module['ns3::Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2UeContextReleaseHeader [class]
     module.add_class('EpcX2UeContextReleaseHeader', parent=root_module['ns3::Header'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2UeImsiSinrUpdateHeader [class]
+    module.add_class('EpcX2UeImsiSinrUpdateHeader', parent=root_module['ns3::Header'])
     ## random-variable-stream.h (module 'core'): ns3::ErlangRandomVariable [class]
     module.add_class('ErlangRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## event-impl.h (module 'core'): ns3::EventImpl [class]
@@ -1294,7 +1409,13 @@
     ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc [class]
     module.add_class('LteEnbRrc', parent=root_module['ns3::Object'])
     ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::LteEpsBearerToRlcMapping_t [enumeration]
-    module.add_enum('LteEpsBearerToRlcMapping_t', ['RLC_SM_ALWAYS', 'RLC_UM_ALWAYS', 'RLC_AM_ALWAYS', 'PER_BASED'], outer_class=root_module['ns3::LteEnbRrc'])
+    module.add_enum('LteEpsBearerToRlcMapping_t', ['RLC_SM_ALWAYS', 'RLC_UM_ALWAYS', 'RLC_AM_ALWAYS', 'PER_BASED', 'RLC_UM_LOWLAT_ALWAYS'], outer_class=root_module['ns3::LteEnbRrc'])
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverMode [enumeration]
+    module.add_enum('HandoverMode', ['FIXED_TTT', 'DYNAMIC_TTT', 'THRESHOLD'], outer_class=root_module['ns3::LteEnbRrc'])
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverEventInfo [struct]
+    module.add_class('HandoverEventInfo', outer_class=root_module['ns3::LteEnbRrc'])
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::MmWaveComponentCarrierConf [struct]
+    module.add_class('MmWaveComponentCarrierConf', outer_class=root_module['ns3::LteEnbRrc'])
     typehandlers.add_type_alias(u'void ( * ) ( uint16_t const, uint16_t const )', u'ns3::LteEnbRrc::NewUeContextTracedCallback')
     typehandlers.add_type_alias(u'void ( * ) ( uint16_t const, uint16_t const )*', u'ns3::LteEnbRrc::NewUeContextTracedCallback*')
     typehandlers.add_type_alias(u'void ( * ) ( uint16_t const, uint16_t const )&', u'ns3::LteEnbRrc::NewUeContextTracedCallback&')
@@ -1307,6 +1428,12 @@
     typehandlers.add_type_alias(u'void ( * ) ( uint64_t const, uint16_t const, uint16_t const, ns3::LteRrcSap::MeasurementReport const )', u'ns3::LteEnbRrc::ReceiveReportTracedCallback')
     typehandlers.add_type_alias(u'void ( * ) ( uint64_t const, uint16_t const, uint16_t const, ns3::LteRrcSap::MeasurementReport const )*', u'ns3::LteEnbRrc::ReceiveReportTracedCallback*')
     typehandlers.add_type_alias(u'void ( * ) ( uint64_t const, uint16_t const, uint16_t const, ns3::LteRrcSap::MeasurementReport const )&', u'ns3::LteEnbRrc::ReceiveReportTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( uint64_t, uint16_t, long double )', u'ns3::LteEnbRrc::NotifyMmWaveSinrTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( uint64_t, uint16_t, long double )*', u'ns3::LteEnbRrc::NotifyMmWaveSinrTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( uint64_t, uint16_t, long double )&', u'ns3::LteEnbRrc::NotifyMmWaveSinrTracedCallback&')
+    typehandlers.add_type_alias(u'std::map< unsigned long, ns3::LteEnbRrc::HandoverEventInfo >', u'ns3::LteEnbRrc::HandoverEventMap')
+    typehandlers.add_type_alias(u'std::map< unsigned long, ns3::LteEnbRrc::HandoverEventInfo >*', u'ns3::LteEnbRrc::HandoverEventMap*')
+    typehandlers.add_type_alias(u'std::map< unsigned long, ns3::LteEnbRrc::HandoverEventInfo >&', u'ns3::LteEnbRrc::HandoverEventMap&')
     ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteEnbRrcProtocolIdeal [class]
     module.add_class('LteEnbRrcProtocolIdeal', parent=root_module['ns3::Object'])
     ## lte-rrc-protocol-real.h (module 'lte'): ns3::LteEnbRrcProtocolReal [class]
@@ -1359,14 +1486,21 @@
     typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint8_t, uint32_t, uint64_t )', u'ns3::LteRlc::ReceiveTracedCallback')
     typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint8_t, uint32_t, uint64_t )*', u'ns3::LteRlc::ReceiveTracedCallback*')
     typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint8_t, uint32_t, uint64_t )&', u'ns3::LteRlc::ReceiveTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint8_t, uint32_t, uint32_t )', u'ns3::LteRlc::RetransmissionCountCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint8_t, uint32_t, uint32_t )*', u'ns3::LteRlc::RetransmissionCountCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint8_t, uint32_t, uint32_t )&', u'ns3::LteRlc::RetransmissionCountCallback&')
     ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm [class]
     module.add_class('LteRlcAm', parent=root_module['ns3::LteRlc'])
+    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::RetxPdu [struct]
+    module.add_class('RetxPdu', outer_class=root_module['ns3::LteRlcAm'])
     ## lte-rlc.h (module 'lte'): ns3::LteRlcSm [class]
     module.add_class('LteRlcSm', parent=root_module['ns3::LteRlc'])
     ## lte-rlc-tm.h (module 'lte'): ns3::LteRlcTm [class]
     module.add_class('LteRlcTm', parent=root_module['ns3::LteRlc'])
     ## lte-rlc-um.h (module 'lte'): ns3::LteRlcUm [class]
     module.add_class('LteRlcUm', parent=root_module['ns3::LteRlc'])
+    ## lte-rlc-um-lowlat.h (module 'lte'): ns3::LteRlcUmLowLat [class]
+    module.add_class('LteRlcUmLowLat', parent=root_module['ns3::LteRlc'])
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteSignalingRadioBearerInfo [class]
     module.add_class('LteSignalingRadioBearerInfo', parent=root_module['ns3::LteRadioBearerInfo'])
     ## lte-spectrum-phy.h (module 'lte'): ns3::LteSpectrumPhy [class]
@@ -1421,9 +1555,9 @@
     typehandlers.add_type_alias(u'void ( * ) ( uint64_t, uint16_t, uint16_t, ns3::LteUeRrc::State, ns3::LteUeRrc::State )', u'ns3::LteUeRrc::StateTracedCallback')
     typehandlers.add_type_alias(u'void ( * ) ( uint64_t, uint16_t, uint16_t, ns3::LteUeRrc::State, ns3::LteUeRrc::State )*', u'ns3::LteUeRrc::StateTracedCallback*')
     typehandlers.add_type_alias(u'void ( * ) ( uint64_t, uint16_t, uint16_t, ns3::LteUeRrc::State, ns3::LteUeRrc::State )&', u'ns3::LteUeRrc::StateTracedCallback&')
-    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::LteUeRrc >, std::list< ns3::LteRrcSap::SCellToAddMod > )', u'ns3::LteUeRrc::SCarrierConfiguredTracedCallback')
-    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::LteUeRrc >, std::list< ns3::LteRrcSap::SCellToAddMod > )*', u'ns3::LteUeRrc::SCarrierConfiguredTracedCallback*')
-    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::LteUeRrc >, std::list< ns3::LteRrcSap::SCellToAddMod > )&', u'ns3::LteUeRrc::SCarrierConfiguredTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::LteUeRrc >, std::list< ns3::LteRrcSap::SCellToAddMod > )', u'ns3::LteUeRrc::SCarrierConfiguredCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::LteUeRrc >, std::list< ns3::LteRrcSap::SCellToAddMod > )*', u'ns3::LteUeRrc::SCarrierConfiguredCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::LteUeRrc >, std::list< ns3::LteRrcSap::SCellToAddMod > )&', u'ns3::LteUeRrc::SCarrierConfiguredCallback&')
     ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteUeRrcProtocolIdeal [class]
     module.add_class('LteUeRrcProtocolIdeal', parent=root_module['ns3::Object'])
     ## lte-rrc-protocol-real.h (module 'lte'): ns3::LteUeRrcProtocolReal [class]
@@ -1438,6 +1572,28 @@
     module.add_class('Mac64AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
     ## mac-stats-calculator.h (module 'lte'): ns3::MacStatsCalculator [class]
     module.add_class('MacStatsCalculator', parent=root_module['ns3::LteStatsCalculator'])
+    ## mac-tx-stats-calculator.h (module 'lte'): ns3::MacTxStatsCalculator [class]
+    module.add_class('MacTxStatsCalculator', parent=root_module['ns3::Object'])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp [class]
+    module.add_class('McEnbPdcp', parent=root_module['ns3::LtePdcp'])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::Status [struct]
+    module.add_class('Status', outer_class=root_module['ns3::McEnbPdcp'])
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint8_t, uint32_t )', u'ns3::McEnbPdcp::PduTxTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint8_t, uint32_t )*', u'ns3::McEnbPdcp::PduTxTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint8_t, uint32_t )&', u'ns3::McEnbPdcp::PduTxTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t const, uint8_t const, uint32_t const, uint64_t const )', u'ns3::McEnbPdcp::PduRxTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t const, uint8_t const, uint32_t const, uint64_t const )*', u'ns3::McEnbPdcp::PduRxTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t const, uint8_t const, uint32_t const, uint64_t const )&', u'ns3::McEnbPdcp::PduRxTracedCallback&')
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp [class]
+    module.add_class('McUePdcp', parent=root_module['ns3::LtePdcp'])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::Status [struct]
+    module.add_class('Status', outer_class=root_module['ns3::McUePdcp'])
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint8_t, uint32_t )', u'ns3::McUePdcp::PduTxTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint8_t, uint32_t )*', u'ns3::McUePdcp::PduTxTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint8_t, uint32_t )&', u'ns3::McUePdcp::PduTxTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t const, uint8_t const, uint32_t const, uint64_t const )', u'ns3::McUePdcp::PduRxTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t const, uint8_t const, uint32_t const, uint64_t const )*', u'ns3::McUePdcp::PduRxTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( uint16_t const, uint8_t const, uint32_t const, uint64_t const )&', u'ns3::McUePdcp::PduRxTracedCallback&')
     ## lte-control-messages.h (module 'lte'): ns3::MibLteControlMessage [class]
     module.add_class('MibLteControlMessage', parent=root_module['ns3::LteControlMessage'])
     ## basic-data-calculators.h (module 'stats'): ns3::MinMaxAvgTotalCalculator<unsigned int> [class]
@@ -1490,9 +1646,6 @@
     typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )', u'ns3::Packet::AddressTracedCallback')
     typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )*', u'ns3::Packet::AddressTracedCallback*')
     typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )&', u'ns3::Packet::AddressTracedCallback&')
-    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )', u'ns3::Packet::TwoAddressTracedCallback')
-    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )*', u'ns3::Packet::TwoAddressTracedCallback*')
-    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )&', u'ns3::Packet::TwoAddressTracedCallback&')
     typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )', u'ns3::Packet::Mac48AddressTracedCallback')
     typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )*', u'ns3::Packet::Mac48AddressTracedCallback*')
     typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )&', u'ns3::Packet::Mac48AddressTracedCallback&')
@@ -1520,6 +1673,17 @@
     module.add_class('PointerValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
     ## pss-ff-mac-scheduler.h (module 'lte'): ns3::PssFfMacScheduler [class]
     module.add_class('PssFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
+    ## queue-item.h (module 'network'): ns3::QueueItem [class]
+    module.add_class('QueueItem', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::QueueItem, ns3::empty, ns3::DefaultDeleter<ns3::QueueItem> >'])
+    ## queue-item.h (module 'network'): ns3::QueueItem::Uint8Values [enumeration]
+    module.add_enum('Uint8Values', ['IP_DSFIELD'], outer_class=root_module['ns3::QueueItem'], import_from_module='ns.network')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::QueueItem const > )', u'ns3::QueueItem::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::QueueItem const > )*', u'ns3::QueueItem::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::QueueItem const > )&', u'ns3::QueueItem::TracedCallback&')
+    ## queue-size.h (module 'network'): ns3::QueueSizeChecker [class]
+    module.add_class('QueueSizeChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
+    ## queue-size.h (module 'network'): ns3::QueueSizeValue [class]
+    module.add_class('QueueSizeValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
     ## lte-control-messages.h (module 'lte'): ns3::RachPreambleLteControlMessage [class]
     module.add_class('RachPreambleLteControlMessage', parent=root_module['ns3::LteControlMessage'])
     ## radio-bearer-stats-calculator.h (module 'lte'): ns3::RadioBearerStatsCalculator [class]
@@ -1544,6 +1708,10 @@
     module.add_class('RrcUlCcchMessage', parent=root_module['ns3::RrcAsn1Header'])
     ## lte-rrc-header.h (module 'lte'): ns3::RrcUlDcchMessage [class]
     module.add_class('RrcUlDcchMessage', parent=root_module['ns3::RrcAsn1Header'])
+    ## epc-s1ap.h (module 'lte'): ns3::S1apConnectionInfo [class]
+    module.add_class('S1apConnectionInfo', parent=root_module['ns3::SimpleRefCount< ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apConnectionInfo> >'])
+    ## epc-s1ap.h (module 'lte'): ns3::S1apIfaceInfo [class]
+    module.add_class('S1apIfaceInfo', parent=root_module['ns3::SimpleRefCount< ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apIfaceInfo> >'])
     ## lte-control-messages.h (module 'lte'): ns3::Sib1LteControlMessage [class]
     module.add_class('Sib1LteControlMessage', parent=root_module['ns3::LteControlMessage'])
     ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::SimpleUeComponentCarrierManager [class]
@@ -1610,6 +1778,8 @@
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['bool', 'ns3::Ptr<ns3::Socket>', 'const ns3::Address &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['ns3::ObjectBase *', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'bool', 'bool', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'const ns3::SpectrumValue &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
@@ -1626,6 +1796,10 @@
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<const ns3::Packet>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::PacketBurst>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<const ns3::PacketBurst>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<const ns3::QueueDiscItem>', 'const char *', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<const ns3::QueueDiscItem>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::LteUeRrc>, std::list<ns3::LteRrcSap::SCellToAddMod, std::allocator<ns3::LteRrcSap::SCellToAddMod> >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<ns3::LteUeRrc>', 'std::list<ns3::LteRrcSap::SCellToAddMod, std::allocator<ns3::LteRrcSap::SCellToAddMod> >', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty> [class]
@@ -1640,10 +1814,16 @@
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<ns3::Socket>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<ns3::Socket>', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Time', 'ns3::Time', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned int', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned int', 'unsigned int', 'unsigned short', 'unsigned char', 'unsigned short', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned long', 'unsigned short', 'long double', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned long', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
@@ -1660,6 +1840,8 @@
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'ns3::Ptr<ns3::SpectrumValue>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned char', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned char', 'unsigned int', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned char', 'unsigned int', 'unsigned long', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty> [class]
@@ -1674,6 +1856,8 @@
     module.add_class('CallbackImpl', template_parameters=['void', 'unsigned short', 'unsigned short', 'ns3::LteUePhy::State', 'ns3::LteUePhy::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned short', 'unsigned int', 'unsigned long', 'bool', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqaFfMacScheduler [class]
     module.add_class('CqaFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
     ## lte-control-messages.h (module 'lte'): ns3::DlCqiLteControlMessage [class]
@@ -1708,6 +1892,10 @@
     module.add_class('LteUeNetDevice', parent=root_module['ns3::LteNetDevice'])
     ## lte-rrc-header.h (module 'lte'): ns3::MeasurementReportHeader [class]
     module.add_class('MeasurementReportHeader', parent=root_module['ns3::RrcUlDcchMessage'])
+    ## queue-item.h (module 'network'): ns3::QueueDiscItem [class]
+    module.add_class('QueueDiscItem', import_from_module='ns.network', parent=root_module['ns3::QueueItem'])
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectToMmWaveHeader [class]
+    module.add_class('RrcConnectToMmWaveHeader', parent=root_module['ns3::RrcDlCcchMessage'])
     ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReconfigurationCompleteHeader [class]
     module.add_class('RrcConnectionReconfigurationCompleteHeader', parent=root_module['ns3::RrcUlDcchMessage'])
     ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReconfigurationHeader [class]
@@ -1730,6 +1918,10 @@
     module.add_class('RrcConnectionSetupCompleteHeader', parent=root_module['ns3::RrcUlDcchMessage'])
     ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSetupHeader [class]
     module.add_class('RrcConnectionSetupHeader', parent=root_module['ns3::RrcDlCcchMessage'])
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSwitchHeader [class]
+    module.add_class('RrcConnectionSwitchHeader', parent=root_module['ns3::RrcDlDcchMessage'])
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcNotifySecondaryConnectedHeader [class]
+    module.add_class('RrcNotifySecondaryConnectedHeader', parent=root_module['ns3::RrcUlDcchMessage'])
     ## lte-enb-net-device.h (module 'lte'): ns3::LteEnbNetDevice [class]
     module.add_class('LteEnbNetDevice', parent=root_module['ns3::LteNetDevice'])
     module.add_container('std::vector< ns3::CeBitmap_e >', 'ns3::CeBitmap_e', container_type=u'vector')
@@ -1743,20 +1935,22 @@
     module.add_container('std::list< ns3::EpcS11SapSgw::BearerContextToBeCreated >', 'ns3::EpcS11SapSgw::BearerContextToBeCreated', container_type=u'list')
     module.add_container('std::list< ns3::EpcS11SapSgw::BearerContextToBeRemoved >', 'ns3::EpcS11SapSgw::BearerContextToBeRemoved', container_type=u'list')
     module.add_container('std::list< ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw >', 'ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapEnb::ErabToBeSetupItem >', 'ns3::EpcS1apSapEnb::ErabToBeSetupItem', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem >', 'ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapMme::ErabToBeReleasedIndication >', 'ns3::EpcS1apSapMme::ErabToBeReleasedIndication', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapMme::ErabSetupItem >', 'ns3::EpcS1apSapMme::ErabSetupItem', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem >', 'ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem', container_type=u'list')
+    module.add_container('std::list< ns3::EpcS1apSap::ErabToBeSetupItem >', 'ns3::EpcS1apSap::ErabToBeSetupItem', container_type=u'list')
+    module.add_container('std::list< ns3::EpcS1apSap::ErabSwitchedInUplinkItem >', 'ns3::EpcS1apSap::ErabSwitchedInUplinkItem', container_type=u'list')
+    module.add_container('std::list< ns3::EpcS1apSap::ErabToBeReleasedIndication >', 'ns3::EpcS1apSap::ErabToBeReleasedIndication', container_type=u'list')
+    module.add_container('std::list< ns3::EpcS1apSap::ErabSetupItem >', 'ns3::EpcS1apSap::ErabSetupItem', container_type=u'list')
+    module.add_container('std::list< ns3::EpcS1apSap::ErabSwitchedInDownlinkItem >', 'ns3::EpcS1apSap::ErabSwitchedInDownlinkItem', container_type=u'list')
     module.add_container('std::vector< bool >', 'bool', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::UlInterferenceOverloadIndicationItem >', 'ns3::EpcX2Sap::UlInterferenceOverloadIndicationItem', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::UlHighInterferenceInformationItem >', 'ns3::EpcX2Sap::UlHighInterferenceInformationItem', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', 'ns3::EpcX2Sap::ErabToBeSetupItem', container_type=u'vector')
+    module.add_container('std::vector< ns3::EpcX2Sap::RlcSetupRequest >', 'ns3::EpcX2Sap::RlcSetupRequest', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::ErabAdmittedItem >', 'ns3::EpcX2Sap::ErabAdmittedItem', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::ErabNotAdmittedItem >', 'ns3::EpcX2Sap::ErabNotAdmittedItem', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem >', 'ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::CellInformationItem >', 'ns3::EpcX2Sap::CellInformationItem', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::CellMeasurementResultItem >', 'ns3::EpcX2Sap::CellMeasurementResultItem', container_type=u'vector')
+    module.add_container('std::map< unsigned long, double >', ('long unsigned int', 'double'), container_type=u'map')
     module.add_container('std::vector< ns3::VendorSpecificListElement_s >', 'ns3::VendorSpecificListElement_s', container_type=u'vector')
     module.add_container('std::vector< ns3::LogicalChannelConfigListElement_s >', 'ns3::LogicalChannelConfigListElement_s', container_type=u'vector')
     module.add_container('std::vector< ns3::PagingInfoListElement_s >', 'ns3::PagingInfoListElement_s', container_type=u'vector')
@@ -1775,6 +1969,8 @@
     module.add_container('std::vector< ns3::LteCcmRrcSapProvider::LcsConfig >', 'ns3::LteCcmRrcSapProvider::LcsConfig', container_type=u'vector')
     module.add_container('std::vector< ns3::LteRrcSap::LogicalChannelConfig >', 'ns3::LteRrcSap::LogicalChannelConfig', container_type=u'vector')
     module.add_container('std::map< unsigned short, std::vector< double > >', ('short unsigned int', 'std::vector< double >'), container_type=u'map')
+    module.add_container('std::list< unsigned int >', 'unsigned int', container_type=u'list')
+    module.add_container('std::list< double >', 'double', container_type=u'list')
     module.add_container('std::vector< int >', 'int', container_type=u'vector')
     module.add_container('ns3::HarqProcessInfoList_t', 'ns3::HarqProcessInfoElement_t', container_type=u'vector')
     module.add_container('std::list< ns3::LteRrcSap::SrbToAddMod >', 'ns3::LteRrcSap::SrbToAddMod', container_type=u'list')
@@ -1785,7 +1981,6 @@
     module.add_container('std::list< ns3::LteRrcSap::MeasObjectToAddMod >', 'ns3::LteRrcSap::MeasObjectToAddMod', container_type=u'list')
     module.add_container('std::list< ns3::LteRrcSap::ReportConfigToAddMod >', 'ns3::LteRrcSap::ReportConfigToAddMod', container_type=u'list')
     module.add_container('std::list< ns3::LteRrcSap::MeasIdToAddMod >', 'ns3::LteRrcSap::MeasIdToAddMod', container_type=u'list')
-    module.add_container('std::list< unsigned int >', 'unsigned int', container_type=u'list')
     module.add_container('std::list< ns3::LteRrcSap::MeasResultScell >', 'ns3::LteRrcSap::MeasResultScell', container_type=u'list')
     module.add_container('std::list< ns3::LteRrcSap::MeasResultBestNeighCell >', 'ns3::LteRrcSap::MeasResultBestNeighCell', container_type=u'list')
     module.add_container('std::list< ns3::LteRrcSap::MeasResultEutra >', 'ns3::LteRrcSap::MeasResultEutra', container_type=u'list')
@@ -1796,13 +1991,21 @@
     module.add_container('std::vector< ns3::HigherLayerSelected_s >', 'ns3::HigherLayerSelected_s', container_type=u'vector')
     module.add_container('std::vector< ns3::SiMessageListElement_s >', 'ns3::SiMessageListElement_s', container_type=u'vector')
     module.add_container('std::list< ns3::Ptr< ns3::Packet > >', 'ns3::Ptr< ns3::Packet >', container_type=u'list')
+    module.add_container('std::map< std::string, unsigned int >', ('std::string', 'unsigned int'), container_type=u'map')
+    module.add_container('std::map< std::string, unsigned long >', ('std::string', 'long unsigned int'), container_type=u'map')
     module.add_container('std::vector< ns3::Ipv6Address >', 'ns3::Ipv6Address', container_type=u'vector')
     module.add_container('std::vector< double >', 'double', container_type=u'vector')
     module.add_container('ns3::Bands', 'ns3::BandInfo', container_type=u'vector')
     module.add_container('std::map< unsigned char, ns3::ComponentCarrier >', ('unsigned char', 'ns3::ComponentCarrier'), container_type=u'map')
     module.add_container('std::map< unsigned int, unsigned int >', ('unsigned int', 'unsigned int'), container_type=u'map')
+    module.add_container('std::map< unsigned char, double >', ('unsigned char', 'double'), container_type=u'map')
     module.add_container('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierEnb > >', ('unsigned char', 'ns3::Ptr< ns3::ComponentCarrierEnb >'), container_type=u'map')
+    module.add_container('std::map< unsigned char, ns3::LteEnbRrc::MmWaveComponentCarrierConf >', ('unsigned char', 'ns3::LteEnbRrc::MmWaveComponentCarrierConf'), container_type=u'map')
+    module.add_container('std::map< unsigned long, ns3::LteEnbRrc::HandoverEventInfo >', ('long unsigned int', 'ns3::LteEnbRrc::HandoverEventInfo'), container_type=u'map')
     module.add_container('std::list< ns3::Ptr< ns3::LteControlMessage > >', 'ns3::Ptr< ns3::LteControlMessage >', container_type=u'list')
+    module.add_container('std::vector< ns3::Ptr< ns3::Packet > >', 'ns3::Ptr< ns3::Packet >', container_type=u'vector')
+    module.add_container('std::vector< ns3::LteRlcAm::RetxPdu >', 'ns3::LteRlcAm::RetxPdu', container_type=u'vector')
+    module.add_container('std::map< unsigned int, ns3::Ptr< ns3::Packet > >', ('unsigned int', 'ns3::Ptr< ns3::Packet >'), container_type=u'map')
     module.add_container('std::list< ns3::UlDciLteControlMessage >', 'ns3::UlDciLteControlMessage', container_type=u'list')
     module.add_container('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierUe > >', ('unsigned char', 'ns3::Ptr< ns3::ComponentCarrierUe >'), container_type=u'map')
     typehandlers.add_type_alias(u'std::vector< unsigned char >', u'ns3::DlHarqProcessesStatus_t')
@@ -1847,12 +2050,21 @@
     typehandlers.add_type_alias(u'std::vector< std::vector< ns3::Ptr< ns3::PacketBurst > > >', u'ns3::DlHarqProcessesBuffer_t')
     typehandlers.add_type_alias(u'std::vector< std::vector< ns3::Ptr< ns3::PacketBurst > > >*', u'ns3::DlHarqProcessesBuffer_t*')
     typehandlers.add_type_alias(u'std::vector< std::vector< ns3::Ptr< ns3::PacketBurst > > >&', u'ns3::DlHarqProcessesBuffer_t&')
+    typehandlers.add_type_alias(u'std::map< unsigned long, double >', u'ns3::ImsiSinrMap')
+    typehandlers.add_type_alias(u'std::map< unsigned long, double >*', u'ns3::ImsiSinrMap*')
+    typehandlers.add_type_alias(u'std::map< unsigned long, double >&', u'ns3::ImsiSinrMap&')
+    typehandlers.add_type_alias(u'std::map< unsigned short, double >', u'ns3::CellSinrMap')
+    typehandlers.add_type_alias(u'std::map< unsigned short, double >*', u'ns3::CellSinrMap*')
+    typehandlers.add_type_alias(u'std::map< unsigned short, double >&', u'ns3::CellSinrMap&')
     typehandlers.add_type_alias(u'ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LteChunkProcessorCallback')
     typehandlers.add_type_alias(u'ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LteChunkProcessorCallback*')
     typehandlers.add_type_alias(u'ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LteChunkProcessorCallback&')
     typehandlers.add_type_alias(u'std::map< ns3::TbId_t, ns3::tbInfo_t >', u'ns3::expectedTbs_t')
     typehandlers.add_type_alias(u'std::map< ns3::TbId_t, ns3::tbInfo_t >*', u'ns3::expectedTbs_t*')
     typehandlers.add_type_alias(u'std::map< ns3::TbId_t, ns3::tbInfo_t >&', u'ns3::expectedTbs_t&')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LtePhyTxEndCallback')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LtePhyTxEndCallback*')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LtePhyTxEndCallback&')
     typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LtePhyRxDataEndErrorCallback')
     typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LtePhyRxDataEndErrorCallback*')
     typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LtePhyRxDataEndErrorCallback&')
@@ -1970,12 +2182,12 @@
     
     ## hash-function.h (module 'core'): ns3::Hash::Implementation [class]
     module.add_class('Implementation', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::Hash::Implementation, ns3::empty, ns3::DefaultDeleter<ns3::Hash::Implementation> >'])
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )', u'ns3::Hash::Hash32Function_ptr')
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )*', u'ns3::Hash::Hash32Function_ptr*')
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )&', u'ns3::Hash::Hash32Function_ptr&')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )', u'ns3::Hash::Hash64Function_ptr')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )*', u'ns3::Hash::Hash64Function_ptr*')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )&', u'ns3::Hash::Hash64Function_ptr&')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )', u'ns3::Hash::Hash32Function_ptr')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )*', u'ns3::Hash::Hash32Function_ptr*')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )&', u'ns3::Hash::Hash32Function_ptr&')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )', u'ns3::Hash::Hash64Function_ptr')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )*', u'ns3::Hash::Hash64Function_ptr*')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )&', u'ns3::Hash::Hash64Function_ptr&')
     
     ## Register a nested module for the namespace Function
     
@@ -2069,6 +2281,9 @@
     register_Ns3DefaultDeleter__Ns3LteHarqPhy_methods(root_module, root_module['ns3::DefaultDeleter< ns3::LteHarqPhy >'])
     register_Ns3DefaultDeleter__Ns3NixVector_methods(root_module, root_module['ns3::DefaultDeleter< ns3::NixVector >'])
     register_Ns3DefaultDeleter__Ns3Packet_methods(root_module, root_module['ns3::DefaultDeleter< ns3::Packet >'])
+    register_Ns3DefaultDeleter__Ns3QueueItem_methods(root_module, root_module['ns3::DefaultDeleter< ns3::QueueItem >'])
+    register_Ns3DefaultDeleter__Ns3S1apConnectionInfo_methods(root_module, root_module['ns3::DefaultDeleter< ns3::S1apConnectionInfo >'])
+    register_Ns3DefaultDeleter__Ns3S1apIfaceInfo_methods(root_module, root_module['ns3::DefaultDeleter< ns3::S1apIfaceInfo >'])
     register_Ns3DefaultDeleter__Ns3SpectrumModel_methods(root_module, root_module['ns3::DefaultDeleter< ns3::SpectrumModel >'])
     register_Ns3DefaultDeleter__Ns3SpectrumValue_methods(root_module, root_module['ns3::DefaultDeleter< ns3::SpectrumValue >'])
     register_Ns3DefaultDeleter__Ns3TraceSourceAccessor_methods(root_module, root_module['ns3::DefaultDeleter< ns3::TraceSourceAccessor >'])
@@ -2104,13 +2319,15 @@
     register_Ns3EpcS11SapSgwDeleteBearerResponseMessage_methods(root_module, root_module['ns3::EpcS11SapSgw::DeleteBearerResponseMessage'])
     register_Ns3EpcS11SapSgwModifyBearerRequestMessage_methods(root_module, root_module['ns3::EpcS11SapSgw::ModifyBearerRequestMessage'])
     register_Ns3EpcS1apSap_methods(root_module, root_module['ns3::EpcS1apSap'])
+    register_Ns3EpcS1apSapErabSetupItem_methods(root_module, root_module['ns3::EpcS1apSap::ErabSetupItem'])
+    register_Ns3EpcS1apSapErabSwitchedInDownlinkItem_methods(root_module, root_module['ns3::EpcS1apSap::ErabSwitchedInDownlinkItem'])
+    register_Ns3EpcS1apSapErabSwitchedInUplinkItem_methods(root_module, root_module['ns3::EpcS1apSap::ErabSwitchedInUplinkItem'])
+    register_Ns3EpcS1apSapErabToBeReleasedIndication_methods(root_module, root_module['ns3::EpcS1apSap::ErabToBeReleasedIndication'])
+    register_Ns3EpcS1apSapErabToBeSetupItem_methods(root_module, root_module['ns3::EpcS1apSap::ErabToBeSetupItem'])
     register_Ns3EpcS1apSapEnb_methods(root_module, root_module['ns3::EpcS1apSapEnb'])
-    register_Ns3EpcS1apSapEnbErabSwitchedInUplinkItem_methods(root_module, root_module['ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem'])
-    register_Ns3EpcS1apSapEnbErabToBeSetupItem_methods(root_module, root_module['ns3::EpcS1apSapEnb::ErabToBeSetupItem'])
+    register_Ns3EpcS1apSapEnbProvider_methods(root_module, root_module['ns3::EpcS1apSapEnbProvider'])
     register_Ns3EpcS1apSapMme_methods(root_module, root_module['ns3::EpcS1apSapMme'])
-    register_Ns3EpcS1apSapMmeErabSetupItem_methods(root_module, root_module['ns3::EpcS1apSapMme::ErabSetupItem'])
-    register_Ns3EpcS1apSapMmeErabSwitchedInDownlinkItem_methods(root_module, root_module['ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem'])
-    register_Ns3EpcS1apSapMmeErabToBeReleasedIndication_methods(root_module, root_module['ns3::EpcS1apSapMme::ErabToBeReleasedIndication'])
+    register_Ns3EpcS1apSapMmeProvider_methods(root_module, root_module['ns3::EpcS1apSapMmeProvider'])
     register_Ns3EpcX2Sap_methods(root_module, root_module['ns3::EpcX2Sap'])
     register_Ns3EpcX2SapCellInformationItem_methods(root_module, root_module['ns3::EpcX2Sap::CellInformationItem'])
     register_Ns3EpcX2SapCellMeasurementResultItem_methods(root_module, root_module['ns3::EpcX2Sap::CellMeasurementResultItem'])
@@ -2119,15 +2336,21 @@
     register_Ns3EpcX2SapErabNotAdmittedItem_methods(root_module, root_module['ns3::EpcX2Sap::ErabNotAdmittedItem'])
     register_Ns3EpcX2SapErabToBeSetupItem_methods(root_module, root_module['ns3::EpcX2Sap::ErabToBeSetupItem'])
     register_Ns3EpcX2SapErabsSubjectToStatusTransferItem_methods(root_module, root_module['ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem'])
+    register_Ns3EpcX2SapHandoverFailedParams_methods(root_module, root_module['ns3::EpcX2Sap::HandoverFailedParams'])
     register_Ns3EpcX2SapHandoverPreparationFailureParams_methods(root_module, root_module['ns3::EpcX2Sap::HandoverPreparationFailureParams'])
     register_Ns3EpcX2SapHandoverRequestAckParams_methods(root_module, root_module['ns3::EpcX2Sap::HandoverRequestAckParams'])
     register_Ns3EpcX2SapHandoverRequestParams_methods(root_module, root_module['ns3::EpcX2Sap::HandoverRequestParams'])
     register_Ns3EpcX2SapLoadInformationParams_methods(root_module, root_module['ns3::EpcX2Sap::LoadInformationParams'])
     register_Ns3EpcX2SapRelativeNarrowbandTxBand_methods(root_module, root_module['ns3::EpcX2Sap::RelativeNarrowbandTxBand'])
     register_Ns3EpcX2SapResourceStatusUpdateParams_methods(root_module, root_module['ns3::EpcX2Sap::ResourceStatusUpdateParams'])
+    register_Ns3EpcX2SapRlcSetupRequest_methods(root_module, root_module['ns3::EpcX2Sap::RlcSetupRequest'])
+    register_Ns3EpcX2SapSecondaryHandoverCompletedParams_methods(root_module, root_module['ns3::EpcX2Sap::SecondaryHandoverCompletedParams'])
+    register_Ns3EpcX2SapSecondaryHandoverParams_methods(root_module, root_module['ns3::EpcX2Sap::SecondaryHandoverParams'])
     register_Ns3EpcX2SapSnStatusTransferParams_methods(root_module, root_module['ns3::EpcX2Sap::SnStatusTransferParams'])
+    register_Ns3EpcX2SapSwitchConnectionParams_methods(root_module, root_module['ns3::EpcX2Sap::SwitchConnectionParams'])
     register_Ns3EpcX2SapUeContextReleaseParams_methods(root_module, root_module['ns3::EpcX2Sap::UeContextReleaseParams'])
     register_Ns3EpcX2SapUeDataParams_methods(root_module, root_module['ns3::EpcX2Sap::UeDataParams'])
+    register_Ns3EpcX2SapUeImsiSinrParams_methods(root_module, root_module['ns3::EpcX2Sap::UeImsiSinrParams'])
     register_Ns3EpcX2SapUlHighInterferenceInformationItem_methods(root_module, root_module['ns3::EpcX2Sap::UlHighInterferenceInformationItem'])
     register_Ns3EpcX2SapProvider_methods(root_module, root_module['ns3::EpcX2SapProvider'])
     register_Ns3EpcX2SapUser_methods(root_module, root_module['ns3::EpcX2SapUser'])
@@ -2199,6 +2422,7 @@
     register_Ns3LteEnbCmacSapUserUeConfig_methods(root_module, root_module['ns3::LteEnbCmacSapUser::UeConfig'])
     register_Ns3LteEnbCphySapProvider_methods(root_module, root_module['ns3::LteEnbCphySapProvider'])
     register_Ns3LteEnbCphySapUser_methods(root_module, root_module['ns3::LteEnbCphySapUser'])
+    register_Ns3LteEnbCphySapUserUeAssociatedSinrInfo_methods(root_module, root_module['ns3::LteEnbCphySapUser::UeAssociatedSinrInfo'])
     register_Ns3LteEnbPhySapProvider_methods(root_module, root_module['ns3::LteEnbPhySapProvider'])
     register_Ns3LteEnbPhySapUser_methods(root_module, root_module['ns3::LteEnbPhySapUser'])
     register_Ns3LteFfConverter_methods(root_module, root_module['ns3::LteFfConverter'])
@@ -2222,6 +2446,7 @@
     register_Ns3LteRlcSapProvider_methods(root_module, root_module['ns3::LteRlcSapProvider'])
     register_Ns3LteRlcSapProviderTransmitPdcpPduParameters_methods(root_module, root_module['ns3::LteRlcSapProvider::TransmitPdcpPduParameters'])
     register_Ns3LteRlcSapUser_methods(root_module, root_module['ns3::LteRlcSapUser'])
+    register_Ns3LteRlcSpecificLteMacSapUser_methods(root_module, root_module['ns3::LteRlcSpecificLteMacSapUser'])
     register_Ns3LteRrcSap_methods(root_module, root_module['ns3::LteRrcSap'])
     register_Ns3LteRrcSapAntennaInfoCommon_methods(root_module, root_module['ns3::LteRrcSap::AntennaInfoCommon'])
     register_Ns3LteRrcSapAntennaInfoDedicated_methods(root_module, root_module['ns3::LteRrcSap::AntennaInfoDedicated'])
@@ -2288,6 +2513,7 @@
     register_Ns3LteRrcSapRrcConnectionRequest_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionRequest'])
     register_Ns3LteRrcSapRrcConnectionSetup_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionSetup'])
     register_Ns3LteRrcSapRrcConnectionSetupCompleted_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionSetupCompleted'])
+    register_Ns3LteRrcSapRrcConnectionSwitch_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionSwitch'])
     register_Ns3LteRrcSapSCellToAddMod_methods(root_module, root_module['ns3::LteRrcSap::SCellToAddMod'])
     register_Ns3LteRrcSapSoundingRsUlConfigCommon_methods(root_module, root_module['ns3::LteRrcSap::SoundingRsUlConfigCommon'])
     register_Ns3LteRrcSapSoundingRsUlConfigDedicated_methods(root_module, root_module['ns3::LteRrcSap::SoundingRsUlConfigDedicated'])
@@ -2344,6 +2570,7 @@
     register_Ns3PhichListElement_s_methods(root_module, root_module['ns3::PhichListElement_s'])
     register_Ns3PhyReceptionStatParameters_methods(root_module, root_module['ns3::PhyReceptionStatParameters'])
     register_Ns3PhyTransmissionStatParameters_methods(root_module, root_module['ns3::PhyTransmissionStatParameters'])
+    register_Ns3QueueSize_methods(root_module, root_module['ns3::QueueSize'])
     register_Ns3RachListElement_s_methods(root_module, root_module['ns3::RachListElement_s'])
     register_Ns3RadioBearerStatsConnector_methods(root_module, root_module['ns3::RadioBearerStatsConnector'])
     register_Ns3RealProtocolRlcSapUser_methods(root_module, root_module['ns3::RealProtocolRlcSapUser'])
@@ -2363,6 +2590,8 @@
     register_Ns3TbId_t_methods(root_module, root_module['ns3::TbId_t'])
     register_Ns3TbStats_t_methods(root_module, root_module['ns3::TbStats_t'])
     register_Ns3TimeWithUnit_methods(root_module, root_module['ns3::TimeWithUnit'])
+    register_Ns3TracedValue__Bool_methods(root_module, root_module['ns3::TracedValue< bool >'])
+    register_Ns3TracedValue__Unsigned_int_methods(root_module, root_module['ns3::TracedValue< unsigned int >'])
     register_Ns3TransmissionModesLayers_methods(root_module, root_module['ns3::TransmissionModesLayers'])
     register_Ns3TypeId_methods(root_module, root_module['ns3::TypeId'])
     register_Ns3TypeIdAttributeInformation_methods(root_module, root_module['ns3::TypeId::AttributeInformation'])
@@ -2388,6 +2617,11 @@
     register_Ns3TdtbfqsFlowPerf_t_methods(root_module, root_module['ns3::tdtbfqsFlowPerf_t'])
     register_Ns3Chunk_methods(root_module, root_module['ns3::Chunk'])
     register_Ns3DownlinkLteGlobalPathlossDatabase_methods(root_module, root_module['ns3::DownlinkLteGlobalPathlossDatabase'])
+    register_Ns3EpcX2PdcpProvider_methods(root_module, root_module['ns3::EpcX2PdcpProvider'])
+    register_Ns3EpcX2PdcpUser_methods(root_module, root_module['ns3::EpcX2PdcpUser'])
+    register_Ns3EpcX2RlcProvider_methods(root_module, root_module['ns3::EpcX2RlcProvider'])
+    register_Ns3EpcX2RlcUser_methods(root_module, root_module['ns3::EpcX2RlcUser'])
+    register_Ns3EpcX2Tag_methods(root_module, root_module['ns3::EpcX2Tag'])
     register_Ns3EpsBearerTag_methods(root_module, root_module['ns3::EpsBearerTag'])
     register_Ns3Header_methods(root_module, root_module['ns3::Header'])
     register_Ns3Ipv4Header_methods(root_module, root_module['ns3::Ipv4Header'])
@@ -2405,9 +2639,15 @@
     register_Ns3Object_methods(root_module, root_module['ns3::Object'])
     register_Ns3ObjectAggregateIterator_methods(root_module, root_module['ns3::Object::AggregateIterator'])
     register_Ns3PacketBurst_methods(root_module, root_module['ns3::PacketBurst'])
+    register_Ns3PacketFilter_methods(root_module, root_module['ns3::PacketFilter'])
     register_Ns3PdcpTag_methods(root_module, root_module['ns3::PdcpTag'])
+    register_Ns3QueueDisc_methods(root_module, root_module['ns3::QueueDisc'])
+    register_Ns3QueueDiscStats_methods(root_module, root_module['ns3::QueueDisc::Stats'])
+    register_Ns3QueueDiscClass_methods(root_module, root_module['ns3::QueueDiscClass'])
     register_Ns3RadioEnvironmentMapHelper_methods(root_module, root_module['ns3::RadioEnvironmentMapHelper'])
     register_Ns3RandomVariableStream_methods(root_module, root_module['ns3::RandomVariableStream'])
+    register_Ns3RetxStatsCalculator_methods(root_module, root_module['ns3::RetxStatsCalculator'])
+    register_Ns3RlcBearerInfo_methods(root_module, root_module['ns3::RlcBearerInfo'])
     register_Ns3RlcTag_methods(root_module, root_module['ns3::RlcTag'])
     register_Ns3SequentialRandomVariable_methods(root_module, root_module['ns3::SequentialRandomVariable'])
     register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >'])
@@ -2425,6 +2665,9 @@
     register_Ns3SimpleRefCount__Ns3LteHarqPhy_Ns3Empty_Ns3DefaultDeleter__lt__ns3LteHarqPhy__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::LteHarqPhy, ns3::empty, ns3::DefaultDeleter<ns3::LteHarqPhy> >'])
     register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
     register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])
+    register_Ns3SimpleRefCount__Ns3QueueItem_Ns3Empty_Ns3DefaultDeleter__lt__ns3QueueItem__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::QueueItem, ns3::empty, ns3::DefaultDeleter<ns3::QueueItem> >'])
+    register_Ns3SimpleRefCount__Ns3S1apConnectionInfo_Ns3Empty_Ns3DefaultDeleter__lt__ns3S1apConnectionInfo__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apConnectionInfo> >'])
+    register_Ns3SimpleRefCount__Ns3S1apIfaceInfo_Ns3Empty_Ns3DefaultDeleter__lt__ns3S1apIfaceInfo__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apIfaceInfo> >'])
     register_Ns3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >'])
     register_Ns3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> >'])
     register_Ns3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> >'])
@@ -2448,6 +2691,7 @@
     register_Ns3Time_methods(root_module, root_module['ns3::Time'])
     register_Ns3TraceFadingLossModel_methods(root_module, root_module['ns3::TraceFadingLossModel'])
     register_Ns3TraceSourceAccessor_methods(root_module, root_module['ns3::TraceSourceAccessor'])
+    register_Ns3TracedValue__Ns3Time_methods(root_module, root_module['ns3::TracedValue< ns3::Time >'])
     register_Ns3Trailer_methods(root_module, root_module['ns3::Trailer'])
     register_Ns3TriangularRandomVariable_methods(root_module, root_module['ns3::TriangularRandomVariable'])
     register_Ns3UeManager_methods(root_module, root_module['ns3::UeManager'])
@@ -2470,6 +2714,7 @@
     register_Ns3CallbackValue_methods(root_module, root_module['ns3::CallbackValue'])
     register_Ns3CcHelper_methods(root_module, root_module['ns3::CcHelper'])
     register_Ns3Channel_methods(root_module, root_module['ns3::Channel'])
+    register_Ns3CoDelQueueDisc_methods(root_module, root_module['ns3::CoDelQueueDisc'])
     register_Ns3ComponentCarrier_methods(root_module, root_module['ns3::ComponentCarrier'])
     register_Ns3ComponentCarrierEnb_methods(root_module, root_module['ns3::ComponentCarrierEnb'])
     register_Ns3ComponentCarrierUe_methods(root_module, root_module['ns3::ComponentCarrierUe'])
@@ -2490,20 +2735,37 @@
     register_Ns3EpcEnbApplicationEpsFlowId_t_methods(root_module, root_module['ns3::EpcEnbApplication::EpsFlowId_t'])
     register_Ns3EpcHelper_methods(root_module, root_module['ns3::EpcHelper'])
     register_Ns3EpcMme_methods(root_module, root_module['ns3::EpcMme'])
+    register_Ns3EpcMmeApplication_methods(root_module, root_module['ns3::EpcMmeApplication'])
+    register_Ns3EpcS1APErabReleaseIndicationHeader_methods(root_module, root_module['ns3::EpcS1APErabReleaseIndicationHeader'])
+    register_Ns3EpcS1APHeader_methods(root_module, root_module['ns3::EpcS1APHeader'])
+    register_Ns3EpcS1APInitialContextSetupRequestHeader_methods(root_module, root_module['ns3::EpcS1APInitialContextSetupRequestHeader'])
+    register_Ns3EpcS1APInitialContextSetupResponseHeader_methods(root_module, root_module['ns3::EpcS1APInitialContextSetupResponseHeader'])
+    register_Ns3EpcS1APInitialUeMessageHeader_methods(root_module, root_module['ns3::EpcS1APInitialUeMessageHeader'])
+    register_Ns3EpcS1APPathSwitchRequestAcknowledgeHeader_methods(root_module, root_module['ns3::EpcS1APPathSwitchRequestAcknowledgeHeader'])
+    register_Ns3EpcS1APPathSwitchRequestHeader_methods(root_module, root_module['ns3::EpcS1APPathSwitchRequestHeader'])
+    register_Ns3EpcS1apEnb_methods(root_module, root_module['ns3::EpcS1apEnb'])
+    register_Ns3EpcS1apMme_methods(root_module, root_module['ns3::EpcS1apMme'])
     register_Ns3EpcSgwPgwApplication_methods(root_module, root_module['ns3::EpcSgwPgwApplication'])
     register_Ns3EpcTft_methods(root_module, root_module['ns3::EpcTft'])
     register_Ns3EpcTftPacketFilter_methods(root_module, root_module['ns3::EpcTft::PacketFilter'])
     register_Ns3EpcTftClassifier_methods(root_module, root_module['ns3::EpcTftClassifier'])
     register_Ns3EpcUeNas_methods(root_module, root_module['ns3::EpcUeNas'])
     register_Ns3EpcX2_methods(root_module, root_module['ns3::EpcX2'])
+    register_Ns3EpcX2ConnectionSwitchHeader_methods(root_module, root_module['ns3::EpcX2ConnectionSwitchHeader'])
     register_Ns3EpcX2HandoverPreparationFailureHeader_methods(root_module, root_module['ns3::EpcX2HandoverPreparationFailureHeader'])
     register_Ns3EpcX2HandoverRequestAckHeader_methods(root_module, root_module['ns3::EpcX2HandoverRequestAckHeader'])
     register_Ns3EpcX2HandoverRequestHeader_methods(root_module, root_module['ns3::EpcX2HandoverRequestHeader'])
     register_Ns3EpcX2Header_methods(root_module, root_module['ns3::EpcX2Header'])
     register_Ns3EpcX2LoadInformationHeader_methods(root_module, root_module['ns3::EpcX2LoadInformationHeader'])
+    register_Ns3EpcX2McHandoverHeader_methods(root_module, root_module['ns3::EpcX2McHandoverHeader'])
+    register_Ns3EpcX2NotifyCoordinatorHandoverFailedHeader_methods(root_module, root_module['ns3::EpcX2NotifyCoordinatorHandoverFailedHeader'])
     register_Ns3EpcX2ResourceStatusUpdateHeader_methods(root_module, root_module['ns3::EpcX2ResourceStatusUpdateHeader'])
+    register_Ns3EpcX2RlcSetupCompletedHeader_methods(root_module, root_module['ns3::EpcX2RlcSetupCompletedHeader'])
+    register_Ns3EpcX2RlcSetupRequestHeader_methods(root_module, root_module['ns3::EpcX2RlcSetupRequestHeader'])
+    register_Ns3EpcX2SecondaryCellHandoverCompletedHeader_methods(root_module, root_module['ns3::EpcX2SecondaryCellHandoverCompletedHeader'])
     register_Ns3EpcX2SnStatusTransferHeader_methods(root_module, root_module['ns3::EpcX2SnStatusTransferHeader'])
     register_Ns3EpcX2UeContextReleaseHeader_methods(root_module, root_module['ns3::EpcX2UeContextReleaseHeader'])
+    register_Ns3EpcX2UeImsiSinrUpdateHeader_methods(root_module, root_module['ns3::EpcX2UeImsiSinrUpdateHeader'])
     register_Ns3ErlangRandomVariable_methods(root_module, root_module['ns3::ErlangRandomVariable'])
     register_Ns3EventImpl_methods(root_module, root_module['ns3::EventImpl'])
     register_Ns3ExponentialRandomVariable_methods(root_module, root_module['ns3::ExponentialRandomVariable'])
@@ -2531,6 +2793,8 @@
     register_Ns3LteEnbComponentCarrierManager_methods(root_module, root_module['ns3::LteEnbComponentCarrierManager'])
     register_Ns3LteEnbMac_methods(root_module, root_module['ns3::LteEnbMac'])
     register_Ns3LteEnbRrc_methods(root_module, root_module['ns3::LteEnbRrc'])
+    register_Ns3LteEnbRrcHandoverEventInfo_methods(root_module, root_module['ns3::LteEnbRrc::HandoverEventInfo'])
+    register_Ns3LteEnbRrcMmWaveComponentCarrierConf_methods(root_module, root_module['ns3::LteEnbRrc::MmWaveComponentCarrierConf'])
     register_Ns3LteEnbRrcProtocolIdeal_methods(root_module, root_module['ns3::LteEnbRrcProtocolIdeal'])
     register_Ns3LteEnbRrcProtocolReal_methods(root_module, root_module['ns3::LteEnbRrcProtocolReal'])
     register_Ns3LteFfrAlgorithm_methods(root_module, root_module['ns3::LteFfrAlgorithm'])
@@ -2552,9 +2816,11 @@
     register_Ns3LteRadioBearerInfo_methods(root_module, root_module['ns3::LteRadioBearerInfo'])
     register_Ns3LteRlc_methods(root_module, root_module['ns3::LteRlc'])
     register_Ns3LteRlcAm_methods(root_module, root_module['ns3::LteRlcAm'])
+    register_Ns3LteRlcAmRetxPdu_methods(root_module, root_module['ns3::LteRlcAm::RetxPdu'])
     register_Ns3LteRlcSm_methods(root_module, root_module['ns3::LteRlcSm'])
     register_Ns3LteRlcTm_methods(root_module, root_module['ns3::LteRlcTm'])
     register_Ns3LteRlcUm_methods(root_module, root_module['ns3::LteRlcUm'])
+    register_Ns3LteRlcUmLowLat_methods(root_module, root_module['ns3::LteRlcUmLowLat'])
     register_Ns3LteSignalingRadioBearerInfo_methods(root_module, root_module['ns3::LteSignalingRadioBearerInfo'])
     register_Ns3LteSpectrumPhy_methods(root_module, root_module['ns3::LteSpectrumPhy'])
     register_Ns3LteSpectrumSignalParameters_methods(root_module, root_module['ns3::LteSpectrumSignalParameters'])
@@ -2574,6 +2840,11 @@
     register_Ns3Mac64AddressChecker_methods(root_module, root_module['ns3::Mac64AddressChecker'])
     register_Ns3Mac64AddressValue_methods(root_module, root_module['ns3::Mac64AddressValue'])
     register_Ns3MacStatsCalculator_methods(root_module, root_module['ns3::MacStatsCalculator'])
+    register_Ns3MacTxStatsCalculator_methods(root_module, root_module['ns3::MacTxStatsCalculator'])
+    register_Ns3McEnbPdcp_methods(root_module, root_module['ns3::McEnbPdcp'])
+    register_Ns3McEnbPdcpStatus_methods(root_module, root_module['ns3::McEnbPdcp::Status'])
+    register_Ns3McUePdcp_methods(root_module, root_module['ns3::McUePdcp'])
+    register_Ns3McUePdcpStatus_methods(root_module, root_module['ns3::McUePdcp::Status'])
     register_Ns3MibLteControlMessage_methods(root_module, root_module['ns3::MibLteControlMessage'])
     register_Ns3MinMaxAvgTotalCalculator__Unsigned_int_methods(root_module, root_module['ns3::MinMaxAvgTotalCalculator< unsigned int >'])
     register_Ns3MinMaxAvgTotalCalculator__Unsigned_long_methods(root_module, root_module['ns3::MinMaxAvgTotalCalculator< unsigned long >'])
@@ -2596,6 +2867,9 @@
     register_Ns3PointerChecker_methods(root_module, root_module['ns3::PointerChecker'])
     register_Ns3PointerValue_methods(root_module, root_module['ns3::PointerValue'])
     register_Ns3PssFfMacScheduler_methods(root_module, root_module['ns3::PssFfMacScheduler'])
+    register_Ns3QueueItem_methods(root_module, root_module['ns3::QueueItem'])
+    register_Ns3QueueSizeChecker_methods(root_module, root_module['ns3::QueueSizeChecker'])
+    register_Ns3QueueSizeValue_methods(root_module, root_module['ns3::QueueSizeValue'])
     register_Ns3RachPreambleLteControlMessage_methods(root_module, root_module['ns3::RachPreambleLteControlMessage'])
     register_Ns3RadioBearerStatsCalculator_methods(root_module, root_module['ns3::RadioBearerStatsCalculator'])
     register_Ns3RarLteControlMessage_methods(root_module, root_module['ns3::RarLteControlMessage'])
@@ -2608,6 +2882,8 @@
     register_Ns3RrcDlDcchMessage_methods(root_module, root_module['ns3::RrcDlDcchMessage'])
     register_Ns3RrcUlCcchMessage_methods(root_module, root_module['ns3::RrcUlCcchMessage'])
     register_Ns3RrcUlDcchMessage_methods(root_module, root_module['ns3::RrcUlDcchMessage'])
+    register_Ns3S1apConnectionInfo_methods(root_module, root_module['ns3::S1apConnectionInfo'])
+    register_Ns3S1apIfaceInfo_methods(root_module, root_module['ns3::S1apIfaceInfo'])
     register_Ns3Sib1LteControlMessage_methods(root_module, root_module['ns3::Sib1LteControlMessage'])
     register_Ns3SimpleUeComponentCarrierManager_methods(root_module, root_module['ns3::SimpleUeComponentCarrierManager'])
     register_Ns3SpectrumChannel_methods(root_module, root_module['ns3::SpectrumChannel'])
@@ -2638,6 +2914,7 @@
     register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3Packet__gt___Const_ns3Address___amp___Const_ns3Address___amp___Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< bool, ns3::Ptr<ns3::Packet>, const ns3::Address &, const ns3::Address &, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3Socket__gt___Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< bool, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Ns3ObjectBase___star___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Bool_Bool_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Const_ns3SpectrumValue___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3DlSchedulingCallbackInfo_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3EpcUeNasState_Ns3EpcUeNasState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::EpcUeNas::State, ns3::EpcUeNas::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
@@ -2646,6 +2923,8 @@
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3MobilityModel__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::MobilityModel>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3Packet__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3PacketBurst__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::PacketBurst>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3QueueDiscItem__gt___Const_char___star___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3QueueDiscItem__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3LteUeRrc__gt___StdList__lt__ns3LteRrcSapSCellToAddMod__stdAllocator__lt__ns3LteRrcSapSCellToAddMod__gt_____gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::LteUeRrc>, std::list<ns3::LteRrcSap::SCellToAddMod, std::allocator<ns3::LteRrcSap::SCellToAddMod> >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Ptr__lt__const_ns3Packet__gt___Unsigned_short_Const_ns3Address___amp___Const_ns3Address___amp___Ns3NetDevicePacketType_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::NetDevice>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
@@ -2653,8 +2932,11 @@
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Ns3Time_Ns3Time_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Unsigned_short_Unsigned_char_Unsigned_short_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Long_double_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Ns3LteRrcSapMeasurementReport_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Ns3LteUeRrcState_Ns3LteUeRrcState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long, unsigned short, unsigned short, ns3::LteUeRrc::State, ns3::LteUeRrc::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
@@ -2663,6 +2945,7 @@
     register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long, unsigned short, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Ns3Ptr__lt__ns3SpectrumValue__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, ns3::Ptr<ns3::SpectrumValue>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Unsigned_long_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned char, unsigned int, unsigned long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Double_Bool_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Double_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, double, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
@@ -2670,6 +2953,7 @@
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Ns3LteUePhyState_Ns3LteUePhyState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, ns3::LteUePhy::State, ns3::LteUePhy::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Unsigned_int_Unsigned_long_Bool_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CqaFfMacScheduler_methods(root_module, root_module['ns3::CqaFfMacScheduler'])
     register_Ns3DlCqiLteControlMessage_methods(root_module, root_module['ns3::DlCqiLteControlMessage'])
     register_Ns3DlDciLteControlMessage_methods(root_module, root_module['ns3::DlDciLteControlMessage'])
@@ -2684,6 +2968,8 @@
     register_Ns3LteNetDevice_methods(root_module, root_module['ns3::LteNetDevice'])
     register_Ns3LteUeNetDevice_methods(root_module, root_module['ns3::LteUeNetDevice'])
     register_Ns3MeasurementReportHeader_methods(root_module, root_module['ns3::MeasurementReportHeader'])
+    register_Ns3QueueDiscItem_methods(root_module, root_module['ns3::QueueDiscItem'])
+    register_Ns3RrcConnectToMmWaveHeader_methods(root_module, root_module['ns3::RrcConnectToMmWaveHeader'])
     register_Ns3RrcConnectionReconfigurationCompleteHeader_methods(root_module, root_module['ns3::RrcConnectionReconfigurationCompleteHeader'])
     register_Ns3RrcConnectionReconfigurationHeader_methods(root_module, root_module['ns3::RrcConnectionReconfigurationHeader'])
     register_Ns3RrcConnectionReestablishmentCompleteHeader_methods(root_module, root_module['ns3::RrcConnectionReestablishmentCompleteHeader'])
@@ -2695,6 +2981,8 @@
     register_Ns3RrcConnectionRequestHeader_methods(root_module, root_module['ns3::RrcConnectionRequestHeader'])
     register_Ns3RrcConnectionSetupCompleteHeader_methods(root_module, root_module['ns3::RrcConnectionSetupCompleteHeader'])
     register_Ns3RrcConnectionSetupHeader_methods(root_module, root_module['ns3::RrcConnectionSetupHeader'])
+    register_Ns3RrcConnectionSwitchHeader_methods(root_module, root_module['ns3::RrcConnectionSwitchHeader'])
+    register_Ns3RrcNotifySecondaryConnectedHeader_methods(root_module, root_module['ns3::RrcNotifySecondaryConnectedHeader'])
     register_Ns3LteEnbNetDevice_methods(root_module, root_module['ns3::LteEnbNetDevice'])
     register_Ns3ConfigMatchContainer_methods(root_module, root_module['ns3::Config::MatchContainer'])
     register_Ns3HashImplementation_methods(root_module, root_module['ns3::Hash::Implementation'])
@@ -3548,6 +3836,42 @@
                    is_static=True)
     return
 
+def register_Ns3DefaultDeleter__Ns3QueueItem_methods(root_module, cls):
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::QueueItem>::DefaultDeleter() [constructor]
+    cls.add_constructor([])
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::QueueItem>::DefaultDeleter(ns3::DefaultDeleter<ns3::QueueItem> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::DefaultDeleter< ns3::QueueItem > const &', 'arg0')])
+    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::QueueItem>::Delete(ns3::QueueItem * object) [member function]
+    cls.add_method('Delete', 
+                   'void', 
+                   [param('ns3::QueueItem *', 'object')], 
+                   is_static=True)
+    return
+
+def register_Ns3DefaultDeleter__Ns3S1apConnectionInfo_methods(root_module, cls):
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::S1apConnectionInfo>::DefaultDeleter() [constructor]
+    cls.add_constructor([])
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::S1apConnectionInfo>::DefaultDeleter(ns3::DefaultDeleter<ns3::S1apConnectionInfo> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::DefaultDeleter< ns3::S1apConnectionInfo > const &', 'arg0')])
+    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::S1apConnectionInfo>::Delete(ns3::S1apConnectionInfo * object) [member function]
+    cls.add_method('Delete', 
+                   'void', 
+                   [param('ns3::S1apConnectionInfo *', 'object')], 
+                   is_static=True)
+    return
+
+def register_Ns3DefaultDeleter__Ns3S1apIfaceInfo_methods(root_module, cls):
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::S1apIfaceInfo>::DefaultDeleter() [constructor]
+    cls.add_constructor([])
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::S1apIfaceInfo>::DefaultDeleter(ns3::DefaultDeleter<ns3::S1apIfaceInfo> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::DefaultDeleter< ns3::S1apIfaceInfo > const &', 'arg0')])
+    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::S1apIfaceInfo>::Delete(ns3::S1apIfaceInfo * object) [member function]
+    cls.add_method('Delete', 
+                   'void', 
+                   [param('ns3::S1apIfaceInfo *', 'object')], 
+                   is_static=True)
+    return
+
 def register_Ns3DefaultDeleter__Ns3SpectrumModel_methods(root_module, cls):
     ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::SpectrumModel>::DefaultDeleter() [constructor]
     cls.add_constructor([])
@@ -4046,111 +4370,155 @@
     cls.add_constructor([param('ns3::EpcS1apSap const &', 'arg0')])
     return
 
-def register_Ns3EpcS1apSapEnb_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::EpcS1apSapEnb() [constructor]
+def register_Ns3EpcS1apSapErabSetupItem_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSetupItem::ErabSetupItem() [constructor]
     cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::EpcS1apSapEnb(ns3::EpcS1apSapEnb const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapEnb const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnb::InitialContextSetupRequest(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSapEnb::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSapEnb::ErabToBeSetupItem> > erabToBeSetupList) [member function]
-    cls.add_method('InitialContextSetupRequest', 
-                   'void', 
-                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSapEnb::ErabToBeSetupItem >', 'erabToBeSetupList')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnb::PathSwitchRequestAcknowledge(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem> > erabToBeSwitchedInUplinkList) [member function]
-    cls.add_method('PathSwitchRequestAcknowledge', 
-                   'void', 
-                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'cgi'), param('std::list< ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem >', 'erabToBeSwitchedInUplinkList')], 
-                   is_pure_virtual=True, is_virtual=True)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSetupItem::ErabSetupItem(ns3::EpcS1apSap::ErabSetupItem const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSap::ErabSetupItem const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSetupItem::enbTeid [variable]
+    cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSetupItem::enbTransportLayerAddress [variable]
+    cls.add_instance_attribute('enbTransportLayerAddress', 'ns3::Ipv4Address', is_const=False)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSetupItem::erabId [variable]
+    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
+    return
+
+def register_Ns3EpcS1apSapErabSwitchedInDownlinkItem_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInDownlinkItem::ErabSwitchedInDownlinkItem() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInDownlinkItem::ErabSwitchedInDownlinkItem(ns3::EpcS1apSap::ErabSwitchedInDownlinkItem const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSap::ErabSwitchedInDownlinkItem const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInDownlinkItem::enbTeid [variable]
+    cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInDownlinkItem::enbTransportLayerAddress [variable]
+    cls.add_instance_attribute('enbTransportLayerAddress', 'ns3::Ipv4Address', is_const=False)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInDownlinkItem::erabId [variable]
+    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
     return
 
-def register_Ns3EpcS1apSapEnbErabSwitchedInUplinkItem_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::ErabSwitchedInUplinkItem() [constructor]
+def register_Ns3EpcS1apSapErabSwitchedInUplinkItem_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInUplinkItem::ErabSwitchedInUplinkItem() [constructor]
     cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::ErabSwitchedInUplinkItem(ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::enbTeid [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInUplinkItem::ErabSwitchedInUplinkItem(ns3::EpcS1apSap::ErabSwitchedInUplinkItem const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSap::ErabSwitchedInUplinkItem const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInUplinkItem::enbTeid [variable]
     cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::erabId [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInUplinkItem::erabId [variable]
     cls.add_instance_attribute('erabId', 'uint8_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::transportLayerAddress [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInUplinkItem::transportLayerAddress [variable]
     cls.add_instance_attribute('transportLayerAddress', 'ns3::Ipv4Address', is_const=False)
     return
 
-def register_Ns3EpcS1apSapEnbErabToBeSetupItem_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::ErabToBeSetupItem() [constructor]
+def register_Ns3EpcS1apSapErabToBeReleasedIndication_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeReleasedIndication::ErabToBeReleasedIndication() [constructor]
     cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::ErabToBeSetupItem(ns3::EpcS1apSapEnb::ErabToBeSetupItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapEnb::ErabToBeSetupItem const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::erabId [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeReleasedIndication::ErabToBeReleasedIndication(ns3::EpcS1apSap::ErabToBeReleasedIndication const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSap::ErabToBeReleasedIndication const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeReleasedIndication::erabId [variable]
     cls.add_instance_attribute('erabId', 'uint8_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::erabLevelQosParameters [variable]
+    return
+
+def register_Ns3EpcS1apSapErabToBeSetupItem_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem::ErabToBeSetupItem() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem::ErabToBeSetupItem(ns3::EpcS1apSap::ErabToBeSetupItem const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSap::ErabToBeSetupItem const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem::erabId [variable]
+    cls.add_instance_attribute('erabId', 'uint8_t', is_const=False)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem::erabLevelQosParameters [variable]
     cls.add_instance_attribute('erabLevelQosParameters', 'ns3::EpsBearer', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::sgwTeid [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem::sgwTeid [variable]
     cls.add_instance_attribute('sgwTeid', 'uint32_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::transportLayerAddress [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem::transportLayerAddress [variable]
     cls.add_instance_attribute('transportLayerAddress', 'ns3::Ipv4Address', is_const=False)
     return
 
+def register_Ns3EpcS1apSapEnb_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::EpcS1apSapEnb() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::EpcS1apSapEnb(ns3::EpcS1apSapEnb const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSapEnb const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnb::InitialContextSetupRequest(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSap::ErabToBeSetupItem> > erabToBeSetupList) [member function]
+    cls.add_method('InitialContextSetupRequest', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabToBeSetupItem >', 'erabToBeSetupList')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnb::PathSwitchRequestAcknowledge(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ns3::EpcS1apSap::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInUplinkItem> > erabToBeSwitchedInUplinkList) [member function]
+    cls.add_method('PathSwitchRequestAcknowledge', 
+                   'void', 
+                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'cgi'), param('std::list< ns3::EpcS1apSap::ErabSwitchedInUplinkItem >', 'erabToBeSwitchedInUplinkList')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3EpcS1apSapEnbProvider_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnbProvider::EpcS1apSapEnbProvider() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnbProvider::EpcS1apSapEnbProvider(ns3::EpcS1apSapEnbProvider const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSapEnbProvider const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnbProvider::SendErabReleaseIndication(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSap::ErabToBeReleasedIndication> > erabToBeReleaseIndication) [member function]
+    cls.add_method('SendErabReleaseIndication', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabToBeReleasedIndication >', 'erabToBeReleaseIndication')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnbProvider::SendInitialContextSetupResponse(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabSetupItem, std::allocator<ns3::EpcS1apSap::ErabSetupItem> > erabSetupList) [member function]
+    cls.add_method('SendInitialContextSetupResponse', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabSetupItem >', 'erabSetupList')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnbProvider::SendInitialUeMessage(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) [member function]
+    cls.add_method('SendInitialUeMessage', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('uint64_t', 'stmsi'), param('uint16_t', 'ecgi')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnbProvider::SendPathSwitchRequest(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem> > erabToBeSwitchedInDownlinkList) [member function]
+    cls.add_method('SendPathSwitchRequest', 
+                   'void', 
+                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'gci'), param('std::list< ns3::EpcS1apSap::ErabSwitchedInDownlinkItem >', 'erabToBeSwitchedInDownlinkList')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
 def register_Ns3EpcS1apSapMme_methods(root_module, cls):
     ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::EpcS1apSapMme() [constructor]
     cls.add_constructor([])
     ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::EpcS1apSapMme(ns3::EpcS1apSapMme const & arg0) [constructor]
     cls.add_constructor([param('ns3::EpcS1apSapMme const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::ErabReleaseIndication(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSapMme::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSapMme::ErabToBeReleasedIndication> > erabToBeReleaseIndication) [member function]
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::ErabReleaseIndication(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSap::ErabToBeReleasedIndication> > erabToBeReleaseIndication) [member function]
     cls.add_method('ErabReleaseIndication', 
                    'void', 
-                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSapMme::ErabToBeReleasedIndication >', 'erabToBeReleaseIndication')], 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabToBeReleasedIndication >', 'erabToBeReleaseIndication')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::InitialContextSetupResponse(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSapMme::ErabSetupItem, std::allocator<ns3::EpcS1apSapMme::ErabSetupItem> > erabSetupList) [member function]
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::InitialContextSetupResponse(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabSetupItem, std::allocator<ns3::EpcS1apSap::ErabSetupItem> > erabSetupList) [member function]
     cls.add_method('InitialContextSetupResponse', 
                    'void', 
-                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSapMme::ErabSetupItem >', 'erabSetupList')], 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabSetupItem >', 'erabSetupList')], 
                    is_pure_virtual=True, is_virtual=True)
     ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::InitialUeMessage(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) [member function]
     cls.add_method('InitialUeMessage', 
                    'void', 
                    [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('uint64_t', 'stmsi'), param('uint16_t', 'ecgi')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::PathSwitchRequest(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem> > erabToBeSwitchedInDownlinkList) [member function]
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::PathSwitchRequest(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem> > erabToBeSwitchedInDownlinkList) [member function]
     cls.add_method('PathSwitchRequest', 
                    'void', 
-                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'gci'), param('std::list< ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem >', 'erabToBeSwitchedInDownlinkList')], 
+                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'gci'), param('std::list< ns3::EpcS1apSap::ErabSwitchedInDownlinkItem >', 'erabToBeSwitchedInDownlinkList')], 
                    is_pure_virtual=True, is_virtual=True)
     return
 
-def register_Ns3EpcS1apSapMmeErabSetupItem_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::ErabSetupItem() [constructor]
-    cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::ErabSetupItem(ns3::EpcS1apSapMme::ErabSetupItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapMme::ErabSetupItem const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::enbTeid [variable]
-    cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::enbTransportLayerAddress [variable]
-    cls.add_instance_attribute('enbTransportLayerAddress', 'ns3::Ipv4Address', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcS1apSapMmeErabSwitchedInDownlinkItem_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::ErabSwitchedInDownlinkItem() [constructor]
+def register_Ns3EpcS1apSapMmeProvider_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMmeProvider::EpcS1apSapMmeProvider() [constructor]
     cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::ErabSwitchedInDownlinkItem(ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::enbTeid [variable]
-    cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::enbTransportLayerAddress [variable]
-    cls.add_instance_attribute('enbTransportLayerAddress', 'ns3::Ipv4Address', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcS1apSapMmeErabToBeReleasedIndication_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabToBeReleasedIndication::ErabToBeReleasedIndication() [constructor]
-    cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabToBeReleasedIndication::ErabToBeReleasedIndication(ns3::EpcS1apSapMme::ErabToBeReleasedIndication const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapMme::ErabToBeReleasedIndication const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabToBeReleasedIndication::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint8_t', is_const=False)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMmeProvider::EpcS1apSapMmeProvider(ns3::EpcS1apSapMmeProvider const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSapMmeProvider const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMmeProvider::SendInitialContextSetupRequest(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSap::ErabToBeSetupItem> > erabToBeSetupList, uint16_t cellId) [member function]
+    cls.add_method('SendInitialContextSetupRequest', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabToBeSetupItem >', 'erabToBeSetupList'), param('uint16_t', 'cellId')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMmeProvider::SendPathSwitchRequestAcknowledge(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ns3::EpcS1apSap::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInUplinkItem> > erabToBeSwitchedInUplinkList) [member function]
+    cls.add_method('SendPathSwitchRequestAcknowledge', 
+                   'void', 
+                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'cgi'), param('std::list< ns3::EpcS1apSap::ErabSwitchedInUplinkItem >', 'erabToBeSwitchedInUplinkList')], 
+                   is_pure_virtual=True, is_virtual=True)
     return
 
 def register_Ns3EpcX2Sap_methods(root_module, cls):
@@ -4281,6 +4649,21 @@
     cls.add_instance_attribute('ulPdcpSn', 'uint16_t', is_const=False)
     return
 
+def register_Ns3EpcX2SapHandoverFailedParams_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams::HandoverFailedParams() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams::HandoverFailedParams(ns3::EpcX2Sap::HandoverFailedParams const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Sap::HandoverFailedParams const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams::coordinatorId [variable]
+    cls.add_instance_attribute('coordinatorId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams::imsi [variable]
+    cls.add_instance_attribute('imsi', 'uint64_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams::sourceCellId [variable]
+    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams::targetCellId [variable]
+    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
+    return
+
 def register_Ns3EpcX2SapHandoverPreparationFailureParams_methods(root_module, cls):
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverPreparationFailureParams::HandoverPreparationFailureParams() [constructor]
     cls.add_constructor([])
@@ -4328,10 +4711,14 @@
     cls.add_instance_attribute('bearers', 'std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', is_const=False)
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::cause [variable]
     cls.add_instance_attribute('cause', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::isMc [variable]
+    cls.add_instance_attribute('isMc', 'bool', is_const=False)
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::mmeUeS1apId [variable]
     cls.add_instance_attribute('mmeUeS1apId', 'uint32_t', is_const=False)
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::oldEnbUeX2apId [variable]
     cls.add_instance_attribute('oldEnbUeX2apId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::rlcRequests [variable]
+    cls.add_instance_attribute('rlcRequests', 'std::vector< ns3::EpcX2Sap::RlcSetupRequest >', is_const=False)
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::rrcContext [variable]
     cls.add_instance_attribute('rrcContext', 'ns3::Ptr< ns3::Packet >', is_const=False)
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::sourceCellId [variable]
@@ -4387,6 +4774,61 @@
     cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
     return
 
+def register_Ns3EpcX2SapRlcSetupRequest_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::RlcSetupRequest() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::RlcSetupRequest(ns3::EpcX2Sap::RlcSetupRequest const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Sap::RlcSetupRequest const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::drbid [variable]
+    cls.add_instance_attribute('drbid', 'uint8_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::gtpTeid [variable]
+    cls.add_instance_attribute('gtpTeid', 'uint32_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::lcinfo [variable]
+    cls.add_instance_attribute('lcinfo', 'ns3::LteEnbCmacSapProvider::LcInfo', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::logicalChannelConfig [variable]
+    cls.add_instance_attribute('logicalChannelConfig', 'ns3::LteRrcSap::LogicalChannelConfig', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::lteRnti [variable]
+    cls.add_instance_attribute('lteRnti', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::mmWaveRnti [variable]
+    cls.add_instance_attribute('mmWaveRnti', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::rlcConfig [variable]
+    cls.add_instance_attribute('rlcConfig', 'ns3::LteRrcSap::RlcConfig', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::rlcType [variable]
+    cls.add_instance_attribute('rlcType', 'ns3::TypeId', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::sourceCellId [variable]
+    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::targetCellId [variable]
+    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
+    return
+
+def register_Ns3EpcX2SapSecondaryHandoverCompletedParams_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams::SecondaryHandoverCompletedParams() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams::SecondaryHandoverCompletedParams(ns3::EpcX2Sap::SecondaryHandoverCompletedParams const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Sap::SecondaryHandoverCompletedParams const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams::cellId [variable]
+    cls.add_instance_attribute('cellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams::imsi [variable]
+    cls.add_instance_attribute('imsi', 'uint64_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams::mmWaveRnti [variable]
+    cls.add_instance_attribute('mmWaveRnti', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams::oldEnbUeX2apId [variable]
+    cls.add_instance_attribute('oldEnbUeX2apId', 'uint16_t', is_const=False)
+    return
+
+def register_Ns3EpcX2SapSecondaryHandoverParams_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverParams::SecondaryHandoverParams() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverParams::SecondaryHandoverParams(ns3::EpcX2Sap::SecondaryHandoverParams const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Sap::SecondaryHandoverParams const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverParams::imsi [variable]
+    cls.add_instance_attribute('imsi', 'uint64_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverParams::oldCellId [variable]
+    cls.add_instance_attribute('oldCellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverParams::targetCellId [variable]
+    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
+    return
+
 def register_Ns3EpcX2SapSnStatusTransferParams_methods(root_module, cls):
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SnStatusTransferParams::SnStatusTransferParams() [constructor]
     cls.add_constructor([])
@@ -4404,6 +4846,21 @@
     cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
     return
 
+def register_Ns3EpcX2SapSwitchConnectionParams_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams::SwitchConnectionParams() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams::SwitchConnectionParams(ns3::EpcX2Sap::SwitchConnectionParams const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Sap::SwitchConnectionParams const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams::drbid [variable]
+    cls.add_instance_attribute('drbid', 'uint8_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams::mmWaveCellId [variable]
+    cls.add_instance_attribute('mmWaveCellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams::mmWaveRnti [variable]
+    cls.add_instance_attribute('mmWaveRnti', 'uint32_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams::useMmWaveConnection [variable]
+    cls.add_instance_attribute('useMmWaveConnection', 'bool', is_const=False)
+    return
+
 def register_Ns3EpcX2SapUeContextReleaseParams_methods(root_module, cls):
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeContextReleaseParams::UeContextReleaseParams() [constructor]
     cls.add_constructor([])
@@ -4434,6 +4891,19 @@
     cls.add_instance_attribute('ueData', 'ns3::Ptr< ns3::Packet >', is_const=False)
     return
 
+def register_Ns3EpcX2SapUeImsiSinrParams_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeImsiSinrParams::UeImsiSinrParams() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeImsiSinrParams::UeImsiSinrParams(ns3::EpcX2Sap::UeImsiSinrParams const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Sap::UeImsiSinrParams const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeImsiSinrParams::sourceCellId [variable]
+    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeImsiSinrParams::targetCellId [variable]
+    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeImsiSinrParams::ueImsiSinrMap [variable]
+    cls.add_instance_attribute('ueImsiSinrMap', 'std::map< unsigned long, double >', is_const=False)
+    return
+
 def register_Ns3EpcX2SapUlHighInterferenceInformationItem_methods(root_module, cls):
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UlHighInterferenceInformationItem::UlHighInterferenceInformationItem() [constructor]
     cls.add_constructor([])
@@ -4450,6 +4920,31 @@
     cls.add_constructor([])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2SapProvider::EpcX2SapProvider(ns3::EpcX2SapProvider const & arg0) [constructor]
     cls.add_constructor([param('ns3::EpcX2SapProvider const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::AddTeidToBeForwarded(uint32_t gtpTeid, uint16_t targetCellId) [member function]
+    cls.add_method('AddTeidToBeForwarded', 
+                   'void', 
+                   [param('uint32_t', 'gtpTeid'), param('uint16_t', 'targetCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::ForwardRlcPdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('ForwardRlcPdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::NotifyCoordinatorHandoverFailed(ns3::EpcX2Sap::HandoverFailedParams params) [member function]
+    cls.add_method('NotifyCoordinatorHandoverFailed', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::HandoverFailedParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::NotifyLteMmWaveHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverParams params) [member function]
+    cls.add_method('NotifyLteMmWaveHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::RemoveTeidToBeForwarded(uint32_t gtpTeid) [member function]
+    cls.add_method('RemoveTeidToBeForwarded', 
+                   'void', 
+                   [param('uint32_t', 'gtpTeid')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendHandoverPreparationFailure(ns3::EpcX2Sap::HandoverPreparationFailureParams params) [member function]
     cls.add_method('SendHandoverPreparationFailure', 
                    'void', 
@@ -4470,16 +4965,41 @@
                    'void', 
                    [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendMcHandoverRequest(ns3::EpcX2Sap::SecondaryHandoverParams params) [member function]
+    cls.add_method('SendMcHandoverRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendResourceStatusUpdate(ns3::EpcX2Sap::ResourceStatusUpdateParams params) [member function]
     cls.add_method('SendResourceStatusUpdate', 
                    'void', 
                    [param('ns3::EpcX2Sap::ResourceStatusUpdateParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendRlcSetupCompleted(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('SendRlcSetupCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendRlcSetupRequest(ns3::EpcX2Sap::RlcSetupRequest params) [member function]
+    cls.add_method('SendRlcSetupRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::RlcSetupRequest', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendSecondaryCellHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverCompletedParams params) [member function]
+    cls.add_method('SendSecondaryCellHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverCompletedParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
     cls.add_method('SendSnStatusTransfer', 
                    'void', 
                    [param('ns3::EpcX2Sap::SnStatusTransferParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendSwitchConnectionToMmWave(ns3::EpcX2Sap::SwitchConnectionParams params) [member function]
+    cls.add_method('SendSwitchConnectionToMmWave', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SwitchConnectionParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendUeContextRelease(ns3::EpcX2Sap::UeContextReleaseParams params) [member function]
     cls.add_method('SendUeContextRelease', 
                    'void', 
@@ -4490,6 +5010,21 @@
                    'void', 
                    [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendUeSinrUpdate(ns3::EpcX2Sap::UeImsiSinrParams params) [member function]
+    cls.add_method('SendUeSinrUpdate', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeImsiSinrParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SetEpcX2PdcpUser(uint32_t teid, ns3::EpcX2PdcpUser * s) [member function]
+    cls.add_method('SetEpcX2PdcpUser', 
+                   'void', 
+                   [param('uint32_t', 'teid'), param('ns3::EpcX2PdcpUser *', 's')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SetEpcX2RlcUser(uint32_t teid, ns3::EpcX2RlcUser * s) [member function]
+    cls.add_method('SetEpcX2RlcUser', 
+                   'void', 
+                   [param('uint32_t', 'teid'), param('ns3::EpcX2RlcUser *', 's')], 
+                   is_pure_virtual=True, is_virtual=True)
     return
 
 def register_Ns3EpcX2SapUser_methods(root_module, cls):
@@ -4497,6 +5032,11 @@
     cls.add_constructor([])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2SapUser::EpcX2SapUser(ns3::EpcX2SapUser const & arg0) [constructor]
     cls.add_constructor([param('ns3::EpcX2SapUser const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvConnectionSwitchToMmWave(ns3::EpcX2Sap::SwitchConnectionParams params) [member function]
+    cls.add_method('RecvConnectionSwitchToMmWave', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SwitchConnectionParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvHandoverPreparationFailure(ns3::EpcX2Sap::HandoverPreparationFailureParams params) [member function]
     cls.add_method('RecvHandoverPreparationFailure', 
                    'void', 
@@ -4517,11 +5057,36 @@
                    'void', 
                    [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvLteMmWaveHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverParams params) [member function]
+    cls.add_method('RecvLteMmWaveHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvMcHandoverRequest(ns3::EpcX2Sap::SecondaryHandoverParams params) [member function]
+    cls.add_method('RecvMcHandoverRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvResourceStatusUpdate(ns3::EpcX2Sap::ResourceStatusUpdateParams params) [member function]
     cls.add_method('RecvResourceStatusUpdate', 
                    'void', 
                    [param('ns3::EpcX2Sap::ResourceStatusUpdateParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvRlcSetupCompleted(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('RecvRlcSetupCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvRlcSetupRequest(ns3::EpcX2Sap::RlcSetupRequest params) [member function]
+    cls.add_method('RecvRlcSetupRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::RlcSetupRequest', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvSecondaryCellHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverCompletedParams params) [member function]
+    cls.add_method('RecvSecondaryCellHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverCompletedParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
     cls.add_method('RecvSnStatusTransfer', 
                    'void', 
@@ -4537,6 +5102,11 @@
                    'void', 
                    [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvUeSinrUpdate(ns3::EpcX2Sap::UeImsiSinrParams params) [member function]
+    cls.add_method('RecvUeSinrUpdate', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeImsiSinrParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     return
 
 def register_Ns3EpsBearer_methods(root_module, cls):
@@ -5346,18 +5916,18 @@
     cls.add_constructor([])
     ## hash.h (module 'core'): ns3::Hasher::Hasher(ns3::Ptr<ns3::Hash::Implementation> hp) [constructor]
     cls.add_constructor([param('ns3::Ptr< ns3::Hash::Implementation >', 'hp')])
-    ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(char const * buffer, std::size_t const size) [member function]
+    ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(char const * buffer, size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('std::size_t const', 'size')])
+                   [param('char const *', 'buffer'), param('size_t const', 'size')])
     ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(std::string const s) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
                    [param('std::string const', 's')])
-    ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(char const * buffer, std::size_t const size) [member function]
+    ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(char const * buffer, size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('std::size_t const', 'size')])
+                   [param('char const *', 'buffer'), param('size_t const', 'size')])
     ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(std::string const s) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
@@ -6382,6 +6952,16 @@
                    'void', 
                    [param('uint16_t', 'cellId'), param('uint32_t', 'dlEarfcn')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::NotifySecondaryCellConnected(uint16_t rnti, uint16_t mmWaveCellId) [member function]
+    cls.add_method('NotifySecondaryCellConnected', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::NotifySecondaryCellHandover(uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, ns3::LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated) [member function]
+    cls.add_method('NotifySecondaryCellHandover', 
+                   'void', 
+                   [param('uint16_t', 'oldRnti'), param('uint16_t', 'newRnti'), param('uint16_t', 'mmWaveCellId'), param('ns3::LteRrcSap::RadioResourceConfigDedicated', 'radioResourceConfigDedicated')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::SendData(ns3::Ptr<ns3::Packet> packet, uint8_t bid) [member function]
     cls.add_method('SendData', 
                    'void', 
@@ -6404,6 +6984,11 @@
     cls.add_constructor([])
     ## lte-as-sap.h (module 'lte'): ns3::LteAsSapUser::LteAsSapUser(ns3::LteAsSapUser const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteAsSapUser const &', 'arg0')])
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyConnectToMmWave(uint16_t mmWaveCellId) [member function]
+    cls.add_method('NotifyConnectToMmWave', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyConnectionFailed() [member function]
     cls.add_method('NotifyConnectionFailed', 
                    'void', 
@@ -6414,10 +6999,20 @@
                    'void', 
                    [], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyConnectionSuccessful() [member function]
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyConnectionSuccessful(uint16_t rnti) [member function]
     cls.add_method('NotifyConnectionSuccessful', 
                    'void', 
-                   [], 
+                   [param('uint16_t', 'rnti')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyHandoverSuccessful(uint16_t rnti, uint16_t mmWaveCellId) [member function]
+    cls.add_method('NotifyHandoverSuccessful', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifySecondaryCellHandoverStarted(uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, ns3::LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated) [member function]
+    cls.add_method('NotifySecondaryCellHandoverStarted', 
+                   'void', 
+                   [param('uint16_t', 'oldRnti'), param('uint16_t', 'newRnti'), param('uint16_t', 'mmWaveCellId'), param('ns3::LteRrcSap::RadioResourceConfigDedicated', 'radioResourceConfigDedicated')], 
                    is_pure_virtual=True, is_virtual=True)
     ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::RecvData(ns3::Ptr<ns3::Packet> packet) [member function]
     cls.add_method('RecvData', 
@@ -6739,6 +7334,22 @@
     cls.add_constructor([])
     ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::LteEnbCphySapUser(ns3::LteEnbCphySapUser const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteEnbCphySapUser const &', 'arg0')])
+    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapUser::UpdateUeSinrEstimate(ns3::LteEnbCphySapUser::UeAssociatedSinrInfo info) [member function]
+    cls.add_method('UpdateUeSinrEstimate', 
+                   'void', 
+                   [param('ns3::LteEnbCphySapUser::UeAssociatedSinrInfo', 'info')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3LteEnbCphySapUserUeAssociatedSinrInfo_methods(root_module, cls):
+    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::UeAssociatedSinrInfo::UeAssociatedSinrInfo() [constructor]
+    cls.add_constructor([])
+    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::UeAssociatedSinrInfo::UeAssociatedSinrInfo(ns3::LteEnbCphySapUser::UeAssociatedSinrInfo const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteEnbCphySapUser::UeAssociatedSinrInfo const &', 'arg0')])
+    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::UeAssociatedSinrInfo::componentCarrierId [variable]
+    cls.add_instance_attribute('componentCarrierId', 'uint8_t', is_const=False)
+    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::UeAssociatedSinrInfo::ueImsiSinrMap [variable]
+    cls.add_instance_attribute('ueImsiSinrMap', 'std::map< unsigned long, double >', is_const=False)
     return
 
 def register_Ns3LteEnbPhySapProvider_methods(root_module, cls):
@@ -7021,8 +7632,14 @@
     cls.add_constructor([])
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::ReportBufferStatusParameters(ns3::LteMacSapProvider::ReportBufferStatusParameters const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteMacSapProvider::ReportBufferStatusParameters const &', 'arg0')])
+    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::arrivalRate [variable]
+    cls.add_instance_attribute('arrivalRate', 'double', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::lcid [variable]
     cls.add_instance_attribute('lcid', 'uint8_t', is_const=False)
+    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::retxPacketDelays [variable]
+    cls.add_instance_attribute('retxPacketDelays', 'std::list< double >', is_const=False)
+    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::retxPacketSizes [variable]
+    cls.add_instance_attribute('retxPacketSizes', 'std::list< unsigned int >', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::retxQueueHolDelay [variable]
     cls.add_instance_attribute('retxQueueHolDelay', 'uint16_t', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::retxQueueSize [variable]
@@ -7031,6 +7648,10 @@
     cls.add_instance_attribute('rnti', 'uint16_t', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::statusPduSize [variable]
     cls.add_instance_attribute('statusPduSize', 'uint16_t', is_const=False)
+    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::txPacketDelays [variable]
+    cls.add_instance_attribute('txPacketDelays', 'std::list< double >', is_const=False)
+    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::txPacketSizes [variable]
+    cls.add_instance_attribute('txPacketSizes', 'std::list< unsigned int >', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::txQueueHolDelay [variable]
     cls.add_instance_attribute('txQueueHolDelay', 'uint16_t', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::txQueueSize [variable]
@@ -7061,6 +7682,11 @@
     cls.add_constructor([])
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapUser::LteMacSapUser(ns3::LteMacSapUser const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteMacSapUser const &', 'arg0')])
+    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::NotifyDlHarqDeliveryFailure(uint8_t harqId) [member function]
+    cls.add_method('NotifyDlHarqDeliveryFailure', 
+                   'void', 
+                   [param('uint8_t', 'harqId')], 
+                   is_virtual=True)
     ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::NotifyHarqDeliveryFailure() [member function]
     cls.add_method('NotifyHarqDeliveryFailure', 
                    'void', 
@@ -7071,6 +7697,11 @@
                    'void', 
                    [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::NotifyUlHarqDeliveryFailure(uint8_t harqId) [member function]
+    cls.add_method('NotifyUlHarqDeliveryFailure', 
+                   'void', 
+                   [param('uint8_t', 'harqId')], 
+                   is_virtual=True)
     ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::ReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
     cls.add_method('ReceivePdu', 
                    'void', 
@@ -7192,6 +7823,33 @@
                    is_pure_virtual=True, is_virtual=True)
     return
 
+def register_Ns3LteRlcSpecificLteMacSapUser_methods(root_module, cls):
+    ## lte-rlc.h (module 'lte'): ns3::LteRlcSpecificLteMacSapUser::LteRlcSpecificLteMacSapUser(ns3::LteRlcSpecificLteMacSapUser const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteRlcSpecificLteMacSapUser const &', 'arg0')])
+    ## lte-rlc.h (module 'lte'): ns3::LteRlcSpecificLteMacSapUser::LteRlcSpecificLteMacSapUser(ns3::LteRlc * rlc) [constructor]
+    cls.add_constructor([param('ns3::LteRlc *', 'rlc')])
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSpecificLteMacSapUser::NotifyHarqDeliveryFailure() [member function]
+    cls.add_method('NotifyHarqDeliveryFailure', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSpecificLteMacSapUser::NotifyHarqDeliveryFailure(uint8_t harqId) [member function]
+    cls.add_method('NotifyHarqDeliveryFailure', 
+                   'void', 
+                   [param('uint8_t', 'harqId')], 
+                   is_virtual=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSpecificLteMacSapUser::NotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
+    cls.add_method('NotifyTxOpportunity', 
+                   'void', 
+                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   is_virtual=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSpecificLteMacSapUser::ReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
+    cls.add_method('ReceivePdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   is_virtual=True)
+    return
+
 def register_Ns3LteRrcSap_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LteRrcSap() [constructor]
     cls.add_constructor([])
@@ -7361,6 +8019,8 @@
     cls.add_instance_attribute('drbIdentity', 'uint8_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::epsBearerIdentity [variable]
     cls.add_instance_attribute('epsBearerIdentity', 'uint8_t', is_const=False)
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::is_mc [variable]
+    cls.add_instance_attribute('is_mc', 'bool', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::logicalChannelConfig [variable]
     cls.add_instance_attribute('logicalChannelConfig', 'ns3::LteRrcSap::LogicalChannelConfig', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::logicalChannelIdentity [variable]
@@ -8059,6 +8719,8 @@
     cls.add_constructor([])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest::RrcConnectionRequest(ns3::LteRrcSap::RrcConnectionRequest const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionRequest const &', 'arg0')])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest::isMc [variable]
+    cls.add_instance_attribute('isMc', 'bool', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest::ueIdentity [variable]
     cls.add_instance_attribute('ueIdentity', 'uint64_t', is_const=False)
     return
@@ -8083,6 +8745,19 @@
     cls.add_instance_attribute('rrcTransactionIdentifier', 'uint8_t', is_const=False)
     return
 
+def register_Ns3LteRrcSapRrcConnectionSwitch_methods(root_module, cls):
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch::RrcConnectionSwitch() [constructor]
+    cls.add_constructor([])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch::RrcConnectionSwitch(ns3::LteRrcSap::RrcConnectionSwitch const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionSwitch const &', 'arg0')])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch::drbidList [variable]
+    cls.add_instance_attribute('drbidList', 'std::vector< unsigned char >', is_const=False)
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch::rrcTransactionIdentifier [variable]
+    cls.add_instance_attribute('rrcTransactionIdentifier', 'uint8_t', is_const=False)
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch::useMmWaveConnection [variable]
+    cls.add_instance_attribute('useMmWaveConnection', 'uint16_t', is_const=False)
+    return
+
 def register_Ns3LteRrcSapSCellToAddMod_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::SCellToAddMod() [constructor]
     cls.add_constructor([])
@@ -8541,6 +9216,11 @@
     cls.add_constructor([])
     ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::LteUeCphySapUser(ns3::LteUeCphySapUser const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteUeCphySapUser const &', 'arg0')])
+    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapUser::NotifyRadioLinkFailure(double lastSinrValue) [member function]
+    cls.add_method('NotifyRadioLinkFailure', 
+                   'void', 
+                   [param('double', 'lastSinrValue')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapUser::RecvMasterInformationBlock(uint16_t cellId, ns3::LteRrcSap::MasterInformationBlock mib) [member function]
     cls.add_method('RecvMasterInformationBlock', 
                    'void', 
@@ -8636,6 +9316,11 @@
                    'void', 
                    [param('ns3::LteUeRrcSapProvider::CompleteSetupParameters', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvRrcConnectToMmWave(uint16_t mmWaveCellId) [member function]
+    cls.add_method('RecvRrcConnectToMmWave', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvRrcConnectionReconfiguration(ns3::LteRrcSap::RrcConnectionReconfiguration msg) [member function]
     cls.add_method('RecvRrcConnectionReconfiguration', 
                    'void', 
@@ -8666,6 +9351,11 @@
                    'void', 
                    [param('ns3::LteRrcSap::RrcConnectionSetup', 'msg')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvRrcConnectionSwitch(ns3::LteRrcSap::RrcConnectionSwitch msg) [member function]
+    cls.add_method('RecvRrcConnectionSwitch', 
+                   'void', 
+                   [param('ns3::LteRrcSap::RrcConnectionSwitch', 'msg')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvSystemInformation(ns3::LteRrcSap::SystemInformation msg) [member function]
     cls.add_method('RecvSystemInformation', 
                    'void', 
@@ -8694,6 +9384,11 @@
                    'void', 
                    [param('ns3::LteRrcSap::MeasurementReport', 'msg')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapUser::SendNotifySecondaryCellConnected(uint16_t mmWaveRnti, uint16_t mmWaveCellId) [member function]
+    cls.add_method('SendNotifySecondaryCellConnected', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveRnti'), param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapUser::SendRrcConnectionReconfigurationCompleted(ns3::LteRrcSap::RrcConnectionReconfigurationCompleted msg) [member function]
     cls.add_method('SendRrcConnectionReconfigurationCompleted', 
                    'void', 
@@ -9470,6 +10165,34 @@
     cls.add_instance_attribute('m_txMode', 'uint8_t', is_const=False)
     return
 
+def register_Ns3QueueSize_methods(root_module, cls):
+    cls.add_output_stream_operator()
+    cls.add_binary_comparison_operator('!=')
+    cls.add_binary_comparison_operator('<')
+    cls.add_binary_comparison_operator('<=')
+    cls.add_binary_comparison_operator('==')
+    cls.add_binary_comparison_operator('>')
+    cls.add_binary_comparison_operator('>=')
+    ## queue-size.h (module 'network'): ns3::QueueSize::QueueSize(ns3::QueueSize const & arg0) [constructor]
+    cls.add_constructor([param('ns3::QueueSize const &', 'arg0')])
+    ## queue-size.h (module 'network'): ns3::QueueSize::QueueSize() [constructor]
+    cls.add_constructor([])
+    ## queue-size.h (module 'network'): ns3::QueueSize::QueueSize(ns3::QueueSizeUnit unit, uint32_t value) [constructor]
+    cls.add_constructor([param('ns3::QueueSizeUnit', 'unit'), param('uint32_t', 'value')])
+    ## queue-size.h (module 'network'): ns3::QueueSize::QueueSize(std::string size) [constructor]
+    cls.add_constructor([param('std::string', 'size')])
+    ## queue-size.h (module 'network'): ns3::QueueSizeUnit ns3::QueueSize::GetUnit() const [member function]
+    cls.add_method('GetUnit', 
+                   'ns3::QueueSizeUnit', 
+                   [], 
+                   is_const=True)
+    ## queue-size.h (module 'network'): uint32_t ns3::QueueSize::GetValue() const [member function]
+    cls.add_method('GetValue', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    return
+
 def register_Ns3RachListElement_s_methods(root_module, cls):
     ## ff-mac-common.h (module 'lte'): ns3::RachListElement_s::RachListElement_s() [constructor]
     cls.add_constructor([])
@@ -9942,6 +10665,74 @@
     cls.add_constructor([param('ns3::Time const', 'time'), param('ns3::Time::Unit const', 'unit')])
     return
 
+def register_Ns3TracedValue__Bool_methods(root_module, cls):
+    ## traced-value.h (module 'core'): ns3::TracedValue<bool>::TracedValue() [constructor]
+    cls.add_constructor([])
+    ## traced-value.h (module 'core'): ns3::TracedValue<bool>::TracedValue(ns3::TracedValue<bool> const & o) [constructor]
+    cls.add_constructor([param('ns3::TracedValue< bool > const &', 'o')])
+    ## traced-value.h (module 'core'): ns3::TracedValue<bool>::TracedValue(bool const & v) [constructor]
+    cls.add_constructor([param('bool const &', 'v')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<bool>::Connect(ns3::CallbackBase const & cb, std::string path) [member function]
+    cls.add_method('Connect', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb'), param('std::string', 'path')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<bool>::ConnectWithoutContext(ns3::CallbackBase const & cb) [member function]
+    cls.add_method('ConnectWithoutContext', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<bool>::Disconnect(ns3::CallbackBase const & cb, std::string path) [member function]
+    cls.add_method('Disconnect', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb'), param('std::string', 'path')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<bool>::DisconnectWithoutContext(ns3::CallbackBase const & cb) [member function]
+    cls.add_method('DisconnectWithoutContext', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb')])
+    ## traced-value.h (module 'core'): bool ns3::TracedValue<bool>::Get() const [member function]
+    cls.add_method('Get', 
+                   'bool', 
+                   [], 
+                   is_const=True)
+    ## traced-value.h (module 'core'): void ns3::TracedValue<bool>::Set(bool const & v) [member function]
+    cls.add_method('Set', 
+                   'void', 
+                   [param('bool const &', 'v')])
+    return
+
+def register_Ns3TracedValue__Unsigned_int_methods(root_module, cls):
+    ## traced-value.h (module 'core'): ns3::TracedValue<unsigned int>::TracedValue() [constructor]
+    cls.add_constructor([])
+    ## traced-value.h (module 'core'): ns3::TracedValue<unsigned int>::TracedValue(ns3::TracedValue<unsigned int> const & o) [constructor]
+    cls.add_constructor([param('ns3::TracedValue< unsigned int > const &', 'o')])
+    ## traced-value.h (module 'core'): ns3::TracedValue<unsigned int>::TracedValue(unsigned int const & v) [constructor]
+    cls.add_constructor([param('unsigned int const &', 'v')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<unsigned int>::Connect(ns3::CallbackBase const & cb, std::string path) [member function]
+    cls.add_method('Connect', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb'), param('std::string', 'path')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<unsigned int>::ConnectWithoutContext(ns3::CallbackBase const & cb) [member function]
+    cls.add_method('ConnectWithoutContext', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<unsigned int>::Disconnect(ns3::CallbackBase const & cb, std::string path) [member function]
+    cls.add_method('Disconnect', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb'), param('std::string', 'path')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<unsigned int>::DisconnectWithoutContext(ns3::CallbackBase const & cb) [member function]
+    cls.add_method('DisconnectWithoutContext', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb')])
+    ## traced-value.h (module 'core'): unsigned int ns3::TracedValue<unsigned int>::Get() const [member function]
+    cls.add_method('Get', 
+                   'unsigned int', 
+                   [], 
+                   is_const=True)
+    ## traced-value.h (module 'core'): void ns3::TracedValue<unsigned int>::Set(unsigned int const & v) [member function]
+    cls.add_method('Set', 
+                   'void', 
+                   [param('unsigned int const &', 'v')])
+    return
+
 def register_Ns3TransmissionModesLayers_methods(root_module, cls):
     ## lte-common.h (module 'lte'): ns3::TransmissionModesLayers::TransmissionModesLayers() [constructor]
     cls.add_constructor([])
@@ -9982,19 +10773,19 @@
     cls.add_method('AddTraceSource', 
                    'ns3::TypeId', 
                    [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor'), param('std::string', 'callback'), param('ns3::TypeId::SupportLevel', 'supportLevel', default_value='::ns3::TypeId::SupportLevel::SUPPORTED'), param('std::string const &', 'supportMsg', default_value='""')])
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation ns3::TypeId::GetAttribute(std::size_t i) const [member function]
+    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation ns3::TypeId::GetAttribute(uint32_t i) const [member function]
     cls.add_method('GetAttribute', 
                    'ns3::TypeId::AttributeInformation', 
-                   [param('std::size_t', 'i')], 
+                   [param('uint32_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): std::string ns3::TypeId::GetAttributeFullName(std::size_t i) const [member function]
+    ## type-id.h (module 'core'): std::string ns3::TypeId::GetAttributeFullName(uint32_t i) const [member function]
     cls.add_method('GetAttributeFullName', 
                    'std::string', 
-                   [param('std::size_t', 'i')], 
+                   [param('uint32_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetAttributeN() const [member function]
+    ## type-id.h (module 'core'): uint32_t ns3::TypeId::GetAttributeN() const [member function]
     cls.add_method('GetAttributeN', 
-                   'std::size_t', 
+                   'uint32_t', 
                    [], 
                    is_const=True)
     ## type-id.h (module 'core'): ns3::Callback<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> ns3::TypeId::GetConstructor() const [member function]
@@ -10022,14 +10813,14 @@
                    'ns3::TypeId', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::GetRegistered(uint16_t i) [member function]
+    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::GetRegistered(uint32_t i) [member function]
     cls.add_method('GetRegistered', 
                    'ns3::TypeId', 
-                   [param('uint16_t', 'i')], 
+                   [param('uint32_t', 'i')], 
                    is_static=True)
-    ## type-id.h (module 'core'): static uint16_t ns3::TypeId::GetRegisteredN() [member function]
+    ## type-id.h (module 'core'): static uint32_t ns3::TypeId::GetRegisteredN() [member function]
     cls.add_method('GetRegisteredN', 
-                   'uint16_t', 
+                   'uint32_t', 
                    [], 
                    is_static=True)
     ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetSize() const [member function]
@@ -10037,14 +10828,14 @@
                    'std::size_t', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation ns3::TypeId::GetTraceSource(std::size_t i) const [member function]
+    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation ns3::TypeId::GetTraceSource(uint32_t i) const [member function]
     cls.add_method('GetTraceSource', 
                    'ns3::TypeId::TraceSourceInformation', 
-                   [param('std::size_t', 'i')], 
+                   [param('uint32_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetTraceSourceN() const [member function]
+    ## type-id.h (module 'core'): uint32_t ns3::TypeId::GetTraceSourceN() const [member function]
     cls.add_method('GetTraceSourceN', 
-                   'std::size_t', 
+                   'uint32_t', 
                    [], 
                    is_const=True)
     ## type-id.h (module 'core'): uint16_t ns3::TypeId::GetUid() const [member function]
@@ -10106,10 +10897,10 @@
                    'bool', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): bool ns3::TypeId::SetAttributeInitialValue(std::size_t i, ns3::Ptr<const ns3::AttributeValue> initialValue) [member function]
+    ## type-id.h (module 'core'): bool ns3::TypeId::SetAttributeInitialValue(uint32_t i, ns3::Ptr<const ns3::AttributeValue> initialValue) [member function]
     cls.add_method('SetAttributeInitialValue', 
                    'bool', 
-                   [param('std::size_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
+                   [param('uint32_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::SetGroupName(std::string groupName) [member function]
     cls.add_method('SetGroupName', 
                    'ns3::TypeId', 
@@ -10623,6 +11414,102 @@
                    is_virtual=True)
     return
 
+def register_Ns3EpcX2PdcpProvider_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2PdcpProvider::EpcX2PdcpProvider() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2PdcpProvider::EpcX2PdcpProvider(ns3::EpcX2PdcpProvider const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2PdcpProvider const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2PdcpProvider::SendMcPdcpPdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('SendMcPdcpPdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3EpcX2PdcpUser_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2PdcpUser::EpcX2PdcpUser() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2PdcpUser::EpcX2PdcpUser(ns3::EpcX2PdcpUser const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2PdcpUser const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2PdcpUser::ReceiveMcPdcpPdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('ReceiveMcPdcpPdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3EpcX2RlcProvider_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2RlcProvider::EpcX2RlcProvider() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2RlcProvider::EpcX2RlcProvider(ns3::EpcX2RlcProvider const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2RlcProvider const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2RlcProvider::ReceiveMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('ReceiveMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3EpcX2RlcUser_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2RlcUser::EpcX2RlcUser() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2RlcUser::EpcX2RlcUser(ns3::EpcX2RlcUser const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2RlcUser const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2RlcUser::SendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('SendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3EpcX2Tag_methods(root_module, cls):
+    ## epc-x2-tag.h (module 'lte'): ns3::EpcX2Tag::EpcX2Tag(ns3::EpcX2Tag const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Tag const &', 'arg0')])
+    ## epc-x2-tag.h (module 'lte'): ns3::EpcX2Tag::EpcX2Tag() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-tag.h (module 'lte'): ns3::EpcX2Tag::EpcX2Tag(ns3::Time senderTimestamp) [constructor]
+    cls.add_constructor([param('ns3::Time', 'senderTimestamp')])
+    ## epc-x2-tag.h (module 'lte'): void ns3::EpcX2Tag::Deserialize(ns3::TagBuffer i) [member function]
+    cls.add_method('Deserialize', 
+                   'void', 
+                   [param('ns3::TagBuffer', 'i')], 
+                   is_virtual=True)
+    ## epc-x2-tag.h (module 'lte'): ns3::TypeId ns3::EpcX2Tag::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-tag.h (module 'lte'): ns3::Time ns3::EpcX2Tag::GetSenderTimestamp() const [member function]
+    cls.add_method('GetSenderTimestamp', 
+                   'ns3::Time', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-tag.h (module 'lte'): uint32_t ns3::EpcX2Tag::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-tag.h (module 'lte'): static ns3::TypeId ns3::EpcX2Tag::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-tag.h (module 'lte'): void ns3::EpcX2Tag::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-tag.h (module 'lte'): void ns3::EpcX2Tag::Serialize(ns3::TagBuffer i) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::TagBuffer', 'i')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-tag.h (module 'lte'): void ns3::EpcX2Tag::SetSenderTimestamp(ns3::Time senderTimestamp) [member function]
+    cls.add_method('SetSenderTimestamp', 
+                   'void', 
+                   [param('ns3::Time', 'senderTimestamp')])
+    return
+
 def register_Ns3EpsBearerTag_methods(root_module, cls):
     ## eps-bearer-tag.h (module 'lte'): ns3::EpsBearerTag::EpsBearerTag(ns3::EpsBearerTag const & arg0) [constructor]
     cls.add_constructor([param('ns3::EpsBearerTag const &', 'arg0')])
@@ -10942,6 +11829,11 @@
                    'void', 
                    [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionSetupCompleted', 'msg')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapProvider::RecvRrcSecondaryCellInitialAccessSuccessful(uint16_t rnti, uint16_t mmWaveRnti, uint16_t mmWaveCellId) [member function]
+    cls.add_method('RecvRrcSecondaryCellInitialAccessSuccessful', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('uint16_t', 'mmWaveRnti'), param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
     return
 
 def register_Ns3LteEnbRrcSapProviderCompleteSetupUeParameters_methods(root_module, cls):
@@ -10985,6 +11877,11 @@
                    'void', 
                    [param('uint16_t', 'rnti')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendRrcConnectToMmWave(uint16_t rnti, uint16_t mmWaveCellId) [member function]
+    cls.add_method('SendRrcConnectToMmWave', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendRrcConnectionReconfiguration(uint16_t rnti, ns3::LteRrcSap::RrcConnectionReconfiguration msg) [member function]
     cls.add_method('SendRrcConnectionReconfiguration', 
                    'void', 
@@ -11015,6 +11912,11 @@
                    'void', 
                    [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionSetup', 'msg')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendRrcConnectionSwitch(uint16_t rnti, ns3::LteRrcSap::RrcConnectionSwitch msg) [member function]
+    cls.add_method('SendRrcConnectionSwitch', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionSwitch', 'msg')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendSystemInformation(uint16_t cellId, ns3::LteRrcSap::SystemInformation msg) [member function]
     cls.add_method('SendSystemInformation', 
                    'void', 
@@ -11599,6 +12501,35 @@
                    visibility='private', is_virtual=True)
     return
 
+def register_Ns3PacketFilter_methods(root_module, cls):
+    ## packet-filter.h (module 'traffic-control'): ns3::PacketFilter::PacketFilter(ns3::PacketFilter const & arg0) [constructor]
+    cls.add_constructor([param('ns3::PacketFilter const &', 'arg0')])
+    ## packet-filter.h (module 'traffic-control'): ns3::PacketFilter::PacketFilter() [constructor]
+    cls.add_constructor([])
+    ## packet-filter.h (module 'traffic-control'): int32_t ns3::PacketFilter::Classify(ns3::Ptr<ns3::QueueDiscItem> item) const [member function]
+    cls.add_method('Classify', 
+                   'int32_t', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')], 
+                   is_const=True)
+    ## packet-filter.h (module 'traffic-control'): static ns3::TypeId ns3::PacketFilter::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## packet-filter.h (module 'traffic-control'): ns3::PacketFilter::PF_NO_MATCH [variable]
+    cls.add_static_attribute('PF_NO_MATCH', 'int const', is_const=True)
+    ## packet-filter.h (module 'traffic-control'): bool ns3::PacketFilter::CheckProtocol(ns3::Ptr<ns3::QueueDiscItem> item) const [member function]
+    cls.add_method('CheckProtocol', 
+                   'bool', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')], 
+                   is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
+    ## packet-filter.h (module 'traffic-control'): int32_t ns3::PacketFilter::DoClassify(ns3::Ptr<ns3::QueueDiscItem> item) const [member function]
+    cls.add_method('DoClassify', 
+                   'int32_t', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')], 
+                   is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
+    return
+
 def register_Ns3PdcpTag_methods(root_module, cls):
     ## lte-pdcp-tag.h (module 'lte'): ns3::PdcpTag::PdcpTag(ns3::PdcpTag const & arg0) [constructor]
     cls.add_constructor([param('ns3::PdcpTag const &', 'arg0')])
@@ -11647,6 +12578,301 @@
                    [param('ns3::Time', 'senderTimestamp')])
     return
 
+def register_Ns3QueueDisc_methods(root_module, cls):
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::QueueDisc(ns3::QueueDiscSizePolicy policy=::ns3::QueueDiscSizePolicy::SINGLE_INTERNAL_QUEUE) [constructor]
+    cls.add_constructor([param('ns3::QueueDiscSizePolicy', 'policy', default_value='::ns3::QueueDiscSizePolicy::SINGLE_INTERNAL_QUEUE')])
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::QueueDisc(ns3::QueueDiscSizePolicy policy, ns3::QueueSizeUnit unit) [constructor]
+    cls.add_constructor([param('ns3::QueueDiscSizePolicy', 'policy'), param('ns3::QueueSizeUnit', 'unit')])
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::AddInternalQueue(ns3::Ptr<ns3::Queue<ns3::QueueDiscItem> > queue) [member function]
+    cls.add_method('AddInternalQueue', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Queue< ns3::QueueDiscItem > >', 'queue')])
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::AddPacketFilter(ns3::Ptr<ns3::PacketFilter> filter) [member function]
+    cls.add_method('AddPacketFilter', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::PacketFilter >', 'filter')])
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::AddQueueDiscClass(ns3::Ptr<ns3::QueueDiscClass> qdClass) [member function]
+    cls.add_method('AddQueueDiscClass', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::QueueDiscClass >', 'qdClass')])
+    ## queue-disc.h (module 'traffic-control'): int32_t ns3::QueueDisc::Classify(ns3::Ptr<ns3::QueueDiscItem> item) [member function]
+    cls.add_method('Classify', 
+                   'int32_t', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')])
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::QueueDiscItem> ns3::QueueDisc::Dequeue() [member function]
+    cls.add_method('Dequeue', 
+                   'ns3::Ptr< ns3::QueueDiscItem >', 
+                   [])
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::QueueDiscItem> ns3::QueueDisc::DequeuePeeked() [member function]
+    cls.add_method('DequeuePeeked', 
+                   'ns3::Ptr< ns3::QueueDiscItem >', 
+                   [])
+    ## queue-disc.h (module 'traffic-control'): bool ns3::QueueDisc::Enqueue(ns3::Ptr<ns3::QueueDiscItem> item) [member function]
+    cls.add_method('Enqueue', 
+                   'bool', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')])
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueSize ns3::QueueDisc::GetCurrentSize() [member function]
+    cls.add_method('GetCurrentSize', 
+                   'ns3::QueueSize', 
+                   [])
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::Queue<ns3::QueueDiscItem> > ns3::QueueDisc::GetInternalQueue(uint32_t i) const [member function]
+    cls.add_method('GetInternalQueue', 
+                   'ns3::Ptr< ns3::Queue< ns3::QueueDiscItem > >', 
+                   [param('uint32_t', 'i')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueSize ns3::QueueDisc::GetMaxSize() const [member function]
+    cls.add_method('GetMaxSize', 
+                   'ns3::QueueSize', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::GetNBytes() const [member function]
+    cls.add_method('GetNBytes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::GetNInternalQueues() const [member function]
+    cls.add_method('GetNInternalQueues', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::GetNPacketFilters() const [member function]
+    cls.add_method('GetNPacketFilters', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::GetNPackets() const [member function]
+    cls.add_method('GetNPackets', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::GetNQueueDiscClasses() const [member function]
+    cls.add_method('GetNQueueDiscClasses', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::NetDevice> ns3::QueueDisc::GetNetDevice() const [member function]
+    cls.add_method('GetNetDevice', 
+                   'ns3::Ptr< ns3::NetDevice >', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::PacketFilter> ns3::QueueDisc::GetPacketFilter(uint32_t i) const [member function]
+    cls.add_method('GetPacketFilter', 
+                   'ns3::Ptr< ns3::PacketFilter >', 
+                   [param('uint32_t', 'i')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::QueueDiscClass> ns3::QueueDisc::GetQueueDiscClass(uint32_t i) const [member function]
+    cls.add_method('GetQueueDiscClass', 
+                   'ns3::Ptr< ns3::QueueDiscClass >', 
+                   [param('uint32_t', 'i')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::GetQuota() const [member function]
+    cls.add_method('GetQuota', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats const & ns3::QueueDisc::GetStats() [member function]
+    cls.add_method('GetStats', 
+                   'ns3::QueueDisc::Stats const &', 
+                   [])
+    ## queue-disc.h (module 'traffic-control'): static ns3::TypeId ns3::QueueDisc::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::WakeMode ns3::QueueDisc::GetWakeMode() const [member function]
+    cls.add_method('GetWakeMode', 
+                   'ns3::QueueDisc::WakeMode', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<const ns3::QueueDiscItem> ns3::QueueDisc::Peek() [member function]
+    cls.add_method('Peek', 
+                   'ns3::Ptr< ns3::QueueDiscItem const >', 
+                   [])
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::Run() [member function]
+    cls.add_method('Run', 
+                   'void', 
+                   [])
+    ## queue-disc.h (module 'traffic-control'): bool ns3::QueueDisc::SetMaxSize(ns3::QueueSize size) [member function]
+    cls.add_method('SetMaxSize', 
+                   'bool', 
+                   [param('ns3::QueueSize', 'size')])
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::SetNetDevice(ns3::Ptr<ns3::NetDevice> device) [member function]
+    cls.add_method('SetNetDevice', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::NetDevice >', 'device')])
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::SetQuota(uint32_t const quota) [member function]
+    cls.add_method('SetQuota', 
+                   'void', 
+                   [param('uint32_t const', 'quota')], 
+                   is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::CHILD_QUEUE_DISC_DROP [variable]
+    cls.add_static_attribute('CHILD_QUEUE_DISC_DROP', 'char const * const', is_const=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::INTERNAL_QUEUE_DROP [variable]
+    cls.add_static_attribute('INTERNAL_QUEUE_DROP', 'char const * const', is_const=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   visibility='protected', is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::DoInitialize() [member function]
+    cls.add_method('DoInitialize', 
+                   'void', 
+                   [], 
+                   visibility='protected', is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::DropAfterDequeue(ns3::Ptr<const ns3::QueueDiscItem> item, char const * reason) [member function]
+    cls.add_method('DropAfterDequeue', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem const >', 'item'), param('char const *', 'reason')], 
+                   visibility='protected')
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::DropBeforeEnqueue(ns3::Ptr<const ns3::QueueDiscItem> item, char const * reason) [member function]
+    cls.add_method('DropBeforeEnqueue', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem const >', 'item'), param('char const *', 'reason')], 
+                   visibility='protected')
+    ## queue-disc.h (module 'traffic-control'): bool ns3::QueueDisc::Mark(ns3::Ptr<ns3::QueueDiscItem> item, char const * reason) [member function]
+    cls.add_method('Mark', 
+                   'bool', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item'), param('char const *', 'reason')], 
+                   visibility='protected')
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<const ns3::QueueDiscItem> ns3::QueueDisc::PeekDequeued() [member function]
+    cls.add_method('PeekDequeued', 
+                   'ns3::Ptr< ns3::QueueDiscItem const >', 
+                   [], 
+                   visibility='protected')
+    ## queue-disc.h (module 'traffic-control'): bool ns3::QueueDisc::CheckConfig() [member function]
+    cls.add_method('CheckConfig', 
+                   'bool', 
+                   [], 
+                   is_pure_virtual=True, visibility='private', is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::QueueDiscItem> ns3::QueueDisc::DoDequeue() [member function]
+    cls.add_method('DoDequeue', 
+                   'ns3::Ptr< ns3::QueueDiscItem >', 
+                   [], 
+                   is_pure_virtual=True, visibility='private', is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): bool ns3::QueueDisc::DoEnqueue(ns3::Ptr<ns3::QueueDiscItem> item) [member function]
+    cls.add_method('DoEnqueue', 
+                   'bool', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')], 
+                   is_pure_virtual=True, visibility='private', is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<const ns3::QueueDiscItem> ns3::QueueDisc::DoPeek() [member function]
+    cls.add_method('DoPeek', 
+                   'ns3::Ptr< ns3::QueueDiscItem const >', 
+                   [], 
+                   is_pure_virtual=True, visibility='private', is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::InitializeParams() [member function]
+    cls.add_method('InitializeParams', 
+                   'void', 
+                   [], 
+                   is_pure_virtual=True, visibility='private', is_virtual=True)
+    return
+
+def register_Ns3QueueDiscStats_methods(root_module, cls):
+    cls.add_output_stream_operator()
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::Stats(ns3::QueueDisc::Stats const & arg0) [constructor]
+    cls.add_constructor([param('ns3::QueueDisc::Stats const &', 'arg0')])
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::Stats() [constructor]
+    cls.add_constructor([])
+    ## queue-disc.h (module 'traffic-control'): uint64_t ns3::QueueDisc::Stats::GetNDroppedBytes(std::string reason) const [member function]
+    cls.add_method('GetNDroppedBytes', 
+                   'uint64_t', 
+                   [param('std::string', 'reason')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::Stats::GetNDroppedPackets(std::string reason) const [member function]
+    cls.add_method('GetNDroppedPackets', 
+                   'uint32_t', 
+                   [param('std::string', 'reason')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint64_t ns3::QueueDisc::Stats::GetNMarkedBytes(std::string reason) const [member function]
+    cls.add_method('GetNMarkedBytes', 
+                   'uint64_t', 
+                   [param('std::string', 'reason')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::Stats::GetNMarkedPackets(std::string reason) const [member function]
+    cls.add_method('GetNMarkedPackets', 
+                   'uint32_t', 
+                   [param('std::string', 'reason')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::Stats::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nDroppedBytesAfterDequeue [variable]
+    cls.add_instance_attribute('nDroppedBytesAfterDequeue', 'std::map< std::string, unsigned long >', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nDroppedBytesBeforeEnqueue [variable]
+    cls.add_instance_attribute('nDroppedBytesBeforeEnqueue', 'std::map< std::string, unsigned long >', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nDroppedPacketsAfterDequeue [variable]
+    cls.add_instance_attribute('nDroppedPacketsAfterDequeue', 'std::map< std::string, unsigned int >', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nDroppedPacketsBeforeEnqueue [variable]
+    cls.add_instance_attribute('nDroppedPacketsBeforeEnqueue', 'std::map< std::string, unsigned int >', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nMarkedBytes [variable]
+    cls.add_instance_attribute('nMarkedBytes', 'std::map< std::string, unsigned long >', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nMarkedPackets [variable]
+    cls.add_instance_attribute('nMarkedPackets', 'std::map< std::string, unsigned int >', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDequeuedBytes [variable]
+    cls.add_instance_attribute('nTotalDequeuedBytes', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDequeuedPackets [variable]
+    cls.add_instance_attribute('nTotalDequeuedPackets', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDroppedBytes [variable]
+    cls.add_instance_attribute('nTotalDroppedBytes', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDroppedBytesAfterDequeue [variable]
+    cls.add_instance_attribute('nTotalDroppedBytesAfterDequeue', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDroppedBytesBeforeEnqueue [variable]
+    cls.add_instance_attribute('nTotalDroppedBytesBeforeEnqueue', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDroppedPackets [variable]
+    cls.add_instance_attribute('nTotalDroppedPackets', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDroppedPacketsAfterDequeue [variable]
+    cls.add_instance_attribute('nTotalDroppedPacketsAfterDequeue', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDroppedPacketsBeforeEnqueue [variable]
+    cls.add_instance_attribute('nTotalDroppedPacketsBeforeEnqueue', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalEnqueuedBytes [variable]
+    cls.add_instance_attribute('nTotalEnqueuedBytes', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalEnqueuedPackets [variable]
+    cls.add_instance_attribute('nTotalEnqueuedPackets', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalMarkedBytes [variable]
+    cls.add_instance_attribute('nTotalMarkedBytes', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalMarkedPackets [variable]
+    cls.add_instance_attribute('nTotalMarkedPackets', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalReceivedBytes [variable]
+    cls.add_instance_attribute('nTotalReceivedBytes', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalReceivedPackets [variable]
+    cls.add_instance_attribute('nTotalReceivedPackets', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalRequeuedBytes [variable]
+    cls.add_instance_attribute('nTotalRequeuedBytes', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalRequeuedPackets [variable]
+    cls.add_instance_attribute('nTotalRequeuedPackets', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalSentBytes [variable]
+    cls.add_instance_attribute('nTotalSentBytes', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalSentPackets [variable]
+    cls.add_instance_attribute('nTotalSentPackets', 'uint32_t', is_const=False)
+    return
+
+def register_Ns3QueueDiscClass_methods(root_module, cls):
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDiscClass::QueueDiscClass(ns3::QueueDiscClass const & arg0) [constructor]
+    cls.add_constructor([param('ns3::QueueDiscClass const &', 'arg0')])
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDiscClass::QueueDiscClass() [constructor]
+    cls.add_constructor([])
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::QueueDisc> ns3::QueueDiscClass::GetQueueDisc() const [member function]
+    cls.add_method('GetQueueDisc', 
+                   'ns3::Ptr< ns3::QueueDisc >', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): static ns3::TypeId ns3::QueueDiscClass::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDiscClass::SetQueueDisc(ns3::Ptr<ns3::QueueDisc> qd) [member function]
+    cls.add_method('SetQueueDisc', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::QueueDisc >', 'qd')])
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDiscClass::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   visibility='protected', is_virtual=True)
+    return
+
 def register_Ns3RadioEnvironmentMapHelper_methods(root_module, cls):
     ## radio-environment-map-helper.h (module 'lte'): ns3::RadioEnvironmentMapHelper::RadioEnvironmentMapHelper() [constructor]
     cls.add_constructor([])
@@ -11718,6 +12944,71 @@
                    is_const=True, visibility='protected')
     return
 
+def register_Ns3RetxStatsCalculator_methods(root_module, cls):
+    ## retx-stats-calculator.h (module 'lte'): ns3::RetxStatsCalculator::RetxStatsCalculator() [constructor]
+    cls.add_constructor([])
+    ## retx-stats-calculator.h (module 'lte'): static ns3::TypeId ns3::RetxStatsCalculator::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## retx-stats-calculator.h (module 'lte'): void ns3::RetxStatsCalculator::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## retx-stats-calculator.h (module 'lte'): void ns3::RetxStatsCalculator::RegisterRetxDl(uint64_t imsi, uint16_t cellId, uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx) [member function]
+    cls.add_method('RegisterRetxDl', 
+                   'void', 
+                   [param('uint64_t', 'imsi'), param('uint16_t', 'cellId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('uint32_t', 'packetSize'), param('uint32_t', 'numRetx')])
+    ## retx-stats-calculator.h (module 'lte'): void ns3::RetxStatsCalculator::RegisterRetxUl(uint64_t imsi, uint16_t cellId, uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx) [member function]
+    cls.add_method('RegisterRetxUl', 
+                   'void', 
+                   [param('uint64_t', 'imsi'), param('uint16_t', 'cellId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('uint32_t', 'packetSize'), param('uint32_t', 'numRetx')])
+    ## retx-stats-calculator.h (module 'lte'): ns3::RetxStatsCalculator::m_retxDlFile [variable]
+    cls.add_instance_attribute('m_retxDlFile', 'std::ofstream', is_const=False)
+    ## retx-stats-calculator.h (module 'lte'): ns3::RetxStatsCalculator::m_retxDlFilename [variable]
+    cls.add_instance_attribute('m_retxDlFilename', 'std::string', is_const=False)
+    ## retx-stats-calculator.h (module 'lte'): ns3::RetxStatsCalculator::m_retxUlFile [variable]
+    cls.add_instance_attribute('m_retxUlFile', 'std::ofstream', is_const=False)
+    ## retx-stats-calculator.h (module 'lte'): ns3::RetxStatsCalculator::m_retxUlFilename [variable]
+    cls.add_instance_attribute('m_retxUlFilename', 'std::string', is_const=False)
+    return
+
+def register_Ns3RlcBearerInfo_methods(root_module, cls):
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::RlcBearerInfo(ns3::RlcBearerInfo const & arg0) [constructor]
+    cls.add_constructor([param('ns3::RlcBearerInfo const &', 'arg0')])
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::RlcBearerInfo() [constructor]
+    cls.add_constructor([])
+    ## lte-radio-bearer-info.h (module 'lte'): static ns3::TypeId ns3::RlcBearerInfo::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::drbid [variable]
+    cls.add_instance_attribute('drbid', 'uint8_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::gtpTeid [variable]
+    cls.add_instance_attribute('gtpTeid', 'uint32_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::lcinfo [variable]
+    cls.add_instance_attribute('lcinfo', 'ns3::LteEnbCmacSapProvider::LcInfo', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::logicalChannelConfig [variable]
+    cls.add_instance_attribute('logicalChannelConfig', 'ns3::LteRrcSap::LogicalChannelConfig', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::logicalChannelIdentity [variable]
+    cls.add_instance_attribute('logicalChannelIdentity', 'uint8_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::lteRnti [variable]
+    cls.add_instance_attribute('lteRnti', 'uint16_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::m_rlc [variable]
+    cls.add_instance_attribute('m_rlc', 'ns3::Ptr< ns3::LteRlc >', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::mmWaveRnti [variable]
+    cls.add_instance_attribute('mmWaveRnti', 'uint16_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::rlcConfig [variable]
+    cls.add_instance_attribute('rlcConfig', 'ns3::LteRrcSap::RlcConfig', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::sourceCellId [variable]
+    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::targetCellId [variable]
+    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
+    return
+
 def register_Ns3RlcTag_methods(root_module, cls):
     ## lte-rlc-tag.h (module 'lte'): ns3::RlcTag::RlcTag(ns3::RlcTag const & arg0) [constructor]
     cls.add_constructor([param('ns3::RlcTag const &', 'arg0')])
@@ -11911,6 +13202,27 @@
     cls.add_constructor([param('ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter< ns3::Packet > > const &', 'o')])
     return
 
+def register_Ns3SimpleRefCount__Ns3QueueItem_Ns3Empty_Ns3DefaultDeleter__lt__ns3QueueItem__gt___methods(root_module, cls):
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::QueueItem, ns3::empty, ns3::DefaultDeleter<ns3::QueueItem> >::SimpleRefCount() [constructor]
+    cls.add_constructor([])
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::QueueItem, ns3::empty, ns3::DefaultDeleter<ns3::QueueItem> >::SimpleRefCount(ns3::SimpleRefCount<ns3::QueueItem, ns3::empty, ns3::DefaultDeleter<ns3::QueueItem> > const & o) [constructor]
+    cls.add_constructor([param('ns3::SimpleRefCount< ns3::QueueItem, ns3::empty, ns3::DefaultDeleter< ns3::QueueItem > > const &', 'o')])
+    return
+
+def register_Ns3SimpleRefCount__Ns3S1apConnectionInfo_Ns3Empty_Ns3DefaultDeleter__lt__ns3S1apConnectionInfo__gt___methods(root_module, cls):
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apConnectionInfo> >::SimpleRefCount() [constructor]
+    cls.add_constructor([])
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apConnectionInfo> >::SimpleRefCount(ns3::SimpleRefCount<ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apConnectionInfo> > const & o) [constructor]
+    cls.add_constructor([param('ns3::SimpleRefCount< ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter< ns3::S1apConnectionInfo > > const &', 'o')])
+    return
+
+def register_Ns3SimpleRefCount__Ns3S1apIfaceInfo_Ns3Empty_Ns3DefaultDeleter__lt__ns3S1apIfaceInfo__gt___methods(root_module, cls):
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apIfaceInfo> >::SimpleRefCount() [constructor]
+    cls.add_constructor([])
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apIfaceInfo> >::SimpleRefCount(ns3::SimpleRefCount<ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apIfaceInfo> > const & o) [constructor]
+    cls.add_constructor([param('ns3::SimpleRefCount< ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter< ns3::S1apIfaceInfo > > const &', 'o')])
+    return
+
 def register_Ns3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___methods(root_module, cls):
     ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >::SimpleRefCount() [constructor]
     cls.add_constructor([])
@@ -13098,6 +14410,40 @@
                    is_pure_virtual=True, is_const=True, is_virtual=True)
     return
 
+def register_Ns3TracedValue__Ns3Time_methods(root_module, cls):
+    ## traced-value.h (module 'core'): ns3::TracedValue<ns3::Time>::TracedValue() [constructor]
+    cls.add_constructor([])
+    ## traced-value.h (module 'core'): ns3::TracedValue<ns3::Time>::TracedValue(ns3::TracedValue<ns3::Time> const & o) [constructor]
+    cls.add_constructor([param('ns3::TracedValue< ns3::Time > const &', 'o')])
+    ## traced-value.h (module 'core'): ns3::TracedValue<ns3::Time>::TracedValue(ns3::Time const & v) [constructor]
+    cls.add_constructor([param('ns3::Time const &', 'v')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<ns3::Time>::Connect(ns3::CallbackBase const & cb, std::string path) [member function]
+    cls.add_method('Connect', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb'), param('std::string', 'path')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<ns3::Time>::ConnectWithoutContext(ns3::CallbackBase const & cb) [member function]
+    cls.add_method('ConnectWithoutContext', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<ns3::Time>::Disconnect(ns3::CallbackBase const & cb, std::string path) [member function]
+    cls.add_method('Disconnect', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb'), param('std::string', 'path')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<ns3::Time>::DisconnectWithoutContext(ns3::CallbackBase const & cb) [member function]
+    cls.add_method('DisconnectWithoutContext', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb')])
+    ## traced-value.h (module 'core'): ns3::Time ns3::TracedValue<ns3::Time>::Get() const [member function]
+    cls.add_method('Get', 
+                   'ns3::Time', 
+                   [], 
+                   is_const=True)
+    ## traced-value.h (module 'core'): void ns3::TracedValue<ns3::Time>::Set(ns3::Time const & v) [member function]
+    cls.add_method('Set', 
+                   'void', 
+                   [param('ns3::Time const &', 'v')])
+    return
+
 def register_Ns3Trailer_methods(root_module, cls):
     cls.add_output_stream_operator()
     ## trailer.h (module 'network'): ns3::Trailer::Trailer() [constructor]
@@ -13198,6 +14544,10 @@
     cls.add_method('DoReceivePdcpSdu', 
                    'void', 
                    [param('ns3::LtePdcpSapUser::ReceivePdcpSduParameters', 'params')])
+    ## lte-enb-rrc.h (module 'lte'): bool ns3::UeManager::GetAllMmWaveInOutageAtInitialAccess() [member function]
+    cls.add_method('GetAllMmWaveInOutageAtInitialAccess', 
+                   'bool', 
+                   [])
     ## lte-enb-rrc.h (module 'lte'): uint8_t ns3::UeManager::GetComponentCarrierId() const [member function]
     cls.add_method('GetComponentCarrierId', 
                    'uint8_t', 
@@ -13212,6 +14562,11 @@
                    'uint64_t', 
                    [], 
                    is_const=True)
+    ## lte-enb-rrc.h (module 'lte'): bool ns3::UeManager::GetIsMc() const [member function]
+    cls.add_method('GetIsMc', 
+                   'bool', 
+                   [], 
+                   is_const=True)
     ## lte-enb-rrc.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated ns3::UeManager::GetRadioResourceConfigForHandoverPreparationInfo() [member function]
     cls.add_method('GetRadioResourceConfigForHandoverPreparationInfo', 
                    'ns3::LteRrcSap::RadioResourceConfigDedicated', 
@@ -13225,6 +14580,10 @@
     cls.add_method('GetRrcConnectionReconfigurationForHandover', 
                    'ns3::LteRrcSap::RrcConnectionReconfiguration', 
                    [])
+    ## lte-enb-rrc.h (module 'lte'): std::pair<unsigned short, unsigned short> ns3::UeManager::GetSource() [member function]
+    cls.add_method('GetSource', 
+                   'std::pair< unsigned short, unsigned short >', 
+                   [])
     ## lte-enb-rrc.h (module 'lte'): uint16_t ns3::UeManager::GetSrsConfigurationIndex() const [member function]
     cls.add_method('GetSrsConfigurationIndex', 
                    'uint16_t', 
@@ -13248,6 +14607,10 @@
     cls.add_method('RecordDataRadioBearersToBeStarted', 
                    'void', 
                    [])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvConnectionSwitchToMmWave(bool useMmWaveConnection, uint8_t drbid) [member function]
+    cls.add_method('RecvConnectionSwitchToMmWave', 
+                   'void', 
+                   [param('bool', 'useMmWaveConnection'), param('uint8_t', 'drbid')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvHandoverPreparationFailure(uint16_t cellId) [member function]
     cls.add_method('RecvHandoverPreparationFailure', 
                    'void', 
@@ -13260,6 +14623,18 @@
     cls.add_method('RecvMeasurementReport', 
                    'void', 
                    [param('ns3::LteRrcSap::MeasurementReport', 'msg')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvNotifyLteMmWaveHandoverCompleted() [member function]
+    cls.add_method('RecvNotifyLteMmWaveHandoverCompleted', 
+                   'void', 
+                   [])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRlcSetupCompleted(uint8_t drbid) [member function]
+    cls.add_method('RecvRlcSetupCompleted', 
+                   'void', 
+                   [param('uint8_t', 'drbid')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRlcSetupRequest(ns3::EpcX2Sap::RlcSetupRequest params) [member function]
+    cls.add_method('RecvRlcSetupRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::RlcSetupRequest', 'params')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRrcConnectionReconfigurationCompleted(ns3::LteRrcSap::RrcConnectionReconfigurationCompleted msg) [member function]
     cls.add_method('RecvRrcConnectionReconfigurationCompleted', 
                    'void', 
@@ -13280,6 +14655,14 @@
     cls.add_method('RecvRrcConnectionSetupCompleted', 
                    'void', 
                    [param('ns3::LteRrcSap::RrcConnectionSetupCompleted', 'msg')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRrcSecondaryCellInitialAccessSuccessful(uint16_t mmWaveRnti, uint16_t mmWaveCellId) [member function]
+    cls.add_method('RecvRrcSecondaryCellInitialAccessSuccessful', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveRnti'), param('uint16_t', 'mmWaveCellId')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvSecondaryCellHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverCompletedParams params) [member function]
+    cls.add_method('RecvSecondaryCellHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverCompletedParams', 'params')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
     cls.add_method('RecvSnStatusTransfer', 
                    'void', 
@@ -13300,14 +14683,30 @@
     cls.add_method('SendData', 
                    'void', 
                    [param('uint8_t', 'bid'), param('ns3::Ptr< ns3::Packet >', 'p')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SendRrcConnectionSwitch(bool useMmWaveConnection) [member function]
+    cls.add_method('SendRrcConnectionSwitch', 
+                   'void', 
+                   [param('bool', 'useMmWaveConnection')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SendUeContextRelease() [member function]
     cls.add_method('SendUeContextRelease', 
                    'void', 
                    [])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetAllMmWaveInOutageAtInitialAccess(bool param) [member function]
+    cls.add_method('SetAllMmWaveInOutageAtInitialAccess', 
+                   'void', 
+                   [param('bool', 'param')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetFirstConnection() [member function]
+    cls.add_method('SetFirstConnection', 
+                   'void', 
+                   [])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetImsi(uint64_t imsi) [member function]
     cls.add_method('SetImsi', 
                    'void', 
                    [param('uint64_t', 'imsi')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetIsMc(bool isMc) [member function]
+    cls.add_method('SetIsMc', 
+                   'void', 
+                   [param('bool', 'isMc')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetPdschConfigDedicated(ns3::LteRrcSap::PdschConfigDedicated pdschConfigDedicated) [member function]
     cls.add_method('SetPdschConfigDedicated', 
                    'void', 
@@ -14052,6 +15451,21 @@
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
+                   is_static=True, visibility='protected', template_parameters=[u'unsigned int'])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
+    cls.add_method('GetCppTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Time'])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
+    cls.add_method('GetCppTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True, visibility='protected', template_parameters=[u'bool'])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
+    cls.add_method('GetCppTypeid', 
+                   'std::string', 
+                   [], 
                    is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::NetDevice> '])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
@@ -14117,37 +15531,37 @@
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'bool'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Socket> '])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Socket> '])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Packet> '])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'unsigned int'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::EpcUeNas::State'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Packet> '])
+                   is_static=True, visibility='protected', template_parameters=[u'unsigned long'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::EpcUeNas::State'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::SpectrumValue const&'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::SpectrumValue const&'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::QueueDiscItem const> '])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'unsigned long'])
+                   is_static=True, visibility='protected', template_parameters=[u'char const*'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
@@ -14162,6 +15576,11 @@
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
+                   is_static=True, visibility='protected', template_parameters=[u'long double'])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
+    cls.add_method('GetCppTypeid', 
+                   'std::string', 
+                   [], 
                    is_static=True, visibility='protected', template_parameters=[u'ns3::DlSchedulingCallbackInfo'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
@@ -14287,19 +15706,19 @@
     cls.add_constructor([param('ns3::Channel const &', 'arg0')])
     ## channel.h (module 'network'): ns3::Channel::Channel() [constructor]
     cls.add_constructor([])
-    ## channel.h (module 'network'): ns3::Ptr<ns3::NetDevice> ns3::Channel::GetDevice(std::size_t i) const [member function]
+    ## channel.h (module 'network'): ns3::Ptr<ns3::NetDevice> ns3::Channel::GetDevice(uint32_t i) const [member function]
     cls.add_method('GetDevice', 
                    'ns3::Ptr< ns3::NetDevice >', 
-                   [param('std::size_t', 'i')], 
+                   [param('uint32_t', 'i')], 
                    is_pure_virtual=True, is_const=True, is_virtual=True)
     ## channel.h (module 'network'): uint32_t ns3::Channel::GetId() const [member function]
     cls.add_method('GetId', 
                    'uint32_t', 
                    [], 
                    is_const=True)
-    ## channel.h (module 'network'): std::size_t ns3::Channel::GetNDevices() const [member function]
+    ## channel.h (module 'network'): uint32_t ns3::Channel::GetNDevices() const [member function]
     cls.add_method('GetNDevices', 
-                   'std::size_t', 
+                   'uint32_t', 
                    [], 
                    is_pure_virtual=True, is_const=True, is_virtual=True)
     ## channel.h (module 'network'): static ns3::TypeId ns3::Channel::GetTypeId() [member function]
@@ -14309,6 +15728,70 @@
                    is_static=True)
     return
 
+def register_Ns3CoDelQueueDisc_methods(root_module, cls):
+    ## codel-queue-disc.h (module 'traffic-control'): static ns3::TypeId ns3::CoDelQueueDisc::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::CoDelQueueDisc::CoDelQueueDisc() [constructor]
+    cls.add_constructor([])
+    ## codel-queue-disc.h (module 'traffic-control'): void ns3::CoDelQueueDisc::SetMode(ns3::CoDelQueueDisc::QueueDiscMode mode) [member function]
+    cls.add_method('SetMode', 
+                   'void', 
+                   [param('ns3::CoDelQueueDisc::QueueDiscMode', 'mode')])
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::CoDelQueueDisc::QueueDiscMode ns3::CoDelQueueDisc::GetMode() const [member function]
+    cls.add_method('GetMode', 
+                   'ns3::CoDelQueueDisc::QueueDiscMode', 
+                   [], 
+                   is_const=True)
+    ## codel-queue-disc.h (module 'traffic-control'): uint32_t ns3::CoDelQueueDisc::GetQueueSize() [member function]
+    cls.add_method('GetQueueSize', 
+                   'uint32_t', 
+                   [])
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::Time ns3::CoDelQueueDisc::GetTarget() [member function]
+    cls.add_method('GetTarget', 
+                   'ns3::Time', 
+                   [])
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::Time ns3::CoDelQueueDisc::GetInterval() [member function]
+    cls.add_method('GetInterval', 
+                   'ns3::Time', 
+                   [])
+    ## codel-queue-disc.h (module 'traffic-control'): uint32_t ns3::CoDelQueueDisc::GetDropNext() [member function]
+    cls.add_method('GetDropNext', 
+                   'uint32_t', 
+                   [])
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::CoDelQueueDisc::TARGET_EXCEEDED_DROP [variable]
+    cls.add_static_attribute('TARGET_EXCEEDED_DROP', 'char const * const', is_const=True)
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::CoDelQueueDisc::OVERLIMIT_DROP [variable]
+    cls.add_static_attribute('OVERLIMIT_DROP', 'char const * const', is_const=True)
+    ## codel-queue-disc.h (module 'traffic-control'): bool ns3::CoDelQueueDisc::DoEnqueue(ns3::Ptr<ns3::QueueDiscItem> item) [member function]
+    cls.add_method('DoEnqueue', 
+                   'bool', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')], 
+                   visibility='private', is_virtual=True)
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::QueueDiscItem> ns3::CoDelQueueDisc::DoDequeue() [member function]
+    cls.add_method('DoDequeue', 
+                   'ns3::Ptr< ns3::QueueDiscItem >', 
+                   [], 
+                   visibility='private', is_virtual=True)
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::Ptr<const ns3::QueueDiscItem> ns3::CoDelQueueDisc::DoPeek() [member function]
+    cls.add_method('DoPeek', 
+                   'ns3::Ptr< ns3::QueueDiscItem const >', 
+                   [], 
+                   visibility='private', is_virtual=True)
+    ## codel-queue-disc.h (module 'traffic-control'): bool ns3::CoDelQueueDisc::CheckConfig() [member function]
+    cls.add_method('CheckConfig', 
+                   'bool', 
+                   [], 
+                   visibility='private', is_virtual=True)
+    ## codel-queue-disc.h (module 'traffic-control'): void ns3::CoDelQueueDisc::InitializeParams() [member function]
+    cls.add_method('InitializeParams', 
+                   'void', 
+                   [], 
+                   visibility='private', is_virtual=True)
+    return
+
 def register_Ns3ComponentCarrier_methods(root_module, cls):
     ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::ComponentCarrier(ns3::ComponentCarrier const & arg0) [constructor]
     cls.add_constructor([param('ns3::ComponentCarrier const &', 'arg0')])
@@ -14679,10 +16162,10 @@
                    is_static=True)
     ## random-variable-stream.h (module 'core'): ns3::DeterministicRandomVariable::DeterministicRandomVariable() [constructor]
     cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): void ns3::DeterministicRandomVariable::SetValueArray(double * values, std::size_t length) [member function]
+    ## random-variable-stream.h (module 'core'): void ns3::DeterministicRandomVariable::SetValueArray(double * values, uint64_t length) [member function]
     cls.add_method('SetValueArray', 
                    'void', 
-                   [param('double *', 'values'), param('std::size_t', 'length')])
+                   [param('double *', 'values'), param('uint64_t', 'length')])
     ## random-variable-stream.h (module 'core'): double ns3::DeterministicRandomVariable::GetValue() [member function]
     cls.add_method('GetValue', 
                    'double', 
@@ -14956,10 +16439,10 @@
     cls.add_method('SetS1SapUser', 
                    'void', 
                    [param('ns3::EpcEnbS1SapUser *', 's')])
-    ## epc-enb-application.h (module 'lte'): void ns3::EpcEnbApplication::SetS1apSapMme(ns3::EpcS1apSapMme * s) [member function]
+    ## epc-enb-application.h (module 'lte'): void ns3::EpcEnbApplication::SetS1apSapMme(ns3::EpcS1apSapEnbProvider * s) [member function]
     cls.add_method('SetS1apSapMme', 
                    'void', 
-                   [param('ns3::EpcS1apSapMme *', 's')])
+                   [param('ns3::EpcS1apSapEnbProvider *', 's')])
     ## epc-enb-application.h (module 'lte'): void ns3::EpcEnbApplication::DoDispose() [member function]
     cls.add_method('DoDispose', 
                    'void', 
@@ -14992,6 +16475,11 @@
                    'uint8_t', 
                    [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-helper.h (module 'lte'): uint8_t ns3::EpcHelper::ActivateEpsBearer(ns3::Ptr<ns3::NetDevice> ueLteDevice, ns3::Ptr<ns3::EpcUeNas> ueNas, uint64_t imsi, ns3::Ptr<ns3::EpcTft> tft, ns3::EpsBearer bearer) [member function]
+    cls.add_method('ActivateEpsBearer', 
+                   'uint8_t', 
+                   [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('ns3::Ptr< ns3::EpcUeNas >', 'ueNas'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-helper.h (module 'lte'): void ns3::EpcHelper::AddEnb(ns3::Ptr<ns3::Node> enbNode, ns3::Ptr<ns3::NetDevice> lteEnbNetDevice, uint16_t cellId) [member function]
     cls.add_method('AddEnb', 
                    'void', 
@@ -15075,6 +16563,672 @@
                    visibility='protected', is_virtual=True)
     return
 
+def register_Ns3EpcMmeApplication_methods(root_module, cls):
+    ## epc-mme-application.h (module 'lte'): ns3::EpcMmeApplication::EpcMmeApplication(ns3::EpcMmeApplication const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcMmeApplication const &', 'arg0')])
+    ## epc-mme-application.h (module 'lte'): ns3::EpcMmeApplication::EpcMmeApplication() [constructor]
+    cls.add_constructor([])
+    ## epc-mme-application.h (module 'lte'): uint8_t ns3::EpcMmeApplication::AddBearer(uint64_t imsi, ns3::Ptr<ns3::EpcTft> tft, ns3::EpsBearer bearer) [member function]
+    cls.add_method('AddBearer', 
+                   'uint8_t', 
+                   [param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')])
+    ## epc-mme-application.h (module 'lte'): void ns3::EpcMmeApplication::AddEnb(uint16_t ecgi, ns3::Ipv4Address enbS1UAddr) [member function]
+    cls.add_method('AddEnb', 
+                   'void', 
+                   [param('uint16_t', 'ecgi'), param('ns3::Ipv4Address', 'enbS1UAddr')])
+    ## epc-mme-application.h (module 'lte'): void ns3::EpcMmeApplication::AddUe(uint64_t imsi) [member function]
+    cls.add_method('AddUe', 
+                   'void', 
+                   [param('uint64_t', 'imsi')])
+    ## epc-mme-application.h (module 'lte'): ns3::EpcS11SapMme * ns3::EpcMmeApplication::GetS11SapMme() [member function]
+    cls.add_method('GetS11SapMme', 
+                   'ns3::EpcS11SapMme *', 
+                   [])
+    ## epc-mme-application.h (module 'lte'): ns3::EpcS1apSapMme * ns3::EpcMmeApplication::GetS1apSapMme() [member function]
+    cls.add_method('GetS1apSapMme', 
+                   'ns3::EpcS1apSapMme *', 
+                   [])
+    ## epc-mme-application.h (module 'lte'): static ns3::TypeId ns3::EpcMmeApplication::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-mme-application.h (module 'lte'): void ns3::EpcMmeApplication::SetS11SapSgw(ns3::EpcS11SapSgw * s) [member function]
+    cls.add_method('SetS11SapSgw', 
+                   'void', 
+                   [param('ns3::EpcS11SapSgw *', 's')])
+    ## epc-mme-application.h (module 'lte'): void ns3::EpcMmeApplication::SetS1apSapMmeProvider(ns3::EpcS1apSapMmeProvider * provider) [member function]
+    cls.add_method('SetS1apSapMmeProvider', 
+                   'void', 
+                   [param('ns3::EpcS1apSapMmeProvider *', 'provider')])
+    ## epc-mme-application.h (module 'lte'): void ns3::EpcMmeApplication::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   visibility='protected', is_virtual=True)
+    return
+
+def register_Ns3EpcS1APErabReleaseIndicationHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APErabReleaseIndicationHeader::EpcS1APErabReleaseIndicationHeader(ns3::EpcS1APErabReleaseIndicationHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APErabReleaseIndicationHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APErabReleaseIndicationHeader::EpcS1APErabReleaseIndicationHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APErabReleaseIndicationHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APErabReleaseIndicationHeader::GetEnbUeS1Id() const [member function]
+    cls.add_method('GetEnbUeS1Id', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): std::list<ns3::EpcS1apSap::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSap::ErabToBeReleasedIndication> > ns3::EpcS1APErabReleaseIndicationHeader::GetErabToBeReleaseIndication() const [member function]
+    cls.add_method('GetErabToBeReleaseIndication', 
+                   'std::list< ns3::EpcS1apSap::ErabToBeReleasedIndication >', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APErabReleaseIndicationHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APErabReleaseIndicationHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APErabReleaseIndicationHeader::GetMmeUeS1Id() const [member function]
+    cls.add_method('GetMmeUeS1Id', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APErabReleaseIndicationHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APErabReleaseIndicationHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APErabReleaseIndicationHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APErabReleaseIndicationHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APErabReleaseIndicationHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APErabReleaseIndicationHeader::SetEnbUeS1Id(uint16_t enbUeS1Id) [member function]
+    cls.add_method('SetEnbUeS1Id', 
+                   'void', 
+                   [param('uint16_t', 'enbUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APErabReleaseIndicationHeader::SetErabReleaseIndication(std::list<ns3::EpcS1apSap::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSap::ErabToBeReleasedIndication> > erabToBeReleaseIndication) [member function]
+    cls.add_method('SetErabReleaseIndication', 
+                   'void', 
+                   [param('std::list< ns3::EpcS1apSap::ErabToBeReleasedIndication >', 'erabToBeReleaseIndication')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APErabReleaseIndicationHeader::SetMmeUeS1Id(uint64_t mmeUeS1Id) [member function]
+    cls.add_method('SetMmeUeS1Id', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id')])
+    return
+
+def register_Ns3EpcS1APHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APHeader::EpcS1APHeader(ns3::EpcS1APHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APHeader::EpcS1APHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint8_t ns3::EpcS1APHeader::GetProcedureCode() const [member function]
+    cls.add_method('GetProcedureCode', 
+                   'uint8_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APHeader::SetLengthOfIes(uint32_t lengthOfIes) [member function]
+    cls.add_method('SetLengthOfIes', 
+                   'void', 
+                   [param('uint32_t', 'lengthOfIes')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APHeader::SetNumberOfIes(uint32_t numberOfIes) [member function]
+    cls.add_method('SetNumberOfIes', 
+                   'void', 
+                   [param('uint32_t', 'numberOfIes')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APHeader::SetProcedureCode(uint8_t procedureCode) [member function]
+    cls.add_method('SetProcedureCode', 
+                   'void', 
+                   [param('uint8_t', 'procedureCode')])
+    return
+
+def register_Ns3EpcS1APInitialContextSetupRequestHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialContextSetupRequestHeader::EpcS1APInitialContextSetupRequestHeader(ns3::EpcS1APInitialContextSetupRequestHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APInitialContextSetupRequestHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialContextSetupRequestHeader::EpcS1APInitialContextSetupRequestHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupRequestHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APInitialContextSetupRequestHeader::GetEnbUeS1Id() const [member function]
+    cls.add_method('GetEnbUeS1Id', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): std::list<ns3::EpcS1apSap::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSap::ErabToBeSetupItem> > ns3::EpcS1APInitialContextSetupRequestHeader::GetErabToBeSetupItem() const [member function]
+    cls.add_method('GetErabToBeSetupItem', 
+                   'std::list< ns3::EpcS1apSap::ErabToBeSetupItem >', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APInitialContextSetupRequestHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupRequestHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APInitialContextSetupRequestHeader::GetMmeUeS1Id() const [member function]
+    cls.add_method('GetMmeUeS1Id', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupRequestHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupRequestHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APInitialContextSetupRequestHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupRequestHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupRequestHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupRequestHeader::SetEnbUeS1Id(uint16_t enbUeS1Id) [member function]
+    cls.add_method('SetEnbUeS1Id', 
+                   'void', 
+                   [param('uint16_t', 'enbUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupRequestHeader::SetErabToBeSetupItem(std::list<ns3::EpcS1apSap::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSap::ErabToBeSetupItem> > erabToBeSetupList) [member function]
+    cls.add_method('SetErabToBeSetupItem', 
+                   'void', 
+                   [param('std::list< ns3::EpcS1apSap::ErabToBeSetupItem >', 'erabToBeSetupList')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupRequestHeader::SetMmeUeS1Id(uint64_t mmeUeS1Id) [member function]
+    cls.add_method('SetMmeUeS1Id', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id')])
+    return
+
+def register_Ns3EpcS1APInitialContextSetupResponseHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialContextSetupResponseHeader::EpcS1APInitialContextSetupResponseHeader(ns3::EpcS1APInitialContextSetupResponseHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APInitialContextSetupResponseHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialContextSetupResponseHeader::EpcS1APInitialContextSetupResponseHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupResponseHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APInitialContextSetupResponseHeader::GetEnbUeS1Id() const [member function]
+    cls.add_method('GetEnbUeS1Id', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): std::list<ns3::EpcS1apSap::ErabSetupItem, std::allocator<ns3::EpcS1apSap::ErabSetupItem> > ns3::EpcS1APInitialContextSetupResponseHeader::GetErabSetupItem() const [member function]
+    cls.add_method('GetErabSetupItem', 
+                   'std::list< ns3::EpcS1apSap::ErabSetupItem >', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APInitialContextSetupResponseHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupResponseHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APInitialContextSetupResponseHeader::GetMmeUeS1Id() const [member function]
+    cls.add_method('GetMmeUeS1Id', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupResponseHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupResponseHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APInitialContextSetupResponseHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupResponseHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupResponseHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupResponseHeader::SetEnbUeS1Id(uint16_t enbUeS1Id) [member function]
+    cls.add_method('SetEnbUeS1Id', 
+                   'void', 
+                   [param('uint16_t', 'enbUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupResponseHeader::SetErabSetupItem(std::list<ns3::EpcS1apSap::ErabSetupItem, std::allocator<ns3::EpcS1apSap::ErabSetupItem> > erabSetupList) [member function]
+    cls.add_method('SetErabSetupItem', 
+                   'void', 
+                   [param('std::list< ns3::EpcS1apSap::ErabSetupItem >', 'erabSetupList')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupResponseHeader::SetMmeUeS1Id(uint64_t mmeUeS1Id) [member function]
+    cls.add_method('SetMmeUeS1Id', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id')])
+    return
+
+def register_Ns3EpcS1APInitialUeMessageHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialUeMessageHeader::EpcS1APInitialUeMessageHeader(ns3::EpcS1APInitialUeMessageHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APInitialUeMessageHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialUeMessageHeader::EpcS1APInitialUeMessageHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialUeMessageHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APInitialUeMessageHeader::GetEcgi() const [member function]
+    cls.add_method('GetEcgi', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APInitialUeMessageHeader::GetEnbUeS1Id() const [member function]
+    cls.add_method('GetEnbUeS1Id', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APInitialUeMessageHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialUeMessageHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APInitialUeMessageHeader::GetMmeUeS1Id() const [member function]
+    cls.add_method('GetMmeUeS1Id', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialUeMessageHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APInitialUeMessageHeader::GetSTmsi() const [member function]
+    cls.add_method('GetSTmsi', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialUeMessageHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APInitialUeMessageHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialUeMessageHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialUeMessageHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialUeMessageHeader::SetEcgi(uint16_t ecgi) [member function]
+    cls.add_method('SetEcgi', 
+                   'void', 
+                   [param('uint16_t', 'ecgi')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialUeMessageHeader::SetEnbUeS1Id(uint16_t enbUeS1Id) [member function]
+    cls.add_method('SetEnbUeS1Id', 
+                   'void', 
+                   [param('uint16_t', 'enbUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialUeMessageHeader::SetMmeUeS1Id(uint64_t mmeUeS1Id) [member function]
+    cls.add_method('SetMmeUeS1Id', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialUeMessageHeader::SetSTmsi(uint64_t stmsi) [member function]
+    cls.add_method('SetSTmsi', 
+                   'void', 
+                   [param('uint64_t', 'stmsi')])
+    return
+
+def register_Ns3EpcS1APPathSwitchRequestAcknowledgeHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::EpcS1APPathSwitchRequestAcknowledgeHeader(ns3::EpcS1APPathSwitchRequestAcknowledgeHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APPathSwitchRequestAcknowledgeHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::EpcS1APPathSwitchRequestAcknowledgeHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetEcgi() const [member function]
+    cls.add_method('GetEcgi', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetEnbUeS1Id() const [member function]
+    cls.add_method('GetEnbUeS1Id', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): std::list<ns3::EpcS1apSap::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInUplinkItem> > ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetErabSwitchedInUplinkItemList() const [member function]
+    cls.add_method('GetErabSwitchedInUplinkItemList', 
+                   'std::list< ns3::EpcS1apSap::ErabSwitchedInUplinkItem >', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetMmeUeS1Id() const [member function]
+    cls.add_method('GetMmeUeS1Id', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::SetEcgi(uint16_t ecgi) [member function]
+    cls.add_method('SetEcgi', 
+                   'void', 
+                   [param('uint16_t', 'ecgi')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::SetEnbUeS1Id(uint16_t enbUeS1Id) [member function]
+    cls.add_method('SetEnbUeS1Id', 
+                   'void', 
+                   [param('uint16_t', 'enbUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::SetErabSwitchedInUplinkItemList(std::list<ns3::EpcS1apSap::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInUplinkItem> > erabToBeSwitchedInDownlinkList) [member function]
+    cls.add_method('SetErabSwitchedInUplinkItemList', 
+                   'void', 
+                   [param('std::list< ns3::EpcS1apSap::ErabSwitchedInUplinkItem >', 'erabToBeSwitchedInDownlinkList')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::SetMmeUeS1Id(uint64_t mmeUeS1Id) [member function]
+    cls.add_method('SetMmeUeS1Id', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id')])
+    return
+
+def register_Ns3EpcS1APPathSwitchRequestHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APPathSwitchRequestHeader::EpcS1APPathSwitchRequestHeader(ns3::EpcS1APPathSwitchRequestHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APPathSwitchRequestHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APPathSwitchRequestHeader::EpcS1APPathSwitchRequestHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APPathSwitchRequestHeader::GetEcgi() const [member function]
+    cls.add_method('GetEcgi', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APPathSwitchRequestHeader::GetEnbUeS1Id() const [member function]
+    cls.add_method('GetEnbUeS1Id', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): std::list<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem> > ns3::EpcS1APPathSwitchRequestHeader::GetErabSwitchedInDownlinkItemList() const [member function]
+    cls.add_method('GetErabSwitchedInDownlinkItemList', 
+                   'std::list< ns3::EpcS1apSap::ErabSwitchedInDownlinkItem >', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APPathSwitchRequestHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APPathSwitchRequestHeader::GetMmeUeS1Id() const [member function]
+    cls.add_method('GetMmeUeS1Id', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APPathSwitchRequestHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestHeader::SetEcgi(uint16_t ecgi) [member function]
+    cls.add_method('SetEcgi', 
+                   'void', 
+                   [param('uint16_t', 'ecgi')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestHeader::SetEnbUeS1Id(uint16_t enbUeS1Id) [member function]
+    cls.add_method('SetEnbUeS1Id', 
+                   'void', 
+                   [param('uint16_t', 'enbUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestHeader::SetErabSwitchedInDownlinkItemList(std::list<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem> > erabToBeSwitchedInDownlinkList) [member function]
+    cls.add_method('SetErabSwitchedInDownlinkItemList', 
+                   'void', 
+                   [param('std::list< ns3::EpcS1apSap::ErabSwitchedInDownlinkItem >', 'erabToBeSwitchedInDownlinkList')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestHeader::SetMmeUeS1Id(uint64_t mmeUeS1Id) [member function]
+    cls.add_method('SetMmeUeS1Id', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id')])
+    return
+
+def register_Ns3EpcS1apEnb_methods(root_module, cls):
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apEnb::EpcS1apEnb(ns3::EpcS1apEnb const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apEnb const &', 'arg0')])
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apEnb::EpcS1apEnb(ns3::Ptr<ns3::Socket> localSocket, ns3::Ipv4Address enbAddress, ns3::Ipv4Address mmeAddress, uint16_t cellId, uint16_t mmeId) [constructor]
+    cls.add_constructor([param('ns3::Ptr< ns3::Socket >', 'localSocket'), param('ns3::Ipv4Address', 'enbAddress'), param('ns3::Ipv4Address', 'mmeAddress'), param('uint16_t', 'cellId'), param('uint16_t', 'mmeId')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::AddS1apInterface(uint16_t enbId, ns3::Ipv4Address enbAddress, uint16_t mmeId, ns3::Ipv4Address mmeAddress, ns3::Ptr<ns3::Socket> localS1apSocket) [member function]
+    cls.add_method('AddS1apInterface', 
+                   'void', 
+                   [param('uint16_t', 'enbId'), param('ns3::Ipv4Address', 'enbAddress'), param('uint16_t', 'mmeId'), param('ns3::Ipv4Address', 'mmeAddress'), param('ns3::Ptr< ns3::Socket >', 'localS1apSocket')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apSapEnbProvider * ns3::EpcS1apEnb::GetEpcS1apSapEnbProvider() [member function]
+    cls.add_method('GetEpcS1apSapEnbProvider', 
+                   'ns3::EpcS1apSapEnbProvider *', 
+                   [])
+    ## epc-s1ap.h (module 'lte'): static ns3::TypeId ns3::EpcS1apEnb::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::RecvFromS1apSocket(ns3::Ptr<ns3::Socket> socket) [member function]
+    cls.add_method('RecvFromS1apSocket', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::SetEpcS1apSapEnbUser(ns3::EpcS1apSapEnb * s) [member function]
+    cls.add_method('SetEpcS1apSapEnbUser', 
+                   'void', 
+                   [param('ns3::EpcS1apSapEnb *', 's')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::DoSendErabReleaseIndication(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSap::ErabToBeReleasedIndication> > erabToBeReleaseIndication) [member function]
+    cls.add_method('DoSendErabReleaseIndication', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabToBeReleasedIndication >', 'erabToBeReleaseIndication')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::DoSendInitialContextSetupResponse(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabSetupItem, std::allocator<ns3::EpcS1apSap::ErabSetupItem> > erabSetupList) [member function]
+    cls.add_method('DoSendInitialContextSetupResponse', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabSetupItem >', 'erabSetupList')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::DoSendInitialUeMessage(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) [member function]
+    cls.add_method('DoSendInitialUeMessage', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('uint64_t', 'stmsi'), param('uint16_t', 'ecgi')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::DoSendPathSwitchRequest(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem> > erabToBeSwitchedInDownlinkList) [member function]
+    cls.add_method('DoSendPathSwitchRequest', 
+                   'void', 
+                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'gci'), param('std::list< ns3::EpcS1apSap::ErabSwitchedInDownlinkItem >', 'erabToBeSwitchedInDownlinkList')], 
+                   visibility='protected', is_virtual=True)
+    return
+
+def register_Ns3EpcS1apMme_methods(root_module, cls):
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apMme::EpcS1apMme(ns3::EpcS1apMme const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apMme const &', 'arg0')])
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apMme::EpcS1apMme(ns3::Ptr<ns3::Socket> const s1apSocket, uint16_t mmeId) [constructor]
+    cls.add_constructor([param('ns3::Ptr< ns3::Socket > const', 's1apSocket'), param('uint16_t', 'mmeId')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apMme::AddS1apInterface(uint16_t enbId, ns3::Ipv4Address enbAddress) [member function]
+    cls.add_method('AddS1apInterface', 
+                   'void', 
+                   [param('uint16_t', 'enbId'), param('ns3::Ipv4Address', 'enbAddress')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apMme::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apSapMmeProvider * ns3::EpcS1apMme::GetEpcS1apSapMmeProvider() [member function]
+    cls.add_method('GetEpcS1apSapMmeProvider', 
+                   'ns3::EpcS1apSapMmeProvider *', 
+                   [])
+    ## epc-s1ap.h (module 'lte'): static ns3::TypeId ns3::EpcS1apMme::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apMme::RecvFromS1apSocket(ns3::Ptr<ns3::Socket> socket) [member function]
+    cls.add_method('RecvFromS1apSocket', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apMme::SetEpcS1apSapMmeUser(ns3::EpcS1apSapMme * s) [member function]
+    cls.add_method('SetEpcS1apSapMmeUser', 
+                   'void', 
+                   [param('ns3::EpcS1apSapMme *', 's')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apMme::DoSendInitialContextSetupRequest(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSap::ErabToBeSetupItem> > erabToBeSetupList, uint16_t cellId) [member function]
+    cls.add_method('DoSendInitialContextSetupRequest', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabToBeSetupItem >', 'erabToBeSetupList'), param('uint16_t', 'cellId')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apMme::DoSendPathSwitchRequestAcknowledge(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ns3::EpcS1apSap::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInUplinkItem> > erabToBeSwitchedInUplinkList) [member function]
+    cls.add_method('DoSendPathSwitchRequestAcknowledge', 
+                   'void', 
+                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'cgi'), param('std::list< ns3::EpcS1apSap::ErabSwitchedInUplinkItem >', 'erabToBeSwitchedInUplinkList')], 
+                   visibility='protected', is_virtual=True)
+    return
+
 def register_Ns3EpcSgwPgwApplication_methods(root_module, cls):
     ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcSgwPgwApplication::EpcSgwPgwApplication(ns3::EpcSgwPgwApplication const & arg0) [constructor]
     cls.add_constructor([param('ns3::EpcSgwPgwApplication const &', 'arg0')])
@@ -15235,6 +17389,10 @@
     cls.add_method('Connect', 
                    'void', 
                    [param('uint16_t', 'cellId'), param('uint32_t', 'dlEarfcn')])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::ConnectMc(uint16_t cellId, uint16_t dlEarfcn, uint16_t mmWaveCellId) [member function]
+    cls.add_method('ConnectMc', 
+                   'void', 
+                   [param('uint16_t', 'cellId'), param('uint16_t', 'dlEarfcn'), param('uint16_t', 'mmWaveCellId')])
     ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::Disconnect() [member function]
     cls.add_method('Disconnect', 
                    'void', 
@@ -15287,6 +17445,10 @@
     cls.add_method('SetImsi', 
                    'void', 
                    [param('uint64_t', 'imsi')])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetMmWaveAsSapProvider(ns3::LteAsSapProvider * s) [member function]
+    cls.add_method('SetMmWaveAsSapProvider', 
+                   'void', 
+                   [param('ns3::LteAsSapProvider *', 's')])
     ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::StartCellSelection(uint32_t dlEarfcn) [member function]
     cls.add_method('StartCellSelection', 
                    'void', 
@@ -15307,6 +17469,14 @@
                    'void', 
                    [], 
                    is_virtual=True)
+    ## epc-x2.h (module 'lte'): ns3::EpcX2PdcpProvider * ns3::EpcX2::GetEpcX2PdcpProvider() [member function]
+    cls.add_method('GetEpcX2PdcpProvider', 
+                   'ns3::EpcX2PdcpProvider *', 
+                   [])
+    ## epc-x2.h (module 'lte'): ns3::EpcX2RlcProvider * ns3::EpcX2::GetEpcX2RlcProvider() [member function]
+    cls.add_method('GetEpcX2RlcProvider', 
+                   'ns3::EpcX2RlcProvider *', 
+                   [])
     ## epc-x2.h (module 'lte'): ns3::EpcX2SapProvider * ns3::EpcX2::GetEpcX2SapProvider() [member function]
     cls.add_method('GetEpcX2SapProvider', 
                    'ns3::EpcX2SapProvider *', 
@@ -15328,6 +17498,39 @@
     cls.add_method('SetEpcX2SapUser', 
                    'void', 
                    [param('ns3::EpcX2SapUser *', 's')])
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::SetMcEpcX2PdcpUser(uint32_t teid, ns3::EpcX2PdcpUser * pdcpUser) [member function]
+    cls.add_method('SetMcEpcX2PdcpUser', 
+                   'void', 
+                   [param('uint32_t', 'teid'), param('ns3::EpcX2PdcpUser *', 'pdcpUser')])
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::SetMcEpcX2RlcUser(uint32_t teid, ns3::EpcX2RlcUser * rlcUser) [member function]
+    cls.add_method('SetMcEpcX2RlcUser', 
+                   'void', 
+                   [param('uint32_t', 'teid'), param('ns3::EpcX2RlcUser *', 'rlcUser')])
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoAddTeidToBeForwarded(uint32_t teid, uint16_t targetCellId) [member function]
+    cls.add_method('DoAddTeidToBeForwarded', 
+                   'void', 
+                   [param('uint32_t', 'teid'), param('uint16_t', 'targetCellId')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoNotifyCoordinatorHandoverFailed(ns3::EpcX2Sap::HandoverFailedParams params) [member function]
+    cls.add_method('DoNotifyCoordinatorHandoverFailed', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::HandoverFailedParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoNotifyLteMmWaveHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverParams params) [member function]
+    cls.add_method('DoNotifyLteMmWaveHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoReceiveMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoReceiveMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoRemoveTeidToBeForwarded(uint32_t teid) [member function]
+    cls.add_method('DoRemoveTeidToBeForwarded', 
+                   'void', 
+                   [param('uint32_t', 'teid')], 
+                   visibility='protected', is_virtual=True)
     ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendHandoverPreparationFailure(ns3::EpcX2Sap::HandoverPreparationFailureParams params) [member function]
     cls.add_method('DoSendHandoverPreparationFailure', 
                    'void', 
@@ -15348,16 +17551,46 @@
                    'void', 
                    [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
                    visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendMcHandoverRequest(ns3::EpcX2Sap::SecondaryHandoverParams params) [member function]
+    cls.add_method('DoSendMcHandoverRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendMcPdcpPdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpPdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   visibility='protected', is_virtual=True)
     ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendResourceStatusUpdate(ns3::EpcX2Sap::ResourceStatusUpdateParams params) [member function]
     cls.add_method('DoSendResourceStatusUpdate', 
                    'void', 
                    [param('ns3::EpcX2Sap::ResourceStatusUpdateParams', 'params')], 
                    visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendRlcSetupCompleted(ns3::EpcX2Sap::UeDataParams arg0) [member function]
+    cls.add_method('DoSendRlcSetupCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'arg0')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendRlcSetupRequest(ns3::EpcX2Sap::RlcSetupRequest params) [member function]
+    cls.add_method('DoSendRlcSetupRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::RlcSetupRequest', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendSecondaryCellHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverCompletedParams params) [member function]
+    cls.add_method('DoSendSecondaryCellHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverCompletedParams', 'params')], 
+                   visibility='protected', is_virtual=True)
     ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
     cls.add_method('DoSendSnStatusTransfer', 
                    'void', 
                    [param('ns3::EpcX2Sap::SnStatusTransferParams', 'params')], 
                    visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendSwitchConnectionToMmWave(ns3::EpcX2Sap::SwitchConnectionParams params) [member function]
+    cls.add_method('DoSendSwitchConnectionToMmWave', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SwitchConnectionParams', 'params')], 
+                   visibility='protected', is_virtual=True)
     ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendUeContextRelease(ns3::EpcX2Sap::UeContextReleaseParams params) [member function]
     cls.add_method('DoSendUeContextRelease', 
                    'void', 
@@ -15368,6 +17601,85 @@
                    'void', 
                    [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
                    visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendUeSinrUpdate(ns3::EpcX2Sap::UeImsiSinrParams params) [member function]
+    cls.add_method('DoSendUeSinrUpdate', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeImsiSinrParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    return
+
+def register_Ns3EpcX2ConnectionSwitchHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ConnectionSwitchHeader::EpcX2ConnectionSwitchHeader(ns3::EpcX2ConnectionSwitchHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2ConnectionSwitchHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ConnectionSwitchHeader::EpcX2ConnectionSwitchHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ConnectionSwitchHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint8_t ns3::EpcX2ConnectionSwitchHeader::GetDrbid() const [member function]
+    cls.add_method('GetDrbid', 
+                   'uint8_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2ConnectionSwitchHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ConnectionSwitchHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2ConnectionSwitchHeader::GetMmWaveRnti() const [member function]
+    cls.add_method('GetMmWaveRnti', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ConnectionSwitchHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ConnectionSwitchHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2ConnectionSwitchHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): bool ns3::EpcX2ConnectionSwitchHeader::GetUseMmWaveConnection() const [member function]
+    cls.add_method('GetUseMmWaveConnection', 
+                   'bool', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ConnectionSwitchHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ConnectionSwitchHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ConnectionSwitchHeader::SetDrbid(uint8_t bid) [member function]
+    cls.add_method('SetDrbid', 
+                   'void', 
+                   [param('uint8_t', 'bid')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ConnectionSwitchHeader::SetMmWaveRnti(uint16_t rnti) [member function]
+    cls.add_method('SetMmWaveRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ConnectionSwitchHeader::SetUseMmWaveConnection(bool useMmWaveConnection) [member function]
+    cls.add_method('SetUseMmWaveConnection', 
+                   'void', 
+                   [param('bool', 'useMmWaveConnection')])
     return
 
 def register_Ns3EpcX2HandoverPreparationFailureHeader_methods(root_module, cls):
@@ -15552,6 +17864,11 @@
                    'ns3::TypeId', 
                    [], 
                    is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): bool ns3::EpcX2HandoverRequestHeader::GetIsMc() const [member function]
+    cls.add_method('GetIsMc', 
+                   'bool', 
+                   [], 
+                   is_const=True)
     ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetLengthOfIes() const [member function]
     cls.add_method('GetLengthOfIes', 
                    'uint32_t', 
@@ -15572,6 +17889,11 @@
                    'uint16_t', 
                    [], 
                    is_const=True)
+    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::RlcSetupRequest, std::allocator<ns3::EpcX2Sap::RlcSetupRequest> > ns3::EpcX2HandoverRequestHeader::GetRlcSetupRequests() const [member function]
+    cls.add_method('GetRlcSetupRequests', 
+                   'std::vector< ns3::EpcX2Sap::RlcSetupRequest >', 
+                   [], 
+                   is_const=True)
     ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetSerializedSize() const [member function]
     cls.add_method('GetSerializedSize', 
                    'uint32_t', 
@@ -15615,6 +17937,10 @@
     cls.add_method('SetCause', 
                    'void', 
                    [param('uint16_t', 'cause')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetIsMc(bool isMc) [member function]
+    cls.add_method('SetIsMc', 
+                   'void', 
+                   [param('bool', 'isMc')])
     ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetMmeUeS1apId(uint32_t mmeUeS1apId) [member function]
     cls.add_method('SetMmeUeS1apId', 
                    'void', 
@@ -15623,6 +17949,10 @@
     cls.add_method('SetOldEnbUeX2apId', 
                    'void', 
                    [param('uint16_t', 'x2apId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetRlcSetupRequests(std::vector<ns3::EpcX2Sap::RlcSetupRequest, std::allocator<ns3::EpcX2Sap::RlcSetupRequest> > rlcRequests) [member function]
+    cls.add_method('SetRlcSetupRequests', 
+                   'void', 
+                   [param('std::vector< ns3::EpcX2Sap::RlcSetupRequest >', 'rlcRequests')])
     ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetTargetCellId(uint16_t targetCellId) [member function]
     cls.add_method('SetTargetCellId', 
                    'void', 
@@ -15756,6 +18086,154 @@
                    [param('std::vector< ns3::EpcX2Sap::CellInformationItem >', 'cellInformationList')])
     return
 
+def register_Ns3EpcX2McHandoverHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2McHandoverHeader::EpcX2McHandoverHeader(ns3::EpcX2McHandoverHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2McHandoverHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2McHandoverHeader::EpcX2McHandoverHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2McHandoverHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint64_t ns3::EpcX2McHandoverHeader::GetImsi() const [member function]
+    cls.add_method('GetImsi', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2McHandoverHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2McHandoverHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2McHandoverHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2McHandoverHeader::GetOldCellId() const [member function]
+    cls.add_method('GetOldCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2McHandoverHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2McHandoverHeader::GetTargetCellId() const [member function]
+    cls.add_method('GetTargetCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2McHandoverHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2McHandoverHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2McHandoverHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2McHandoverHeader::SetImsi(uint64_t imsi) [member function]
+    cls.add_method('SetImsi', 
+                   'void', 
+                   [param('uint64_t', 'imsi')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2McHandoverHeader::SetOldCellId(uint16_t oldCellId) [member function]
+    cls.add_method('SetOldCellId', 
+                   'void', 
+                   [param('uint16_t', 'oldCellId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2McHandoverHeader::SetTargetCellId(uint16_t targetCellId) [member function]
+    cls.add_method('SetTargetCellId', 
+                   'void', 
+                   [param('uint16_t', 'targetCellId')])
+    return
+
+def register_Ns3EpcX2NotifyCoordinatorHandoverFailedHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::EpcX2NotifyCoordinatorHandoverFailedHeader(ns3::EpcX2NotifyCoordinatorHandoverFailedHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2NotifyCoordinatorHandoverFailedHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::EpcX2NotifyCoordinatorHandoverFailedHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint64_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetImsi() const [member function]
+    cls.add_method('GetImsi', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetSourceCellId() const [member function]
+    cls.add_method('GetSourceCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetTargetCellId() const [member function]
+    cls.add_method('GetTargetCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::SetImsi(uint64_t imsi) [member function]
+    cls.add_method('SetImsi', 
+                   'void', 
+                   [param('uint64_t', 'imsi')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::SetSourceCellId(uint16_t oldCellId) [member function]
+    cls.add_method('SetSourceCellId', 
+                   'void', 
+                   [param('uint16_t', 'oldCellId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::SetTargetCellId(uint16_t targetCellId) [member function]
+    cls.add_method('SetTargetCellId', 
+                   'void', 
+                   [param('uint16_t', 'targetCellId')])
+    return
+
 def register_Ns3EpcX2ResourceStatusUpdateHeader_methods(root_module, cls):
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2ResourceStatusUpdateHeader::EpcX2ResourceStatusUpdateHeader(ns3::EpcX2ResourceStatusUpdateHeader const & arg0) [constructor]
     cls.add_constructor([param('ns3::EpcX2ResourceStatusUpdateHeader const &', 'arg0')])
@@ -15830,6 +18308,281 @@
                    [param('uint16_t', 'enb2MeasurementId')])
     return
 
+def register_Ns3EpcX2RlcSetupCompletedHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2RlcSetupCompletedHeader::EpcX2RlcSetupCompletedHeader(ns3::EpcX2RlcSetupCompletedHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2RlcSetupCompletedHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2RlcSetupCompletedHeader::EpcX2RlcSetupCompletedHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupCompletedHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupCompletedHeader::GetGtpTeid() const [member function]
+    cls.add_method('GetGtpTeid', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2RlcSetupCompletedHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupCompletedHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupCompletedHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupCompletedHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2RlcSetupCompletedHeader::GetSourceCellId() const [member function]
+    cls.add_method('GetSourceCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2RlcSetupCompletedHeader::GetTargetCellId() const [member function]
+    cls.add_method('GetTargetCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2RlcSetupCompletedHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupCompletedHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupCompletedHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupCompletedHeader::SetGtpTeid(uint32_t gtpTeid) [member function]
+    cls.add_method('SetGtpTeid', 
+                   'void', 
+                   [param('uint32_t', 'gtpTeid')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupCompletedHeader::SetSourceCellId(uint16_t sourceCellId) [member function]
+    cls.add_method('SetSourceCellId', 
+                   'void', 
+                   [param('uint16_t', 'sourceCellId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupCompletedHeader::SetTargetCellId(uint16_t targetCellId) [member function]
+    cls.add_method('SetTargetCellId', 
+                   'void', 
+                   [param('uint16_t', 'targetCellId')])
+    return
+
+def register_Ns3EpcX2RlcSetupRequestHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2RlcSetupRequestHeader::EpcX2RlcSetupRequestHeader(ns3::EpcX2RlcSetupRequestHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2RlcSetupRequestHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2RlcSetupRequestHeader::EpcX2RlcSetupRequestHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupRequestHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint8_t ns3::EpcX2RlcSetupRequestHeader::GetDrbid() const [member function]
+    cls.add_method('GetDrbid', 
+                   'uint8_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupRequestHeader::GetGtpTeid() const [member function]
+    cls.add_method('GetGtpTeid', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2RlcSetupRequestHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo ns3::EpcX2RlcSetupRequestHeader::GetLcInfo() const [member function]
+    cls.add_method('GetLcInfo', 
+                   'ns3::LteEnbCmacSapProvider::LcInfo', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupRequestHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::LteRrcSap::LogicalChannelConfig ns3::EpcX2RlcSetupRequestHeader::GetLogicalChannelConfig() [member function]
+    cls.add_method('GetLogicalChannelConfig', 
+                   'ns3::LteRrcSap::LogicalChannelConfig', 
+                   [])
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2RlcSetupRequestHeader::GetLteRnti() const [member function]
+    cls.add_method('GetLteRnti', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2RlcSetupRequestHeader::GetMmWaveRnti() const [member function]
+    cls.add_method('GetMmWaveRnti', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupRequestHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::LteRrcSap::RlcConfig ns3::EpcX2RlcSetupRequestHeader::GetRlcConfig() const [member function]
+    cls.add_method('GetRlcConfig', 
+                   'ns3::LteRrcSap::RlcConfig', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupRequestHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2RlcSetupRequestHeader::GetSourceCellId() const [member function]
+    cls.add_method('GetSourceCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2RlcSetupRequestHeader::GetTargetCellId() const [member function]
+    cls.add_method('GetTargetCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2RlcSetupRequestHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetDrbid(uint8_t drbid) [member function]
+    cls.add_method('SetDrbid', 
+                   'void', 
+                   [param('uint8_t', 'drbid')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetGtpTeid(uint32_t gtpTeid) [member function]
+    cls.add_method('SetGtpTeid', 
+                   'void', 
+                   [param('uint32_t', 'gtpTeid')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetLcInfo(ns3::LteEnbCmacSapProvider::LcInfo lcInfo) [member function]
+    cls.add_method('SetLcInfo', 
+                   'void', 
+                   [param('ns3::LteEnbCmacSapProvider::LcInfo', 'lcInfo')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetLogicalChannelConfig(ns3::LteRrcSap::LogicalChannelConfig conf) [member function]
+    cls.add_method('SetLogicalChannelConfig', 
+                   'void', 
+                   [param('ns3::LteRrcSap::LogicalChannelConfig', 'conf')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetLteRnti(uint16_t rnti) [member function]
+    cls.add_method('SetLteRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetMmWaveRnti(uint16_t rnti) [member function]
+    cls.add_method('SetMmWaveRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetRlcConfig(ns3::LteRrcSap::RlcConfig rlcConfig) [member function]
+    cls.add_method('SetRlcConfig', 
+                   'void', 
+                   [param('ns3::LteRrcSap::RlcConfig', 'rlcConfig')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetSourceCellId(uint16_t sourceCellId) [member function]
+    cls.add_method('SetSourceCellId', 
+                   'void', 
+                   [param('uint16_t', 'sourceCellId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetTargetCellId(uint16_t targetCellId) [member function]
+    cls.add_method('SetTargetCellId', 
+                   'void', 
+                   [param('uint16_t', 'targetCellId')])
+    return
+
+def register_Ns3EpcX2SecondaryCellHandoverCompletedHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2SecondaryCellHandoverCompletedHeader::EpcX2SecondaryCellHandoverCompletedHeader(ns3::EpcX2SecondaryCellHandoverCompletedHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2SecondaryCellHandoverCompletedHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2SecondaryCellHandoverCompletedHeader::EpcX2SecondaryCellHandoverCompletedHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint64_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetImsi() const [member function]
+    cls.add_method('GetImsi', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetMmWaveRnti() const [member function]
+    cls.add_method('GetMmWaveRnti', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetOldEnbUeX2apId() const [member function]
+    cls.add_method('GetOldEnbUeX2apId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SecondaryCellHandoverCompletedHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SecondaryCellHandoverCompletedHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SecondaryCellHandoverCompletedHeader::SetImsi(uint64_t imsi) [member function]
+    cls.add_method('SetImsi', 
+                   'void', 
+                   [param('uint64_t', 'imsi')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SecondaryCellHandoverCompletedHeader::SetMmWaveRnti(uint16_t mmWaveRnti) [member function]
+    cls.add_method('SetMmWaveRnti', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveRnti')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SecondaryCellHandoverCompletedHeader::SetOldEnbUeX2apId(uint16_t oldEnbUeX2apId) [member function]
+    cls.add_method('SetOldEnbUeX2apId', 
+                   'void', 
+                   [param('uint16_t', 'oldEnbUeX2apId')])
+    return
+
 def register_Ns3EpcX2SnStatusTransferHeader_methods(root_module, cls):
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2SnStatusTransferHeader::EpcX2SnStatusTransferHeader(ns3::EpcX2SnStatusTransferHeader const & arg0) [constructor]
     cls.add_constructor([param('ns3::EpcX2SnStatusTransferHeader const &', 'arg0')])
@@ -15969,6 +18722,71 @@
                    [param('uint16_t', 'x2apId')])
     return
 
+def register_Ns3EpcX2UeImsiSinrUpdateHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2UeImsiSinrUpdateHeader::EpcX2UeImsiSinrUpdateHeader(ns3::EpcX2UeImsiSinrUpdateHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2UeImsiSinrUpdateHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2UeImsiSinrUpdateHeader::EpcX2UeImsiSinrUpdateHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2UeImsiSinrUpdateHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2UeImsiSinrUpdateHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2UeImsiSinrUpdateHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2UeImsiSinrUpdateHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2UeImsiSinrUpdateHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2UeImsiSinrUpdateHeader::GetSourceCellId() const [member function]
+    cls.add_method('GetSourceCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2UeImsiSinrUpdateHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): std::map<unsigned long, double, std::less<unsigned long>, std::allocator<std::pair<const unsigned long, double> > > ns3::EpcX2UeImsiSinrUpdateHeader::GetUeImsiSinrMap() const [member function]
+    cls.add_method('GetUeImsiSinrMap', 
+                   'std::map< unsigned long, double >', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2UeImsiSinrUpdateHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2UeImsiSinrUpdateHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2UeImsiSinrUpdateHeader::SetSourceCellId(uint16_t sourceCellId) [member function]
+    cls.add_method('SetSourceCellId', 
+                   'void', 
+                   [param('uint16_t', 'sourceCellId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2UeImsiSinrUpdateHeader::SetUeImsiSinrMap(std::map<unsigned long, double, std::less<unsigned long>, std::allocator<std::pair<const unsigned long, double> > > map) [member function]
+    cls.add_method('SetUeImsiSinrMap', 
+                   'void', 
+                   [param('std::map< unsigned long, double >', 'map')])
+    return
+
 def register_Ns3ErlangRandomVariable_methods(root_module, cls):
     ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::ErlangRandomVariable::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
@@ -17154,6 +19972,11 @@
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
+    ## lte-enb-component-carrier-manager.h (module 'lte'): void ns3::LteEnbComponentCarrierManager::SetBandwidthMap(std::map<unsigned char, double, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, double> > > bandwidthMap) [member function]
+    cls.add_method('SetBandwidthMap', 
+                   'void', 
+                   [param('std::map< unsigned char, double >', 'bandwidthMap')], 
+                   is_virtual=True)
     ## lte-enb-component-carrier-manager.h (module 'lte'): bool ns3::LteEnbComponentCarrierManager::SetCcmMacSapProviders(uint8_t componentCarrierId, ns3::LteCcmMacSapProvider * sap) [member function]
     cls.add_method('SetCcmMacSapProviders', 
                    'bool', 
@@ -17293,6 +20116,14 @@
     cls.add_method('ConfigureCell', 
                    'void', 
                    [param('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierEnb > >', 'ccPhyConf')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::ConfigureCell(std::map<unsigned char, ns3::LteEnbRrc::MmWaveComponentCarrierConf, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::LteEnbRrc::MmWaveComponentCarrierConf> > > ccPhyConf) [member function]
+    cls.add_method('ConfigureCell', 
+                   'void', 
+                   [param('std::map< unsigned char, ns3::LteEnbRrc::MmWaveComponentCarrierConf >', 'ccPhyConf')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::ConfigureMmWaveCarriers(std::map<unsigned char, ns3::LteEnbRrc::MmWaveComponentCarrierConf, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::LteEnbRrc::MmWaveComponentCarrierConf> > > ccPhyConf) [member function]
+    cls.add_method('ConfigureMmWaveCarriers', 
+                   'void', 
+                   [param('std::map< unsigned char, ns3::LteEnbRrc::MmWaveComponentCarrierConf >', 'ccPhyConf')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::ConnectionRejectedTimeout(uint16_t rnti) [member function]
     cls.add_method('ConnectionRejectedTimeout', 
                    'void', 
@@ -17309,10 +20140,29 @@
     cls.add_method('DoSendReleaseDataRadioBearer', 
                    'void', 
                    [param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('uint8_t', 'bearerId')])
+    ## lte-enb-rrc.h (module 'lte'): uint16_t ns3::LteEnbRrc::GetCellId() const [member function]
+    cls.add_method('GetCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## lte-enb-rrc.h (module 'lte'): ns3::EpcX2PdcpProvider * ns3::LteEnbRrc::GetEpcX2PdcpProvider() const [member function]
+    cls.add_method('GetEpcX2PdcpProvider', 
+                   'ns3::EpcX2PdcpProvider *', 
+                   [], 
+                   is_const=True)
+    ## lte-enb-rrc.h (module 'lte'): ns3::EpcX2RlcProvider * ns3::LteEnbRrc::GetEpcX2RlcProvider() const [member function]
+    cls.add_method('GetEpcX2RlcProvider', 
+                   'ns3::EpcX2RlcProvider *', 
+                   [], 
+                   is_const=True)
     ## lte-enb-rrc.h (module 'lte'): ns3::EpcX2SapUser * ns3::LteEnbRrc::GetEpcX2SapUser() [member function]
     cls.add_method('GetEpcX2SapUser', 
                    'ns3::EpcX2SapUser *', 
                    [])
+    ## lte-enb-rrc.h (module 'lte'): uint64_t ns3::LteEnbRrc::GetImsiFromRnti(uint16_t rnti) [member function]
+    cls.add_method('GetImsiFromRnti', 
+                   'uint64_t', 
+                   [param('uint16_t', 'rnti')])
     ## lte-enb-rrc.h (module 'lte'): ns3::LteAnrSapUser * ns3::LteEnbRrc::GetLteAnrSapUser() [member function]
     cls.add_method('GetLteAnrSapUser', 
                    'ns3::LteAnrSapUser *', 
@@ -17353,6 +20203,10 @@
     cls.add_method('GetLteHandoverManagementSapUser', 
                    'ns3::LteHandoverManagementSapUser *', 
                    [])
+    ## lte-enb-rrc.h (module 'lte'): uint16_t ns3::LteEnbRrc::GetRntiFromImsi(uint64_t imsi) [member function]
+    cls.add_method('GetRntiFromImsi', 
+                   'uint16_t', 
+                   [param('uint64_t', 'imsi')])
     ## lte-enb-rrc.h (module 'lte'): ns3::EpcEnbS1SapUser * ns3::LteEnbRrc::GetS1SapUser() [member function]
     cls.add_method('GetS1SapUser', 
                    'ns3::EpcEnbS1SapUser *', 
@@ -17384,6 +20238,10 @@
                    'bool', 
                    [param('uint16_t', 'rnti')], 
                    is_const=True)
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::RegisterImsiToRnti(uint64_t imsi, uint16_t rnti) [member function]
+    cls.add_method('RegisterImsiToRnti', 
+                   'void', 
+                   [param('uint64_t', 'imsi'), param('uint16_t', 'rnti')])
     ## lte-enb-rrc.h (module 'lte'): bool ns3::LteEnbRrc::SendData(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('SendData', 
                    'bool', 
@@ -17400,10 +20258,22 @@
     cls.add_method('SetCellId', 
                    'void', 
                    [param('uint16_t', 'm_cellId'), param('uint8_t', 'ccIndex')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetClosestLteCellId(uint16_t cellId) [member function]
+    cls.add_method('SetClosestLteCellId', 
+                   'void', 
+                   [param('uint16_t', 'cellId')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetCsgId(uint32_t csgId, bool csgIndication) [member function]
     cls.add_method('SetCsgId', 
                    'void', 
                    [param('uint32_t', 'csgId'), param('bool', 'csgIndication')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetEpcX2PdcpProvider(ns3::EpcX2PdcpProvider * s) [member function]
+    cls.add_method('SetEpcX2PdcpProvider', 
+                   'void', 
+                   [param('ns3::EpcX2PdcpProvider *', 's')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetEpcX2RlcProvider(ns3::EpcX2RlcProvider * s) [member function]
+    cls.add_method('SetEpcX2RlcProvider', 
+                   'void', 
+                   [param('ns3::EpcX2RlcProvider *', 's')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetEpcX2SapProvider(ns3::EpcX2SapProvider * s) [member function]
     cls.add_method('SetEpcX2SapProvider', 
                    'void', 
@@ -17412,6 +20282,10 @@
     cls.add_method('SetForwardUpCallback', 
                    'void', 
                    [param('ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetInterRatHoMode() [member function]
+    cls.add_method('SetInterRatHoMode', 
+                   'void', 
+                   [])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteAnrSapProvider(ns3::LteAnrSapProvider * s) [member function]
     cls.add_method('SetLteAnrSapProvider', 
                    'void', 
@@ -17475,6 +20349,32 @@
                    visibility='protected', is_virtual=True)
     return
 
+def register_Ns3LteEnbRrcHandoverEventInfo_methods(root_module, cls):
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverEventInfo::HandoverEventInfo() [constructor]
+    cls.add_constructor([])
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverEventInfo::HandoverEventInfo(ns3::LteEnbRrc::HandoverEventInfo const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteEnbRrc::HandoverEventInfo const &', 'arg0')])
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverEventInfo::scheduledHandoverEvent [variable]
+    cls.add_instance_attribute('scheduledHandoverEvent', 'ns3::EventId', is_const=False)
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverEventInfo::sourceCellId [variable]
+    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverEventInfo::targetCellId [variable]
+    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
+    return
+
+def register_Ns3LteEnbRrcMmWaveComponentCarrierConf_methods(root_module, cls):
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::MmWaveComponentCarrierConf::MmWaveComponentCarrierConf() [constructor]
+    cls.add_constructor([])
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::MmWaveComponentCarrierConf::MmWaveComponentCarrierConf(ns3::LteEnbRrc::MmWaveComponentCarrierConf const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteEnbRrc::MmWaveComponentCarrierConf const &', 'arg0')])
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::MmWaveComponentCarrierConf::m_bandwidth [variable]
+    cls.add_instance_attribute('m_bandwidth', 'uint32_t', is_const=False)
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::MmWaveComponentCarrierConf::m_ccId [variable]
+    cls.add_instance_attribute('m_ccId', 'uint8_t', is_const=False)
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::MmWaveComponentCarrierConf::m_cellId [variable]
+    cls.add_instance_attribute('m_cellId', 'uint16_t', is_const=False)
+    return
+
 def register_Ns3LteEnbRrcProtocolIdeal_methods(root_module, cls):
     ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteEnbRrcProtocolIdeal::LteEnbRrcProtocolIdeal(ns3::LteEnbRrcProtocolIdeal const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteEnbRrcProtocolIdeal const &', 'arg0')])
@@ -18948,9 +21848,9 @@
     cls.add_method('GetControlMessages', 
                    'std::list< ns3::Ptr< ns3::LteControlMessage > >', 
                    [])
-    ## lte-phy.h (module 'lte'): ns3::Ptr<ns3::LteNetDevice> ns3::LtePhy::GetDevice() const [member function]
+    ## lte-phy.h (module 'lte'): ns3::Ptr<ns3::NetDevice> ns3::LtePhy::GetDevice() const [member function]
     cls.add_method('GetDevice', 
-                   'ns3::Ptr< ns3::LteNetDevice >', 
+                   'ns3::Ptr< ns3::NetDevice >', 
                    [], 
                    is_const=True)
     ## lte-phy.h (module 'lte'): ns3::Ptr<ns3::LteSpectrumPhy> ns3::LtePhy::GetDownlinkSpectrumPhy() [member function]
@@ -19008,10 +21908,10 @@
     cls.add_method('SetControlMessages', 
                    'void', 
                    [param('ns3::Ptr< ns3::LteControlMessage >', 'm')])
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetDevice(ns3::Ptr<ns3::LteNetDevice> d) [member function]
+    ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetDevice(ns3::Ptr<ns3::NetDevice> d) [member function]
     cls.add_method('SetDevice', 
                    'void', 
-                   [param('ns3::Ptr< ns3::LteNetDevice >', 'd')])
+                   [param('ns3::Ptr< ns3::NetDevice >', 'd')])
     ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetDownlinkChannel(ns3::Ptr<ns3::SpectrumChannel> c) [member function]
     cls.add_method('SetDownlinkChannel', 
                    'void', 
@@ -19056,6 +21956,10 @@
                    'void', 
                    [], 
                    is_virtual=True)
+    ## lte-rlc.h (module 'lte'): ns3::EpcX2RlcUser * ns3::LteRlc::GetEpcX2RlcUser() [member function]
+    cls.add_method('GetEpcX2RlcUser', 
+                   'ns3::EpcX2RlcUser *', 
+                   [])
     ## lte-rlc.h (module 'lte'): ns3::LteMacSapUser * ns3::LteRlc::GetLteMacSapUser() [member function]
     cls.add_method('GetLteMacSapUser', 
                    'ns3::LteMacSapUser *', 
@@ -19069,6 +21973,10 @@
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::SetEpcX2RlcProvider(ns3::EpcX2RlcProvider * s) [member function]
+    cls.add_method('SetEpcX2RlcProvider', 
+                   'void', 
+                   [param('ns3::EpcX2RlcProvider *', 's')])
     ## lte-rlc.h (module 'lte'): void ns3::LteRlc::SetLcId(uint8_t lcId) [member function]
     cls.add_method('SetLcId', 
                    'void', 
@@ -19085,11 +21993,20 @@
     cls.add_method('SetRnti', 
                    'void', 
                    [param('uint16_t', 'rnti')])
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::SetUeDataParams(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('SetUeDataParams', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')])
     ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoNotifyHarqDeliveryFailure() [member function]
     cls.add_method('DoNotifyHarqDeliveryFailure', 
                    'void', 
                    [], 
                    is_pure_virtual=True, visibility='protected', is_virtual=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoNotifyHarqDeliveryFailure(uint8_t harqId) [member function]
+    cls.add_method('DoNotifyHarqDeliveryFailure', 
+                   'void', 
+                   [param('uint8_t', 'harqId')], 
+                   visibility='protected', is_virtual=True)
     ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
     cls.add_method('DoNotifyTxOpportunity', 
                    'void', 
@@ -19100,6 +22017,11 @@
                    'void', 
                    [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
                    is_pure_virtual=True, visibility='protected', is_virtual=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoSendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, visibility='protected', is_virtual=True)
     ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoTransmitPdcpPdu', 
                    'void', 
@@ -19108,8 +22030,6 @@
     return
 
 def register_Ns3LteRlcAm_methods(root_module, cls):
-    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::LteRlcAm(ns3::LteRlcAm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlcAm const &', 'arg0')])
     ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::LteRlcAm() [constructor]
     cls.add_constructor([])
     ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoDispose() [member function]
@@ -19117,6 +22037,11 @@
                    'void', 
                    [], 
                    is_virtual=True)
+    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoNotifyDlHarqDeliveryFailure(uint8_t harqId) [member function]
+    cls.add_method('DoNotifyDlHarqDeliveryFailure', 
+                   'void', 
+                   [param('uint8_t', 'harqId')], 
+                   is_virtual=True)
     ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoNotifyHarqDeliveryFailure() [member function]
     cls.add_method('DoNotifyHarqDeliveryFailure', 
                    'void', 
@@ -19127,21 +22052,86 @@
                    'void', 
                    [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
                    is_virtual=True)
+    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoNotifyUlHarqDeliveryFailure(uint8_t harqId) [member function]
+    cls.add_method('DoNotifyUlHarqDeliveryFailure', 
+                   'void', 
+                   [param('uint8_t', 'harqId')], 
+                   is_virtual=True)
     ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
     cls.add_method('DoReceivePdu', 
                    'void', 
                    [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
                    is_virtual=True)
+    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoSendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_virtual=True)
     ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoTransmitPdcpPdu', 
                    'void', 
                    [param('ns3::Ptr< ns3::Packet >', 'p')], 
                    is_virtual=True)
+    ## lte-rlc-am.h (module 'lte'): std::vector<ns3::LteRlcAm::RetxPdu, std::allocator<ns3::LteRlcAm::RetxPdu> > ns3::LteRlcAm::GetRetxBuffer() [member function]
+    cls.add_method('GetRetxBuffer', 
+                   'std::vector< ns3::LteRlcAm::RetxPdu >', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): uint32_t ns3::LteRlcAm::GetRetxBufferSize() [member function]
+    cls.add_method('GetRetxBufferSize', 
+                   'uint32_t', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): ns3::Ptr<ns3::Packet> ns3::LteRlcAm::GetSegmentedRlcsdu() [member function]
+    cls.add_method('GetSegmentedRlcsdu', 
+                   'ns3::Ptr< ns3::Packet >', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): std::map<unsigned int, ns3::Ptr<ns3::Packet>, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, ns3::Ptr<ns3::Packet> > > > ns3::LteRlcAm::GetTransmittingRlcSduBuffer() [member function]
+    cls.add_method('GetTransmittingRlcSduBuffer', 
+                   'std::map< unsigned int, ns3::Ptr< ns3::Packet > >', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): uint32_t ns3::LteRlcAm::GetTransmittingRlcSduBufferSize() [member function]
+    cls.add_method('GetTransmittingRlcSduBufferSize', 
+                   'uint32_t', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): std::vector<ns3::Ptr<ns3::Packet>, std::allocator<ns3::Ptr<ns3::Packet> > > ns3::LteRlcAm::GetTxBuffer() [member function]
+    cls.add_method('GetTxBuffer', 
+                   'std::vector< ns3::Ptr< ns3::Packet > >', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): uint32_t ns3::LteRlcAm::GetTxBufferSize() [member function]
+    cls.add_method('GetTxBufferSize', 
+                   'uint32_t', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): std::vector<ns3::LteRlcAm::RetxPdu, std::allocator<ns3::LteRlcAm::RetxPdu> > ns3::LteRlcAm::GetTxedBuffer() [member function]
+    cls.add_method('GetTxedBuffer', 
+                   'std::vector< ns3::LteRlcAm::RetxPdu >', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): uint32_t ns3::LteRlcAm::GetTxedBufferSize() [member function]
+    cls.add_method('GetTxedBufferSize', 
+                   'uint32_t', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): std::vector<ns3::Ptr<ns3::Packet>, std::allocator<ns3::Ptr<ns3::Packet> > > ns3::LteRlcAm::GetTxedRlcSduBuffer() [member function]
+    cls.add_method('GetTxedRlcSduBuffer', 
+                   'std::vector< ns3::Ptr< ns3::Packet > >', 
+                   [])
     ## lte-rlc-am.h (module 'lte'): static ns3::TypeId ns3::LteRlcAm::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
+    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::RlcPdusToRlcSdus(std::vector<ns3::LteRlcAm::RetxPdu, std::allocator<ns3::LteRlcAm::RetxPdu> > Pdus) [member function]
+    cls.add_method('RlcPdusToRlcSdus', 
+                   'void', 
+                   [param('std::vector< ns3::LteRlcAm::RetxPdu >', 'Pdus')])
+    return
+
+def register_Ns3LteRlcAmRetxPdu_methods(root_module, cls):
+    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::RetxPdu::RetxPdu() [constructor]
+    cls.add_constructor([])
+    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::RetxPdu::RetxPdu(ns3::LteRlcAm::RetxPdu const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteRlcAm::RetxPdu const &', 'arg0')])
+    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::RetxPdu::m_pdu [variable]
+    cls.add_instance_attribute('m_pdu', 'ns3::Ptr< ns3::Packet >', is_const=False)
+    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::RetxPdu::m_retxCount [variable]
+    cls.add_instance_attribute('m_retxCount', 'uint16_t', is_const=False)
     return
 
 def register_Ns3LteRlcSm_methods(root_module, cls):
@@ -19174,6 +22164,11 @@
                    'void', 
                    [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
                    is_virtual=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoSendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_virtual=True)
     ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoTransmitPdcpPdu', 
                    'void', 
@@ -19211,6 +22206,11 @@
                    'void', 
                    [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
                    is_virtual=True)
+    ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoSendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_virtual=True)
     ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoTransmitPdcpPdu', 
                    'void', 
@@ -19248,11 +22248,28 @@
                    'void', 
                    [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
                    is_virtual=True)
+    ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoSendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_virtual=True)
     ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoTransmitPdcpPdu', 
                    'void', 
                    [param('ns3::Ptr< ns3::Packet >', 'p')], 
                    is_virtual=True)
+    ## lte-rlc-um.h (module 'lte'): uint32_t ns3::LteRlcUm::GetMaxBuff() [member function]
+    cls.add_method('GetMaxBuff', 
+                   'uint32_t', 
+                   [])
+    ## lte-rlc-um.h (module 'lte'): std::vector<ns3::Ptr<ns3::Packet>, std::allocator<ns3::Ptr<ns3::Packet> > > ns3::LteRlcUm::GetTxBuffer() [member function]
+    cls.add_method('GetTxBuffer', 
+                   'std::vector< ns3::Ptr< ns3::Packet > >', 
+                   [])
+    ## lte-rlc-um.h (module 'lte'): uint32_t ns3::LteRlcUm::GetTxBufferSize() [member function]
+    cls.add_method('GetTxBufferSize', 
+                   'uint32_t', 
+                   [])
     ## lte-rlc-um.h (module 'lte'): static ns3::TypeId ns3::LteRlcUm::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
@@ -19260,6 +22277,56 @@
                    is_static=True)
     return
 
+def register_Ns3LteRlcUmLowLat_methods(root_module, cls):
+    ## lte-rlc-um-lowlat.h (module 'lte'): ns3::LteRlcUmLowLat::LteRlcUmLowLat(ns3::LteRlcUmLowLat const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteRlcUmLowLat const &', 'arg0')])
+    ## lte-rlc-um-lowlat.h (module 'lte'): ns3::LteRlcUmLowLat::LteRlcUmLowLat() [constructor]
+    cls.add_constructor([])
+    ## lte-rlc-um-lowlat.h (module 'lte'): void ns3::LteRlcUmLowLat::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## lte-rlc-um-lowlat.h (module 'lte'): void ns3::LteRlcUmLowLat::DoNotifyHarqDeliveryFailure() [member function]
+    cls.add_method('DoNotifyHarqDeliveryFailure', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## lte-rlc-um-lowlat.h (module 'lte'): void ns3::LteRlcUmLowLat::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
+    cls.add_method('DoNotifyTxOpportunity', 
+                   'void', 
+                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   is_virtual=True)
+    ## lte-rlc-um-lowlat.h (module 'lte'): void ns3::LteRlcUmLowLat::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
+    cls.add_method('DoReceivePdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   is_virtual=True)
+    ## lte-rlc-um-lowlat.h (module 'lte'): void ns3::LteRlcUmLowLat::DoSendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_virtual=True)
+    ## lte-rlc-um-lowlat.h (module 'lte'): void ns3::LteRlcUmLowLat::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('DoTransmitPdcpPdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   is_virtual=True)
+    ## lte-rlc-um-lowlat.h (module 'lte'): std::vector<ns3::Ptr<ns3::Packet>, std::allocator<ns3::Ptr<ns3::Packet> > > ns3::LteRlcUmLowLat::GetTxBuffer() [member function]
+    cls.add_method('GetTxBuffer', 
+                   'std::vector< ns3::Ptr< ns3::Packet > >', 
+                   [])
+    ## lte-rlc-um-lowlat.h (module 'lte'): uint32_t ns3::LteRlcUmLowLat::GetTxBufferSize() [member function]
+    cls.add_method('GetTxBufferSize', 
+                   'uint32_t', 
+                   [])
+    ## lte-rlc-um-lowlat.h (module 'lte'): static ns3::TypeId ns3::LteRlcUmLowLat::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    return
+
 def register_Ns3LteSignalingRadioBearerInfo_methods(root_module, cls):
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteSignalingRadioBearerInfo::LteSignalingRadioBearerInfo() [constructor]
     cls.add_constructor([])
@@ -19373,6 +22440,10 @@
     cls.add_method('StartTxUlSrsFrame', 
                    'bool', 
                    [])
+    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetLtePhyTxEndCallback(ns3::LtePhyTxEndCallback c) [member function]
+    cls.add_method('SetLtePhyTxEndCallback', 
+                   'void', 
+                   [param('ns3::Callback< void, ns3::Ptr< ns3::Packet const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'c')])
     ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetLtePhyRxDataEndErrorCallback(ns3::LtePhyRxDataEndErrorCallback c) [member function]
     cls.add_method('SetLtePhyRxDataEndErrorCallback', 
                    'void', 
@@ -19983,6 +23054,14 @@
     cls.add_constructor([param('ns3::LteUeRrc const &', 'arg0')])
     ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrc::LteUeRrc() [constructor]
     cls.add_constructor([])
+    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::AddLteCellId(uint16_t cellId) [member function]
+    cls.add_method('AddLteCellId', 
+                   'void', 
+                   [param('uint16_t', 'cellId')])
+    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::AddMmWaveCellId(uint16_t cellId) [member function]
+    cls.add_method('AddMmWaveCellId', 
+                   'void', 
+                   [param('uint16_t', 'cellId')])
     ## lte-ue-rrc.h (module 'lte'): ns3::LteAsSapProvider * ns3::LteUeRrc::GetAsSapProvider() [member function]
     cls.add_method('GetAsSapProvider', 
                    'ns3::LteAsSapProvider *', 
@@ -20096,12 +23175,34 @@
     cls.add_method('SetLteUeRrcSapUser', 
                    'void', 
                    [param('ns3::LteUeRrcSapUser *', 's')])
+    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetMmWaveMacSapProvider(ns3::LteMacSapProvider * s) [member function]
+    cls.add_method('SetMmWaveMacSapProvider', 
+                   'void', 
+                   [param('ns3::LteMacSapProvider *', 's')])
+    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetMmWaveUeCmacSapProvider(ns3::LteUeCmacSapProvider * s) [member function]
+    cls.add_method('SetMmWaveUeCmacSapProvider', 
+                   'void', 
+                   [param('ns3::LteUeCmacSapProvider *', 's')])
+    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetMmWaveUeCmacSapProvider(ns3::LteUeCmacSapProvider * s, uint8_t index) [member function]
+    cls.add_method('SetMmWaveUeCmacSapProvider', 
+                   'void', 
+                   [param('ns3::LteUeCmacSapProvider *', 's'), param('uint8_t', 'index')])
+    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetMmWaveUeCphySapProvider(ns3::LteUeCphySapProvider * s) [member function]
+    cls.add_method('SetMmWaveUeCphySapProvider', 
+                   'void', 
+                   [param('ns3::LteUeCphySapProvider *', 's')])
     ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetUseRlcSm(bool val) [member function]
     cls.add_method('SetUseRlcSm', 
                    'void', 
                    [param('bool', 'val')])
+    ## lte-ue-rrc.h (module 'lte'): bool ns3::LteUeRrc::SwitchLowerLayerProviders(uint16_t cellId) [member function]
+    cls.add_method('SwitchLowerLayerProviders', 
+                   'bool', 
+                   [param('uint16_t', 'cellId')])
     ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrc::m_numberOfComponentCarriers [variable]
     cls.add_instance_attribute('m_numberOfComponentCarriers', 'uint16_t', is_const=False)
+    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrc::m_numberOfMmWaveComponentCarriers [variable]
+    cls.add_instance_attribute('m_numberOfMmWaveComponentCarriers', 'uint16_t', is_const=False)
     ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::DoDispose() [member function]
     cls.add_method('DoDispose', 
                    'void', 
@@ -20298,6 +23399,223 @@
                    is_static=True)
     return
 
+def register_Ns3MacTxStatsCalculator_methods(root_module, cls):
+    ## mac-tx-stats-calculator.h (module 'lte'): ns3::MacTxStatsCalculator::MacTxStatsCalculator() [constructor]
+    cls.add_constructor([])
+    ## mac-tx-stats-calculator.h (module 'lte'): static ns3::TypeId ns3::MacTxStatsCalculator::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## mac-tx-stats-calculator.h (module 'lte'): void ns3::MacTxStatsCalculator::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## mac-tx-stats-calculator.h (module 'lte'): void ns3::MacTxStatsCalculator::RegisterMacTxDl(uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx) [member function]
+    cls.add_method('RegisterMacTxDl', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('uint16_t', 'cellId'), param('uint32_t', 'packetSize'), param('uint8_t', 'numRetx')])
+    ## mac-tx-stats-calculator.h (module 'lte'): void ns3::MacTxStatsCalculator::RegisterMacTxUl(uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx) [member function]
+    cls.add_method('RegisterMacTxUl', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('uint16_t', 'cellId'), param('uint32_t', 'packetSize'), param('uint8_t', 'numRetx')])
+    ## mac-tx-stats-calculator.h (module 'lte'): ns3::MacTxStatsCalculator::m_retxDlFile [variable]
+    cls.add_instance_attribute('m_retxDlFile', 'std::ofstream', is_const=False)
+    ## mac-tx-stats-calculator.h (module 'lte'): ns3::MacTxStatsCalculator::m_retxDlFilename [variable]
+    cls.add_instance_attribute('m_retxDlFilename', 'std::string', is_const=False)
+    ## mac-tx-stats-calculator.h (module 'lte'): ns3::MacTxStatsCalculator::m_retxUlFile [variable]
+    cls.add_instance_attribute('m_retxUlFile', 'std::ofstream', is_const=False)
+    ## mac-tx-stats-calculator.h (module 'lte'): ns3::MacTxStatsCalculator::m_retxUlFilename [variable]
+    cls.add_instance_attribute('m_retxUlFilename', 'std::string', is_const=False)
+    return
+
+def register_Ns3McEnbPdcp_methods(root_module, cls):
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::McEnbPdcp(ns3::McEnbPdcp const & arg0) [constructor]
+    cls.add_constructor([param('ns3::McEnbPdcp const &', 'arg0')])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::McEnbPdcp() [constructor]
+    cls.add_constructor([])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## mc-enb-pdcp.h (module 'lte'): ns3::EpcX2PdcpUser * ns3::McEnbPdcp::GetEpcX2PdcpUser() [member function]
+    cls.add_method('GetEpcX2PdcpUser', 
+                   'ns3::EpcX2PdcpUser *', 
+                   [])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::LtePdcpSapProvider * ns3::McEnbPdcp::GetLtePdcpSapProvider() [member function]
+    cls.add_method('GetLtePdcpSapProvider', 
+                   'ns3::LtePdcpSapProvider *', 
+                   [])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::LteRlcSapUser * ns3::McEnbPdcp::GetLteRlcSapUser() [member function]
+    cls.add_method('GetLteRlcSapUser', 
+                   'ns3::LteRlcSapUser *', 
+                   [])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::Status ns3::McEnbPdcp::GetStatus() [member function]
+    cls.add_method('GetStatus', 
+                   'ns3::McEnbPdcp::Status', 
+                   [])
+    ## mc-enb-pdcp.h (module 'lte'): static ns3::TypeId ns3::McEnbPdcp::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## mc-enb-pdcp.h (module 'lte'): bool ns3::McEnbPdcp::GetUseMmWaveConnection() const [member function]
+    cls.add_method('GetUseMmWaveConnection', 
+                   'bool', 
+                   [], 
+                   is_const=True)
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetEpcX2PdcpProvider(ns3::EpcX2PdcpProvider * s) [member function]
+    cls.add_method('SetEpcX2PdcpProvider', 
+                   'void', 
+                   [param('ns3::EpcX2PdcpProvider *', 's')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetLcId(uint8_t lcId) [member function]
+    cls.add_method('SetLcId', 
+                   'void', 
+                   [param('uint8_t', 'lcId')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetLtePdcpSapUser(ns3::LtePdcpSapUser * s) [member function]
+    cls.add_method('SetLtePdcpSapUser', 
+                   'void', 
+                   [param('ns3::LtePdcpSapUser *', 's')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetLteRlcSapProvider(ns3::LteRlcSapProvider * s) [member function]
+    cls.add_method('SetLteRlcSapProvider', 
+                   'void', 
+                   [param('ns3::LteRlcSapProvider *', 's')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetMmWaveRnti(uint16_t rnti) [member function]
+    cls.add_method('SetMmWaveRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetRnti(uint16_t rnti) [member function]
+    cls.add_method('SetRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetStatus(ns3::McEnbPdcp::Status s) [member function]
+    cls.add_method('SetStatus', 
+                   'void', 
+                   [param('ns3::McEnbPdcp::Status', 's')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetUeDataParams(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('SetUeDataParams', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SwitchConnection(bool useMmWaveConnection) [member function]
+    cls.add_method('SwitchConnection', 
+                   'void', 
+                   [param('bool', 'useMmWaveConnection')])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::MAX_PDCP_SN [variable]
+    cls.add_static_attribute('MAX_PDCP_SN', 'uint16_t const', is_const=True)
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::DoReceiveMcPdcpPdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoReceiveMcPdcpPdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::DoReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('DoReceivePdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   visibility='protected', is_virtual=True)
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::DoTransmitPdcpSdu(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('DoTransmitPdcpSdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   visibility='protected', is_virtual=True)
+    return
+
+def register_Ns3McEnbPdcpStatus_methods(root_module, cls):
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::Status::Status() [constructor]
+    cls.add_constructor([])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::Status::Status(ns3::McEnbPdcp::Status const & arg0) [constructor]
+    cls.add_constructor([param('ns3::McEnbPdcp::Status const &', 'arg0')])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::Status::rxSn [variable]
+    cls.add_instance_attribute('rxSn', 'uint16_t', is_const=False)
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::Status::txSn [variable]
+    cls.add_instance_attribute('txSn', 'uint16_t', is_const=False)
+    return
+
+def register_Ns3McUePdcp_methods(root_module, cls):
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::McUePdcp(ns3::McUePdcp const & arg0) [constructor]
+    cls.add_constructor([param('ns3::McUePdcp const &', 'arg0')])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::McUePdcp() [constructor]
+    cls.add_constructor([])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## mc-ue-pdcp.h (module 'lte'): ns3::LtePdcpSapProvider * ns3::McUePdcp::GetLtePdcpSapProvider() [member function]
+    cls.add_method('GetLtePdcpSapProvider', 
+                   'ns3::LtePdcpSapProvider *', 
+                   [])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::LteRlcSapUser * ns3::McUePdcp::GetLteRlcSapUser() [member function]
+    cls.add_method('GetLteRlcSapUser', 
+                   'ns3::LteRlcSapUser *', 
+                   [])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::Status ns3::McUePdcp::GetStatus() [member function]
+    cls.add_method('GetStatus', 
+                   'ns3::McUePdcp::Status', 
+                   [])
+    ## mc-ue-pdcp.h (module 'lte'): static ns3::TypeId ns3::McUePdcp::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetLcId(uint8_t lcId) [member function]
+    cls.add_method('SetLcId', 
+                   'void', 
+                   [param('uint8_t', 'lcId')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetLtePdcpSapUser(ns3::LtePdcpSapUser * s) [member function]
+    cls.add_method('SetLtePdcpSapUser', 
+                   'void', 
+                   [param('ns3::LtePdcpSapUser *', 's')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetLteRlcSapProvider(ns3::LteRlcSapProvider * s) [member function]
+    cls.add_method('SetLteRlcSapProvider', 
+                   'void', 
+                   [param('ns3::LteRlcSapProvider *', 's')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetMmWaveRlcSapProvider(ns3::LteRlcSapProvider * s) [member function]
+    cls.add_method('SetMmWaveRlcSapProvider', 
+                   'void', 
+                   [param('ns3::LteRlcSapProvider *', 's')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetMmWaveRnti(uint16_t rnti) [member function]
+    cls.add_method('SetMmWaveRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetRnti(uint16_t rnti) [member function]
+    cls.add_method('SetRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetStatus(ns3::McUePdcp::Status s) [member function]
+    cls.add_method('SetStatus', 
+                   'void', 
+                   [param('ns3::McUePdcp::Status', 's')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SwitchConnection(bool useMmWaveConnection) [member function]
+    cls.add_method('SwitchConnection', 
+                   'void', 
+                   [param('bool', 'useMmWaveConnection')])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::MAX_PDCP_SN [variable]
+    cls.add_static_attribute('MAX_PDCP_SN', 'uint16_t const', is_const=True)
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::DoReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('DoReceivePdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   visibility='protected', is_virtual=True)
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::DoTransmitPdcpSdu(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('DoTransmitPdcpSdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   visibility='protected', is_virtual=True)
+    return
+
+def register_Ns3McUePdcpStatus_methods(root_module, cls):
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::Status::Status() [constructor]
+    cls.add_constructor([])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::Status::Status(ns3::McUePdcp::Status const & arg0) [constructor]
+    cls.add_constructor([param('ns3::McUePdcp::Status const &', 'arg0')])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::Status::rxSn [variable]
+    cls.add_instance_attribute('rxSn', 'uint16_t', is_const=False)
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::Status::txSn [variable]
+    cls.add_instance_attribute('txSn', 'uint16_t', is_const=False)
+    return
+
 def register_Ns3MibLteControlMessage_methods(root_module, cls):
     ## lte-control-messages.h (module 'lte'): ns3::MibLteControlMessage::MibLteControlMessage(ns3::MibLteControlMessage const & arg0) [constructor]
     cls.add_constructor([param('ns3::MibLteControlMessage const &', 'arg0')])
@@ -21455,6 +24773,11 @@
                    'uint8_t', 
                    [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
                    is_virtual=True)
+    ## point-to-point-epc-helper.h (module 'lte'): uint8_t ns3::PointToPointEpcHelper::ActivateEpsBearer(ns3::Ptr<ns3::NetDevice> ueLteDevice, ns3::Ptr<ns3::EpcUeNas> ueNas, uint64_t imsi, ns3::Ptr<ns3::EpcTft> tft, ns3::EpsBearer bearer) [member function]
+    cls.add_method('ActivateEpsBearer', 
+                   'uint8_t', 
+                   [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('ns3::Ptr< ns3::EpcUeNas >', 'ueNas'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
+                   is_virtual=True)
     ## point-to-point-epc-helper.h (module 'lte'): void ns3::PointToPointEpcHelper::AddEnb(ns3::Ptr<ns3::Node> enbNode, ns3::Ptr<ns3::NetDevice> lteEnbNetDevice, uint16_t cellId) [member function]
     cls.add_method('AddEnb', 
                    'void', 
@@ -21489,6 +24812,11 @@
                    'ns3::TypeId', 
                    [], 
                    is_const=True, is_virtual=True)
+    ## point-to-point-epc-helper.h (module 'lte'): ns3::Ptr<ns3::Node> ns3::PointToPointEpcHelper::GetMmeNode() [member function]
+    cls.add_method('GetMmeNode', 
+                   'ns3::Ptr< ns3::Node >', 
+                   [], 
+                   is_virtual=True)
     ## point-to-point-epc-helper.h (module 'lte'): ns3::Ptr<ns3::Node> ns3::PointToPointEpcHelper::GetPgwNode() [member function]
     cls.add_method('GetPgwNode', 
                    'ns3::Ptr< ns3::Node >', 
@@ -21606,6 +24934,72 @@
                    [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
     return
 
+def register_Ns3QueueItem_methods(root_module, cls):
+    cls.add_output_stream_operator()
+    ## queue-item.h (module 'network'): ns3::QueueItem::QueueItem(ns3::Ptr<ns3::Packet> p) [constructor]
+    cls.add_constructor([param('ns3::Ptr< ns3::Packet >', 'p')])
+    ## queue-item.h (module 'network'): ns3::Ptr<ns3::Packet> ns3::QueueItem::GetPacket() const [member function]
+    cls.add_method('GetPacket', 
+                   'ns3::Ptr< ns3::Packet >', 
+                   [], 
+                   is_const=True)
+    ## queue-item.h (module 'network'): uint32_t ns3::QueueItem::GetSize() const [member function]
+    cls.add_method('GetSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## queue-item.h (module 'network'): bool ns3::QueueItem::GetUint8Value(ns3::QueueItem::Uint8Values field, uint8_t & value) const [member function]
+    cls.add_method('GetUint8Value', 
+                   'bool', 
+                   [param('ns3::QueueItem::Uint8Values', 'field'), param('uint8_t &', 'value')], 
+                   is_const=True, is_virtual=True)
+    ## queue-item.h (module 'network'): void ns3::QueueItem::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    return
+
+def register_Ns3QueueSizeChecker_methods(root_module, cls):
+    ## queue-size.h (module 'network'): ns3::QueueSizeChecker::QueueSizeChecker() [constructor]
+    cls.add_constructor([])
+    ## queue-size.h (module 'network'): ns3::QueueSizeChecker::QueueSizeChecker(ns3::QueueSizeChecker const & arg0) [constructor]
+    cls.add_constructor([param('ns3::QueueSizeChecker const &', 'arg0')])
+    return
+
+def register_Ns3QueueSizeValue_methods(root_module, cls):
+    ## queue-size.h (module 'network'): ns3::QueueSizeValue::QueueSizeValue() [constructor]
+    cls.add_constructor([])
+    ## queue-size.h (module 'network'): ns3::QueueSizeValue::QueueSizeValue(ns3::QueueSize const & value) [constructor]
+    cls.add_constructor([param('ns3::QueueSize const &', 'value')])
+    ## queue-size.h (module 'network'): ns3::QueueSizeValue::QueueSizeValue(ns3::QueueSizeValue const & arg0) [constructor]
+    cls.add_constructor([param('ns3::QueueSizeValue const &', 'arg0')])
+    ## queue-size.h (module 'network'): ns3::Ptr<ns3::AttributeValue> ns3::QueueSizeValue::Copy() const [member function]
+    cls.add_method('Copy', 
+                   'ns3::Ptr< ns3::AttributeValue >', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## queue-size.h (module 'network'): bool ns3::QueueSizeValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
+    cls.add_method('DeserializeFromString', 
+                   'bool', 
+                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
+                   is_virtual=True)
+    ## queue-size.h (module 'network'): ns3::QueueSize ns3::QueueSizeValue::Get() const [member function]
+    cls.add_method('Get', 
+                   'ns3::QueueSize', 
+                   [], 
+                   is_const=True)
+    ## queue-size.h (module 'network'): std::string ns3::QueueSizeValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
+    cls.add_method('SerializeToString', 
+                   'std::string', 
+                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
+                   is_const=True, is_virtual=True)
+    ## queue-size.h (module 'network'): void ns3::QueueSizeValue::Set(ns3::QueueSize const & value) [member function]
+    cls.add_method('Set', 
+                   'void', 
+                   [param('ns3::QueueSize const &', 'value')])
+    return
+
 def register_Ns3RachPreambleLteControlMessage_methods(root_module, cls):
     ## lte-control-messages.h (module 'lte'): ns3::RachPreambleLteControlMessage::RachPreambleLteControlMessage(ns3::RachPreambleLteControlMessage const & arg0) [constructor]
     cls.add_constructor([param('ns3::RachPreambleLteControlMessage const &', 'arg0')])
@@ -22334,6 +25728,28 @@
                    is_const=True, visibility='protected')
     return
 
+def register_Ns3S1apConnectionInfo_methods(root_module, cls):
+    ## epc-s1ap.h (module 'lte'): ns3::S1apConnectionInfo::S1apConnectionInfo(ns3::S1apConnectionInfo const & arg0) [constructor]
+    cls.add_constructor([param('ns3::S1apConnectionInfo const &', 'arg0')])
+    ## epc-s1ap.h (module 'lte'): ns3::S1apConnectionInfo::S1apConnectionInfo(uint16_t enbId, uint16_t mmeId) [constructor]
+    cls.add_constructor([param('uint16_t', 'enbId'), param('uint16_t', 'mmeId')])
+    ## epc-s1ap.h (module 'lte'): ns3::S1apConnectionInfo::m_enbId [variable]
+    cls.add_instance_attribute('m_enbId', 'uint16_t', is_const=False)
+    ## epc-s1ap.h (module 'lte'): ns3::S1apConnectionInfo::m_mmeId [variable]
+    cls.add_instance_attribute('m_mmeId', 'uint16_t', is_const=False)
+    return
+
+def register_Ns3S1apIfaceInfo_methods(root_module, cls):
+    ## epc-s1ap.h (module 'lte'): ns3::S1apIfaceInfo::S1apIfaceInfo(ns3::S1apIfaceInfo const & arg0) [constructor]
+    cls.add_constructor([param('ns3::S1apIfaceInfo const &', 'arg0')])
+    ## epc-s1ap.h (module 'lte'): ns3::S1apIfaceInfo::S1apIfaceInfo(ns3::Ipv4Address remoteIpAddr, ns3::Ptr<ns3::Socket> localCtrlPlaneSocket) [constructor]
+    cls.add_constructor([param('ns3::Ipv4Address', 'remoteIpAddr'), param('ns3::Ptr< ns3::Socket >', 'localCtrlPlaneSocket')])
+    ## epc-s1ap.h (module 'lte'): ns3::S1apIfaceInfo::m_localCtrlPlaneSocket [variable]
+    cls.add_instance_attribute('m_localCtrlPlaneSocket', 'ns3::Ptr< ns3::Socket >', is_const=False)
+    ## epc-s1ap.h (module 'lte'): ns3::S1apIfaceInfo::m_remoteIpAddr [variable]
+    cls.add_instance_attribute('m_remoteIpAddr', 'ns3::Ipv4Address', is_const=False)
+    return
+
 def register_Ns3Sib1LteControlMessage_methods(root_module, cls):
     ## lte-control-messages.h (module 'lte'): ns3::Sib1LteControlMessage::Sib1LteControlMessage(ns3::Sib1LteControlMessage const & arg0) [constructor]
     cls.add_constructor([param('ns3::Sib1LteControlMessage const &', 'arg0')])
@@ -23326,6 +26742,28 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
+def register_Ns3CallbackImpl__Void_Bool_Bool_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(bool arg0, bool arg1) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('bool', 'arg0'), param('bool', 'arg1')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
 def register_Ns3CallbackImpl__Void_Const_ns3SpectrumValue___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
     ## callback.h (module 'core'): ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
@@ -23502,6 +26940,50 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
+def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3QueueDiscItem__gt___Const_char___star___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::QueueDiscItem const >, char const *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<const ns3::QueueDiscItem> arg0, char const * arg1) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem const >', 'arg0'), param('char const *', 'arg1')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
+def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3QueueDiscItem__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::QueueDiscItem const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<const ns3::QueueDiscItem> arg0) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem const >', 'arg0')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
 def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3LteUeRrc__gt___StdList__lt__ns3LteRrcSapSCellToAddMod__stdAllocator__lt__ns3LteRrcSapSCellToAddMod__gt_____gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::LteUeRrc>, std::list<ns3::LteRrcSap::SCellToAddMod, std::allocator<ns3::LteRrcSap::SCellToAddMod> >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
@@ -23657,6 +27139,28 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
+def register_Ns3CallbackImpl__Void_Ns3Time_Ns3Time_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Time arg0, ns3::Time arg1) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('ns3::Time', 'arg0'), param('ns3::Time', 'arg1')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
 def register_Ns3CallbackImpl__Void_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
@@ -23679,6 +27183,28 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
+def register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(unsigned int arg0, unsigned int arg1) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('unsigned int', 'arg0'), param('unsigned int', 'arg1')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
 def register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Unsigned_short_Unsigned_char_Unsigned_short_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
@@ -23701,6 +27227,28 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
+def register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Long_double_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(long unsigned int arg0, short unsigned int arg1, long double arg2) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('long unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('long double', 'arg2')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
 def register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
@@ -23877,6 +27425,28 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
+def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, unsigned char arg1, unsigned int arg2, unsigned int arg3) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('short unsigned int', 'arg0'), param('unsigned char', 'arg1'), param('unsigned int', 'arg2'), param('unsigned int', 'arg3')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
 def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Unsigned_long_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
@@ -24031,6 +27601,28 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
+def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Unsigned_int_Unsigned_long_Bool_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, short unsigned int arg1, unsigned int arg2, long unsigned int arg3, bool arg4) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('short unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('unsigned int', 'arg2'), param('long unsigned int', 'arg3'), param('bool', 'arg4')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
 def register_Ns3CqaFfMacScheduler_methods(root_module, cls):
     ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqaFfMacScheduler::CqaFfMacScheduler(ns3::CqaFfMacScheduler const & arg0) [constructor]
     cls.add_constructor([param('ns3::CqaFfMacScheduler const &', 'arg0')])
@@ -24137,6 +27729,11 @@
                    'uint8_t', 
                    [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
                    is_virtual=True)
+    ## emu-epc-helper.h (module 'lte'): uint8_t ns3::EmuEpcHelper::ActivateEpsBearer(ns3::Ptr<ns3::NetDevice> ueLteDevice, ns3::Ptr<ns3::EpcUeNas> ueNas, uint64_t imsi, ns3::Ptr<ns3::EpcTft> tft, ns3::EpsBearer bearer) [member function]
+    cls.add_method('ActivateEpsBearer', 
+                   'uint8_t', 
+                   [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('ns3::Ptr< ns3::EpcUeNas >', 'ueNas'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
+                   is_virtual=True)
     ## emu-epc-helper.h (module 'lte'): void ns3::EmuEpcHelper::AddEnb(ns3::Ptr<ns3::Node> enbNode, ns3::Ptr<ns3::NetDevice> lteEnbNetDevice, uint16_t cellId) [member function]
     cls.add_method('AddEnb', 
                    'void', 
@@ -24404,12 +28001,16 @@
     cls.add_instance_attribute('m_epsBearerIdentity', 'uint8_t', is_const=False)
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_gtpTeid [variable]
     cls.add_instance_attribute('m_gtpTeid', 'uint32_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_isMc [variable]
+    cls.add_instance_attribute('m_isMc', 'bool', is_const=False)
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_logicalChannelConfig [variable]
     cls.add_instance_attribute('m_logicalChannelConfig', 'ns3::LteRrcSap::LogicalChannelConfig', is_const=False)
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_logicalChannelIdentity [variable]
     cls.add_instance_attribute('m_logicalChannelIdentity', 'uint8_t', is_const=False)
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_rlcConfig [variable]
     cls.add_instance_attribute('m_rlcConfig', 'ns3::LteRrcSap::RlcConfig', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_rlcSetupRequest [variable]
+    cls.add_instance_attribute('m_rlcSetupRequest', 'ns3::EpcX2Sap::RlcSetupRequest', is_const=False)
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_transportLayerAddress [variable]
     cls.add_instance_attribute('m_transportLayerAddress', 'ns3::Ipv4Address', is_const=False)
     return
@@ -24868,6 +28469,90 @@
                    [param('ns3::LteRrcSap::MeasurementReport', 'msg')])
     return
 
+def register_Ns3QueueDiscItem_methods(root_module, cls):
+    ## queue-item.h (module 'network'): ns3::QueueDiscItem::QueueDiscItem(ns3::Ptr<ns3::Packet> p, ns3::Address const & addr, uint16_t protocol) [constructor]
+    cls.add_constructor([param('ns3::Ptr< ns3::Packet >', 'p'), param('ns3::Address const &', 'addr'), param('uint16_t', 'protocol')])
+    ## queue-item.h (module 'network'): ns3::Address ns3::QueueDiscItem::GetAddress() const [member function]
+    cls.add_method('GetAddress', 
+                   'ns3::Address', 
+                   [], 
+                   is_const=True)
+    ## queue-item.h (module 'network'): uint16_t ns3::QueueDiscItem::GetProtocol() const [member function]
+    cls.add_method('GetProtocol', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## queue-item.h (module 'network'): uint8_t ns3::QueueDiscItem::GetTxQueueIndex() const [member function]
+    cls.add_method('GetTxQueueIndex', 
+                   'uint8_t', 
+                   [], 
+                   is_const=True)
+    ## queue-item.h (module 'network'): void ns3::QueueDiscItem::SetTxQueueIndex(uint8_t txq) [member function]
+    cls.add_method('SetTxQueueIndex', 
+                   'void', 
+                   [param('uint8_t', 'txq')])
+    ## queue-item.h (module 'network'): ns3::Time ns3::QueueDiscItem::GetTimeStamp() const [member function]
+    cls.add_method('GetTimeStamp', 
+                   'ns3::Time', 
+                   [], 
+                   is_const=True)
+    ## queue-item.h (module 'network'): void ns3::QueueDiscItem::SetTimeStamp(ns3::Time t) [member function]
+    cls.add_method('SetTimeStamp', 
+                   'void', 
+                   [param('ns3::Time', 't')])
+    ## queue-item.h (module 'network'): void ns3::QueueDiscItem::AddHeader() [member function]
+    cls.add_method('AddHeader', 
+                   'void', 
+                   [], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## queue-item.h (module 'network'): void ns3::QueueDiscItem::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## queue-item.h (module 'network'): bool ns3::QueueDiscItem::Mark() [member function]
+    cls.add_method('Mark', 
+                   'bool', 
+                   [], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3RrcConnectToMmWaveHeader_methods(root_module, cls):
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectToMmWaveHeader::RrcConnectToMmWaveHeader(ns3::RrcConnectToMmWaveHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::RrcConnectToMmWaveHeader const &', 'arg0')])
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectToMmWaveHeader::RrcConnectToMmWaveHeader() [constructor]
+    cls.add_constructor([])
+    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectToMmWaveHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'bIterator')], 
+                   is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): uint16_t ns3::RrcConnectToMmWaveHeader::GetMessage() const [member function]
+    cls.add_method('GetMessage', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## lte-rrc-header.h (module 'lte'): static ns3::TypeId ns3::RrcConnectToMmWaveHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectToMmWaveHeader::PreSerialize() const [member function]
+    cls.add_method('PreSerialize', 
+                   'void', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectToMmWaveHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectToMmWaveHeader::SetMessage(uint16_t mmWaveId) [member function]
+    cls.add_method('SetMessage', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveId')])
+    return
+
 def register_Ns3RrcConnectionReconfigurationCompleteHeader_methods(root_module, cls):
     ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReconfigurationCompleteHeader::RrcConnectionReconfigurationCompleteHeader(ns3::RrcConnectionReconfigurationCompleteHeader const & arg0) [constructor]
     cls.add_constructor([param('ns3::RrcConnectionReconfigurationCompleteHeader const &', 'arg0')])
@@ -25223,6 +28908,11 @@
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'bIterator')], 
                    is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): std::bitset<1> ns3::RrcConnectionRequestHeader::GetIsMc() const [member function]
+    cls.add_method('GetIsMc', 
+                   'std::bitset< 1 >', 
+                   [], 
+                   is_const=True)
     ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest ns3::RrcConnectionRequestHeader::GetMessage() const [member function]
     cls.add_method('GetMessage', 
                    'ns3::LteRrcSap::RrcConnectionRequest', 
@@ -25361,6 +29051,83 @@
                    [param('ns3::LteRrcSap::RrcConnectionSetup', 'msg')])
     return
 
+def register_Ns3RrcConnectionSwitchHeader_methods(root_module, cls):
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSwitchHeader::RrcConnectionSwitchHeader(ns3::RrcConnectionSwitchHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::RrcConnectionSwitchHeader const &', 'arg0')])
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSwitchHeader::RrcConnectionSwitchHeader() [constructor]
+    cls.add_constructor([])
+    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionSwitchHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'bIterator')], 
+                   is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch ns3::RrcConnectionSwitchHeader::GetMessage() const [member function]
+    cls.add_method('GetMessage', 
+                   'ns3::LteRrcSap::RrcConnectionSwitch', 
+                   [], 
+                   is_const=True)
+    ## lte-rrc-header.h (module 'lte'): uint8_t ns3::RrcConnectionSwitchHeader::GetRrcTransactionIdentifier() const [member function]
+    cls.add_method('GetRrcTransactionIdentifier', 
+                   'uint8_t', 
+                   [], 
+                   is_const=True)
+    ## lte-rrc-header.h (module 'lte'): static ns3::TypeId ns3::RrcConnectionSwitchHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionSwitchHeader::PreSerialize() const [member function]
+    cls.add_method('PreSerialize', 
+                   'void', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionSwitchHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionSwitchHeader::SetMessage(ns3::LteRrcSap::RrcConnectionSwitch msg) [member function]
+    cls.add_method('SetMessage', 
+                   'void', 
+                   [param('ns3::LteRrcSap::RrcConnectionSwitch', 'msg')])
+    return
+
+def register_Ns3RrcNotifySecondaryConnectedHeader_methods(root_module, cls):
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcNotifySecondaryConnectedHeader::RrcNotifySecondaryConnectedHeader(ns3::RrcNotifySecondaryConnectedHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::RrcNotifySecondaryConnectedHeader const &', 'arg0')])
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcNotifySecondaryConnectedHeader::RrcNotifySecondaryConnectedHeader() [constructor]
+    cls.add_constructor([])
+    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcNotifySecondaryConnectedHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'bIterator')], 
+                   is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): std::pair<unsigned short, unsigned short> ns3::RrcNotifySecondaryConnectedHeader::GetMessage() const [member function]
+    cls.add_method('GetMessage', 
+                   'std::pair< unsigned short, unsigned short >', 
+                   [], 
+                   is_const=True)
+    ## lte-rrc-header.h (module 'lte'): static ns3::TypeId ns3::RrcNotifySecondaryConnectedHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcNotifySecondaryConnectedHeader::PreSerialize() const [member function]
+    cls.add_method('PreSerialize', 
+                   'void', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcNotifySecondaryConnectedHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcNotifySecondaryConnectedHeader::SetMessage(uint16_t mmWaveId, uint16_t mmWaveRnti) [member function]
+    cls.add_method('SetMessage', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveId'), param('uint16_t', 'mmWaveRnti')])
+    return
+
 def register_Ns3LteEnbNetDevice_methods(root_module, cls):
     ## lte-enb-net-device.h (module 'lte'): static ns3::TypeId ns3::LteEnbNetDevice::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
@@ -25519,19 +29286,19 @@
                    'ns3::Config::MatchContainer::Iterator', 
                    [], 
                    is_const=True)
-    ## config.h (module 'core'): ns3::Ptr<ns3::Object> ns3::Config::MatchContainer::Get(std::size_t i) const [member function]
+    ## config.h (module 'core'): ns3::Ptr<ns3::Object> ns3::Config::MatchContainer::Get(uint32_t i) const [member function]
     cls.add_method('Get', 
                    'ns3::Ptr< ns3::Object >', 
-                   [param('std::size_t', 'i')], 
+                   [param('uint32_t', 'i')], 
                    is_const=True)
     ## config.h (module 'core'): std::string ns3::Config::MatchContainer::GetMatchedPath(uint32_t i) const [member function]
     cls.add_method('GetMatchedPath', 
                    'std::string', 
                    [param('uint32_t', 'i')], 
                    is_const=True)
-    ## config.h (module 'core'): std::size_t ns3::Config::MatchContainer::GetN() const [member function]
+    ## config.h (module 'core'): uint32_t ns3::Config::MatchContainer::GetN() const [member function]
     cls.add_method('GetN', 
-                   'std::size_t', 
+                   'uint32_t', 
                    [], 
                    is_const=True)
     ## config.h (module 'core'): std::string ns3::Config::MatchContainer::GetPath() const [member function]
@@ -25550,15 +29317,15 @@
     cls.add_constructor([param('ns3::Hash::Implementation const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Implementation::Implementation() [constructor]
     cls.add_constructor([])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Implementation::GetHash32(char const * buffer, std::size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Implementation::GetHash32(char const * buffer, size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Implementation::GetHash64(char const * buffer, std::size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Implementation::GetHash64(char const * buffer, size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Implementation::clear() [member function]
     cls.add_method('clear', 
@@ -25594,10 +29361,10 @@
     cls.add_constructor([param('ns3::Hash::Function::Hash32 const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Function::Hash32::Hash32(ns3::Hash::Hash32Function_ptr hp) [constructor]
     cls.add_constructor([param('ns3::Hash::Hash32Function_ptr', 'hp')])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash32::GetHash32(char const * buffer, std::size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash32::GetHash32(char const * buffer, size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Function::Hash32::clear() [member function]
     cls.add_method('clear', 
@@ -25611,15 +29378,15 @@
     cls.add_constructor([param('ns3::Hash::Function::Hash64 const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Function::Hash64::Hash64(ns3::Hash::Hash64Function_ptr hp) [constructor]
     cls.add_constructor([param('ns3::Hash::Hash64Function_ptr', 'hp')])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash64::GetHash32(char const * buffer, std::size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash64::GetHash32(char const * buffer, size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
                    is_virtual=True)
-    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Function::Hash64::GetHash64(char const * buffer, std::size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Function::Hash64::GetHash64(char const * buffer, size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Function::Hash64::clear() [member function]
     cls.add_method('clear', 
@@ -25633,15 +29400,15 @@
     cls.add_constructor([param('ns3::Hash::Function::Murmur3 const &', 'arg0')])
     ## hash-murmur3.h (module 'core'): ns3::Hash::Function::Murmur3::Murmur3() [constructor]
     cls.add_constructor([])
-    ## hash-murmur3.h (module 'core'): uint32_t ns3::Hash::Function::Murmur3::GetHash32(char const * buffer, std::size_t const size) [member function]
+    ## hash-murmur3.h (module 'core'): uint32_t ns3::Hash::Function::Murmur3::GetHash32(char const * buffer, size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
                    is_virtual=True)
-    ## hash-murmur3.h (module 'core'): uint64_t ns3::Hash::Function::Murmur3::GetHash64(char const * buffer, std::size_t const size) [member function]
+    ## hash-murmur3.h (module 'core'): uint64_t ns3::Hash::Function::Murmur3::GetHash64(char const * buffer, size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
                    is_virtual=True)
     ## hash-murmur3.h (module 'core'): void ns3::Hash::Function::Murmur3::clear() [member function]
     cls.add_method('clear', 
diff -Naru a/examples/lena-fading.cc b/examples/lena-fading.cc
--- a/examples/lena-fading.cc	2018-08-03 16:38:46.531805672 +0200
+++ b/examples/lena-fading.cc	2018-08-03 16:39:02.875957522 +0200
@@ -68,7 +68,7 @@
       lteHelper->SetFadingModelAttribute ("TraceFilename", StringValue ("src/lte/model/fading-traces/fading_trace_EPA_3kmph.fad"));
     }
     
-  // these parameters have to set only in case of the trace format 
+  // these parameters have to be set only in case of the trace format 
   // differs from the standard one, that is
   // - 10 seconds length trace
   // - 10,000 samples
diff -Naru a/helper/emu-epc-helper.cc b/helper/emu-epc-helper.cc
--- a/helper/emu-epc-helper.cc	2018-08-03 16:38:46.531805672 +0200
+++ b/helper/emu-epc-helper.cc	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011-2013 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,8 +19,11 @@
  * Author: Jaume Nin <jnin@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Support for real S1AP link
  */
-
+#include <ns3/point-to-point-helper.h>
 #include <ns3/emu-epc-helper.h>
 #include <ns3/log.h>
 #include <ns3/inet-socket-address.h>
@@ -37,9 +41,10 @@
 #include "ns3/ipv6-static-routing-helper.h"
 #include <ns3/lte-enb-rrc.h>
 #include <ns3/epc-x2.h>
+#include <ns3/epc-s1ap.h>
 #include <ns3/lte-enb-net-device.h>
 #include <ns3/lte-ue-net-device.h>
-#include <ns3/epc-mme.h>
+#include <ns3/epc-mme-application.h>
 #include <ns3/epc-ue-nas.h>
 #include <ns3/string.h>
 #include <ns3/abort.h>
@@ -50,6 +55,8 @@
 #include <iomanip>
 #include <iostream>
 
+// TODO S1AP is a P2P link, extend to support emulation on this link
+
 namespace ns3 {
 
 NS_LOG_COMPONENT_DEFINE ("EmuEpcHelper");
@@ -57,8 +64,9 @@
 NS_OBJECT_ENSURE_REGISTERED (EmuEpcHelper);
 
 
-EmuEpcHelper::EmuEpcHelper () 
-  : m_gtpuUdpPort (2152)  // fixed by the standard
+EmuEpcHelper::EmuEpcHelper ()
+  : m_gtpuUdpPort (2152),  // fixed by the standard
+    m_s1apUdpPort (36412)
 {
   NS_LOG_FUNCTION (this);
   // To access the attribute value within the constructor
@@ -77,26 +85,41 @@
     .SetParent<EpcHelper> ()
     .SetGroupName("Lte")
     .AddConstructor<EmuEpcHelper> ()
-    .AddAttribute ("sgwDeviceName", 
+    .AddAttribute ("sgwDeviceName",
                    "The name of the device used for the S1-U interface of the SGW",
                    StringValue ("veth0"),
                    MakeStringAccessor (&EmuEpcHelper::m_sgwDeviceName),
                    MakeStringChecker ())
-    .AddAttribute ("enbDeviceName", 
+    .AddAttribute ("enbDeviceName",
                    "The name of the device used for the S1-U interface of the eNB",
                    StringValue ("veth1"),
                    MakeStringAccessor (&EmuEpcHelper::m_enbDeviceName),
                    MakeStringChecker ())
-    .AddAttribute ("SgwMacAddress", 
+    .AddAttribute ("SgwMacAddress",
                    "MAC address used for the SGW ",
                    StringValue ("00:00:00:59:00:aa"),
                    MakeStringAccessor (&EmuEpcHelper::m_sgwMacAddress),
                    MakeStringChecker ())
-    .AddAttribute ("EnbMacAddressBase", 
+    .AddAttribute ("EnbMacAddressBase",
                    "First 5 bytes of the Enb MAC address base",
                    StringValue ("00:00:00:eb:00"),
                    MakeStringAccessor (&EmuEpcHelper::m_enbMacAddressBase),
                    MakeStringChecker ())
+    .AddAttribute ("S1apLinkDataRate",
+                   "The data rate to be used for the S1-AP link to be created",
+                   DataRateValue (DataRate ("10Mb/s")),
+                   MakeDataRateAccessor (&EmuEpcHelper::m_s1apLinkDataRate),
+                   MakeDataRateChecker ())
+    .AddAttribute ("S1apLinkDelay",
+                   "The delay to be used for the S1-AP link to be created",
+                   TimeValue (Seconds (0.1)),
+                   MakeTimeAccessor (&EmuEpcHelper::m_s1apLinkDelay),
+                   MakeTimeChecker ())
+    .AddAttribute ("S1apLinkMtu",
+                   "The MTU of the next S1-AP link to be created",
+                   UintegerValue (2000),
+                   MakeUintegerAccessor (&EmuEpcHelper::m_s1apLinkMtu),
+                   MakeUintegerChecker<uint16_t> ())
     ;
   return tid;
 }
@@ -110,10 +133,11 @@
 void
 EmuEpcHelper::DoInitialize ()
 {
-  NS_LOG_LOGIC (this);   
+  NS_LOG_LOGIC (this);
 
   // we use a /8 net for all UEs
   m_uePgwAddressHelper.SetBase ("7.0.0.0", "255.0.0.0");
+  m_s1apIpv4AddressHelper.SetBase ("11.0.0.0", "255.255.255.252");
 
   // we use a /64 IPv6 net all UEs
   m_uePgwAddressHelper6.SetBase ("7777:f00d::", Ipv6Prefix (64));
@@ -122,6 +146,7 @@
   // create SgwPgwNode
   m_sgwPgw = CreateObject<Node> ();
   InternetStackHelper internet;
+  internet.SetIpv4StackInstall (true);
   internet.Install (m_sgwPgw);
 
   // The Tun device resides in different 64 bit subnet.
@@ -130,29 +155,38 @@
   Ipv6StaticRoutingHelper ipv6RoutingHelper;
   Ptr<Ipv6StaticRouting> pgwStaticRouting = ipv6RoutingHelper.GetStaticRouting (m_sgwPgw->GetObject<Ipv6> ());
   pgwStaticRouting->AddNetworkRouteTo ("7777:f00d::", Ipv6Prefix (64), Ipv6Address ("::"), 1, 0);
-  
-  // create S1-U socket
+
+  // create MmeNode
+  m_mmeNode = CreateObject<Node> ();
+  internet.Install (m_mmeNode);
+
+  // create S1-U socket for SgwPgwNode
   Ptr<Socket> sgwPgwS1uSocket = Socket::CreateSocket (m_sgwPgw, TypeId::LookupByName ("ns3::UdpSocketFactory"));
   int retval = sgwPgwS1uSocket->Bind (InetSocketAddress (Ipv4Address::GetAny (), m_gtpuUdpPort));
   NS_ASSERT (retval == 0);
 
-  // create TUN device containing IPv4 address and implementing tunneling of user data over GTP-U/UDP/IP 
+  // create S1-AP socket for MmeNode
+  Ptr<Socket> mmeS1apSocket = Socket::CreateSocket (m_mmeNode, TypeId::LookupByName ("ns3::UdpSocketFactory"));
+  retval = mmeS1apSocket->Bind (InetSocketAddress (Ipv4Address::GetAny (), m_s1apUdpPort)); // it listens on any IP, port m_s1apUdpPort
+  NS_ASSERT (retval == 0);
+
+  // create TUN device containing IPv4 address and implementing tunneling of user data over GTP-U/UDP/IP
   m_tunDevice = CreateObject<VirtualNetDevice> ();
 
   // allow jumbo packets
   m_tunDevice->SetAttribute ("Mtu", UintegerValue (30000));
 
   // yes we need this
-  m_tunDevice->SetAddress (Mac48Address::Allocate ()); 
+  m_tunDevice->SetAddress (Mac48Address::Allocate ());
 
   m_sgwPgw->AddDevice (m_tunDevice);
   NetDeviceContainer tunDeviceContainer;
   tunDeviceContainer.Add (m_tunDevice);
-  
+
   // the TUN device is on the same subnet as the UEs, so when a packet
   // addressed to an UE IPv4 address arrives at the intenet to the WAN interface of
-  // the PGW it will be forwarded to the TUN device. 
-  Ipv4InterfaceContainer tunDeviceIpv4IfContainer = AssignUeIpv4Address (tunDeviceContainer); 
+  // the PGW it will be forwarded to the TUN device.
+  Ipv4InterfaceContainer tunDeviceIpv4IfContainer = AssignUeIpv4Address (tunDeviceContainer);
 
   // the TUN device for IPv6 address is on the different subnet as the
   // UEs, it will forward the UE packets as we have inserted the route
@@ -163,19 +197,25 @@
   tunDeviceIpv6IfContainer.SetForwarding (0,true);
   tunDeviceIpv6IfContainer.SetDefaultRouteInAllNodes (0);
 
-
   // create EpcSgwPgwApplication
   m_sgwPgwApp = CreateObject<EpcSgwPgwApplication> (m_tunDevice, sgwPgwS1uSocket);
   m_sgwPgw->AddApplication (m_sgwPgwApp);
-  
+
   // connect SgwPgwApplication and virtual net device for tunneling
   m_tunDevice->SetSendCallback (MakeCallback (&EpcSgwPgwApplication::RecvFromTunDevice, m_sgwPgwApp));
 
-
-  // Create MME and connect with SGW via S11 interface
-  m_mme = CreateObject<EpcMme> ();
-  m_mme->SetS11SapSgw (m_sgwPgwApp->GetS11SapSgw ());
-  m_sgwPgwApp->SetS11SapMme (m_mme->GetS11SapMme ());
+  // create S1apMme object and aggregate it with the m_mmeNode
+  Ptr<EpcS1apMme> s1apMme = CreateObject<EpcS1apMme> (mmeS1apSocket, 1); // for now, only one mme!
+  m_mmeNode->AggregateObject(s1apMme);
+
+  // create EpcMmeApplication and connect with SGW via S11 interface
+  m_mmeApp = CreateObject<EpcMmeApplication> ();
+  m_mmeNode->AddApplication (m_mmeApp);
+  m_mmeApp->SetS11SapSgw (m_sgwPgwApp->GetS11SapSgw ());
+  m_sgwPgwApp->SetS11SapMme (m_mmeApp->GetS11SapMme ());
+  // connect m_mmeApp to the s1apMme
+  m_mmeApp->SetS1apSapMmeProvider(s1apMme->GetEpcS1apSapMmeProvider());
+  s1apMme->SetEpcS1apSapMmeUser(m_mmeApp->GetS1apSapMme());
 
   // Create EmuFdNetDevice for SGW
   EmuFdNetDeviceHelper emu;
@@ -187,11 +227,11 @@
   sgwDevice->SetAttribute ("Address", Mac48AddressValue (m_sgwMacAddress.c_str ()));
 
   // we use a /8 subnet so the SGW and the eNBs can talk directly to each other
-  m_epcIpv4AddressHelper.SetBase ("10.0.0.0", "255.255.255.0", "0.0.0.1");  
+  m_epcIpv4AddressHelper.SetBase ("10.0.0.0", "255.255.255.0", "0.0.0.1");
   m_sgwIpIfaces = m_epcIpv4AddressHelper.Assign (sgwDevices);
-  m_epcIpv4AddressHelper.SetBase ("10.0.0.0", "255.0.0.0", "0.0.0.101");  
-  
-  
+  m_epcIpv4AddressHelper.SetBase ("10.0.0.0", "255.0.0.0", "0.0.0.101");
+
+
   EpcHelper::DoInitialize ();
 }
 
@@ -201,7 +241,7 @@
   NS_LOG_FUNCTION (this);
   m_tunDevice->SetSendCallback (MakeNullCallback<bool, Ptr<Packet>, const Address&, const Address&, uint16_t> ());
   m_tunDevice = 0;
-  m_sgwPgwApp = 0;  
+  m_sgwPgwApp = 0;
   m_sgwPgw->Dispose ();
 }
 
@@ -213,7 +253,7 @@
 
   Initialize ();
 
-  NS_ASSERT (enb == lteEnbNetDevice->GetNode ());  
+  NS_ASSERT (enb == lteEnbNetDevice->GetNode ());
 
   // add an Internet stack to the previously created eNB
   InternetStackHelper internet;
@@ -225,7 +265,7 @@
   // Create an EmuFdNetDevice for the eNB to connect with the SGW and other eNBs
   EmuFdNetDeviceHelper emu;
   NS_LOG_LOGIC ("eNB device: " << m_enbDeviceName);
-  emu.SetDeviceName (m_enbDeviceName);  
+  emu.SetDeviceName (m_enbDeviceName);
   NetDeviceContainer enbDevices = emu.Install (enb);
 
   NS_ABORT_IF ((cellId == 0) || (cellId > 255));
@@ -237,10 +277,10 @@
 
   //emu.EnablePcap ("enbDevice", enbDev);
 
-  NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after installing emu dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());  
+  NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after installing emu dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());
   Ipv4InterfaceContainer enbIpIfaces = m_epcIpv4AddressHelper.Assign (enbDevices);
   NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after assigning Ipv4 addr to S1 dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());
-  
+
   Ipv4Address enbAddress = enbIpIfaces.GetAddress (0);
   Ipv4Address sgwAddress = m_sgwIpIfaces.GetAddress (0);
 
@@ -248,35 +288,59 @@
   Ptr<Socket> enbS1uSocket = Socket::CreateSocket (enb, TypeId::LookupByName ("ns3::UdpSocketFactory"));
   int retval = enbS1uSocket->Bind (InetSocketAddress (enbAddress, m_gtpuUdpPort));
   NS_ASSERT (retval == 0);
-    
-  // create LTE socket for the ENB 
+
+  // create LTE socket for the ENB
   Ptr<Socket> enbLteSocket = Socket::CreateSocket (enb, TypeId::LookupByName ("ns3::PacketSocketFactory"));
   PacketSocketAddress enbLteSocketBindAddress;
   enbLteSocketBindAddress.SetSingleDevice (lteEnbNetDevice->GetIfIndex ());
   enbLteSocketBindAddress.SetProtocol (Ipv4L3Protocol::PROT_NUMBER);
   retval = enbLteSocket->Bind (enbLteSocketBindAddress);
-  NS_ASSERT (retval == 0);  
+  NS_ASSERT (retval == 0);
   PacketSocketAddress enbLteSocketConnectAddress;
   enbLteSocketConnectAddress.SetPhysicalAddress (Mac48Address::GetBroadcast ());
   enbLteSocketConnectAddress.SetSingleDevice (lteEnbNetDevice->GetIfIndex ());
   enbLteSocketConnectAddress.SetProtocol (Ipv4L3Protocol::PROT_NUMBER);
   retval = enbLteSocket->Connect (enbLteSocketConnectAddress);
-  NS_ASSERT (retval == 0);  
+  NS_ASSERT (retval == 0);
 
-  // create LTE socket for the ENB 
+  // create LTE socket for the ENB
   Ptr<Socket> enbLteSocket6 = Socket::CreateSocket (enb, TypeId::LookupByName ("ns3::PacketSocketFactory"));
   PacketSocketAddress enbLteSocketBindAddress6;
   enbLteSocketBindAddress6.SetSingleDevice (lteEnbNetDevice->GetIfIndex ());
   enbLteSocketBindAddress6.SetProtocol (Ipv6L3Protocol::PROT_NUMBER);
   retval = enbLteSocket6->Bind (enbLteSocketBindAddress6);
-  NS_ASSERT (retval == 0);  
+  NS_ASSERT (retval == 0);
   PacketSocketAddress enbLteSocketConnectAddress6;
   enbLteSocketConnectAddress6.SetPhysicalAddress (Mac48Address::GetBroadcast ());
   enbLteSocketConnectAddress6.SetSingleDevice (lteEnbNetDevice->GetIfIndex ());
   enbLteSocketConnectAddress6.SetProtocol (Ipv6L3Protocol::PROT_NUMBER);
   retval = enbLteSocket6->Connect (enbLteSocketConnectAddress6);
   NS_ASSERT (retval == 0);
-  
+
+  // create a point to point link between the new eNB and the MME with
+  // the corresponding new NetDevices on each side
+  NodeContainer enbMmeNodes;
+  enbMmeNodes.Add (m_mmeNode);
+  enbMmeNodes.Add (enb);
+  PointToPointHelper p2ph_mme;
+  p2ph_mme.SetDeviceAttribute ("DataRate", DataRateValue (m_s1apLinkDataRate));
+  p2ph_mme.SetDeviceAttribute ("Mtu", UintegerValue (m_s1apLinkMtu));
+  p2ph_mme.SetChannelAttribute ("Delay", TimeValue (m_s1apLinkDelay));
+  NetDeviceContainer enbMmeDevices = p2ph_mme.Install (enb, m_mmeNode);
+  NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after installing p2p dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());
+
+  m_s1apIpv4AddressHelper.NewNetwork ();
+  Ipv4InterfaceContainer enbMmeIpIfaces = m_s1apIpv4AddressHelper.Assign (enbMmeDevices);
+  NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after assigning Ipv4 addr to S1 dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());
+
+  Ipv4Address mme_enbAddress = enbMmeIpIfaces.GetAddress (0);
+  Ipv4Address mmeAddress = enbMmeIpIfaces.GetAddress (1);
+
+  // create S1-AP socket for the ENB
+  Ptr<Socket> enbS1apSocket = Socket::CreateSocket (enb, TypeId::LookupByName ("ns3::UdpSocketFactory"));
+  retval = enbS1apSocket->Bind (InetSocketAddress (mme_enbAddress, m_s1apUdpPort));
+  NS_ASSERT (retval == 0);
+
   NS_LOG_INFO ("create EpcEnbApplication");
   Ptr<EpcEnbApplication> enbApp = CreateObject<EpcEnbApplication> (enbLteSocket, enbLteSocket6, enbS1uSocket, enbAddress, sgwAddress, cellId);
   enb->AddApplication (enbApp);
@@ -284,15 +348,24 @@
   NS_ASSERT_MSG (enb->GetApplication (0)->GetObject<EpcEnbApplication> () != 0, "cannot retrieve EpcEnbApplication");
   NS_LOG_LOGIC ("enb: " << enb << ", enb->GetApplication (0): " << enb->GetApplication (0));
 
-  
+
   NS_LOG_INFO ("Create EpcX2 entity");
   Ptr<EpcX2> x2 = CreateObject<EpcX2> ();
   enb->AggregateObject (x2);
 
   NS_LOG_INFO ("connect S1-AP interface");
-  m_mme->AddEnb (cellId, enbAddress, enbApp->GetS1apSapEnb ());
+
+  uint16_t mmeId = 1;
+  Ptr<EpcS1apEnb> s1apEnb = CreateObject<EpcS1apEnb> (enbS1apSocket, mme_enbAddress, mmeAddress, cellId, mmeId); // only one mme!
+  enb->AggregateObject(s1apEnb);
+  enbApp->SetS1apSapMme (s1apEnb->GetEpcS1apSapEnbProvider ());
+  s1apEnb->SetEpcS1apSapEnbUser (enbApp->GetS1apSapEnb());
+  m_mmeApp->AddEnb (cellId, mme_enbAddress); // TODO consider if this can be removed
+  // add the interface to the S1AP endpoint on the MME
+  Ptr<EpcS1apMme> s1apMme = m_mmeNode->GetObject<EpcS1apMme> ();
+  s1apMme->AddS1apInterface (cellId, mme_enbAddress);
+
   m_sgwPgwApp->AddEnb (cellId, enbAddress, sgwAddress);
-  enbApp->SetS1apSapMme (m_mme->GetS1apSapMme ());
 }
 
 
@@ -322,11 +395,11 @@
   NS_ASSERT (enb2Interface >= 0);
   NS_ASSERT (enb1Ipv4->GetNAddresses (enb1Interface) == 1);
   NS_ASSERT (enb2Ipv4->GetNAddresses (enb2Interface) == 1);
-  Ipv4Address enb1Addr = enb1Ipv4->GetAddress (enb1Interface, 0).GetLocal (); 
-  Ipv4Address enb2Addr = enb2Ipv4->GetAddress (enb2Interface, 0).GetLocal (); 
-  NS_LOG_LOGIC (" eNB 1 IP address: " << enb1Addr); 
+  Ipv4Address enb1Addr = enb1Ipv4->GetAddress (enb1Interface, 0).GetLocal ();
+  Ipv4Address enb2Addr = enb2Ipv4->GetAddress (enb2Interface, 0).GetLocal ();
+  NS_LOG_LOGIC (" eNB 1 IP address: " << enb1Addr);
   NS_LOG_LOGIC (" eNB 2 IP address: " << enb2Addr);
-  
+
   // Add X2 interface to both eNBs' X2 entities
   Ptr<EpcX2> enb1X2 = enb1->GetObject<EpcX2> ();
   Ptr<LteEnbNetDevice> enb1LteDev = enb1->GetDevice (0)->GetObject<LteEnbNetDevice> ();
@@ -346,14 +419,14 @@
 }
 
 
-void 
+void
 EmuEpcHelper::AddUe (Ptr<NetDevice> ueDevice, uint64_t imsi)
 {
   NS_LOG_FUNCTION (this << imsi << ueDevice );
-  
-  m_mme->AddUe (imsi);
+
+  m_mmeApp->AddUe (imsi);
   m_sgwPgwApp->AddUe (imsi);
-  
+
 }
 
 
@@ -364,8 +437,8 @@
 
   // we now retrieve the IPv4/IPv6 address of the UE and notify it to the SGW;
   // we couldn't do it before since address assignment is triggered by
-  // the user simulation program, rather than done by the EPC   
-  Ptr<Node> ueNode = ueDevice->GetNode (); 
+  // the user simulation program, rather than done by the EPC
+  Ptr<Node> ueNode = ueDevice->GetNode ();
   Ptr<Ipv4> ueIpv4 = ueNode->GetObject<Ipv4> ();
   Ptr<Ipv6> ueIpv6 = ueNode->GetObject<Ipv6> ();
   NS_ASSERT_MSG (ueIpv4 != 0 || ueIpv6 != 0, "UEs need to have IPv4/IPv6 installed before EPS bearers can be activated");
@@ -391,7 +464,7 @@
         }
     }
 
-  uint8_t bearerId = m_mme->AddBearer (imsi, tft, bearer);
+  uint8_t bearerId = m_mmeApp->AddBearer (imsi, tft, bearer);
   Ptr<LteUeNetDevice> ueLteDevice = ueDevice->GetObject<LteUeNetDevice> ();
   if (ueLteDevice)
     {
@@ -400,6 +473,45 @@
   return bearerId;
 }
 
+uint8_t
+EmuEpcHelper::ActivateEpsBearer (Ptr<NetDevice> ueDevice, Ptr<EpcUeNas> ueNas, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer)
+{
+  NS_LOG_FUNCTION (this << ueDevice << imsi);
+
+  // we now retrieve the IPv4 address of the UE and notify it to the SGW;
+  // we couldn't do it before since address assignment is triggered by
+  // the user simulation program, rather than done by the EPC
+  Ptr<Node> ueNode = ueDevice->GetNode ();
+  Ptr<Ipv4> ueIpv4 = ueNode->GetObject<Ipv4> ();
+  Ptr<Ipv6> ueIpv6 = ueNode->GetObject<Ipv6> ();
+  NS_ASSERT_MSG (ueIpv4 != 0 || ueIpv6 != 0, "UEs need to have IPv4/IPv6 installed before EPS bearers can be activated");
+
+  if (ueIpv4)
+    {
+      int32_t interface =  ueIpv4->GetInterfaceForDevice (ueDevice);
+      if (interface >= 0 && ueIpv4->GetNAddresses (interface) == 1)
+        {
+          Ipv4Address ueAddr = ueIpv4->GetAddress (interface, 0).GetLocal ();
+          NS_LOG_LOGIC (" UE IPv4 address: " << ueAddr);
+          m_sgwPgwApp->SetUeAddress (imsi, ueAddr);
+        }
+    }
+  if (ueIpv6)
+    {
+      int32_t interface6 =  ueIpv6->GetInterfaceForDevice (ueDevice);
+      if (interface6 >= 0 && ueIpv6->GetNAddresses (interface6) == 2)
+        {
+          Ipv6Address ueAddr6 = ueIpv6->GetAddress (interface6, 1).GetAddress ();
+          NS_LOG_LOGIC (" UE IPv6 address: " << ueAddr6);
+          m_sgwPgwApp->SetUeAddress6 (imsi, ueAddr6);
+        }
+    }
+
+  uint8_t bearerId = m_mmeApp->AddBearer (imsi, tft, bearer);
+  Simulator::ScheduleNow (&EpcUeNas::ActivateEpsBearer, ueNas, bearer, tft);
+  return bearerId;
+}
+
 
 Ptr<Node>
 EmuEpcHelper::GetPgwNode ()
@@ -408,13 +520,13 @@
 }
 
 
-Ipv4InterfaceContainer 
+Ipv4InterfaceContainer
 EmuEpcHelper::AssignUeIpv4Address (NetDeviceContainer ueDevices)
 {
   return m_uePgwAddressHelper.Assign (ueDevices);
 }
 
-Ipv6InterfaceContainer 
+Ipv6InterfaceContainer
 EmuEpcHelper::AssignUeIpv6Address (NetDeviceContainer ueDevices)
 {
   for (NetDeviceContainer::Iterator iter = ueDevices.Begin ();
diff -Naru a/helper/emu-epc-helper.h b/helper/emu-epc-helper.h
--- a/helper/emu-epc-helper.h	2018-08-03 16:38:46.531805672 +0200
+++ b/helper/emu-epc-helper.h	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011-2013 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Jaume Nin <jnin@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Support for real S1AP link
  */
 
 #ifndef EMU_EPC_HELPER_H
@@ -38,33 +42,36 @@
 class VirtualNetDevice;
 class EpcSgwPgwApplication;
 class EpcX2;
-class EpcMme;
+class EpcUeNas;
+class EpcMmeApplication;
+class EpcS1apEnb;
+class EpcS1apMme;
 
 /**
  * \ingroup lte
  *
- * \brief Create an EPC network using EmuFdNetDevice 
+ * \brief Create an EPC network using EmuFdNetDevice
  *
  * This Helper will create an EPC network topology comprising of a
  * single node that implements both the SGW and PGW functionality, and
  * an MME node. The S1-U, X2-U and X2-C interfaces are realized using
  * EmuFdNetDevice; in particular, one device is used to send all the
- * traffic related to these interfaces. 
+ * traffic related to these interfaces.
  */
 class EmuEpcHelper : public EpcHelper
 {
 public:
-  
-  /** 
+
+  /**
    * Constructor
    */
   EmuEpcHelper ();
 
-  /** 
+  /**
    * Destructor
-   */  
+   */
   virtual ~EmuEpcHelper ();
-  
+
   // inherited from Object
   /**
    *  Register this type.
@@ -80,6 +87,7 @@
   virtual void AddUe (Ptr<NetDevice> ueLteDevice, uint64_t imsi);
   virtual void AddX2Interface (Ptr<Node> enbNode1, Ptr<Node> enbNode2);
   virtual uint8_t ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer);
+  virtual uint8_t ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, Ptr<EpcUeNas> ueNas, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer);
   virtual Ptr<Node> GetPgwNode ();
   virtual Ipv4InterfaceContainer AssignUeIpv4Address (NetDeviceContainer ueDevices);
   Ipv6InterfaceContainer AssignUeIpv6Address (NetDeviceContainer ueDevices);
@@ -89,20 +97,26 @@
 
 private:
 
-  /** 
+  /**
    * helper to assign IPv4 addresses to UE devices as well as to the TUN device of the SGW/PGW
    */
-  Ipv4AddressHelper m_uePgwAddressHelper; 
+  Ipv4AddressHelper m_uePgwAddressHelper;
 
-  /** 
+  /**
    * helper to assign IPv6 addresses to UE devices as well as to the TUN device of the SGW/PGW
    */
-  Ipv6AddressHelper m_uePgwAddressHelper6; 
+  Ipv6AddressHelper m_uePgwAddressHelper6;
+
+  /**
+   * helper to assign addresses to S1-AP NetDevices
+   */
+  Ipv4AddressHelper m_s1apIpv4AddressHelper;
+
 
   /**
    * SGW-PGW network element
-   */  
-  Ptr<Node> m_sgwPgw; 
+   */
+  Ptr<Node> m_sgwPgw;
 
   /**
    * SGW-PGW application
@@ -110,19 +124,24 @@
   Ptr<EpcSgwPgwApplication> m_sgwPgwApp;
 
   /**
-   * TUN device containing IPv4 address and implementing tunneling of user data over GTP-U/UDP/IP
+   * TUN device containing IPv4 address and  implementing tunneling of user data over GTP-U/UDP/IP
    */
   Ptr<VirtualNetDevice> m_tunDevice;
 
   /**
    * MME network element
    */
-  Ptr<EpcMme> m_mme;
+  Ptr<Node> m_mmeNode;
+
+  /**
+   * MME application
+   */
+  Ptr<EpcMmeApplication> m_mmeApp;
 
-  /** 
-   * helper to assign addresses to S1-U NetDevices 
+  /**
+   * helper to assign addresses to S1-U NetDevices
    */
-  Ipv4AddressHelper m_epcIpv4AddressHelper; 
+  Ipv4AddressHelper m_epcIpv4AddressHelper;
 
   /**
    * UDP port where the GTP-U Socket is bound, fixed by the standard as 2152
@@ -130,15 +149,36 @@
   uint16_t m_gtpuUdpPort;
 
   /**
+   * The data rate to be used for the next S1-AP link to be created
+   */
+  DataRate m_s1apLinkDataRate;
+
+  /**
+   * The delay to be used for the next S1-AP link to be created
+   */
+  Time     m_s1apLinkDelay;
+
+  /**
+   * The MTU of the next S1-AP link to be created.
+   */
+  uint16_t m_s1apLinkMtu;
+
+  /**
+   * UDP port where the UDP Socket is bound, fixed by the standard as
+   * 36412 (it should be sctp, but it is not supported in ns-3)
+   */
+  uint16_t m_s1apUdpPort;
+
+  /**
    * Map storing for each IMSI the corresponding eNB NetDevice
-   * 
+   *
    */
   std::map<uint64_t, Ptr<NetDevice> > m_imsiEnbDeviceMap;
 
   /**
    * Container for Ipv4Interfaces of the SGW/PGW
    */
-  Ipv4InterfaceContainer m_sgwIpIfaces; 
+  Ipv4InterfaceContainer m_sgwIpIfaces;
 
   /**
    * The name of the device used for the S1-U interface of the SGW
@@ -159,7 +199,7 @@
    * First 5 bytes of the Enb MAC address base
    */
   std::string m_enbMacAddressBase;
-  
+
 };
 
 
diff -Naru a/helper/epc-helper.cc b/helper/epc-helper.cc
--- a/helper/epc-helper.cc	2018-08-03 16:38:46.531805672 +0200
+++ b/helper/epc-helper.cc	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011-2013 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Jaume Nin <jnin@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Support for real S1AP link
  */
 
 #include <ns3/epc-helper.h>
@@ -33,7 +37,7 @@
 NS_OBJECT_ENSURE_REGISTERED (EpcHelper);
 
 
-EpcHelper::EpcHelper () 
+EpcHelper::EpcHelper ()
 {
   NS_LOG_FUNCTION (this);
 }
diff -Naru a/helper/epc-helper.h b/helper/epc-helper.h
--- a/helper/epc-helper.h	2018-08-03 16:38:46.531805672 +0200
+++ b/helper/epc-helper.h	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011-2013 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Jaume Nin <jnin@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Support for real S1AP link
  */
 
 #ifndef EPC_HELPER_H
@@ -38,6 +42,7 @@
 class EpcSgwPgwApplication;
 class EpcX2;
 class EpcMme;
+class EpcUeNas;
 
 /**
  * \ingroup lte
@@ -46,22 +51,22 @@
  *
  * This class provides the API for the implementation of helpers that
  * allow to create EPC entities and the nodes and interfaces that host
- * and connect them. 
+ * and connect them.
  */
 class EpcHelper : public Object
 {
 public:
-  
-  /** 
+
+  /**
    * Constructor
    */
   EpcHelper ();
 
-  /** 
+  /**
    * Destructor
-   */  
+   */
   virtual ~EpcHelper ();
-  
+
   // inherited from Object
   /**
    *  Register this type.
@@ -70,10 +75,10 @@
   static TypeId GetTypeId (void);
   virtual void DoDispose ();
 
-  
-  /** 
+
+  /**
    * Add an eNB to the EPC
-   * 
+   *
    * \param enbNode the previously created eNB node which is to be
    * added to the EPC
    * \param lteEnbNetDevice the LteEnbNetDevice of the eNB node
@@ -81,27 +86,27 @@
    */
   virtual void AddEnb (Ptr<Node> enbNode, Ptr<NetDevice> lteEnbNetDevice, uint16_t cellId) = 0;
 
-  /** 
+  /**
    * Notify the EPC of the existence of a new UE which might attach at a later time
-   * 
+   *
    * \param ueLteDevice the UE device to be attached
    * \param imsi the unique identifier of the UE
    */
   virtual void AddUe (Ptr<NetDevice> ueLteDevice, uint64_t imsi) = 0;
 
-  /** 
+  /**
    * Add an X2 interface between two eNB
-   * 
+   *
    * \param enbNode1 one eNB peer of the X2 interface
    * \param enbNode2 the other eNB peer of the X2 interface
    */
   virtual void AddX2Interface (Ptr<Node> enbNode1, Ptr<Node> enbNode2) = 0;
 
-  /** 
+  /**
    * Activate an EPS bearer, setting up the corresponding S1-U tunnel.
-   * 
-   * 
-   * 
+   *
+   *
+   *
    * \param ueLteDevice the Ipv4-enabled device of the UE, normally
    * connected via the LTE radio interface
    * \param imsi the unique identifier of the UE
@@ -111,9 +116,22 @@
    */
   virtual uint8_t ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer) = 0;
 
+  /**
+   * Activate an EPS bearer, setting up the corresponding S1-U tunnel.
+   *
+   *
+   *
+   * \param ueLteDevice the Ipv4-enabled device of the UE, normally
+   * connected via the LTE radio interface
+   * \param the NAS of that device
+   * \param imsi the unique identifier of the UE
+   * \param tft the Traffic Flow Template of the new bearer
+   * \param bearer struct describing the characteristics of the EPS bearer to be activated
+   */
+  virtual uint8_t ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, Ptr<EpcUeNas> ueNas, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer) = 0;
 
-  /** 
-   * 
+  /**
+   *
    * \return a pointer to the node implementing PGW
    * functionality. Note that in this particular implementation this
    * node will also hold the SGW functionality. The primary use
@@ -122,18 +140,18 @@
    */
   virtual Ptr<Node> GetPgwNode () = 0;
 
-  /** 
+  /**
    * Assign IPv4 addresses to UE devices
-   * 
+   *
    * \param ueDevices the set of UE devices
-   * 
+   *
    * \return the interface container, \see Ipv4AddressHelper::Assign() which has similar semantics
    */
   virtual Ipv4InterfaceContainer AssignUeIpv4Address (NetDeviceContainer ueDevices) = 0;
 
 
-  /** 
-   * 
+  /**
+   *
    * \return the IPv4 address of the Default Gateway to be used by UEs to reach the internet
    */
   virtual Ipv4Address GetUeDefaultGatewayAddress () = 0;
diff -Naru a/helper/lte-global-pathloss-database.h b/helper/lte-global-pathloss-database.h
--- a/helper/lte-global-pathloss-database.h	2018-08-03 16:38:46.531805672 +0200
+++ b/helper/lte-global-pathloss-database.h	2018-08-03 16:39:02.875957522 +0200
@@ -36,8 +36,8 @@
  *
  * Store the last pathloss value for each TX-RX pair. This is an
  * example of how the PathlossTrace (provided by some SpectrumChannel
- * implementations) work. 
- * 
+ * implementations) work.
+ *
  */
 class LteGlobalPathlossDatabase
 {
@@ -45,29 +45,29 @@
 
   virtual ~LteGlobalPathlossDatabase (void);
 
-  /** 
+  /**
    * update the pathloss value
-   * 
-   * \param context 
+   *
+   * \param context
    * \param txPhy the transmitting PHY
    * \param rxPhy the receiving PHY
    * \param lossDb the loss in dB
    */
   virtual void UpdatePathloss (std::string context, Ptr<SpectrumPhy> txPhy, Ptr<SpectrumPhy> rxPhy, double lossDb) = 0;
 
-  /** 
-   * 
-   * 
+  /**
+   *
+   *
    * \param cellId the id of the eNB
    * \param imsi the id of the UE
-   * 
+   *
    * \return the pathloss value between the UE and the eNB
    */
   double GetPathloss (uint16_t cellId, uint64_t imsi);
 
-  /** 
+  /**
    * print the stored pathloss values to standard output
-   * 
+   *
    */
   void Print ();
 
diff -Naru a/helper/lte-helper.cc b/helper/lte-helper.cc
--- a/helper/lte-helper.cc	2018-08-03 16:38:46.531805672 +0200
+++ b/helper/lte-helper.cc	2018-08-03 16:39:02.875957522 +0200
@@ -18,7 +18,7 @@
  * Author: Nicola Baldo <nbaldo@cttc.es> (re-wrote from scratch this helper)
  *         Giuseppe Piro <g.piro@poliba.it> (parts of the PHY & channel  creation & configuration copied from the GSoC 2011 code)
  * Modified by: Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *              Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation) 
+ *              Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
  */
 
 #include "lte-helper.h"
@@ -85,7 +85,7 @@
   m_channelFactory.SetTypeId (MultiModelSpectrumChannel::GetTypeId ());
 }
 
-void 
+void
 LteHelper::DoInitialize (void)
 {
   NS_LOG_FUNCTION (this);
@@ -152,7 +152,7 @@
     .AddAttribute ("UseIdealRrc",
                    "If true, LteRrcProtocolIdeal will be used for RRC signaling. "
                    "If false, LteRrcProtocolReal will be used.",
-                   BooleanValue (true), 
+                   BooleanValue (true),
                    MakeBooleanAccessor (&LteHelper::m_useIdealRrc),
                    MakeBooleanChecker ())
     .AddAttribute ("AnrEnabled",
@@ -268,15 +268,15 @@
     }
 }
 
-void 
+void
 LteHelper::SetEpcHelper (Ptr<EpcHelper> h)
 {
   NS_LOG_FUNCTION (this << h);
   m_epcHelper = h;
 }
 
-void 
-LteHelper::SetSchedulerType (std::string type) 
+void
+LteHelper::SetSchedulerType (std::string type)
 {
   NS_LOG_FUNCTION (this << type);
   m_schedulerFactory = ObjectFactory ();
@@ -287,9 +287,9 @@
 LteHelper::GetSchedulerType () const
 {
   return m_schedulerFactory.GetTypeId ().GetName ();
-} 
+}
 
-void 
+void
 LteHelper::SetSchedulerAttribute (std::string n, const AttributeValue &v)
 {
   NS_LOG_FUNCTION (this << n);
@@ -389,7 +389,7 @@
   m_pathlossModelFactory.SetTypeId (type);
 }
 
-void 
+void
 LteHelper::SetPathlossModelAttribute (std::string n, const AttributeValue &v)
 {
   NS_LOG_FUNCTION (this << n);
@@ -404,14 +404,14 @@
 }
 
 
-void 
+void
 LteHelper::SetEnbAntennaModelType (std::string type)
 {
   NS_LOG_FUNCTION (this);
   m_enbAntennaModelFactory.SetTypeId (type);
 }
 
-void 
+void
 LteHelper::SetEnbAntennaModelAttribute (std::string n, const AttributeValue &v)
 {
   NS_LOG_FUNCTION (this);
@@ -425,22 +425,22 @@
   m_ueNetDeviceFactory.Set (n, v);
 }
 
-void 
+void
 LteHelper::SetUeAntennaModelType (std::string type)
 {
   NS_LOG_FUNCTION (this);
   m_ueAntennaModelFactory.SetTypeId (type);
 }
 
-void 
+void
 LteHelper::SetUeAntennaModelAttribute (std::string n, const AttributeValue &v)
 {
   NS_LOG_FUNCTION (this);
   m_ueAntennaModelFactory.Set (n, v);
 }
 
-void 
-LteHelper::SetFadingModel (std::string type) 
+void
+LteHelper::SetFadingModel (std::string type)
 {
   NS_LOG_FUNCTION (this << type);
   m_fadingModelType = type;
@@ -451,20 +451,20 @@
     }
 }
 
-void 
+void
 LteHelper::SetFadingModelAttribute (std::string n, const AttributeValue &v)
 {
   m_fadingModelFactory.Set (n, v);
 }
 
-void 
-LteHelper::SetSpectrumChannelType (std::string type) 
+void
+LteHelper::SetSpectrumChannelType (std::string type)
 {
   NS_LOG_FUNCTION (this << type);
   m_channelFactory.SetTypeId (type);
 }
 
-void 
+void
 LteHelper::SetSpectrumChannelAttribute (std::string n, const AttributeValue &v)
 {
   m_channelFactory.Set (n, v);
@@ -520,8 +520,8 @@
   // create component carrier map for this eNb device
   std::map<uint8_t,Ptr<ComponentCarrierEnb> > ccMap;
   for (std::map<uint8_t, ComponentCarrier >::iterator it = m_componentCarrierPhyParams.begin ();
-       it != m_componentCarrierPhyParams.end ();
-       ++it)
+   it != m_componentCarrierPhyParams.end ();
+    ++it)
     {
       Ptr <ComponentCarrierEnb> cc = CreateObject<ComponentCarrierEnb> ();
       cc->SetUlBandwidth (it->second.GetUlBandwidth ());
@@ -583,7 +583,7 @@
       it->second->SetMac (mac);
       it->second->SetFfMacScheduler (sched);
       it->second->SetFfrAlgorithm (ffrAlgorithm);
-  
+
       it->second->SetPhy (phy);
 
     }
@@ -591,7 +591,7 @@
   Ptr<LteEnbRrc> rrc = CreateObject<LteEnbRrc> ();
   Ptr<LteEnbComponentCarrierManager> ccmEnbManager = m_enbComponentCarrierManagerFactory.Create<LteEnbComponentCarrierManager> ();
   rrc->ConfigureCarriers (ccMap);
-  
+
   //ComponentCarrierManager SAP
   rrc->SetLteCcmRrcSapProvider (ccmEnbManager->GetLteCcmRrcSapProvider ());
   ccmEnbManager->SetLteCcmRrcSapUser (rrc->GetLteCcmRrcSapUser ());
@@ -628,7 +628,7 @@
 
   rrc->SetLteHandoverManagementSapProvider (handoverAlgorithm->GetLteHandoverManagementSapProvider ());
   handoverAlgorithm->SetLteHandoverManagementSapUser (rrc->GetLteHandoverManagementSapUser ());
- 
+
   // This RRC attribute is used to connect each new RLC instance with the MAC layer
   // (for function such as TransmitPdu, ReportBufferStatusReport).
   // Since in this new architecture, the component carrier manager acts a proxy, it
@@ -689,7 +689,7 @@
   dev->SetAttribute ("LteEnbComponentCarrierManager", PointerValue (ccmEnbManager));
   dev->SetCcMap (ccMap);
   std::map<uint8_t,Ptr<ComponentCarrierEnb> >::iterator it = ccMap.begin ();
-  dev->SetAttribute ("LteEnbRrc", PointerValue (rrc)); 
+  dev->SetAttribute ("LteEnbRrc", PointerValue (rrc));
   dev->SetAttribute ("LteHandoverAlgorithm", PointerValue (handoverAlgorithm));
   dev->SetAttribute ("LteFfrAlgorithm", PointerValue (it->second->GetFfrAlgorithm ()));
 
@@ -778,8 +778,8 @@
   std::map<uint8_t, Ptr<ComponentCarrierUe> > ueCcMap;
 
   for (std::map< uint8_t, ComponentCarrier >::iterator it = m_componentCarrierPhyParams.begin();
-       it != m_componentCarrierPhyParams.end();
-       ++it)
+   it != m_componentCarrierPhyParams.end();
+    ++it)
     {
       Ptr <ComponentCarrierUe> cc = CreateObject<ComponentCarrierUe> ();
       cc->SetUlBandwidth (it->second.GetUlBandwidth ());
@@ -886,7 +886,7 @@
       rrc->SetUseRlcSm (false);
     }
   Ptr<EpcUeNas> nas = CreateObject<EpcUeNas> ();
- 
+
   nas->SetAsSapProvider (rrc->GetAsSapProvider ());
   rrc->SetAsSapUser (nas->GetAsSapUser ());
 
@@ -1022,7 +1022,7 @@
       m_epcHelper->ActivateEpsBearer (ueDevice, ueLteDevice->GetImsi (), EpcTft::Default (), EpsBearer (EpsBearer::NGBR_VIDEO_TCP_DEFAULT));
     }
 
-  // tricks needed for the simplified LTE-only simulations 
+  // tricks needed for the simplified LTE-only simulations
   if (m_epcHelper == 0)
     {
       ueDevice->GetObject<LteUeNetDevice> ()->SetTargetEnb (enbDevice->GetObject<LteEnbNetDevice> ());
@@ -1167,7 +1167,7 @@
 
 void
 DrbActivator::ActivateDrb (uint64_t imsi, uint16_t cellId, uint16_t rnti)
-{ 
+{
   NS_LOG_FUNCTION (this << imsi << cellId << rnti << m_active);
   if ((!m_active) && (imsi == m_imsi))
     {
@@ -1191,7 +1191,7 @@
 }
 
 
-void 
+void
 LteHelper::ActivateDataRadioBearer (Ptr<NetDevice> ueDevice, EpsBearer bearer)
 {
   NS_LOG_FUNCTION (this << ueDevice);
@@ -1206,7 +1206,7 @@
   Ptr<LteEnbNetDevice> enbLteDevice = ueDevice->GetObject<LteUeNetDevice> ()->GetTargetEnb ();
 
   std::ostringstream path;
-  path << "/NodeList/" << enbLteDevice->GetNode ()->GetId () 
+  path << "/NodeList/" << enbLteDevice->GetNode ()->GetId ()
        << "/DeviceList/" << enbLteDevice->GetIfIndex ()
        << "/LteEnbRrc/ConnectionEstablished";
   Ptr<DrbActivator> arg = Create<DrbActivator> (ueDevice, bearer);
@@ -1306,7 +1306,7 @@
   m_componentCarrierPhyParams.at (0).SetAsPrimary (true);
 }
 
-void 
+void
 LteHelper::ActivateDataRadioBearer (NetDeviceContainer ueDevices, EpsBearer bearer)
 {
   NS_LOG_FUNCTION (this);
diff -Naru a/helper/lte-helper.h b/helper/lte-helper.h
--- a/helper/lte-helper.h	2018-08-03 16:38:46.535805709 +0200
+++ b/helper/lte-helper.h	2018-08-03 16:39:02.875957522 +0200
@@ -17,7 +17,7 @@
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
  * Modified by: Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *              Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation) 
+ *              Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
  */
 
 #ifndef LTE_HELPER_H
@@ -81,7 +81,7 @@
  *     * Handover algorithm
  *     * FFR (frequency reuse) algorithm
  *     * ANR (automatic neighbour relation)
- *     * CCM (Carrier Component Manager) 
+ *     * CCM (Carrier Component Manager)
  *   + EPC related models (EPC application, Internet stack, X2 interface)
  * - UE node(s)
  *   + Mobility model
@@ -112,7 +112,7 @@
   static TypeId GetTypeId (void);
   virtual void DoDispose (void);
 
-  /** 
+  /**
    * Set the EpcHelper to be used to setup the EPC network in
    * conjunction with the setup of the LTE radio access network.
    *
@@ -122,14 +122,14 @@
    * words, it will be a radio-level simulation involving only LTE PHY
    * and MAC and the FF Scheduler, with a saturation traffic model for
    * the RLC.
-   * 
+   *
    * \param h a pointer to the EpcHelper to be used
    */
   void SetEpcHelper (Ptr<EpcHelper> h);
 
-  /** 
+  /**
    * Set the type of path loss model to be used for both DL and UL channels.
-   * 
+   *
    * \param type type of path loss model, must be a type name of any class
    *             inheriting from ns3::PropagationLossModel, for example:
    *             "ns3::FriisPropagationLossModel"
@@ -138,15 +138,15 @@
 
   /**
    * Set an attribute for the path loss models to be created.
-   * 
+   *
    * \param n the name of the attribute
    * \param v the value of the attribute
    */
   void SetPathlossModelAttribute (std::string n, const AttributeValue &v);
 
-  /** 
+  /**
    * Set the type of scheduler to be used by eNodeB devices.
-   * 
+   *
    * \param type type of scheduler, must be a type name of any class
    *             inheriting from ns3::FfMacScheduler, for example:
    *             "ns3::PfFfMacScheduler"
@@ -159,11 +159,11 @@
    *
    * \return the scheduler type
    */
-  std::string GetSchedulerType () const; 
+  std::string GetSchedulerType () const;
 
   /**
    * Set an attribute for the scheduler to be created.
-   * 
+   *
    * \param n the name of the attribute
    * \param v the value of the attribute
    */
@@ -221,15 +221,15 @@
 
   /**
    * Set an attribute for the eNodeB devices (LteEnbNetDevice) to be created.
-   * 
+   *
    * \param n the name of the attribute.
    * \param v the value of the attribute
    */
   void SetEnbDeviceAttribute (std::string n, const AttributeValue &v);
 
-  /** 
+  /**
    * Set the type of antenna model to be used by eNodeB devices.
-   * 
+   *
    * \param type type of antenna model, must be a type name of any class
    *             inheriting from ns3::AntennaModel, for example:
    *             "ns3::IsotropicAntennaModel"
@@ -238,7 +238,7 @@
 
   /**
    * Set an attribute for the eNodeB antenna model to be created.
-   * 
+   *
    * \param n the name of the attribute.
    * \param v the value of the attribute
    */
@@ -252,9 +252,9 @@
    */
   void SetUeDeviceAttribute (std::string n, const AttributeValue &v);
 
-  /** 
+  /**
    * Set the type of antenna model to be used by UE devices.
-   * 
+   *
    * \param type type of antenna model, must be a type name of any class
    *             inheriting from ns3::AntennaModel, for example:
    *             "ns3::IsotropicAntennaModel"
@@ -263,7 +263,7 @@
 
   /**
    * Set an attribute for the UE antenna model to be created.
-   * 
+   *
    * \param n the name of the attribute
    * \param v the value of the attribute
    */
@@ -280,7 +280,7 @@
 
   /**
    * Set an attribute for the spectrum channel to be created (both DL and UL).
-   * 
+   *
    * \param n the name of the attribute
    * \param v the value of the attribute
    */
@@ -414,23 +414,23 @@
    */
   void Attach (Ptr<NetDevice> ueDevice, Ptr<NetDevice> enbDevice);
 
-  /** 
+  /**
    * \brief Manual attachment of a set of UE devices to the network via the
    *        closest eNodeB (with respect to distance) among those in the set.
    * \param ueDevices the set of UE devices to be attached
    * \param enbDevices the set of eNodeB devices to be considered
-   * 
+   *
    * This function finds among the eNodeB set the closest eNodeB for each UE,
    * and then invokes manual attachment between the pair.
-   * 
+   *
    * Users are encouraged to use automatic attachment (Idle mode cell selection)
    * instead of this function.
-   * 
+   *
    * \sa LteHelper::Attach(NetDeviceContainer ueDevices);
    */
   void AttachToClosestEnb (NetDeviceContainer ueDevices, NetDeviceContainer enbDevices);
 
-  /** 
+  /**
    * \brief Manual attachment of a UE device to the network via the closest
    *        eNodeB (with respect to distance) among those in the set.
    * \param ueDevice the UE device to be attached
@@ -438,7 +438,7 @@
    *
    * This function finds among the eNodeB set the closest eNodeB for the UE,
    * and then invokes manual attachment between the pair.
-   * 
+   *
    * Users are encouraged to use automatic attachment (Idle mode cell selection)
    * instead of this function.
    *
@@ -523,27 +523,27 @@
   void HandoverRequest (Time hoTime, Ptr<NetDevice> ueDev,
                         Ptr<NetDevice> sourceEnbDev, uint16_t targetCellId);
 
-  /** 
+  /**
    * Activate a Data Radio Bearer on a given UE devices (for LTE-only simulation).
-   * 
+   *
    * \param ueDevices the set of UE devices
    * \param bearer the characteristics of the bearer to be activated
    */
   void ActivateDataRadioBearer (NetDeviceContainer ueDevices,  EpsBearer bearer);
 
-  /** 
+  /**
    * Activate a Data Radio Bearer on a UE device (for LTE-only simulation).
    * This method will schedule the actual activation
    * the bearer so that it happens after the UE got connected.
-   * 
+   *
    * \param ueDevice the UE device
    * \param bearer the characteristics of the bearer to be activated
    */
   void ActivateDataRadioBearer (Ptr<NetDevice> ueDevice,  EpsBearer bearer);
 
-  /** 
+  /**
    * Set the type of fading model to be used in both DL and UL.
-   * 
+   *
    * \param type type of fading model, must be a type name of any class
    *             inheriting from ns3::SpectrumPropagationLossModel, for
    *             example: "ns3::TraceFadingLossModel"
@@ -625,8 +625,8 @@
    */
   void EnableRlcTraces (void);
 
-  /** 
-   * 
+  /**
+   *
    * \return the RLC stats calculator object
    */
   Ptr<RadioBearerStatsCalculator> GetRlcStats (void);
@@ -636,8 +636,8 @@
    */
   void EnablePdcpTraces (void);
 
-  /** 
-   * 
+  /**
+   *
    * \return the PDCP stats calculator object
    */
   Ptr<RadioBearerStatsCalculator> GetPdcpStats (void);
@@ -658,13 +658,13 @@
   */
   int64_t AssignStreams (NetDeviceContainer c, int64_t stream);
 
-  /** 
+  /**
    * \return a pointer to the SpectrumChannel instance used for the uplink
    */
   Ptr<SpectrumChannel> GetUplinkSpectrumChannel (void) const;
 
 
-  /** 
+  /**
    * \return a pointer to the SpectrumChannel instance used for the downlink
    */
   Ptr<SpectrumChannel> GetDownlinkSpectrumChannel (void) const;
diff -Naru a/helper/mac-tx-stats-calculator.cc b/helper/mac-tx-stats-calculator.cc
--- a/helper/mac-tx-stats-calculator.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/helper/mac-tx-stats-calculator.cc	2018-08-03 16:39:02.875957522 +0200
@@ -0,0 +1,98 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2017 SIGNET Lab, Dept. of Information Engineering, UNIPD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Jaume Nin <jnin@cttc.es>
+ *         Nicola Baldo <nbaldo@cttc.es>
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ */
+
+#include "mac-tx-stats-calculator.h"
+#include "ns3/string.h"
+#include "ns3/nstime.h"
+#include <ns3/log.h>
+#include <vector>
+#include <algorithm>
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("MacTxStatsCalculator");
+
+NS_OBJECT_ENSURE_REGISTERED ( MacTxStatsCalculator);
+
+MacTxStatsCalculator::MacTxStatsCalculator ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+
+MacTxStatsCalculator::~MacTxStatsCalculator ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+TypeId
+MacTxStatsCalculator::GetTypeId (void)
+{
+  static TypeId tid =
+    TypeId ("ns3::MacTxStatsCalculator")
+    .SetParent<Object> ().AddConstructor<MacTxStatsCalculator> ()
+    .SetGroupName("Lte")
+    .AddAttribute ("DlMacTxFilename",
+                   "Name of the file where the MAC downlink tx results will be saved.",
+                   StringValue ("DlMacTx.txt"),
+                   MakeStringAccessor (&MacTxStatsCalculator::m_retxDlFilename),
+                   MakeStringChecker ())
+    .AddAttribute ("UlMacTxFilename",
+                   "Name of the file where the MAC uplink tx results will be saved.",
+                   StringValue ("UlMacTx.txt"),
+                   MakeStringAccessor (&MacTxStatsCalculator::m_retxUlFilename),
+                   MakeStringChecker ())
+    ;
+  return tid;
+}
+
+void
+MacTxStatsCalculator::DoDispose ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+void
+MacTxStatsCalculator::RegisterMacTxDl(uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx)
+{
+	if(!m_retxDlFile.is_open())
+	{
+	    m_retxDlFile.open(m_retxDlFilename.c_str());
+	    NS_LOG_LOGIC("File opened");
+	}
+  NS_LOG_LOGIC(rnti << cellId << packetSize << numRetx);
+	m_retxDlFile << Simulator::Now().GetSeconds() << " " << cellId << " " << rnti << " "  << packetSize << " " << (uint32_t)numRetx << std::endl;
+}
+
+void
+MacTxStatsCalculator::RegisterMacTxUl(uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx)
+{
+	if(!m_retxUlFile.is_open())
+	{
+	    m_retxUlFile.open(m_retxUlFilename.c_str());
+	    NS_LOG_LOGIC("File opened");
+	}
+  m_retxUlFile << Simulator::Now().GetSeconds() << " " << cellId << " " << rnti << " "  << packetSize << " " << (uint32_t)numRetx << std::endl;
+}
+
+}
\ No newline at end of file
diff -Naru a/helper/mac-tx-stats-calculator.h b/helper/mac-tx-stats-calculator.h
--- a/helper/mac-tx-stats-calculator.h	1970-01-01 01:00:00.000000000 +0100
+++ b/helper/mac-tx-stats-calculator.h	2018-08-03 16:39:02.875957522 +0200
@@ -0,0 +1,73 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2017 SIGNET Lab, Dept. of Information Engineering, UNIPD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Jaume Nin <jnin@cttc.es>
+ *         Nicola Baldo <nbaldo@cttc.es>
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ */
+
+#ifndef MAC_TX_STATS_CALCULATOR_H_
+#define MAC_TX_STATS_CALCULATOR_H_
+
+#include "ns3/lte-common.h"
+#include "ns3/uinteger.h"
+#include "ns3/object.h"
+#include "ns3/basic-data-calculators.h"
+#include "ns3/lte-common.h"
+#include <string>
+#include <map>
+#include <fstream>
+
+namespace ns3
+{
+
+class MacTxStatsCalculator : public Object
+{
+public:
+  /**
+   * Class constructor
+   */
+  MacTxStatsCalculator ();
+
+  /**
+   * Class destructor
+   */
+  virtual
+  ~MacTxStatsCalculator ();
+
+  // Inherited from ns3::Object
+  /**
+   *  Register this type.
+   *  \return The object TypeId.
+   */
+  static TypeId GetTypeId (void);
+  void DoDispose ();
+
+  void RegisterMacTxDl(uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx);
+  void RegisterMacTxUl(uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx);
+
+  std::ofstream m_retxDlFile;
+  std::string m_retxDlFilename;
+
+  std::ofstream m_retxUlFile;
+  std::string m_retxUlFilename;
+};
+
+}
+
+#endif /* MAC_TX_STATS_CALCULATOR_H_ */
diff -Naru a/helper/phy-stats-calculator.h b/helper/phy-stats-calculator.h
--- a/helper/phy-stats-calculator.h	2018-08-03 16:38:46.535805709 +0200
+++ b/helper/phy-stats-calculator.h	2018-08-03 16:39:02.875957522 +0200
@@ -141,41 +141,41 @@
    */
   void ReportInterference (uint16_t cellId, Ptr<SpectrumValue> interference);
 
-  /** 
+  /**
    * trace sink
-   * 
-   * \param phyStats 
-   * \param path 
-   * \param cellId 
-   * \param rnti 
-   * \param rsrp 
-   * \param sinr 
+   *
+   * \param phyStats
+   * \param path
+   * \param cellId
+   * \param rnti
+   * \param rsrp
+   * \param sinr
    * \param componentCarrierId
    */
   static void ReportCurrentCellRsrpSinrCallback (Ptr<PhyStatsCalculator> phyStats,
                                           std::string path, uint16_t cellId, uint16_t rnti,
                                           double rsrp, double sinr, uint8_t componentCarrierId);
-  
-  /** 
+
+  /**
    * trace sink
-   * 
-   * \param phyStats 
-   * \param path 
-   * \param cellId 
-   * \param rnti 
+   *
+   * \param phyStats
+   * \param path
+   * \param cellId
+   * \param rnti
    * \param sinrLinear
    * \param componentCarrierId
    */
   static void ReportUeSinr (Ptr<PhyStatsCalculator> phyStats, std::string path,
                      uint16_t cellId, uint16_t rnti, double sinrLinear, uint8_t componentCarrierId);
 
-  /** 
+  /**
    * trace sink
-   * 
-   * \param phyStats 
-   * \param path 
-   * \param cellId 
-   * \param interference 
+   *
+   * \param phyStats
+   * \param path
+   * \param cellId
+   * \param interference
    */
   static void ReportInterference (Ptr<PhyStatsCalculator> phyStats, std::string path,
                            uint16_t cellId, Ptr<SpectrumValue> interference);
diff -Naru a/helper/phy-tx-stats-calculator.cc b/helper/phy-tx-stats-calculator.cc
--- a/helper/phy-tx-stats-calculator.cc	2018-08-03 16:38:46.535805709 +0200
+++ b/helper/phy-tx-stats-calculator.cc	2018-08-03 16:39:02.875957522 +0200
@@ -227,4 +227,3 @@
 
 
 } // namespace ns3
-
diff -Naru a/helper/point-to-point-epc-helper.cc b/helper/point-to-point-epc-helper.cc
--- a/helper/point-to-point-epc-helper.cc	2018-08-03 16:38:46.535805709 +0200
+++ b/helper/point-to-point-epc-helper.cc	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011-2013 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Jaume Nin <jnin@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Support for real S1AP link
  */
 
 #include <ns3/point-to-point-epc-helper.h>
@@ -38,9 +42,10 @@
 #include "ns3/ipv6-static-routing-helper.h"
 #include <ns3/lte-enb-rrc.h>
 #include <ns3/epc-x2.h>
+#include <ns3/epc-s1ap.h>
 #include <ns3/lte-enb-net-device.h>
 #include <ns3/lte-ue-net-device.h>
-#include <ns3/epc-mme.h>
+#include <ns3/epc-mme-application.h>
 #include <ns3/epc-ue-nas.h>
 #include <ns3/ipv4-address-generator.h>
 #include <ns3/ipv6-address-generator.h>
@@ -53,18 +58,19 @@
 NS_OBJECT_ENSURE_REGISTERED (PointToPointEpcHelper);
 
 
-PointToPointEpcHelper::PointToPointEpcHelper () 
-  : m_gtpuUdpPort (2152)  // fixed by the standard
+PointToPointEpcHelper::PointToPointEpcHelper ()
+  : m_gtpuUdpPort (2152),  // fixed by the standard
+    m_s1apUdpPort (36412)
 {
   NS_LOG_FUNCTION (this);
   // To access the attribute value within the constructor
   ObjectBase::ConstructSelf (AttributeConstructionList ());
 
-  // since we use point-to-point links for all S1-U links, 
-  // we use a /30 subnet which can hold exactly two addresses 
+  // since we use point-to-point links for all S1-U and S1-AP links,
+  // we use a /30 subnet which can hold exactly two addresses
   // (remember that net broadcast and null address are not valid)
   m_s1uIpv4AddressHelper.SetBase ("10.0.0.0", "255.255.255.252");
-
+  m_s1apIpv4AddressHelper.SetBase ("11.0.0.0", "255.255.255.252");
   m_x2Ipv4AddressHelper.SetBase ("12.0.0.0", "255.255.255.252");
 
   // we use a /8 net for all UEs
@@ -78,21 +84,29 @@
   InternetStackHelper internet;
   internet.Install (m_sgwPgw);
 
+  // create MmeNode
+  m_mmeNode = CreateObject<Node> ();
+  internet.Install (m_mmeNode);
+
   // The Tun device resides in different 64 bit subnet.
   // We must create an unique route to tun device for all the packets destined
   // to all 64 bit IPv6 prefixes of UEs, based by the unique 48 bit network prefix of this EPC network
   Ipv6StaticRoutingHelper ipv6RoutingHelper;
   Ptr<Ipv6StaticRouting> pgwStaticRouting = ipv6RoutingHelper.GetStaticRouting (m_sgwPgw->GetObject<Ipv6> ());
   pgwStaticRouting->AddNetworkRouteTo ("7777:f00d::", Ipv6Prefix (64), Ipv6Address ("::"), 1, 0);
-  
-  // create S1-U socket
+
+  // create S1-U socket for SgwPgwNode
   Ptr<Socket> sgwPgwS1uSocket = Socket::CreateSocket (m_sgwPgw, TypeId::LookupByName ("ns3::UdpSocketFactory"));
   int retval = sgwPgwS1uSocket->Bind (InetSocketAddress (Ipv4Address::GetAny (), m_gtpuUdpPort));
   NS_ASSERT (retval == 0);
 
-  // create TUN device implementing tunneling of user data over GTP-U/UDP/IP 
-  m_tunDevice = CreateObject<VirtualNetDevice> ();
+  // create S1-AP socket for MmeNode
+  Ptr<Socket> mmeS1apSocket = Socket::CreateSocket (m_mmeNode, TypeId::LookupByName ("ns3::UdpSocketFactory"));
+  retval = mmeS1apSocket->Bind (InetSocketAddress (Ipv4Address::GetAny (), m_s1apUdpPort)); // it listens on any IP, port m_s1apUdpPort
+  NS_ASSERT (retval == 0);
 
+  // create TUN device implementing tunneling of user data over GTP-U/UDP/IP
+  m_tunDevice = CreateObject<VirtualNetDevice> ();
   // allow jumbo packets
   m_tunDevice->SetAttribute ("Mtu", UintegerValue (30000));
 
@@ -102,11 +116,11 @@
   m_sgwPgw->AddDevice (m_tunDevice);
   NetDeviceContainer tunDeviceContainer;
   tunDeviceContainer.Add (m_tunDevice);
-  
+
   // the TUN device is on the same subnet as the UEs, so when a packet
   // addressed to an UE arrives at the intenet to the WAN interface of
-  // the PGW it will be forwarded to the TUN device. 
-  Ipv4InterfaceContainer tunDeviceIpv4IfContainer = AssignUeIpv4Address (tunDeviceContainer);  
+  // the PGW it will be forwarded to the TUN device.
+  Ipv4InterfaceContainer tunDeviceIpv4IfContainer = AssignUeIpv4Address (tunDeviceContainer);
 
 
   // the TUN device for IPv6 address is on the different subnet as the
@@ -122,15 +136,22 @@
   // create EpcSgwPgwApplication
   m_sgwPgwApp = CreateObject<EpcSgwPgwApplication> (m_tunDevice, sgwPgwS1uSocket);
   m_sgwPgw->AddApplication (m_sgwPgwApp);
-  
+
   // connect SgwPgwApplication and virtual net device for tunneling
   m_tunDevice->SetSendCallback (MakeCallback (&EpcSgwPgwApplication::RecvFromTunDevice, m_sgwPgwApp));
 
-
-  // Create MME and connect with SGW via S11 interface
-  m_mme = CreateObject<EpcMme> ();
-  m_mme->SetS11SapSgw (m_sgwPgwApp->GetS11SapSgw ());
-  m_sgwPgwApp->SetS11SapMme (m_mme->GetS11SapMme ());
+  // create S1apMme object and aggregate it with the m_mmeNode
+  Ptr<EpcS1apMme> s1apMme = CreateObject<EpcS1apMme> (mmeS1apSocket, 1); // for now, only one mme!
+  m_mmeNode->AggregateObject(s1apMme);
+
+  // create EpcMmeApplication and connect with SGW via S11 interface
+  m_mmeApp = CreateObject<EpcMmeApplication> ();
+  m_mmeNode->AddApplication (m_mmeApp);
+  m_mmeApp->SetS11SapSgw (m_sgwPgwApp->GetS11SapSgw ());
+  m_sgwPgwApp->SetS11SapMme (m_mmeApp->GetS11SapMme ());
+  // connect m_mmeApp to the s1apMme
+  m_mmeApp->SetS1apSapMmeProvider(s1apMme->GetEpcS1apSapMmeProvider());
+  s1apMme->SetEpcS1apSapMmeUser(m_mmeApp->GetS1apSapMme());
 }
 
 PointToPointEpcHelper::~PointToPointEpcHelper ()
@@ -145,21 +166,36 @@
     .SetParent<EpcHelper> ()
     .SetGroupName("Lte")
     .AddConstructor<PointToPointEpcHelper> ()
-    .AddAttribute ("S1uLinkDataRate", 
+    .AddAttribute ("S1uLinkDataRate",
                    "The data rate to be used for the next S1-U link to be created",
                    DataRateValue (DataRate ("10Gb/s")),
                    MakeDataRateAccessor (&PointToPointEpcHelper::m_s1uLinkDataRate),
                    MakeDataRateChecker ())
-    .AddAttribute ("S1uLinkDelay", 
+    .AddAttribute ("S1uLinkDelay",
                    "The delay to be used for the next S1-U link to be created",
                    TimeValue (Seconds (0)),
                    MakeTimeAccessor (&PointToPointEpcHelper::m_s1uLinkDelay),
                    MakeTimeChecker ())
-    .AddAttribute ("S1uLinkMtu", 
+    .AddAttribute ("S1uLinkMtu",
                    "The MTU of the next S1-U link to be created. Note that, because of the additional GTP/UDP/IP tunneling overhead, you need a MTU larger than the end-to-end MTU that you want to support.",
                    UintegerValue (2000),
                    MakeUintegerAccessor (&PointToPointEpcHelper::m_s1uLinkMtu),
                    MakeUintegerChecker<uint16_t> ())
+    .AddAttribute ("S1apLinkDataRate",
+                   "The data rate to be used for the S1-AP link to be created",
+                   DataRateValue (DataRate ("10Mb/s")),
+                   MakeDataRateAccessor (&PointToPointEpcHelper::m_s1apLinkDataRate),
+                   MakeDataRateChecker ())
+    .AddAttribute ("S1apLinkDelay",
+                   "The delay to be used for the S1-AP link to be created",
+                   TimeValue (Seconds (0.01)),
+                   MakeTimeAccessor (&PointToPointEpcHelper::m_s1apLinkDelay),
+                   MakeTimeChecker ())
+    .AddAttribute ("S1apLinkMtu",
+                   "The MTU of the next S1-AP link to be created",
+                   UintegerValue (2000),
+                   MakeUintegerAccessor (&PointToPointEpcHelper::m_s1apLinkMtu),
+                   MakeUintegerChecker<uint16_t> ())
     .AddAttribute ("X2LinkDataRate",
                    "The data rate to be used for the next X2 link to be created",
                    DataRateValue (DataRate ("10Gb/s")),
@@ -175,26 +211,26 @@
                    UintegerValue (3000),
                    MakeUintegerAccessor (&PointToPointEpcHelper::m_x2LinkMtu),
                    MakeUintegerChecker<uint16_t> ())
-    .AddAttribute ("S1uLinkPcapPrefix",
-                   "Prefix for Pcap generated by S1-U link",
-                   StringValue ("s1-u"),
-                   MakeStringAccessor (&PointToPointEpcHelper::m_s1uLinkPcapPrefix),
-                   MakeStringChecker ())
-    .AddAttribute ("X2LinkPcapPrefix",
-                   "Prefix for Pcap generated by X2 link",
-                   StringValue ("x2"),
-                   MakeStringAccessor (&PointToPointEpcHelper::m_x2LinkPcapPrefix),
-                   MakeStringChecker ())
-    .AddAttribute ("X2LinkEnablePcap",
-                   "Enable Pcap for X2 link",
-                   BooleanValue (false),
-                   MakeBooleanAccessor (&PointToPointEpcHelper::m_enablePcapOverX2),
-                   MakeBooleanChecker ())
-    .AddAttribute ("S1uLinkEnablePcap",
-                   "Enable Pcap for X2 link",
-                   BooleanValue (false),
-                   MakeBooleanAccessor (&PointToPointEpcHelper::m_enablePcapOverS1U),
-                   MakeBooleanChecker ())
+     .AddAttribute ("S1uLinkPcapPrefix",
+                    "Prefix for Pcap generated by S1-U link",
+                    StringValue ("s1-u"),
+                    MakeStringAccessor (&PointToPointEpcHelper::m_s1uLinkPcapPrefix),
+                    MakeStringChecker ())
+     .AddAttribute ("X2LinkPcapPrefix",
+                    "Prefix for Pcap generated by X2 link",
+                    StringValue ("x2"),
+                    MakeStringAccessor (&PointToPointEpcHelper::m_x2LinkPcapPrefix),
+                    MakeStringChecker ())
+     .AddAttribute ("X2LinkEnablePcap",
+                    "Enable Pcap for X2 link",
+                    BooleanValue (false),
+                    MakeBooleanAccessor (&PointToPointEpcHelper::m_enablePcapOverX2),
+                    MakeBooleanChecker ())
+     .AddAttribute ("S1uLinkEnablePcap",
+                    "Enable Pcap for X2 link",
+                    BooleanValue (false),
+                    MakeBooleanAccessor (&PointToPointEpcHelper::m_enablePcapOverS1U),
+                    MakeBooleanChecker ())
   ;
   return tid;
 }
@@ -211,7 +247,7 @@
   NS_LOG_FUNCTION (this);
   m_tunDevice->SetSendCallback (MakeNullCallback<bool, Ptr<Packet>, const Address&, const Address&, uint16_t> ());
   m_tunDevice = 0;
-  m_sgwPgwApp = 0;  
+  m_sgwPgwApp = 0;
   m_sgwPgw->Dispose ();
 }
 
@@ -229,7 +265,7 @@
   NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after node creation: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());
 
   // create a point to point link between the new eNB and the SGW with
-  // the corresponding new NetDevices on each side  
+  // the corresponding new NetDevices on each side
   NodeContainer enbSgwNodes;
   enbSgwNodes.Add (m_sgwPgw);
   enbSgwNodes.Add (enb);
@@ -238,7 +274,7 @@
   p2ph.SetDeviceAttribute ("Mtu", UintegerValue (m_s1uLinkMtu));
   p2ph.SetChannelAttribute ("Delay", TimeValue (m_s1uLinkDelay));
   NetDeviceContainer enbSgwDevices = p2ph.Install (enb, m_sgwPgw);
-  NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after installing p2p dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());  
+  NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after installing p2p dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());
   Ptr<NetDevice> enbDev = enbSgwDevices.Get (0);
   Ptr<NetDevice> sgwDev = enbSgwDevices.Get (1);
 
@@ -250,7 +286,7 @@
   m_s1uIpv4AddressHelper.NewNetwork ();
   Ipv4InterfaceContainer enbSgwIpIfaces = m_s1uIpv4AddressHelper.Assign (enbSgwDevices);
   NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after assigning Ipv4 addr to S1 dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());
-  
+
   Ipv4Address enbAddress = enbSgwIpIfaces.GetAddress (0);
   Ipv4Address sgwAddress = enbSgwIpIfaces.GetAddress (1);
 
@@ -259,33 +295,62 @@
   int retval = enbS1uSocket->Bind (InetSocketAddress (enbAddress, m_gtpuUdpPort));
   NS_ASSERT (retval == 0);
 
-  // create LTE socket for the ENB 
+
+  // create a point to point link between the new eNB and the MME with
+  // the corresponding new NetDevices on each side
+  NodeContainer enbMmeNodes;
+  enbMmeNodes.Add (m_mmeNode);
+  enbMmeNodes.Add (enb);
+  PointToPointHelper p2ph_mme;
+  p2ph_mme.SetDeviceAttribute ("DataRate", DataRateValue (m_s1apLinkDataRate));
+  p2ph_mme.SetDeviceAttribute ("Mtu", UintegerValue (m_s1apLinkMtu));
+  p2ph_mme.SetChannelAttribute ("Delay", TimeValue (m_s1apLinkDelay));
+  NetDeviceContainer enbMmeDevices = p2ph_mme.Install (enb, m_mmeNode);
+  NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after installing p2p dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());
+
+  m_s1apIpv4AddressHelper.NewNetwork ();
+  Ipv4InterfaceContainer enbMmeIpIfaces = m_s1apIpv4AddressHelper.Assign (enbMmeDevices);
+  NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after assigning Ipv4 addr to S1 dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());
+
+  Ipv4Address mme_enbAddress = enbMmeIpIfaces.GetAddress (0);
+  Ipv4Address mmeAddress = enbMmeIpIfaces.GetAddress (1);
+
+  // create S1-AP socket for the ENB
+  Ptr<Socket> enbS1apSocket = Socket::CreateSocket (enb, TypeId::LookupByName ("ns3::UdpSocketFactory"));
+  retval = enbS1apSocket->Bind (InetSocketAddress (mme_enbAddress, m_s1apUdpPort));
+  NS_ASSERT (retval == 0);
+
+  // give PacketSocket powers to the eNB
+  //PacketSocketHelper packetSocket;
+  //packetSocket.Install (enb);
+
+  // create LTE socket for the ENB
   Ptr<Socket> enbLteSocket = Socket::CreateSocket (enb, TypeId::LookupByName ("ns3::PacketSocketFactory"));
   PacketSocketAddress enbLteSocketBindAddress;
   enbLteSocketBindAddress.SetSingleDevice (lteEnbNetDevice->GetIfIndex ());
   enbLteSocketBindAddress.SetProtocol (Ipv4L3Protocol::PROT_NUMBER);
   retval = enbLteSocket->Bind (enbLteSocketBindAddress);
-  NS_ASSERT (retval == 0);  
+  NS_ASSERT (retval == 0);
   PacketSocketAddress enbLteSocketConnectAddress;
   enbLteSocketConnectAddress.SetPhysicalAddress (Mac48Address::GetBroadcast ());
   enbLteSocketConnectAddress.SetSingleDevice (lteEnbNetDevice->GetIfIndex ());
   enbLteSocketConnectAddress.SetProtocol (Ipv4L3Protocol::PROT_NUMBER);
   retval = enbLteSocket->Connect (enbLteSocketConnectAddress);
-  NS_ASSERT (retval == 0);  
+  NS_ASSERT (retval == 0);
 
-  // create LTE socket for the ENB 
+  // create LTE socket for the ENB
   Ptr<Socket> enbLteSocket6 = Socket::CreateSocket (enb, TypeId::LookupByName ("ns3::PacketSocketFactory"));
   PacketSocketAddress enbLteSocketBindAddress6;
   enbLteSocketBindAddress6.SetSingleDevice (lteEnbNetDevice->GetIfIndex ());
   enbLteSocketBindAddress6.SetProtocol (Ipv6L3Protocol::PROT_NUMBER);
   retval = enbLteSocket6->Bind (enbLteSocketBindAddress6);
-  NS_ASSERT (retval == 0);  
+  NS_ASSERT (retval == 0);
   PacketSocketAddress enbLteSocketConnectAddress6;
   enbLteSocketConnectAddress6.SetPhysicalAddress (Mac48Address::GetBroadcast ());
   enbLteSocketConnectAddress6.SetSingleDevice (lteEnbNetDevice->GetIfIndex ());
   enbLteSocketConnectAddress6.SetProtocol (Ipv6L3Protocol::PROT_NUMBER);
   retval = enbLteSocket6->Connect (enbLteSocketConnectAddress6);
-  NS_ASSERT (retval == 0);  
+  NS_ASSERT (retval == 0);
 
   NS_LOG_INFO ("create EpcEnbApplication");
   Ptr<EpcEnbApplication> enbApp = CreateObject<EpcEnbApplication> (enbLteSocket, enbLteSocket6, enbS1uSocket, enbAddress, sgwAddress, cellId);
@@ -294,15 +359,24 @@
   NS_ASSERT_MSG (enb->GetApplication (0)->GetObject<EpcEnbApplication> () != 0, "cannot retrieve EpcEnbApplication");
   NS_LOG_LOGIC ("enb: " << enb << ", enb->GetApplication (0): " << enb->GetApplication (0));
 
-  
+
   NS_LOG_INFO ("Create EpcX2 entity");
   Ptr<EpcX2> x2 = CreateObject<EpcX2> ();
   enb->AggregateObject (x2);
 
   NS_LOG_INFO ("connect S1-AP interface");
-  m_mme->AddEnb (cellId, enbAddress, enbApp->GetS1apSapEnb ());
+
+  uint16_t mmeId = 1;
+  Ptr<EpcS1apEnb> s1apEnb = CreateObject<EpcS1apEnb> (enbS1apSocket, mme_enbAddress, mmeAddress, cellId, mmeId); // only one mme!
+  enb->AggregateObject(s1apEnb);
+  enbApp->SetS1apSapMme (s1apEnb->GetEpcS1apSapEnbProvider ());
+  s1apEnb->SetEpcS1apSapEnbUser (enbApp->GetS1apSapEnb());
+  m_mmeApp->AddEnb (cellId, mme_enbAddress); // TODO consider if this can be removed
+  // add the interface to the S1AP endpoint on the MME
+  Ptr<EpcS1apMme> s1apMme = m_mmeNode->GetObject<EpcS1apMme> ();
+  s1apMme->AddS1apInterface (cellId, mme_enbAddress);
+
   m_sgwPgwApp->AddEnb (cellId, enbAddress, sgwAddress);
-  enbApp->SetS1apSapMme (m_mme->GetS1apSapMme ());
 }
 
 
@@ -358,14 +432,14 @@
 }
 
 
-void 
+void
 PointToPointEpcHelper::AddUe (Ptr<NetDevice> ueDevice, uint64_t imsi)
 {
   NS_LOG_FUNCTION (this << imsi << ueDevice );
-  
-  m_mme->AddUe (imsi);
+
+  m_mmeApp->AddUe (imsi);
   m_sgwPgwApp->AddUe (imsi);
-  
+
 
 }
 
@@ -374,13 +448,13 @@
 {
   NS_LOG_FUNCTION (this << ueDevice << imsi);
 
-  // we now retrieve the IPv4/IPv6 address of the UE and notify it to the SGW;
+  // we now retrieve the IPv44/IPv6 address of the UE and notify it to the SGW;
   // we couldn't do it before since address assignment is triggered by
-  // the user simulation program, rather than done by the EPC   
-  Ptr<Node> ueNode = ueDevice->GetNode (); 
+  // the user simulation program, rather than done by the EPC
+  Ptr<Node> ueNode = ueDevice->GetNode ();
   Ptr<Ipv4> ueIpv4 = ueNode->GetObject<Ipv4> ();
   Ptr<Ipv6> ueIpv6 = ueNode->GetObject<Ipv6> ();
-  NS_ASSERT_MSG (ueIpv4 != 0 || ueIpv6 != 0, "UEs need to have IPv4/IPv6 installed before EPS bearers can be activated");
+  NS_ASSERT_MSG (ueIpv4 != 0, "UEs need to have IPv4 installed before EPS bearers can be activated");
 
   if (ueIpv4)
     {
@@ -388,7 +462,7 @@
       if (interface >= 0 && ueIpv4->GetNAddresses (interface) == 1)
         {
           Ipv4Address ueAddr = ueIpv4->GetAddress (interface, 0).GetLocal ();
-          NS_LOG_LOGIC (" UE IPv4 address: " << ueAddr);
+          NS_LOG_LOGIC (" UE IP address: " << ueAddr);
           m_sgwPgwApp->SetUeAddress (imsi, ueAddr);
         }
     }
@@ -402,28 +476,61 @@
           m_sgwPgwApp->SetUeAddress6 (imsi, ueAddr6);
         }
     }
-  uint8_t bearerId = m_mme->AddBearer (imsi, tft, bearer);
+
+  uint8_t bearerId = m_mmeApp->AddBearer (imsi, tft, bearer);
   Ptr<LteUeNetDevice> ueLteDevice = ueDevice->GetObject<LteUeNetDevice> ();
   if (ueLteDevice)
     {
       Simulator::ScheduleNow (&EpcUeNas::ActivateEpsBearer, ueLteDevice->GetNas (), bearer, tft);
     }
+  NS_LOG_LOGIC("Bearer Id added in mmeApp " << bearerId);
   return bearerId;
 }
 
+uint8_t
+PointToPointEpcHelper::ActivateEpsBearer (Ptr<NetDevice> ueDevice, Ptr<EpcUeNas> ueNas, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer)
+{
+  NS_LOG_FUNCTION (this << ueDevice << imsi);
+
+  // we now retrieve the IPv4 address of the UE and notify it to the SGW;
+  // we couldn't do it before since address assignment is triggered by
+  // the user simulation program, rather than done by the EPC
+  Ptr<Node> ueNode = ueDevice->GetNode ();
+  Ptr<Ipv4> ueIpv4 = ueNode->GetObject<Ipv4> ();
+  NS_ASSERT_MSG (ueIpv4 != 0, "UEs need to have IPv4 installed before EPS bearers can be activated");
+  int32_t interface =  ueIpv4->GetInterfaceForDevice (ueDevice);
+  NS_ASSERT (interface >= 0);
+  NS_ASSERT (ueIpv4->GetNAddresses (interface) == 1);
+  Ipv4Address ueAddr = ueIpv4->GetAddress (interface, 0).GetLocal ();
+  NS_LOG_LOGIC (" UE IP address: " << ueAddr);  m_sgwPgwApp->SetUeAddress (imsi, ueAddr);
+
+  uint8_t bearerId = m_mmeApp->AddBearer (imsi, tft, bearer);
+  ueNas->ActivateEpsBearer (bearer, tft);
+  return bearerId;
+}
+
+
 Ptr<Node>
 PointToPointEpcHelper::GetPgwNode ()
 {
   return m_sgwPgw;
 }
 
-Ipv4InterfaceContainer 
+Ptr<Node>
+PointToPointEpcHelper::GetMmeNode ()
+{
+  return m_mmeNode;
+}
+
+
+
+Ipv4InterfaceContainer
 PointToPointEpcHelper::AssignUeIpv4Address (NetDeviceContainer ueDevices)
 {
   return m_uePgwAddressHelper.Assign (ueDevices);
 }
 
-Ipv6InterfaceContainer 
+Ipv6InterfaceContainer
 PointToPointEpcHelper::AssignUeIpv6Address (NetDeviceContainer ueDevices)
 {
   for (NetDeviceContainer::Iterator iter = ueDevices.Begin ();
@@ -436,6 +543,8 @@
   return m_uePgwAddressHelper6.Assign (ueDevices);
 }
 
+
+
 Ipv4Address
 PointToPointEpcHelper::GetUeDefaultGatewayAddress ()
 {
diff -Naru a/helper/point-to-point-epc-helper.h b/helper/point-to-point-epc-helper.h
--- a/helper/point-to-point-epc-helper.h	2018-08-03 16:38:46.535805709 +0200
+++ b/helper/point-to-point-epc-helper.h	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011-2013 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Jaume Nin <jnin@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *        Support for real S1AP link
  */
 
 #ifndef POINT_TO_POINT_EPC_HELPER_H
@@ -39,6 +43,10 @@
 class EpcSgwPgwApplication;
 class EpcX2;
 class EpcMme;
+class EpcUeNas;
+class EpcMmeApplication;
+class EpcS1apEnb;
+class EpcS1apMme;
 
 /**
  * \ingroup lte
@@ -46,23 +54,23 @@
  *
  * This Helper will create an EPC network topology comprising of a
  * single node that implements both the SGW and PGW functionality, and
- * an MME node. The S1-U, X2-U and X2-C interfaces are realized over
- * PointToPoint links. 
+ * an MME node. The S1-U, S1-AP, X2-U and X2-C interfaces are realized over
+ * PointToPoint links.
  */
 class PointToPointEpcHelper : public EpcHelper
 {
 public:
-  
-  /** 
+
+  /**
    * Constructor
    */
   PointToPointEpcHelper ();
 
-  /** 
+  /**
    * Destructor
-   */  
+   */
   virtual ~PointToPointEpcHelper ();
-  
+
   // inherited from Object
   /**
    *  Register this type.
@@ -77,28 +85,32 @@
   virtual void AddUe (Ptr<NetDevice> ueLteDevice, uint64_t imsi);
   virtual void AddX2Interface (Ptr<Node> enbNode1, Ptr<Node> enbNode2);
   virtual uint8_t ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer);
+  virtual uint8_t ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, Ptr<EpcUeNas> ueNas, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer);
   virtual Ptr<Node> GetPgwNode ();
+  virtual Ptr<Node> GetMmeNode ();
   virtual Ipv4InterfaceContainer AssignUeIpv4Address (NetDeviceContainer ueDevices);
   Ipv6InterfaceContainer AssignUeIpv6Address (NetDeviceContainer ueDevices);
   virtual Ipv4Address GetUeDefaultGatewayAddress ();
   Ipv6Address GetUeDefaultGatewayAddress6 ();
 
 
+
 private:
 
-  /** 
+  /**
    * helper to assign IPv4 addresses to UE devices as well as to the TUN device of the SGW/PGW
    */
   Ipv4AddressHelper m_uePgwAddressHelper;
-  /** 
+
+  /**
    * helper to assign IPv6 addresses to UE devices as well as to the TUN device of the SGW/PGW
    */
   Ipv6AddressHelper m_uePgwAddressHelper6;
-  
+
   /**
    * SGW-PGW network element
    */
-  Ptr<Node> m_sgwPgw; 
+  Ptr<Node> m_sgwPgw;
 
   /**
    * SGW-PGW application
@@ -113,16 +125,21 @@
   /**
    * MME network element
    */
-  Ptr<EpcMme> m_mme;
+  Ptr<Node> m_mmeNode;
+
+  /**
+   * MME application
+   */
+  Ptr<EpcMmeApplication> m_mmeApp;
 
   /**
    * S1-U interfaces
    */
 
-  /** 
-   * helper to assign addresses to S1-U NetDevices 
+  /**
+   * helper to assign addresses to S1-U NetDevices
    */
-  Ipv4AddressHelper m_s1uIpv4AddressHelper; 
+  Ipv4AddressHelper m_s1uIpv4AddressHelper;
 
   /**
    * The data rate to be used for the next S1-U link to be created
@@ -153,6 +170,42 @@
   std::map<uint64_t, Ptr<NetDevice> > m_imsiEnbDeviceMap;
 
   /**
+   * S1-AP interfaces
+   */
+
+  /**
+   * helper to assign addresses to S1-AP NetDevices
+   */
+  Ipv4AddressHelper m_s1apIpv4AddressHelper;
+
+  /**
+   * The data rate to be used for the next S1-AP link to be created
+   */
+  DataRate m_s1apLinkDataRate;
+
+  /**
+   * The delay to be used for the next S1-AP link to be created
+   */
+  Time     m_s1apLinkDelay;
+
+  /**
+   * The MTU of the next S1-AP link to be created.
+   */
+  uint16_t m_s1apLinkMtu;
+
+  /**
+   * UDP port where the UDP Socket is bound, fixed by the standard as
+   * 36412 (it should be sctp, but it is not supported in ns-3)
+   */
+  uint16_t m_s1apUdpPort;
+
+  /**
+   * Map storing for each eNB the corresponding MME NetDevice
+   */
+  std::map<uint16_t, Ptr<NetDevice> > m_cellIdMmeDeviceMap;
+
+
+  /**
    * helper to assign addresses to X2 NetDevices
    */
   Ipv4AddressHelper m_x2Ipv4AddressHelper;
diff -Naru a/helper/radio-bearer-stats-calculator.cc b/helper/radio-bearer-stats-calculator.cc
--- a/helper/radio-bearer-stats-calculator.cc	2018-08-03 16:38:46.535805709 +0200
+++ b/helper/radio-bearer-stats-calculator.cc	2018-08-03 16:39:02.875957522 +0200
@@ -272,7 +272,8 @@
 {
   NS_LOG_FUNCTION (this);
 
-  // Get the unique IMSI/LCID pairs list
+  // Get the unique IMSI / LCID list
+
   std::vector < ImsiLcidPair_t > pairVector;
   for (Uint32Map::iterator it = m_ulTxPackets.begin (); it != m_ulTxPackets.end (); ++it)
     {
@@ -282,14 +283,6 @@
         }
     }
 
-  for (Uint32Map::iterator it = m_ulRxPackets.begin (); it != m_ulRxPackets.end (); ++it)
-    {
-      if (find (pairVector.begin (), pairVector.end (), (*it).first) == pairVector.end ())
-        {
-          pairVector.push_back ((*it).first);
-        }
-    }
-
   Time endTime = m_startTime + m_epochDuration;
   for (std::vector<ImsiLcidPair_t>::iterator it = pairVector.begin (); it != pairVector.end (); ++it)
     {
@@ -333,20 +326,12 @@
 {
   NS_LOG_FUNCTION (this);
 
-  // Get the unique IMSI/LCID pairs list
+  // Get the unique IMSI list
   std::vector < ImsiLcidPair_t > pairVector;
   for (Uint32Map::iterator it = m_dlTxPackets.begin (); it != m_dlTxPackets.end (); ++it)
     {
       if (find (pairVector.begin (), pairVector.end (), (*it).first) == pairVector.end ())
         {
-          pairVector.push_back ((*it).first);
-        }
-    }
-
-  for (Uint32Map::iterator it = m_dlRxPackets.begin (); it != m_dlRxPackets.end (); ++it)
-    {
-      if (find (pairVector.begin (), pairVector.end (), (*it).first) == pairVector.end ())
-        {
           pairVector.push_back ((*it).first);
         }
     }
diff -Naru a/helper/radio-bearer-stats-calculator.h b/helper/radio-bearer-stats-calculator.h
--- a/helper/radio-bearer-stats-calculator.h	2018-08-03 16:38:46.535805709 +0200
+++ b/helper/radio-bearer-stats-calculator.h	2018-08-03 16:39:02.875957522 +0200
@@ -77,7 +77,6 @@
 
   /**
     * Class constructor
-    * \param protocolType the name of the protocol type
     */
   RadioBearerStatsCalculator (std::string protocolType);
 
diff -Naru a/helper/radio-bearer-stats-connector.cc b/helper/radio-bearer-stats-connector.cc
--- a/helper/radio-bearer-stats-connector.cc	2018-08-03 16:38:46.535805709 +0200
+++ b/helper/radio-bearer-stats-connector.cc	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2018, University of Padova, Dep. of Information Engineering, SIGNET lab.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+ *							Integration of Carrier Aggregation for the mmWave module
  */
 
 
@@ -56,13 +60,27 @@
   uint16_t cellId; //!< cellId
 };
 
+struct BoundCallbackArgumentRetx : public SimpleRefCount<BoundCallbackArgumentRetx>
+{
+public:
+  Ptr<RetxStatsCalculator> stats;  //!< statistics calculator
+  uint64_t imsi; //!< imsi
+  uint16_t cellId; //!< cellId
+};
+
+struct BoundCallbackArgumentMacTx : public SimpleRefCount<BoundCallbackArgumentMacTx>
+{
+public:
+  Ptr<MacTxStatsCalculator> stats;  //!< statistics calculator
+};
+
 /**
  * Callback function for DL TX statistics for both RLC and PDCP
- * \param arg
- * \param path
- * \param rnti
- * \param lcid
- * \param packetSize
+ * /param arg
+ * /param path
+ * /param rnti
+ * /param lcid
+ * /param packetSize
  */
 void
 DlTxPduCallback (Ptr<BoundCallbackArgument> arg, std::string path,
@@ -74,12 +92,12 @@
 
 /**
  * Callback function for DL RX statistics for both RLC and PDCP
- * \param arg
- * \param path
- * \param rnti
- * \param lcid
- * \param packetSize
- * \param delay
+ * /param arg
+ * /param path
+ * /param rnti
+ * /param lcid
+ * /param packetSize
+ * /param delay
  */
 void
 DlRxPduCallback (Ptr<BoundCallbackArgument> arg, std::string path,
@@ -91,61 +109,96 @@
 
 /**
  * Callback function for UL TX statistics for both RLC and PDCP
- * \param arg
- * \param path
- * \param rnti
- * \param lcid
- * \param packetSize
+ * /param arg
+ * /param path
+ * /param rnti
+ * /param lcid
+ * /param packetSize
  */
 void
 UlTxPduCallback (Ptr<BoundCallbackArgument> arg, std::string path,
                  uint16_t rnti, uint8_t lcid, uint32_t packetSize)
 {
   NS_LOG_FUNCTION (path << rnti << (uint16_t)lcid << packetSize);
- 
+
   arg->stats->UlTxPdu (arg->cellId, arg->imsi, rnti, lcid, packetSize);
 }
 
 /**
  * Callback function for UL RX statistics for both RLC and PDCP
- * \param arg
- * \param path
- * \param rnti
- * \param lcid
- * \param packetSize
- * \param delay
+ * /param arg
+ * /param path
+ * /param rnti
+ * /param lcid
+ * /param packetSize
+ * /param delay
  */
 void
 UlRxPduCallback (Ptr<BoundCallbackArgument> arg, std::string path,
                  uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint64_t delay)
 {
   NS_LOG_FUNCTION (path << rnti << (uint16_t)lcid << packetSize << delay);
- 
+
   arg->stats->UlRxPdu (arg->cellId, arg->imsi, rnti, lcid, packetSize, delay);
 }
 
+void
+DlRetxCallback (Ptr<BoundCallbackArgumentRetx> arg, std::string path,
+                 uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx)
+{
+  NS_LOG_FUNCTION(path << arg->stats << arg->imsi);
+  arg->stats->RegisterRetxDl(arg->imsi, arg->cellId, rnti, lcid, packetSize, numRetx);
+}
+
+void
+UlRetxCallback (Ptr<BoundCallbackArgumentRetx> arg, std::string path,
+                 uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx)
+{
+  NS_LOG_FUNCTION(path << arg->stats << arg->imsi);
+  arg->stats->RegisterRetxUl(arg->imsi, arg->cellId, rnti, lcid, packetSize, numRetx);
+}
+
+void
+NotifyDlMacTx (Ptr<BoundCallbackArgumentMacTx> arg, std::string path, uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx)
+{
+  NS_LOG_FUNCTION(path << rnti << cellId << packetSize << (uint32_t)numRetx);
+  arg->stats->RegisterMacTxDl(rnti, cellId, packetSize, numRetx);
+}
 
 
 RadioBearerStatsConnector::RadioBearerStatsConnector ()
   : m_connected (false)
 {
+  m_retxStats = CreateObject<RetxStatsCalculator> ();
+  m_macTxStats = CreateObject<MacTxStatsCalculator> ();
 }
 
-void 
+void
 RadioBearerStatsConnector::EnableRlcStats (Ptr<RadioBearerStatsCalculator> rlcStats)
 {
   m_rlcStats = rlcStats;
   EnsureConnected ();
 }
 
-void 
+void
 RadioBearerStatsConnector::EnablePdcpStats (Ptr<RadioBearerStatsCalculator> pdcpStats)
 {
   m_pdcpStats = pdcpStats;
   EnsureConnected ();
 }
 
-void 
+// TypeId
+// RadioBearerStatsConnector::GetTypeId (void)
+// {
+//   static TypeId tid =
+//     TypeId ("ns3::RadioBearerStatsConnector")
+//     .SetParent<Object> ()
+//     .AddConstructor<RadioBearerStatsConnector> ()
+//     .SetGroupName("Lte");
+//   return tid;
+// }
+
+void
 RadioBearerStatsConnector::EnsureConnected ()
 {
   NS_LOG_FUNCTION (this);
@@ -167,65 +220,76 @@
 		       MakeBoundCallback (&RadioBearerStatsConnector::NotifyHandoverEndOkEnb, this));
       Config::Connect ("/NodeList/*/DeviceList/*/LteUeRrc/HandoverEndOk",
 		       MakeBoundCallback (&RadioBearerStatsConnector::NotifyHandoverEndOkUe, this));
+      // MAC related callback
+      if(m_macTxStats)
+      {
+        Ptr<BoundCallbackArgumentMacTx> arg = Create<BoundCallbackArgumentMacTx>();
+        arg->stats = m_macTxStats;
+        Config::Connect ("/NodeList/*/DeviceList/*/MmWaveEnbMac/DlMacTxCallback",
+           MakeBoundCallback (&NotifyDlMacTx, arg));
+      }
       m_connected = true;
     }
 }
 
-void 
+void
 RadioBearerStatsConnector::NotifyRandomAccessSuccessfulUe (RadioBearerStatsConnector* c, std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
 {
   c->ConnectSrb0Traces (context, imsi, cellId, rnti);
 }
 
-void 
+void
 RadioBearerStatsConnector::NotifyConnectionSetupUe (RadioBearerStatsConnector* c, std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
 {
   c->ConnectSrb1TracesUe (context, imsi, cellId, rnti);
 }
 
-void 
+void
 RadioBearerStatsConnector::NotifyConnectionReconfigurationUe (RadioBearerStatsConnector* c, std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
 {
   c->ConnectTracesUeIfFirstTime (context, imsi, cellId, rnti);
 }
 
-void 
+void
 RadioBearerStatsConnector::NotifyHandoverStartUe (RadioBearerStatsConnector* c, std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti, uint16_t targetCellId)
 {
   c->DisconnectTracesUe (context, imsi, cellId, rnti);
 }
 
-void 
+void
 RadioBearerStatsConnector::NotifyHandoverEndOkUe (RadioBearerStatsConnector* c, std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
 {
-  c->ConnectTracesUe (context, imsi, cellId, rnti);
+  c->ConnectSrb1TracesUe (context, imsi, cellId, rnti);
+  c->ConnectDrbTracesUe (context, imsi, cellId, rnti);
+
 }
 
-void 
+void
 RadioBearerStatsConnector::NotifyNewUeContextEnb (RadioBearerStatsConnector* c, std::string context, uint16_t cellId, uint16_t rnti)
 {
   c->StoreUeManagerPath (context, cellId, rnti);
 }
 
-void 
+void
 RadioBearerStatsConnector::NotifyConnectionReconfigurationEnb (RadioBearerStatsConnector* c, std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
 {
   c->ConnectTracesEnbIfFirstTime (context, imsi, cellId, rnti);
 }
 
-void 
+void
 RadioBearerStatsConnector::NotifyHandoverStartEnb (RadioBearerStatsConnector* c, std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti, uint16_t targetCellId)
 {
   c->DisconnectTracesEnb (context, imsi, cellId, rnti);
 }
 
-void 
+void
 RadioBearerStatsConnector::NotifyHandoverEndOkEnb (RadioBearerStatsConnector* c, std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
 {
-  c->ConnectTracesEnb (context, imsi, cellId, rnti);
+  c->ConnectSrb1TracesEnb (context, imsi, cellId, rnti);
+  c->ConnectDrbTracesEnb (context, imsi, cellId, rnti);
 }
 
-void 
+void
 RadioBearerStatsConnector::StoreUeManagerPath (std::string context, uint16_t cellId, uint16_t rnti)
 {
   NS_LOG_FUNCTION (this << context << cellId << rnti);
@@ -237,7 +301,7 @@
   m_ueManagerPathByCellIdRnti[key] = ueManagerPath.str ();
 }
 
-void 
+void
 RadioBearerStatsConnector::ConnectSrb0Traces (std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
 {
   NS_LOG_FUNCTION (this << imsi << cellId << rnti);
@@ -247,7 +311,7 @@
   key.rnti = rnti;
   std::map<CellIdRnti, std::string>::iterator it = m_ueManagerPathByCellIdRnti.find (key);
   NS_ASSERT (it != m_ueManagerPathByCellIdRnti.end ());
-  std::string ueManagerPath = it->second;  
+  std::string ueManagerPath = it->second;
   NS_LOG_LOGIC (this << " ueManagerPath: " << ueManagerPath);
   m_ueManagerPathByCellIdRnti.erase (it);
 
@@ -255,7 +319,7 @@
     {
       Ptr<BoundCallbackArgument> arg = Create<BoundCallbackArgument> ();
       arg->imsi = imsi;
-      arg->cellId = cellId; 
+      arg->cellId = cellId;
       arg->stats = m_rlcStats;
 
       // diconnect eventually previously connected SRB0 both at UE and eNB
@@ -288,7 +352,7 @@
     {
       Ptr<BoundCallbackArgument> arg = Create<BoundCallbackArgument> ();
       arg->imsi = imsi;
-      arg->cellId = cellId; 
+      arg->cellId = cellId;
       arg->stats = m_pdcpStats;
 
       // connect SRB1 at eNB only (at UE SRB1 will be setup later)
@@ -299,7 +363,81 @@
     }
 }
 
-void 
+void
+RadioBearerStatsConnector::ConnectTracesUeIfFirstTime (std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
+{
+  NS_LOG_FUNCTION (this << context);
+
+  //Connect PDCP and RLC traces for SRB1
+  if(m_imsiSeenUeSrb.find (imsi) == m_imsiSeenUeSrb.end ())
+  {
+      m_imsiSeenUeSrb.insert (imsi);
+      ConnectSrb1TracesUe (context, imsi, cellId, rnti);
+  }
+
+  //Look for the RLCs
+  std::string basePath = context.substr (0, context.rfind ("/"));
+  Config::MatchContainer rlc_container = Config::LookupMatches( basePath + "/DataRadioBearerMap/*/LteRlc/");
+  uint16_t numberOfRlc = rlc_container.GetN();
+
+  //Connect PDCP and RLC for data radio bearers
+  std::map<uint64_t,uint16_t>::iterator it = m_imsiSeenUeDrb.find(imsi);
+  if (it == m_imsiSeenUeDrb.end () && numberOfRlc > 0)
+    {
+      //If it is the first time for this imsi
+      NS_LOG_DEBUG("Insert imsi " + std::to_string(imsi));
+      m_imsiSeenUeDrb.insert (m_imsiSeenUeDrb.end(), std::pair<uint64_t,uint16_t>(imsi, 1));
+      ConnectDrbTracesUe (context, imsi, cellId, rnti);
+    }
+  else
+    {
+      if(it->second < numberOfRlc)
+      {
+        //If this imsi has already been connected but a new DRB is established
+        NS_LOG_DEBUG("There is a new RLC. Call ConnectDrbTracesUe to connect the traces.");
+        it->second ++; //TODO Check if there could be more than one RLC to connect
+        ConnectDrbTracesUe (context, imsi, cellId, rnti);
+      }
+      else
+      {
+        it->second = numberOfRlc; //One or more DRBs could have been removed
+        NS_LOG_DEBUG("All RLCs traces are already connected. No need for a call to ConnectDrbTracesUe.");
+      }
+    }
+
+    //Debug: print map
+    for( std::map<uint64_t,uint16_t>::const_iterator it2 = m_imsiSeenUeDrb.begin(); it2!=m_imsiSeenUeDrb.end(); ++it2 )
+    {
+      NS_LOG_DEBUG("imsi " + std::to_string(it2->first) + "\tnum of rlc " + std::to_string(it2->second));
+    }
+}
+
+void
+RadioBearerStatsConnector::ConnectTracesEnbIfFirstTime (std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
+{
+  NS_LOG_FUNCTION (this << context);
+
+  //Connect PDCP and RLC traces for SRB1
+  if(m_imsiSeenEnbSrb.find (imsi) == m_imsiSeenEnbSrb.end ())
+  {
+    m_imsiSeenEnbSrb.insert (imsi);
+    ConnectSrb1TracesEnb (context, imsi, cellId, rnti);
+  }
+
+  //Connect PDCP and RLC for data radio bearers
+  //Look for the RLCs
+  std::string basePath = context.substr (0, context.rfind ("/")) + "/UeMap/" + std::to_string((uint32_t) rnti);
+  Config::MatchContainer rlc_container = Config::LookupMatches(basePath +  "/DataRadioBearerMap/*/LteRlc/");
+
+   if (m_imsiSeenEnbDrb.find (imsi) == m_imsiSeenEnbDrb.end () && rlc_container.GetN() > 0)
+    {
+      //it is executed only if there exist at least one rlc layer
+      m_imsiSeenEnbDrb.insert (imsi);
+      ConnectDrbTracesEnb (context, imsi, cellId, rnti);
+    }
+}
+
+void
 RadioBearerStatsConnector::ConnectSrb1TracesUe (std::string ueRrcPath, uint64_t imsi, uint16_t cellId, uint16_t rnti)
 {
   NS_LOG_FUNCTION (this << imsi << cellId << rnti);
@@ -307,7 +445,7 @@
     {
       Ptr<BoundCallbackArgument> arg = Create<BoundCallbackArgument> ();
       arg->imsi = imsi;
-      arg->cellId = cellId; 
+      arg->cellId = cellId;
       arg->stats = m_rlcStats;
       Config::Connect (ueRrcPath + "/Srb1/LteRlc/TxPDU",
                        MakeBoundCallback (&UlTxPduCallback, arg));
@@ -318,39 +456,17 @@
     {
       Ptr<BoundCallbackArgument> arg = Create<BoundCallbackArgument> ();
       arg->imsi = imsi;
-      arg->cellId = cellId; 
+      arg->cellId = cellId;
       arg->stats = m_pdcpStats;
       Config::Connect (ueRrcPath + "/Srb1/LtePdcp/RxPDU",
-		       MakeBoundCallback (&DlRxPduCallback, arg));
+           MakeBoundCallback (&DlRxPduCallback, arg));
       Config::Connect (ueRrcPath + "/Srb1/LtePdcp/TxPDU",
-		       MakeBoundCallback (&UlTxPduCallback, arg));
-    }
-}
-  
-void 
-RadioBearerStatsConnector::ConnectTracesUeIfFirstTime (std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
-{
-  NS_LOG_FUNCTION (this << context);
-  if (m_imsiSeenUe.find (imsi) == m_imsiSeenUe.end ())
-    {
-      m_imsiSeenUe.insert (imsi);
-      ConnectTracesUe (context, imsi, cellId, rnti);
-    }
-}
- 
-void 
-RadioBearerStatsConnector::ConnectTracesEnbIfFirstTime (std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
-{
-  NS_LOG_FUNCTION (this << context);
-   if (m_imsiSeenEnb.find (imsi) == m_imsiSeenEnb.end ())
-    {
-      m_imsiSeenEnb.insert (imsi);
-      ConnectTracesEnb (context, imsi, cellId, rnti);
+           MakeBoundCallback (&UlTxPduCallback, arg));
     }
 }
 
-void 
-RadioBearerStatsConnector::ConnectTracesUe (std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
+void
+RadioBearerStatsConnector::ConnectDrbTracesUe (std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
 {
   NS_LOG_FUNCTION (this << context);
   NS_LOG_LOGIC (this << "expected context should match /NodeList/*/DeviceList/*/LteUeRrc/");
@@ -359,37 +475,38 @@
     {
       Ptr<BoundCallbackArgument> arg = Create<BoundCallbackArgument> ();
       arg->imsi = imsi;
-      arg->cellId = cellId; 
+      arg->cellId = cellId;
       arg->stats = m_rlcStats;
       Config::Connect (basePath + "/DataRadioBearerMap/*/LteRlc/TxPDU",
 		       MakeBoundCallback (&UlTxPduCallback, arg));
       Config::Connect (basePath + "/DataRadioBearerMap/*/LteRlc/RxPDU",
 		       MakeBoundCallback (&DlRxPduCallback, arg));
-      Config::Connect (basePath + "/Srb1/LteRlc/TxPDU",
-		       MakeBoundCallback (&UlTxPduCallback, arg));
-      Config::Connect (basePath + "/Srb1/LteRlc/RxPDU",
-		       MakeBoundCallback (&DlRxPduCallback, arg));
 
     }
   if (m_pdcpStats)
     {
       Ptr<BoundCallbackArgument> arg = Create<BoundCallbackArgument> ();
       arg->imsi = imsi;
-      arg->cellId = cellId; 
+      arg->cellId = cellId;
       arg->stats = m_pdcpStats;
       Config::Connect (basePath + "/DataRadioBearerMap/*/LtePdcp/RxPDU",
 		       MakeBoundCallback (&DlRxPduCallback, arg));
       Config::Connect (basePath + "/DataRadioBearerMap/*/LtePdcp/TxPDU",
 		       MakeBoundCallback (&UlTxPduCallback, arg));
-      Config::Connect (basePath + "/Srb1/LtePdcp/RxPDU",
-		       MakeBoundCallback (&DlRxPduCallback, arg));
-      Config::Connect (basePath + "/Srb1/LtePdcp/TxPDU",
-		       MakeBoundCallback (&UlTxPduCallback, arg));
+    }
+  if (m_retxStats) // TODO set condition
+    {
+      Ptr<BoundCallbackArgumentRetx> arg = Create<BoundCallbackArgumentRetx> ();
+      arg->imsi = imsi;
+      arg->cellId = cellId;
+      arg->stats = m_retxStats;
+      Config::Connect (basePath + "/DataRadioBearerMap/*/LteRlc/TxCompletedCallback",
+         MakeBoundCallback (&UlRetxCallback, arg));
     }
 }
 
-void 
-RadioBearerStatsConnector::ConnectTracesEnb (std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
+void
+RadioBearerStatsConnector::ConnectSrb1TracesEnb (std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
 {
   NS_LOG_FUNCTION (this << context);
   NS_LOG_LOGIC (this << "expected context  should match /NodeList/*/DeviceList/*/LteEnbRrc/");
@@ -399,12 +516,8 @@
     {
       Ptr<BoundCallbackArgument> arg = Create<BoundCallbackArgument> ();
       arg->imsi = imsi;
-      arg->cellId = cellId; 
+      arg->cellId = cellId;
       arg->stats = m_rlcStats;
-      Config::Connect (basePath.str () + "/DataRadioBearerMap/*/LteRlc/RxPDU",
-		       MakeBoundCallback (&UlRxPduCallback, arg));
-      Config::Connect (basePath.str () + "/DataRadioBearerMap/*/LteRlc/TxPDU",
-		       MakeBoundCallback (&DlTxPduCallback, arg));
       Config::Connect (basePath.str () + "/Srb0/LteRlc/RxPDU",
 		       MakeBoundCallback (&UlRxPduCallback, arg));
       Config::Connect (basePath.str () + "/Srb0/LteRlc/TxPDU",
@@ -418,12 +531,8 @@
     {
       Ptr<BoundCallbackArgument> arg = Create<BoundCallbackArgument> ();
       arg->imsi = imsi;
-      arg->cellId = cellId; 
+      arg->cellId = cellId;
       arg->stats = m_pdcpStats;
-      Config::Connect (basePath.str () + "/DataRadioBearerMap/*/LtePdcp/TxPDU",
-		       MakeBoundCallback (&DlTxPduCallback, arg));
-      Config::Connect (basePath.str () + "/DataRadioBearerMap/*/LtePdcp/RxPDU",
-		       MakeBoundCallback (&UlRxPduCallback, arg));
       Config::Connect (basePath.str () + "/Srb1/LtePdcp/TxPDU",
 		       MakeBoundCallback (&DlTxPduCallback, arg));
       Config::Connect (basePath.str () + "/Srb1/LtePdcp/RxPDU",
@@ -431,14 +540,55 @@
     }
 }
 
-void 
+void
+RadioBearerStatsConnector::ConnectDrbTracesEnb (std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
+{
+  NS_LOG_FUNCTION (this << context);
+  NS_LOG_LOGIC (this << "expected context  should match /NodeList/*/DeviceList/*/LteEnbRrc/");
+  std::ostringstream basePath;
+  basePath <<  context.substr (0, context.rfind ("/")) << "/UeMap/" << (uint32_t) rnti;
+  if (m_rlcStats)
+    {
+      Ptr<BoundCallbackArgument> arg = Create<BoundCallbackArgument> ();
+      arg->imsi = imsi;
+      arg->cellId = cellId;
+      arg->stats = m_rlcStats;
+      Config::Connect (basePath.str () + "/DataRadioBearerMap/*/LteRlc/RxPDU",
+		       MakeBoundCallback (&UlRxPduCallback, arg));
+      Config::Connect (basePath.str () + "/DataRadioBearerMap/*/LteRlc/TxPDU",
+		       MakeBoundCallback (&DlTxPduCallback, arg));
+    }
+  if (m_pdcpStats)
+    {
+      Ptr<BoundCallbackArgument> arg = Create<BoundCallbackArgument> ();
+      arg->imsi = imsi;
+      arg->cellId = cellId;
+      arg->stats = m_pdcpStats;
+      Config::Connect (basePath.str () + "/DataRadioBearerMap/*/LtePdcp/TxPDU",
+		       MakeBoundCallback (&DlTxPduCallback, arg));
+      Config::Connect (basePath.str () + "/DataRadioBearerMap/*/LtePdcp/RxPDU",
+		       MakeBoundCallback (&UlRxPduCallback, arg));
+    }
+  if (m_retxStats)
+    {
+      Ptr<BoundCallbackArgumentRetx> arg = Create<BoundCallbackArgumentRetx> ();
+      arg->imsi = imsi;
+      arg->cellId = cellId;
+      arg->stats = m_retxStats;
+      Config::Connect (basePath.str () + "/DataRadioBearerMap/*/LteRlc/TxCompletedCallback",
+         MakeBoundCallback (&DlRetxCallback, arg));
+    }
+}
+
+
+void
 RadioBearerStatsConnector::DisconnectTracesUe (std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
 {
   NS_LOG_FUNCTION (this);
 }
 
 
-void 
+void
 RadioBearerStatsConnector::DisconnectTracesEnb (std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
 {
   NS_LOG_FUNCTION (this);
diff -Naru a/helper/radio-bearer-stats-connector.h b/helper/radio-bearer-stats-connector.h
--- a/helper/radio-bearer-stats-connector.h	2018-08-03 16:38:46.535805709 +0200
+++ b/helper/radio-bearer-stats-connector.h	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2018, University of Padova, Dep. of Information Engineering, SIGNET lab.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+ *							Integration of Carrier Aggregation for the mmWave module
  */
 
 
@@ -28,9 +32,13 @@
 #include <ns3/config.h>
 #include <ns3/simple-ref-count.h>
 #include <ns3/ptr.h>
-
+#include <ns3/object.h>
+#include <fstream>
 #include <set>
 #include <map>
+#include "retx-stats-calculator.h"
+#include "mac-tx-stats-calculator.h"
+
 
 namespace ns3 {
 
@@ -193,15 +201,6 @@
   void ConnectSrb0Traces (std::string ueRrcPath, uint64_t imsi, uint16_t cellId, uint16_t rnti);
 
   /**
-   * Connects Srb1 trace sources at UE to RLC and PDCP calculators
-   * \param ueRrcPath
-   * \param imsi
-   * \param cellId
-   * \param rnti
-   */
-  void ConnectSrb1TracesUe (std::string ueRrcPath, uint64_t imsi, uint16_t cellId, uint16_t rnti);
-
-  /**
    * Connects all trace sources at UE to RLC and PDCP calculators.
    * This function can connect traces only once for UE.
    * \param context
@@ -222,13 +221,23 @@
   void ConnectTracesEnbIfFirstTime (std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti);
 
   /**
-   * Connects all trace sources at UE to RLC and PDCP calculators.
+   * Connects SRB1 trace sources at UE to RLC and PDCP calculators
+   * \param ueRrcPath
+   * \param imsi
+   * \param cellId
+   * \param rnti
+   */
+  void ConnectSrb1TracesUe (std::string ueRrcPath, uint64_t imsi, uint16_t cellId, uint16_t rnti);
+
+  /**
+   * Connects DRBs trace sources at UE to RLC and PDCP calculators.
    * \param context
    * \param imsi
    * \param cellid
    * \param rnti
    */
-  void ConnectTracesUe (std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti);
+  void ConnectDrbTracesUe (std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti);
+
 
   /**
    * Disconnects all trace sources at UE to RLC and PDCP calculators.
@@ -241,13 +250,23 @@
   void DisconnectTracesUe (std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti);
 
   /**
-   * Connects all trace sources at eNB to RLC and PDCP calculators
+   * Connects SRB1 trace sources at eNB to RLC and PDCP calculators
    * \param context
    * \param imsi
    * \param cellid
    * \param rnti
    */
-  void ConnectTracesEnb (std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti);
+  void ConnectSrb1TracesEnb (std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti);
+
+  /**
+   * Connects DRBs trace sources at eNB to RLC and PDCP calculators
+   * \param context
+   * \param imsi
+   * \param cellid
+   * \param rnti
+   */
+  void ConnectDrbTracesEnb (std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti);
+
 
   /**
    * Disconnects all trace sources at eNB to RLC and PDCP calculators.
@@ -262,11 +281,16 @@
 
   Ptr<RadioBearerStatsCalculator> m_rlcStats; //!< Calculator for RLC Statistics
   Ptr<RadioBearerStatsCalculator> m_pdcpStats; //!< Calculator for PDCP Statistics
+  Ptr<RetxStatsCalculator> m_retxStats;
+  Ptr<MacTxStatsCalculator> m_macTxStats;
+
 
   bool m_connected; //!< true if traces are connected to sinks, initially set to false
-  std::set<uint64_t> m_imsiSeenUe; //!< stores all UEs for which RLC and PDCP traces were connected
-  std::set<uint64_t> m_imsiSeenEnb; //!< stores all eNBs for which RLC and PDCP traces were connected
-  
+  std::set<uint64_t> m_imsiSeenUeSrb; //!< stores all UEs for which RLC and PDCP for SRB1 traces were connected
+  std::set<uint64_t> m_imsiSeenEnbSrb; //!< stores all eNBs for which RLC and PDCP traces and SRB1 were connected
+  std::map<uint64_t,uint16_t> m_imsiSeenUeDrb; //!< stores all UEs for which RLC and PDCP traces for DRBs were connected
+  std::set<uint64_t> m_imsiSeenEnbDrb; //!< stores all eNBs for which RLC and PDCP traces for drbs were connected
+
   /**
    * Struct used as key in m_ueManagerPathByCellIdRnti map
    */
@@ -278,10 +302,6 @@
 
   /**
    * Less than operator for CellIdRnti, because it is used as key in map
-   *
-   * \param a the lhs operand
-   * \param b the rhs operand
-   * \returns true if less than
    */
   friend bool operator < (const CellIdRnti &a, const CellIdRnti &b);
 
diff -Naru a/helper/radio-environment-map-helper.cc b/helper/radio-environment-map-helper.cc
--- a/helper/radio-environment-map-helper.cc	2018-08-03 16:38:46.535805709 +0200
+++ b/helper/radio-environment-map-helper.cc	2018-08-03 16:39:02.875957522 +0200
@@ -130,7 +130,7 @@
     .AddAttribute ("Bandwidth",
                    "Transmission Bandwidth Configuration (in number of RBs) over which the SINR will be calculated",
                    UintegerValue (25),
-                   MakeUintegerAccessor (&RadioEnvironmentMapHelper::SetBandwidth, 
+                   MakeUintegerAccessor (&RadioEnvironmentMapHelper::SetBandwidth,
                                          &RadioEnvironmentMapHelper::GetBandwidth),
                    MakeUintegerChecker<uint16_t> ())
     .AddAttribute ("UseDataChannel",
@@ -149,17 +149,17 @@
 }
 
 
-uint8_t 
+uint8_t
 RadioEnvironmentMapHelper::GetBandwidth () const
 {
   return m_bandwidth;
 }
 
-void 
+void
 RadioEnvironmentMapHelper::SetBandwidth (uint8_t bw)
 {
   switch (bw)
-    { 
+    {
     case 6:
     case 15:
     case 25:
@@ -177,7 +177,7 @@
 
 
 
-void 
+void
 RadioEnvironmentMapHelper::Install ()
 {
   NS_LOG_FUNCTION (this);
@@ -199,7 +199,7 @@
       NS_FATAL_ERROR ("Can't open file " << (m_outputFile));
       return;
     }
-  
+
   double startDelay = 0.0026;
 
   if (m_useDataChannel)
@@ -214,18 +214,18 @@
 }
 
 
-void 
+void
 RadioEnvironmentMapHelper::DelayedInstall ()
 {
   NS_LOG_FUNCTION (this);
   m_xStep = (m_xMax - m_xMin)/(m_xRes-1);
   m_yStep = (m_yMax - m_yMin)/(m_yRes-1);
-  
+
   if ((double)m_xRes * (double) m_yRes < (double) m_maxPointsPerIteration)
     {
       m_maxPointsPerIteration = m_xRes * m_yRes;
     }
-  
+
   for (uint32_t i = 0; i < m_maxPointsPerIteration; ++i)
     {
       RemPoint p;
@@ -256,28 +256,28 @@
               yMinNext = y;
               justScheduled = false;
             }
-          
+
           ++numPointsCurrentIteration;
           if ((numPointsCurrentIteration == m_maxPointsPerIteration)
               || ((x > m_xMax - 0.5*m_xStep) && (y > m_yMax - 0.5*m_yStep)) )
             {
-              Simulator::Schedule (Seconds (remIterationStartTime), 
+              Simulator::Schedule (Seconds (remIterationStartTime),
                                    &RadioEnvironmentMapHelper::RunOneIteration,
                                    this, xMinNext, x, yMinNext, y);
               remIterationStartTime += 0.001;
               justScheduled = true;
               numPointsCurrentIteration = 0;
             }
-        }      
+        }
     }
 
-  Simulator::Schedule (Seconds (remIterationStartTime), 
+  Simulator::Schedule (Seconds (remIterationStartTime),
                        &RadioEnvironmentMapHelper::Finalize,
                        this);
 }
 
-  
-void 
+
+void
 RadioEnvironmentMapHelper::RunOneIteration (double xMin, double xMax, double yMin, double yMax)
 {
   NS_LOG_FUNCTION (this << xMin << xMax << yMin << yMax);
@@ -294,7 +294,7 @@
           remIt->bmm->SetPosition (Vector (x, y, m_z));
           BuildingsHelper::MakeConsistent (remIt->bmm);
           ++remIt;
-        }      
+        }
     }
 
   if (remIt != m_rem.end ())
@@ -308,14 +308,14 @@
         }
     }
 
-  Simulator::Schedule (Seconds (0.0005), &RadioEnvironmentMapHelper::PrintAndReset, this);  
+  Simulator::Schedule (Seconds (0.0005), &RadioEnvironmentMapHelper::PrintAndReset, this);
 }
 
-void 
+void
 RadioEnvironmentMapHelper::PrintAndReset ()
 {
   NS_LOG_FUNCTION (this);
-  
+
   for (std::list<RemPoint>::iterator it = m_rem.begin ();
        it != m_rem.end ();
        ++it)
@@ -327,20 +327,20 @@
           break;
         }
       Vector pos = it->bmm->GetPosition ();
-      NS_LOG_LOGIC ("output: " << pos.x << "\t" 
-                    << pos.y << "\t" 
-                    << pos.z << "\t" 
+      NS_LOG_LOGIC ("output: " << pos.x << "\t"
+                    << pos.y << "\t"
+                    << pos.z << "\t"
                     << it->phy->GetSinr (m_noisePower));
-      m_outFile << pos.x << "\t" 
-                << pos.y << "\t" 
-                << pos.z << "\t" 
+      m_outFile << pos.x << "\t"
+                << pos.y << "\t"
+                << pos.z << "\t"
                 << it->phy->GetSinr (m_noisePower)
                 << std::endl;
       it->phy->Reset ();
     }
 }
 
-void 
+void
 RadioEnvironmentMapHelper::Finalize ()
 {
   NS_LOG_FUNCTION (this);
diff -Naru a/helper/retx-stats-calculator.cc b/helper/retx-stats-calculator.cc
--- a/helper/retx-stats-calculator.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/helper/retx-stats-calculator.cc	2018-08-03 16:39:02.875957522 +0200
@@ -0,0 +1,101 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2017 SIGNET Lab, Dept. of Information Engineering, UNIPD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Jaume Nin <jnin@cttc.es>
+ *         Nicola Baldo <nbaldo@cttc.es>
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ */
+
+#include "retx-stats-calculator.h"
+#include "ns3/string.h"
+#include "ns3/nstime.h"
+#include <ns3/log.h>
+#include <vector>
+#include <algorithm>
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("RetxStatsCalculator");
+
+NS_OBJECT_ENSURE_REGISTERED ( RetxStatsCalculator);
+
+RetxStatsCalculator::RetxStatsCalculator ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+
+RetxStatsCalculator::~RetxStatsCalculator ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+TypeId
+RetxStatsCalculator::GetTypeId (void)
+{
+  static TypeId tid =
+    TypeId ("ns3::RetxStatsCalculator")
+    .SetParent<Object> ().AddConstructor<RetxStatsCalculator> ()
+    .SetGroupName("Lte")
+    .AddAttribute ("DlRlcRetxFilename",
+                   "Name of the file where the downlink retx results will be saved.",
+                   StringValue ("DlRlcRetx.txt"),
+                   MakeStringAccessor (&RetxStatsCalculator::m_retxDlFilename),
+                   MakeStringChecker ())
+    .AddAttribute ("UlRlcRetxFilename",
+                   "Name of the file where the uplink retx results will be saved.",
+                   StringValue ("UlRlcRetx.txt"),
+                   MakeStringAccessor (&RetxStatsCalculator::m_retxUlFilename),
+                   MakeStringChecker ())
+    ;
+  return tid;
+}
+
+void
+RetxStatsCalculator::DoDispose ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+void
+RetxStatsCalculator::RegisterRetxDl(uint64_t imsi, uint16_t cellId, 
+	uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx)
+{
+	if(!m_retxDlFile.is_open())
+	{
+	    m_retxDlFile.open(m_retxDlFilename.c_str());
+	    NS_LOG_LOGIC("File opened");
+  	}
+	m_retxDlFile << Simulator::Now().GetSeconds() << " " << cellId << " " << imsi << " "
+		<< rnti << " " << (uint16_t) lcid << " " << packetSize << " " << numRetx << std::endl;
+}
+
+void
+RetxStatsCalculator::RegisterRetxUl(uint64_t imsi, uint16_t cellId, 
+	uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx)
+{
+	if(!m_retxUlFile.is_open())
+	{
+	    m_retxUlFile.open(m_retxUlFilename.c_str());
+	    NS_LOG_LOGIC("File opened");
+  	}
+	m_retxUlFile << Simulator::Now().GetSeconds() << " " << cellId << " " << imsi << " "
+		<< rnti << " " << (uint16_t) lcid << " " << packetSize << " " << numRetx << std::endl;
+}
+
+}
\ No newline at end of file
diff -Naru a/helper/retx-stats-calculator.h b/helper/retx-stats-calculator.h
--- a/helper/retx-stats-calculator.h	1970-01-01 01:00:00.000000000 +0100
+++ b/helper/retx-stats-calculator.h	2018-08-03 16:39:02.875957522 +0200
@@ -0,0 +1,73 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2017 SIGNET Lab, Dept. of Information Engineering, UNIPD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Jaume Nin <jnin@cttc.es>
+ *         Nicola Baldo <nbaldo@cttc.es>
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ */
+
+#ifndef RETX_STATS_CALCULATOR_H_
+#define RETX_STATS_CALCULATOR_H_
+
+#include "ns3/lte-common.h"
+#include "ns3/uinteger.h"
+#include "ns3/object.h"
+#include "ns3/basic-data-calculators.h"
+#include "ns3/lte-common.h"
+#include <string>
+#include <map>
+#include <fstream>
+
+namespace ns3
+{
+
+class RetxStatsCalculator : public Object
+{
+public:
+  /**
+   * Class constructor
+   */
+  RetxStatsCalculator ();
+
+  /**
+   * Class destructor
+   */
+  virtual
+  ~RetxStatsCalculator ();
+
+  // Inherited from ns3::Object
+  /**
+   *  Register this type.
+   *  \return The object TypeId.
+   */
+  static TypeId GetTypeId (void);
+  void DoDispose ();
+
+  void RegisterRetxDl(uint64_t imsi, uint16_t cellId, uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx);
+  void RegisterRetxUl(uint64_t imsi, uint16_t cellId, uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx);
+
+  std::ofstream m_retxDlFile;
+  std::string m_retxDlFilename;
+
+  std::ofstream m_retxUlFile;
+  std::string m_retxUlFilename;
+};
+
+}
+
+#endif /* RETX_STATS_CALCULATOR_H_ */
diff -Naru a/model/cqa-ff-mac-scheduler.cc b/model/cqa-ff-mac-scheduler.cc
--- a/model/cqa-ff-mac-scheduler.cc	2018-08-03 16:38:46.539805747 +0200
+++ b/model/cqa-ff-mac-scheduler.cc	2018-08-03 16:39:02.875957522 +0200
@@ -120,7 +120,7 @@
  * \param key1 the first item
  * \param key2 the second item
  * \returns true if the first item > the second item
- */  
+ */
 bool CqaKeyDescComparator (uint16_t key1, uint16_t key2)
 {
   return key1>key2;
@@ -383,7 +383,7 @@
           NS_FATAL_ERROR ("Logical channels cannot be released because it can not be found in the list of active LCs");
         }
     }
-	
+
   for (uint16_t i = 0; i < params.m_logicalChannelIdentity.size (); i++)
     {
       std::map<LteFlowId_t, FfMacSchedSapProvider::SchedDlRlcBufferReqParameters>::iterator it = m_rlcBufferReq.begin ();
@@ -766,7 +766,7 @@
         {
           m_rachAllocationMap.at (i) = (*itRach).m_rnti;
         }
-      
+
       if (m_harqOn == true)
         {
           // generate UL-DCI for HARQ retransmissions
@@ -804,7 +804,7 @@
             }
           (*itDci).second.at (harqId) = uldci;
         }
-      
+
       rbStart = rbStart + rbLen;
       ret.m_buildRarList.push_back (newRar);
     }
@@ -1087,7 +1087,7 @@
     }
 
   std::map <LteFlowId_t,struct LogicalChannelConfigListElement_s>::iterator itLogicalChannels;
-	
+
   for (itLogicalChannels = m_ueLogicalChannelsConfigList.begin (); itLogicalChannels != m_ueLogicalChannelsConfigList.end (); itLogicalChannels++)
     {
       std::set <uint16_t>::iterator itRnti = rntiAllocated.find (itLogicalChannels->first.m_rnti);
@@ -1203,7 +1203,7 @@
           NS_LOG_INFO ("Skip this flow, CQI==0, rnti:"<<(*itrbr).first.m_rnti);
           continue;
         }
-      
+
       // map: UE, to the amount of traffic they have to transfer
       int amountOfDataToTransfer =  8*((int)m_rlcBufferReq.find (flowId)->second.m_rlcRetransmissionQueueSize +
                                        (int)m_rlcBufferReq.find (flowId)->second.m_rlcTransmissionQueueSize);
@@ -2498,7 +2498,7 @@
               // for SRB1 (using RLC AM) it's better to
               // overestimate RLC overhead rather than
               // underestimate it and risk unneeded
-              // segmentation which increases delay 
+              // segmentation which increases delay
               rlcOverhead = 4;
             }
           else
diff -Naru a/model/epc-enb-application.cc b/model/epc-enb-application.cc
--- a/model/epc-enb-application.cc	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-enb-application.cc	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Jaume Nin <jnin@cttc.cat>
  *         Nicola Baldo <nbaldo@cttc.cat>
+ *
+ * Modified by Michele Polese <michele.polese@gmail.com>
+ *     (support for RRC_CONNECTED->RRC_IDLE state transition + support for real S1AP link)
  */
 
 
@@ -87,15 +91,16 @@
   delete m_s1apSapEnb;
 }
 
+
 EpcEnbApplication::EpcEnbApplication (Ptr<Socket> lteSocket, Ptr<Socket> lteSocket6, Ptr<Socket> s1uSocket, Ipv4Address enbS1uAddress, Ipv4Address sgwS1uAddress, uint16_t cellId)
   : m_lteSocket (lteSocket),
     m_lteSocket6 (lteSocket6),
-    m_s1uSocket (s1uSocket),    
+    m_s1uSocket (s1uSocket),
     m_enbS1uAddress (enbS1uAddress),
     m_sgwS1uAddress (sgwS1uAddress),
     m_gtpuUdpPort (2152), // fixed by the standard
     m_s1SapUser (0),
-    m_s1apSapMme (0),
+    m_s1apSapEnbProvider (0),
     m_cellId (cellId)
 {
   NS_LOG_FUNCTION (this << lteSocket << s1uSocket << sgwS1uAddress);
@@ -113,46 +118,46 @@
 }
 
 
-void 
+void
 EpcEnbApplication::SetS1SapUser (EpcEnbS1SapUser * s)
 {
   m_s1SapUser = s;
 }
 
-  
-EpcEnbS1SapProvider* 
+
+EpcEnbS1SapProvider*
 EpcEnbApplication::GetS1SapProvider ()
 {
   return m_s1SapProvider;
 }
 
-void 
-EpcEnbApplication::SetS1apSapMme (EpcS1apSapMme * s)
+void
+EpcEnbApplication::SetS1apSapMme (EpcS1apSapEnbProvider * s)
 {
-  m_s1apSapMme = s;
+  m_s1apSapEnbProvider = s;
 }
 
-  
-EpcS1apSapEnb* 
+
+EpcS1apSapEnb*
 EpcEnbApplication::GetS1apSapEnb ()
 {
   return m_s1apSapEnb;
 }
 
-void 
+void
 EpcEnbApplication::DoInitialUeMessage (uint64_t imsi, uint16_t rnti)
 {
   NS_LOG_FUNCTION (this);
   // side effect: create entry if not exist
   m_imsiRntiMap[imsi] = rnti;
-  m_s1apSapMme->InitialUeMessage (imsi, rnti, imsi, m_cellId);
+  m_s1apSapEnbProvider->SendInitialUeMessage (imsi, rnti, imsi, m_cellId); // TODO if more than one MME is used, extend this call
 }
 
-void 
+void
 EpcEnbApplication::DoPathSwitchRequest (EpcEnbS1SapProvider::PathSwitchRequestParameters params)
 {
   NS_LOG_FUNCTION (this);
-  uint16_t enbUeS1Id = params.rnti;  
+  uint16_t enbUeS1Id = params.rnti;
   uint64_t mmeUeS1Id = params.mmeUeS1Id;
   uint64_t imsi = mmeUeS1Id;
   // side effect: create entry if not exist
@@ -168,7 +173,7 @@
       flowId.m_rnti = params.rnti;
       flowId.m_bid = bit->epsBearerId;
       uint32_t teid = bit->teid;
-      
+
       EpsFlowId_t rbid (params.rnti, bit->epsBearerId);
       // side effect: create entries if not exist
       m_rbidTeidMap[params.rnti][bit->epsBearerId] = teid;
@@ -181,10 +186,10 @@
 
       erabToBeSwitchedInDownlinkList.push_back (erab);
     }
-  m_s1apSapMme->PathSwitchRequest (enbUeS1Id, mmeUeS1Id, gci, erabToBeSwitchedInDownlinkList);
+  m_s1apSapEnbProvider->SendPathSwitchRequest (enbUeS1Id, mmeUeS1Id, gci, erabToBeSwitchedInDownlinkList);
 }
 
-void 
+void
 EpcEnbApplication::DoUeContextRelease (uint16_t rnti)
 {
   NS_LOG_FUNCTION (this << rnti);
@@ -202,22 +207,22 @@
     }
 }
 
-void 
+void
 EpcEnbApplication::DoInitialContextSetupRequest (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapEnb::ErabToBeSetupItem> erabToBeSetupList)
 {
   NS_LOG_FUNCTION (this);
-  
+  NS_LOG_INFO("In EnpEnbApplication DoInitialContextSetupRequest size of the erabToBeSetupList is " << erabToBeSetupList.size());
+
   for (std::list<EpcS1apSapEnb::ErabToBeSetupItem>::iterator erabIt = erabToBeSetupList.begin ();
        erabIt != erabToBeSetupList.end ();
        ++erabIt)
     {
       // request the RRC to setup a radio bearer
-
       uint64_t imsi = mmeUeS1Id;
       std::map<uint64_t, uint16_t>::iterator imsiIt = m_imsiRntiMap.find (imsi);
       NS_ASSERT_MSG (imsiIt != m_imsiRntiMap.end (), "unknown IMSI");
       uint16_t rnti = imsiIt->second;
-      
+
       struct EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters params;
       params.rnti = rnti;
       params.bearer = erabIt->erabLevelQosParameters;
@@ -233,7 +238,7 @@
     }
 }
 
-void 
+void
 EpcEnbApplication::DoPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<EpcS1apSapEnb::ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList)
 {
   NS_LOG_FUNCTION (this);
@@ -247,10 +252,10 @@
   m_s1SapUser->PathSwitchRequestAcknowledge (params);
 }
 
-void 
+void
 EpcEnbApplication::RecvFromLteSocket (Ptr<Socket> socket)
 {
-  NS_LOG_FUNCTION (this);  
+  NS_LOG_FUNCTION (this);
   if(m_lteSocket6)
     {
       NS_ASSERT (socket == m_lteSocket || socket == m_lteSocket6);
@@ -261,6 +266,11 @@
     }
   Ptr<Packet> packet = socket->Recv ();
 
+  /// \internal
+  /// Workaround for \bugid{231}
+  //SocketAddressTag satag;
+  //packet->RemovePacketTag (satag);
+
   EpsBearerTag tag;
   bool found = packet->RemovePacketTag (tag);
   NS_ASSERT (found);
@@ -270,7 +280,7 @@
   std::map<uint16_t, std::map<uint8_t, uint32_t> >::iterator rntiIt = m_rbidTeidMap.find (rnti);
   if (rntiIt == m_rbidTeidMap.end ())
     {
-      NS_LOG_WARN ("UE context not found, discarding packet");
+      NS_LOG_WARN ("UE context not found, discarding packet when receiving from lteSocket");
     }
   else
     {
@@ -282,26 +292,38 @@
     }
 }
 
-void 
+void
 EpcEnbApplication::RecvFromS1uSocket (Ptr<Socket> socket)
 {
-  NS_LOG_FUNCTION (this << socket);  
+  NS_LOG_FUNCTION (this << socket);
   NS_ASSERT (socket == m_s1uSocket);
   Ptr<Packet> packet = socket->Recv ();
   GtpuHeader gtpu;
   packet->RemoveHeader (gtpu);
   uint32_t teid = gtpu.GetTeid ();
-  std::map<uint32_t, EpsFlowId_t>::iterator it = m_teidRbidMap.find (teid);
-  NS_ASSERT (it != m_teidRbidMap.end ());
 
-  m_rxS1uSocketPktTrace (packet->Copy ());
-  SendToLteSocket (packet, it->second.m_rnti, it->second.m_bid);
+  /// \internal
+  /// Workaround for \bugid{231}
+  //SocketAddressTag tag;
+  //packet->RemovePacketTag (tag);
+
+  std::map<uint32_t, EpsFlowId_t>::iterator it = m_teidRbidMap.find (teid);
+  if (it != m_teidRbidMap.end ())
+    {
+      m_rxS1uSocketPktTrace (packet->Copy ());
+      SendToLteSocket (packet, it->second.m_rnti, it->second.m_bid);
+    }
+  else
+    {
+      packet = 0;
+      NS_LOG_DEBUG("UE context not found, discarding packet when receiving from s1uSocket");
+    }
 }
 
-void 
+void
 EpcEnbApplication::SendToLteSocket (Ptr<Packet> packet, uint16_t rnti, uint8_t bid)
 {
-  NS_LOG_FUNCTION (this << packet << rnti << (uint16_t) bid << packet->GetSize ());  
+  NS_LOG_FUNCTION (this << packet << rnti << (uint16_t) bid << packet->GetSize ());
   EpsBearerTag tag (rnti, bid);
   packet->AddPacketTag (tag);
   uint8_t ipType;
@@ -327,15 +349,15 @@
 }
 
 
-void 
+void
 EpcEnbApplication::SendToS1uSocket (Ptr<Packet> packet, uint32_t teid)
 {
-  NS_LOG_FUNCTION (this << packet << teid <<  packet->GetSize ());  
+  NS_LOG_FUNCTION (this << packet << teid <<  packet->GetSize ());
   GtpuHeader gtpu;
   gtpu.SetTeid (teid);
   // From 3GPP TS 29.281 v10.0.0 Section 5.1
   // Length of the payload + the non obligatory GTP-U header
-  gtpu.SetLength (packet->GetSize () + gtpu.GetSerializedSize () - 8);  
+  gtpu.SetLength (packet->GetSize () + gtpu.GetSerializedSize () - 8);
   packet->AddHeader (gtpu);
   uint32_t flags = 0;
   m_s1uSocket->SendTo (packet, flags, InetSocketAddress (m_sgwS1uAddress, m_gtpuUdpPort));
@@ -350,7 +372,7 @@
   erab.erabId = bearerId;
   erabToBeReleaseIndication.push_back (erab);
   //From 3GPP TS 23401-950 Section 5.4.4.2, enB sends EPS bearer Identity in Bearer Release Indication message to MME
-  m_s1apSapMme->ErabReleaseIndication (imsi, rnti, erabToBeReleaseIndication);
+  m_s1apSapEnbProvider->SendErabReleaseIndication (imsi, rnti, erabToBeReleaseIndication);
 }
 
 }  // namespace ns3
diff -Naru a/model/epc-enb-application.h b/model/epc-enb-application.h
--- a/model/epc-enb-application.h	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-enb-application.h	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Jaume Nin <jnin@cttc.cat>
  *         Nicola Baldo <nbaldo@cttc.cat>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Support for real S1AP link
  */
 
 #ifndef EPC_ENB_APPLICATION_H
@@ -49,32 +53,27 @@
 class EpcEnbApplication : public Application
 {
 
-  /// allow MemberEpcEnbS1SapProvider<EpcEnbApplication> class friend access
   friend class MemberEpcEnbS1SapProvider<EpcEnbApplication>;
-  /// allow MemberEpcS1apSapEnb<EpcEnbApplication> class friend access
   friend class MemberEpcS1apSapEnb<EpcEnbApplication>;
 
 
+  // inherited from Object
 public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 protected:
   void DoDispose (void);
 
 public:
-  
-  
 
-  /** 
+
+
+  /**
    * Constructor
-   * 
+   *
    * \param lteSocket the socket to be used to send/receive IPv4 packets to/from the LTE radio interface
    * \param lteSocket the socket to be used to send/receive IPv6 packets to/from the LTE radio interface
    * \param s1uSocket the socket to be used to send/receive packets
-   * to/from the S1-U interface connected with the SGW 
+   * to/from the S1-U interface connected with the SGW
    * \param enbS1uAddress the IPv4 address of the S1-U interface of this eNB
    * \param sgwS1uAddress the IPv4 address at which this eNB will be able to reach its SGW for S1-U communications
    * \param cellId the identifier of the enb
@@ -83,48 +82,48 @@
 
   /**
    * Destructor
-   * 
+   *
    */
   virtual ~EpcEnbApplication (void);
 
 
-  /** 
+  /**
    * Set the S1 SAP User
-   * 
+   *
    * \param s the S1 SAP User
    */
   void SetS1SapUser (EpcEnbS1SapUser * s);
 
-  /** 
-   * 
+  /**
+   *
    * \return the S1 SAP Provider
    */
   EpcEnbS1SapProvider* GetS1SapProvider ();
 
-  /** 
-   * Set the MME side of the S1-AP SAP 
-   * 
-   * \param s the MME side of the S1-AP SAP 
-   */
-  void SetS1apSapMme (EpcS1apSapMme * s);
-
-  /** 
-   * 
-   * \return the ENB side of the S1-AP SAP 
+  /**
+   * Set the S1AP provider for the S1AP eNB endpoint
+   *
+   * \param s the S1AP provider
+   */
+  void SetS1apSapMme (EpcS1apSapEnbProvider * s);
+
+  /**
+   *
+   * \return the ENB side of the S1-AP SAP
    */
   EpcS1apSapEnb* GetS1apSapEnb ();
- 
-  /** 
+
+  /**
    * Method to be assigned to the recv callback of the LTE socket. It is called when the eNB receives a data packet from the radio interface that is to be forwarded to the SGW.
-   * 
+   *
    * \param socket pointer to the LTE socket
    */
   void RecvFromLteSocket (Ptr<Socket> socket);
 
 
-  /** 
+  /**
    * Method to be assigned to the recv callback of the S1-U socket. It is called when the eNB receives a data packet from the SGW that is to be forwarded to the UE.
-   * 
+   *
    * \param socket pointer to the S1-U socket
    */
   void RecvFromS1uSocket (Ptr<Socket> socket);
@@ -138,39 +137,16 @@
     (Ptr<Packet> packet);
 
 
-  /**
-   * EPS flow ID structure
-   */
   struct EpsFlowId_t
   {
-    uint16_t  m_rnti; ///< RNTI
-    uint8_t   m_bid; ///< Bid, the EPS Bearer IDentifier
+    uint16_t  m_rnti;
+    uint8_t   m_bid;
 
   public:
     EpsFlowId_t ();
-    /**
-     * Constructor
-     *
-     * \param a RNTI
-     * \param b bid
-     */
     EpsFlowId_t (const uint16_t a, const uint8_t b);
 
-    /**
-     * Comparison operator
-     *
-     * \param a first application
-     * \param b second application
-     * \returns true is the applications are "equal"
-     */
     friend bool operator == (const EpsFlowId_t &a, const EpsFlowId_t &b);
-    /**
-     * Less than operator
-     *
-     * \param a first application
-     * \param b second application
-     * \returns true is the applications are "equal"
-     */
     friend bool operator < (const EpsFlowId_t &a, const EpsFlowId_t &b);
   };
 
@@ -178,41 +154,15 @@
 private:
 
   // ENB S1 SAP provider methods
-  /**
-   * Initial UE message function
-   * \param imsi the IMSI
-   * \param rnti the RNTI
-   */
   void DoInitialUeMessage (uint64_t imsi, uint16_t rnti);
-  /**
-   * Path switch request function
-   * \param params PathSwitchRequestParameters
-   */
   void DoPathSwitchRequest (EpcEnbS1SapProvider::PathSwitchRequestParameters params);
-  /**
-   * UE Context Release function
-   * \param rnti the RNTI
-   */
   void DoUeContextRelease (uint16_t rnti);
-  
+
   // S1-AP SAP ENB methods
-  /**
-   * Initial Context Setup Request 
-   * \param mmeUeS1Id the MME UE S1 ID
-   * \param enbUeS1Id the ENB UE S1 ID
-   * \param erabToBeSetupList the ERAB setup list
-   */
   void DoInitialContextSetupRequest (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapEnb::ErabToBeSetupItem> erabToBeSetupList);
-  /**
-   * Path Switch Request Acknowledge 
-   * \param mmeUeS1Id the MME UE S1 ID
-   * \param enbUeS1Id the ENB UE S1 ID
-   * \param cgi the CGI
-   * \param erabToBeSwitchedInUplinkList the ERAB switched in uplink list
-   */
   void DoPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<EpcS1apSapEnb::ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList);
 
-  /** 
+  /**
    * \brief This function accepts bearer id corresponding to a particular UE and schedules indication of bearer release towards MME
    * \param imsi maps to mmeUeS1Id
    * \param rnti maps to enbUeS1Id
@@ -223,29 +173,29 @@
 
   /**
    * Send a packet to the UE via the LTE radio interface of the eNB
-   * 
+   *
    * \param packet t
-   * \param rnti maps to enbUeS1Id
    * \param bid the EPS Bearer IDentifier
    */
   void SendToLteSocket (Ptr<Packet> packet, uint16_t rnti, uint8_t bid);
 
 
-  /** 
+  /**
    * Send a packet to the SGW via the S1-U interface
-   * 
+   *
    * \param packet packet to be sent
    * \param teid the Tunnel Enpoint IDentifier
    */
   void SendToS1uSocket (Ptr<Packet> packet, uint32_t teid);
 
 
-  /** 
+
+  /**
    * internal method used for the actual setup of the S1 Bearer
-   * 
-   * \param teid the Tunnel Endpoint IDentifier
-   * \param rnti maps to enbUeS1Id
-   * \param bid the S1-U Bearer IDentifier
+   *
+   * \param teid
+   * \param rnti
+   * \param bid
    */
   void SetupS1Bearer (uint32_t teid, uint16_t rnti, uint8_t bid);
 
@@ -259,6 +209,7 @@
    */
   Ptr<Socket> m_lteSocket6;
 
+
   /**
    * UDP socket to send and receive GTP-U the packets to and from the S1-U interface
    */
@@ -276,63 +227,62 @@
 
   /**
    * map of maps telling for each RNTI and BID the corresponding  S1-U TEID
-   * 
+   *
    */
-  std::map<uint16_t, std::map<uint8_t, uint32_t> > m_rbidTeidMap;  
+  std::map<uint16_t, std::map<uint8_t, uint32_t> > m_rbidTeidMap;
 
   /**
    * map telling for each S1-U TEID the corresponding RNTI,BID
-   * 
+   *
    */
   std::map<uint32_t, EpsFlowId_t> m_teidRbidMap;
- 
+
   /**
    * UDP port to be used for GTP
    */
   uint16_t m_gtpuUdpPort;
 
   /**
-   * Provider for the S1 SAP 
+   * Provider for the S1 SAP
    */
   EpcEnbS1SapProvider* m_s1SapProvider;
 
   /**
-   * User for the S1 SAP 
+   * User for the S1 SAP
    */
   EpcEnbS1SapUser* m_s1SapUser;
 
   /**
-   * MME side of the S1-AP SAP
-   * 
+   * Provider for the methods of S1AP eNB endpoint
+   *
    */
-  EpcS1apSapMme* m_s1apSapMme;
+  EpcS1apSapEnbProvider* m_s1apSapEnbProvider;
 
   /**
-   * ENB side of the S1-AP SAP
-   * 
+   * ENB side of the S1-AP SAP eNB endpoint
+   *
    */
   EpcS1apSapEnb* m_s1apSapEnb;
 
   /**
    * UE context info
-   * 
+   *
    */
   std::map<uint64_t, uint16_t> m_imsiRntiMap;
 
-  uint16_t m_cellId; ///< cell ID
+  uint16_t m_cellId;
 
   /**
    * \brief Callback to trace RX (reception) data packets from LTE Socket.
-   */ 
+   */
   TracedCallback<Ptr<Packet> > m_rxLteSocketPktTrace;
 
   /**
    * \brief Callback to trace RX (reception) data packets from S1-U Socket.
-   */ 
+   */
   TracedCallback<Ptr<Packet> > m_rxS1uSocketPktTrace;
 };
 
 } //namespace ns3
 
 #endif /* EPC_ENB_APPLICATION_H */
-
diff -Naru a/model/epc-enb-s1-sap.h b/model/epc-enb-s1-sap.h
--- a/model/epc-enb-s1-sap.h	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-enb-s1-sap.h	2018-08-03 16:39:02.875957522 +0200
@@ -57,27 +57,20 @@
    */
   virtual void DoSendReleaseIndication (uint64_t imsi, uint16_t rnti, uint8_t bearerId) = 0;
 
-  /// BearerToBeSwitched structure
   struct BearerToBeSwitched
   {
-    uint8_t epsBearerId; ///< Bearer ID
-    uint32_t teid; ///< TEID
+    uint8_t epsBearerId;
+    uint32_t teid;
   };
   
-  /// PathSwitchRequestParameters structure
   struct PathSwitchRequestParameters
   {
-    uint16_t rnti; ///< RNTI
-    uint16_t cellId; ///< cell ID
-    uint32_t mmeUeS1Id; ///< mmeUeS1Id in practice, we use the IMSI
-    std::list<BearerToBeSwitched> bearersToBeSwitched; ///< list of bearers to be switched 
+    uint16_t rnti;
+    uint16_t cellId;
+    uint32_t mmeUeS1Id;
+    std::list<BearerToBeSwitched> bearersToBeSwitched;
   };
 
-  /** 
-   * Path Switch Request 
-   * 
-   * \param params 
-   */
   virtual void PathSwitchRequest (PathSwitchRequestParameters params) = 0;
 
 
@@ -124,22 +117,15 @@
   /**
    * request the setup of a DataRadioBearer
    * 
-   *  \param params
    */
   virtual void DataRadioBearerSetupRequest (DataRadioBearerSetupRequestParameters params) = 0;
 
   
-  /// PathSwitchRequestAcknowledgeParameters structure
   struct PathSwitchRequestAcknowledgeParameters
   {
-    uint16_t rnti; ///< RNTI
+    uint16_t rnti;
   };
 
-  /**
-   * request a path switch acknowledge
-   * 
-   *  \param params
-   */
   virtual void PathSwitchRequestAcknowledge (PathSwitchRequestAcknowledgeParameters params) = 0;
   
 };
@@ -156,11 +142,6 @@
 class MemberEpcEnbS1SapProvider : public EpcEnbS1SapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberEpcEnbS1SapProvider (C* owner);
 
   // inherited from EpcEnbS1SapProvider
@@ -172,7 +153,7 @@
 
 private:
   MemberEpcEnbS1SapProvider ();
-  C* m_owner; ///< owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -220,11 +201,6 @@
 class MemberEpcEnbS1SapUser : public EpcEnbS1SapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberEpcEnbS1SapUser (C* owner);
 
   // inherited from EpcEnbS1SapUser
@@ -233,7 +209,7 @@
 
 private:
   MemberEpcEnbS1SapUser ();
-  C* m_owner; ///< owner class
+  C* m_owner;
 };
 
 template <class C>
diff -Naru a/model/epc-mme-application.cc b/model/epc-mme-application.cc
--- a/model/epc-mme-application.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-mme-application.cc	2018-08-03 16:39:02.875957522 +0200
@@ -0,0 +1,298 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by Michele Polese <michele.polese@gmail.com>
+ *     (support for RRC_CONNECTED->RRC_IDLE state transition + fix for bug 2161
+ *      + extension to application & support for real S1AP link)
+ */
+
+#include <ns3/fatal-error.h>
+#include <ns3/log.h>
+
+#include "epc-s1ap-sap.h"
+#include "epc-s11-sap.h"
+
+#include "epc-mme-application.h"
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("EpcMmeApplication");
+
+NS_OBJECT_ENSURE_REGISTERED (EpcMmeApplication);
+
+EpcMmeApplication::EpcMmeApplication ()
+  : m_s11SapSgw (0)
+{
+  NS_LOG_FUNCTION (this);
+  m_s1apSapMme = new MemberEpcS1apSapMme<EpcMmeApplication> (this);
+  m_s11SapMme = new MemberEpcS11SapMme<EpcMmeApplication> (this);
+}
+
+
+EpcMmeApplication::~EpcMmeApplication ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+void
+EpcMmeApplication::DoDispose ()
+{
+  NS_LOG_FUNCTION (this);
+  delete m_s1apSapMme;
+  delete m_s11SapMme;
+}
+
+TypeId
+EpcMmeApplication::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcMmeApplication")
+    .SetParent<Object> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcMmeApplication> ()
+    ;
+  return tid;
+}
+
+EpcS1apSapMme* 
+EpcMmeApplication::GetS1apSapMme ()
+{
+  return m_s1apSapMme;
+}
+
+void 
+EpcMmeApplication::SetS1apSapMmeProvider(EpcS1apSapMmeProvider* provider)
+{
+  m_s1apSapMmeProvider = provider;
+}
+
+
+void 
+EpcMmeApplication::SetS11SapSgw (EpcS11SapSgw * s)
+{
+  m_s11SapSgw = s;
+}
+
+EpcS11SapMme* 
+EpcMmeApplication::GetS11SapMme ()
+{
+  return m_s11SapMme;
+}
+
+void 
+EpcMmeApplication::AddEnb (uint16_t gci, Ipv4Address enbS1uAddr)
+{
+  NS_LOG_FUNCTION (this << gci << enbS1uAddr);
+  Ptr<EnbInfo> enbInfo = Create<EnbInfo> ();
+  enbInfo->gci = gci;
+  enbInfo->s1uAddr = enbS1uAddr;
+  m_enbInfoMap[gci] = enbInfo;
+}
+
+void 
+EpcMmeApplication::AddUe (uint64_t imsi)
+{
+  NS_LOG_FUNCTION (this << imsi);
+  Ptr<UeInfo> ueInfo = Create<UeInfo> ();
+  ueInfo->imsi = imsi;
+  ueInfo->mmeUeS1Id = imsi;
+  m_ueInfoMap[imsi] = ueInfo;
+  ueInfo->bearerCounter = 0;
+}
+
+uint8_t
+EpcMmeApplication::AddBearer (uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer)
+{
+  NS_LOG_FUNCTION (this << imsi);
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+  NS_ASSERT_MSG (it->second->bearerCounter < 11, "too many bearers already! " << it->second->bearerCounter);
+  BearerInfo bearerInfo;
+  bearerInfo.bearerId = ++(it->second->bearerCounter);
+  bearerInfo.tft = tft;
+  bearerInfo.bearer = bearer;  
+  it->second->bearersToBeActivated.push_back (bearerInfo);
+  return bearerInfo.bearerId;
+}
+
+
+// S1-AP SAP MME forwarded methods
+
+void 
+EpcMmeApplication::DoInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t gci)
+{
+  NS_LOG_FUNCTION (this << mmeUeS1Id << enbUeS1Id << imsi << gci);
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+  it->second->cellId = gci;
+  EpcS11SapSgw::CreateSessionRequestMessage msg;
+  msg.imsi = imsi;
+  msg.uli.gci = gci;
+  for (std::list<BearerInfo>::iterator bit = it->second->bearersToBeActivated.begin ();
+       bit != it->second->bearersToBeActivated.end ();
+       ++bit)
+    {
+      EpcS11SapSgw::BearerContextToBeCreated bearerContext;
+      bearerContext.epsBearerId =  bit->bearerId;
+      NS_LOG_INFO("Mme: sending as bearerId " << (uint32_t) bit->bearerId);
+      bearerContext.bearerLevelQos = bit->bearer; 
+      bearerContext.tft = bit->tft;
+      msg.bearerContextsToBeCreated.push_back (bearerContext);
+    }
+  m_s11SapSgw->CreateSessionRequest (msg);
+}
+
+void 
+EpcMmeApplication::DoInitialContextSetupResponse (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapMme::ErabSetupItem> erabSetupList)
+{
+  NS_LOG_FUNCTION (this << mmeUeS1Id << enbUeS1Id);
+  NS_FATAL_ERROR ("unimplemented");
+}
+
+void 
+EpcMmeApplication::DoPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<EpcS1apSapMme::ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList)
+{
+  NS_LOG_FUNCTION (this << mmeUeS1Id << enbUeS1Id << gci);
+
+  uint64_t imsi = mmeUeS1Id; 
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+  NS_LOG_INFO ("IMSI " << imsi << " old eNB: " << it->second->cellId << ", new eNB: " << gci);
+  it->second->cellId = gci;
+  it->second->enbUeS1Id = enbUeS1Id;
+
+  EpcS11SapSgw::ModifyBearerRequestMessage msg;
+  msg.teid = imsi; // trick to avoid the need for allocating TEIDs on the S11 interface
+  msg.uli.gci = gci;
+  // bearer modification is not supported for now
+  m_s11SapSgw->ModifyBearerRequest (msg);
+}
+
+
+// S11 SAP MME forwarded methods
+
+void 
+EpcMmeApplication::DoCreateSessionResponse (EpcS11SapMme::CreateSessionResponseMessage msg)
+{
+  NS_LOG_FUNCTION (this << msg.teid);
+  uint64_t imsi = msg.teid;
+  std::list<EpcS1apSapEnb::ErabToBeSetupItem> erabToBeSetupList;
+  for (std::list<EpcS11SapMme::BearerContextCreated>::iterator bit = msg.bearerContextsCreated.begin ();
+       bit != msg.bearerContextsCreated.end ();
+       ++bit)
+    {
+      EpcS1apSapEnb::ErabToBeSetupItem erab;
+      erab.erabId = bit->epsBearerId;
+      erab.erabLevelQosParameters = bit->bearerLevelQos;
+      erab.transportLayerAddress = bit->sgwFteid.address;
+      erab.sgwTeid = bit->sgwFteid.teid;      
+      erabToBeSetupList.push_back (erab);
+    }
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+  uint16_t cellId = it->second->cellId;
+  uint16_t enbUeS1Id = it->second->enbUeS1Id;
+  uint64_t mmeUeS1Id = it->second->mmeUeS1Id;
+  std::map<uint16_t, Ptr<EnbInfo> >::iterator jt = m_enbInfoMap.find (cellId);
+  NS_ASSERT_MSG (jt != m_enbInfoMap.end (), "could not find any eNB with CellId " << cellId);
+  m_s1apSapMmeProvider->SendInitialContextSetupRequest (mmeUeS1Id, enbUeS1Id, erabToBeSetupList, cellId);
+}
+
+
+void 
+EpcMmeApplication::DoModifyBearerResponse (EpcS11SapMme::ModifyBearerResponseMessage msg)
+{
+  NS_LOG_FUNCTION (this << msg.teid);
+  NS_ASSERT (msg.cause == EpcS11SapMme::ModifyBearerResponseMessage::REQUEST_ACCEPTED);
+  uint64_t imsi = msg.teid;
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+  uint64_t enbUeS1Id = it->second->enbUeS1Id;
+  uint64_t mmeUeS1Id = it->second->mmeUeS1Id;
+  uint16_t cgi = it->second->cellId;
+  std::list<EpcS1apSapEnb::ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList; // unused for now
+  std::map<uint16_t, Ptr<EnbInfo> >::iterator jt = m_enbInfoMap.find (it->second->cellId);
+  NS_ASSERT_MSG (jt != m_enbInfoMap.end (), "could not find any eNB with CellId " << it->second->cellId);
+  m_s1apSapMmeProvider->SendPathSwitchRequestAcknowledge (enbUeS1Id, mmeUeS1Id, cgi, erabToBeSwitchedInUplinkList);
+}
+
+void
+EpcMmeApplication::DoErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapMme::ErabToBeReleasedIndication> erabToBeReleaseIndication)
+{
+  NS_LOG_FUNCTION (this << mmeUeS1Id << enbUeS1Id);
+  uint64_t imsi = mmeUeS1Id;
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+
+  EpcS11SapSgw::DeleteBearerCommandMessage msg;
+  // trick to avoid the need for allocating TEIDs on the S11 interface
+  msg.teid = imsi;
+
+  for (std::list<EpcS1apSapMme::ErabToBeReleasedIndication>::iterator bit = erabToBeReleaseIndication.begin (); bit != erabToBeReleaseIndication.end (); ++bit)
+    {
+      EpcS11SapSgw::BearerContextToBeRemoved bearerContext;
+      bearerContext.epsBearerId =  bit->erabId;
+      msg.bearerContextsToBeRemoved.push_back (bearerContext);
+    }
+  //Delete Bearer command towards epc-sgw-pgw-application
+  m_s11SapSgw->DeleteBearerCommand (msg);
+}
+
+void
+EpcMmeApplication::DoDeleteBearerRequest (EpcS11SapMme::DeleteBearerRequestMessage msg)
+{
+  NS_LOG_FUNCTION (this);
+  uint64_t imsi = msg.teid;
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+  EpcS11SapSgw::DeleteBearerResponseMessage res;
+
+  res.teid = imsi;
+
+  for (std::list<EpcS11SapMme::BearerContextRemoved>::iterator bit = msg.bearerContextsRemoved.begin ();
+       bit != msg.bearerContextsRemoved.end ();
+       ++bit)
+    {
+      EpcS11SapSgw::BearerContextRemovedSgwPgw bearerContext;
+      bearerContext.epsBearerId = bit->epsBearerId;
+      res.bearerContextsRemoved.push_back (bearerContext);
+
+      RemoveBearer (it->second, bearerContext.epsBearerId); //schedules function to erase, context of de-activated bearer
+    }
+  //schedules Delete Bearer Response towards epc-sgw-pgw-application
+  m_s11SapSgw->DeleteBearerResponse (res);
+}
+
+void EpcMmeApplication::RemoveBearer (Ptr<UeInfo> ueInfo, uint8_t epsBearerId)
+{
+  NS_LOG_FUNCTION (this << epsBearerId);
+  for (std::list<BearerInfo>::iterator bearerIterator = ueInfo->bearersToBeActivated.begin ();
+       bearerIterator != ueInfo->bearersToBeActivated.end ();
+       ++bearerIterator)
+    {
+      if (bearerIterator->bearerId == epsBearerId)
+        {
+          ueInfo->bearersToBeActivated.erase (bearerIterator);
+          ueInfo->bearerCounter = ueInfo->bearerCounter - 1;
+          break;
+        }
+    }
+}
+
+} // namespace ns3
diff -Naru a/model/epc-mme-application.h b/model/epc-mme-application.h
--- a/model/epc-mme-application.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-mme-application.h	2018-08-03 16:39:02.875957522 +0200
@@ -0,0 +1,205 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Nicola Baldo <nbaldo@cttc.es> wrote the EpcMme class
+ * Author: Michele Polese <michele.polese@gmail.com> wrote the Application version
+ */
+
+#ifndef EPC_MME_APPLICATION_H
+#define EPC_MME_APPLICATION_H
+
+#include <ns3/object.h>
+#include <ns3/epc-s1ap-sap.h>
+#include <ns3/epc-s11-sap.h>
+#include <ns3/application.h>
+
+
+#include <map>
+#include <list>
+
+namespace ns3 {
+
+class Node;
+class NetDevice;
+
+/**
+ * \brief This object implements as an application the MME functionality.
+ *
+ */
+class EpcMmeApplication : public Application
+{
+
+  friend class MemberEpcS1apSapMme<EpcMmeApplication>;
+  friend class MemberEpcS11SapMme<EpcMmeApplication>;
+  
+public:
+  
+  /** 
+   * Constructor
+   */
+  EpcMmeApplication ();
+
+  /** 
+   * Destructor
+   */  
+  virtual ~EpcMmeApplication ();
+  
+  // inherited from Object  
+  static TypeId GetTypeId (void);
+protected:
+  virtual void DoDispose ();
+
+public:
+
+
+  /** 
+   * 
+   * \return the MME side of the S1-AP SAP 
+   */
+  EpcS1apSapMme* GetS1apSapMme ();
+
+  /**
+   * \param the MME provider, given by the S1AP object associated to this application
+   */
+  void SetS1apSapMmeProvider(EpcS1apSapMmeProvider* provider);
+
+  /** 
+   * Set the SGW side of the S11 SAP 
+   * 
+   * \param s the SGW side of the S11 SAP 
+   */
+  void SetS11SapSgw (EpcS11SapSgw * s);
+
+  /** 
+   * 
+   * \return the MME side of the S11 SAP 
+   */
+  EpcS11SapMme* GetS11SapMme ();
+
+  /** 
+   * Add a new ENB to the MME. 
+   * \param ecgi E-UTRAN Cell Global ID, the unique identifier of the eNodeB
+   * \param the eNB S1UAddr 
+   */
+  void AddEnb (uint16_t ecgi, Ipv4Address enbS1UAddr);
+  
+  /** 
+   * Add a new UE to the MME. This is the equivalent of storing the UE
+   * credentials before the UE is ever turned on. 
+   * 
+   * \param imsi the unique identifier of the UE
+   */
+  void AddUe (uint64_t imsi);
+
+  /** 
+   * Add an EPS bearer to the list of bearers to be activated for this
+   * UE. The bearer will be activated when the UE enters the ECM
+   * connected state.
+   * 
+   * \param imsi UE identifier
+   * \param tft traffic flow template of the bearer
+   * \param bearer QoS characteristics of the bearer
+   */
+  uint8_t AddBearer (uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer);
+
+
+private:
+
+  // S1-AP SAP MME forwarded methods
+  void DoInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t ecgi);
+  void DoInitialContextSetupResponse (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapMme::ErabSetupItem> erabSetupList);
+  void DoPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<EpcS1apSapMme::ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList);
+  void DoErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapMme::ErabToBeReleasedIndication> erabToBeReleaseIndication);
+
+  // S11 SAP MME forwarded methods
+  void DoCreateSessionResponse (EpcS11SapMme::CreateSessionResponseMessage msg);
+  void DoModifyBearerResponse (EpcS11SapMme::ModifyBearerResponseMessage msg);
+  void DoDeleteBearerRequest (EpcS11SapMme::DeleteBearerRequestMessage msg);
+
+
+  /**
+   * Hold info on an EPS bearer to be activated
+   * 
+   */
+  struct BearerInfo
+  {
+    Ptr<EpcTft> tft;
+    EpsBearer bearer;
+    uint8_t bearerId;
+  };
+  
+  /**
+   * Hold info on a UE
+   * 
+   */
+  struct UeInfo : public SimpleRefCount<UeInfo>
+  {
+    uint64_t mmeUeS1Id;
+    uint16_t enbUeS1Id;
+    uint64_t imsi;
+    uint16_t cellId;
+    std::list<BearerInfo> bearersToBeActivated;
+    uint16_t bearerCounter;
+  };
+
+  /**
+   * UeInfo stored by IMSI
+   * 
+   */  
+  std::map<uint64_t, Ptr<UeInfo> > m_ueInfoMap;
+
+  /**
+   * \brief This Function erases all contexts of bearer from MME side
+   * \param ueInfo UE information pointer
+   * \param epsBearerId Bearer Id which need to be removed corresponding to UE
+   */
+  void RemoveBearer (Ptr<UeInfo> ueInfo, uint8_t epsBearerId);
+
+  /**
+   * Hold info on a ENB
+   * 
+   */
+  struct EnbInfo : public SimpleRefCount<EnbInfo>
+  {
+    uint16_t gci;
+    Ipv4Address s1uAddr;
+  };
+
+  /**
+   * EnbInfo stored by EGCI
+   * 
+   */
+  std::map<uint16_t, Ptr<EnbInfo> > m_enbInfoMap;
+
+
+  
+
+  EpcS1apSapMme* m_s1apSapMme;
+  EpcS1apSapMmeProvider* m_s1apSapMmeProvider;
+
+  EpcS11SapMme* m_s11SapMme;
+  EpcS11SapSgw* m_s11SapSgw;
+  
+};
+
+
+
+
+} // namespace ns3
+
+#endif // EPC_MME_APPLICATION_H
diff -Naru a/model/epc-mme.cc b/model/epc-mme.cc
--- a/model/epc-mme.cc	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-mme.cc	2018-08-03 16:39:02.875957522 +0200
@@ -65,25 +65,25 @@
   return tid;
 }
 
-EpcS1apSapMme* 
+EpcS1apSapMme*
 EpcMme::GetS1apSapMme ()
 {
   return m_s1apSapMme;
 }
 
-void 
+void
 EpcMme::SetS11SapSgw (EpcS11SapSgw * s)
 {
   m_s11SapSgw = s;
 }
 
-EpcS11SapMme* 
+EpcS11SapMme*
 EpcMme::GetS11SapMme ()
 {
   return m_s11SapMme;
 }
 
-void 
+void
 EpcMme::AddEnb (uint16_t gci, Ipv4Address enbS1uAddr, EpcS1apSapEnb* enbS1apSap)
 {
   NS_LOG_FUNCTION (this << gci << enbS1uAddr);
@@ -94,7 +94,7 @@
   m_enbInfoMap[gci] = enbInfo;
 }
 
-void 
+void
 EpcMme::AddUe (uint64_t imsi)
 {
   NS_LOG_FUNCTION (this << imsi);
@@ -115,7 +115,7 @@
   BearerInfo bearerInfo;
   bearerInfo.bearerId = ++(it->second->bearerCounter);
   bearerInfo.tft = tft;
-  bearerInfo.bearer = bearer;  
+  bearerInfo.bearer = bearer;
   it->second->bearersToBeActivated.push_back (bearerInfo);
   return bearerInfo.bearerId;
 }
@@ -123,7 +123,7 @@
 
 // S1-AP SAP MME forwarded methods
 
-void 
+void
 EpcMme::DoInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t gci)
 {
   NS_LOG_FUNCTION (this << mmeUeS1Id << enbUeS1Id << imsi << gci);
@@ -139,27 +139,27 @@
        ++bit)
     {
       EpcS11SapSgw::BearerContextToBeCreated bearerContext;
-      bearerContext.epsBearerId =  bit->bearerId; 
-      bearerContext.bearerLevelQos = bit->bearer; 
+      bearerContext.epsBearerId =  bit->bearerId;
+      bearerContext.bearerLevelQos = bit->bearer;
       bearerContext.tft = bit->tft;
       msg.bearerContextsToBeCreated.push_back (bearerContext);
     }
   m_s11SapSgw->CreateSessionRequest (msg);
 }
 
-void 
+void
 EpcMme::DoInitialContextSetupResponse (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapMme::ErabSetupItem> erabSetupList)
 {
   NS_LOG_FUNCTION (this << mmeUeS1Id << enbUeS1Id);
   NS_FATAL_ERROR ("unimplemented");
 }
 
-void 
+void
 EpcMme::DoPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<EpcS1apSapMme::ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList)
 {
   NS_LOG_FUNCTION (this << mmeUeS1Id << enbUeS1Id << gci);
 
-  uint64_t imsi = mmeUeS1Id; 
+  uint64_t imsi = mmeUeS1Id;
   std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
   NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
   NS_LOG_INFO ("IMSI " << imsi << " old eNB: " << it->second->cellId << ", new eNB: " << gci);
@@ -176,7 +176,7 @@
 
 // S11 SAP MME forwarded methods
 
-void 
+void
 EpcMme::DoCreateSessionResponse (EpcS11SapMme::CreateSessionResponseMessage msg)
 {
   NS_LOG_FUNCTION (this << msg.teid);
@@ -190,7 +190,7 @@
       erab.erabId = bit->epsBearerId;
       erab.erabLevelQosParameters = bit->bearerLevelQos;
       erab.transportLayerAddress = bit->sgwFteid.address;
-      erab.sgwTeid = bit->sgwFteid.teid;      
+      erab.sgwTeid = bit->sgwFteid.teid;
       erabToBeSetupList.push_back (erab);
     }
   std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
@@ -204,7 +204,7 @@
 }
 
 
-void 
+void
 EpcMme::DoModifyBearerResponse (EpcS11SapMme::ModifyBearerResponseMessage msg)
 {
   NS_LOG_FUNCTION (this << msg.teid);
diff -Naru a/model/epc-mme.h b/model/epc-mme.h
--- a/model/epc-mme.h	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-mme.h	2018-08-03 16:39:02.875957522 +0200
@@ -44,19 +44,19 @@
   friend class MemberEpcS1apSapMme<EpcMme>;
   /// allow MemberEpcS11SapMme<EpcMme> class friend access
   friend class MemberEpcS11SapMme<EpcMme>;
-  
+
 public:
-  
-  /** 
+
+  /**
    * Constructor
    */
   EpcMme ();
 
-  /** 
+  /**
    * Destructor
-   */  
+   */
   virtual ~EpcMme ();
-  
+
   /**
    * \brief Get the type ID.
    * \return the object TypeId
@@ -68,50 +68,50 @@
 public:
 
 
-  /** 
-   * 
-   * \return the MME side of the S1-AP SAP 
+  /**
+   *
+   * \return the MME side of the S1-AP SAP
    */
   EpcS1apSapMme* GetS1apSapMme ();
 
-  /** 
-   * Set the SGW side of the S11 SAP 
-   * 
-   * \param s the SGW side of the S11 SAP 
+  /**
+   * Set the SGW side of the S11 SAP
+   *
+   * \param s the SGW side of the S11 SAP
    */
   void SetS11SapSgw (EpcS11SapSgw * s);
 
-  /** 
-   * 
-   * \return the MME side of the S11 SAP 
+  /**
+   *
+   * \return the MME side of the S11 SAP
    */
   EpcS11SapMme* GetS11SapMme ();
 
-  /** 
-   * Add a new ENB to the MME. 
+  /**
+   * Add a new ENB to the MME.
    * \param ecgi E-UTRAN Cell Global ID, the unique identifier of the eNodeB
    * \param enbS1UAddr address of the eNB for S1-U communications
-   * \param enbS1apSap the ENB side of the S1-AP SAP 
+   * \param enbS1apSap the ENB side of the S1-AP SAP
    */
   void AddEnb (uint16_t ecgi, Ipv4Address enbS1UAddr, EpcS1apSapEnb* enbS1apSap);
-  
-  /** 
+
+  /**
    * Add a new UE to the MME. This is the equivalent of storing the UE
-   * credentials before the UE is ever turned on. 
-   * 
+   * credentials before the UE is ever turned on.
+   *
    * \param imsi the unique identifier of the UE
    */
   void AddUe (uint64_t imsi);
 
-  /** 
+  /**
    * Add an EPS bearer to the list of bearers to be activated for this
    * UE. The bearer will be activated when the UE enters the ECM
    * connected state.
-   * 
+   *
    * \param imsi UE identifier
    * \param tft traffic flow template of the bearer
    * \param bearer QoS characteristics of the bearer
-   * \returns bearer ID 
+   * \returns bearer ID
    */
   uint8_t AddBearer (uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer);
 
@@ -120,7 +120,7 @@
 
   // S1-AP SAP MME forwarded methods
   /**
-   * Initial UE Message function 
+   * Initial UE Message function
    * \param mmeUeS1Id the MME UE S1 ID
    * \param enbUeS1Id the ENB UE S1 ID
    * \param imsi the IMSI
@@ -128,7 +128,7 @@
    */
   void DoInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t ecgi);
   /**
-   * Initial Context Setup Response function 
+   * Initial Context Setup Response function
    * \param mmeUeS1Id the MME UE S1 ID
    * \param enbUeS1Id the ENB UE S1 ID
    * \param erabSetupList the ERAB setup list
@@ -170,18 +170,18 @@
 
   /**
    * Hold info on an EPS bearer to be activated
-   * 
+   *
    */
   struct BearerInfo
   {
     Ptr<EpcTft> tft;  ///< traffic flow template
-    EpsBearer bearer; ///< bearer QOS characteristics 
+    EpsBearer bearer; ///< bearer QOS characteristics
     uint8_t bearerId; ///< bearer ID
   };
-  
+
   /**
    * Hold info on a UE
-   * 
+   *
    */
   struct UeInfo : public SimpleRefCount<UeInfo>
   {
@@ -195,8 +195,8 @@
 
   /**
    * UeInfo stored by IMSI
-   * 
-   */  
+   *
+   */
   std::map<uint64_t, Ptr<UeInfo> > m_ueInfoMap;
 
   /**
@@ -208,7 +208,7 @@
 
   /**
    * Hold info on a ENB
-   * 
+   *
    */
   struct EnbInfo : public SimpleRefCount<EnbInfo>
   {
@@ -219,18 +219,18 @@
 
   /**
    * EnbInfo stored by EGCI
-   * 
+   *
    */
   std::map<uint16_t, Ptr<EnbInfo> > m_enbInfoMap;
 
 
-  
+
 
   EpcS1apSapMme* m_s1apSapMme; ///< EpcS1apSapMme
 
   EpcS11SapMme* m_s11SapMme; ///< EpcS11SapMme
   EpcS11SapSgw* m_s11SapSgw; ///< EpcS11SapSgw
-  
+
 };
 
 
diff -Naru a/model/epc-s1ap.cc b/model/epc-s1ap.cc
--- a/model/epc-s1ap.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-s1ap.cc	2018-08-03 16:39:02.875957522 +0200
@@ -0,0 +1,620 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab. 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com> 
+ *          Support for real S1AP link
+ */
+
+#include "ns3/log.h"
+#include "ns3/inet-socket-address.h"
+#include "ns3/packet.h"
+#include "ns3/node.h"
+#include "ns3/epc-gtpu-header.h"
+#include <ns3/simulator.h>
+
+#include "ns3/epc-s1ap-header.h"
+#include "ns3/epc-s1ap.h"
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("EpcS1ap");
+
+S1apIfaceInfo::S1apIfaceInfo (Ipv4Address remoteIpAddr, Ptr<Socket> localCtrlPlaneSocket)
+{
+  m_remoteIpAddr = remoteIpAddr;
+  m_localCtrlPlaneSocket = localCtrlPlaneSocket;
+}
+
+S1apIfaceInfo::~S1apIfaceInfo (void)
+{
+  m_localCtrlPlaneSocket = 0;
+}
+
+S1apIfaceInfo& 
+S1apIfaceInfo::operator= (const S1apIfaceInfo& value)
+{
+  NS_LOG_FUNCTION (this);
+  m_remoteIpAddr = value.m_remoteIpAddr;
+  m_localCtrlPlaneSocket = value.m_localCtrlPlaneSocket;
+  return *this;
+}
+
+///////////////////////////////////////////
+
+S1apConnectionInfo::S1apConnectionInfo (uint16_t enbId, uint16_t mmeId)
+{
+  m_enbId = enbId;
+  m_mmeId = mmeId;
+}
+
+S1apConnectionInfo::~S1apConnectionInfo (void)
+{
+  m_enbId = 0;
+  m_mmeId = 0;
+}
+
+S1apConnectionInfo& 
+S1apConnectionInfo::operator= (const S1apConnectionInfo& value)
+{
+  NS_LOG_FUNCTION (this);
+  m_enbId = value.m_enbId;
+  m_mmeId = value.m_mmeId;
+  return *this;
+}
+
+///////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1apEnb);
+
+EpcS1apEnb::EpcS1apEnb (Ptr<Socket> localSocket, Ipv4Address enbAddress, Ipv4Address mmeAddress, uint16_t cellId, uint16_t mmeId)
+  : m_s1apUdpPort (36412) // As defined by IANA
+{
+  NS_LOG_FUNCTION (this);
+  AddS1apInterface(cellId, enbAddress, mmeId, mmeAddress, localSocket);
+  m_s1apSapProvider = new MemberEpcS1apSapEnbProvider<EpcS1apEnb> (this);
+}
+
+EpcS1apEnb::~EpcS1apEnb ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+void
+EpcS1apEnb::DoDispose (void)
+{
+  NS_LOG_FUNCTION (this);
+
+  m_s1apInterfaceSockets.clear ();
+  m_s1apInterfaceCellIds.clear ();
+  delete m_s1apSapProvider;
+}
+
+TypeId
+EpcS1apEnb::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1apEnb")
+    .SetParent<Object> ()
+    .SetGroupName("Lte");
+  return tid;
+}
+
+void
+EpcS1apEnb::SetEpcS1apSapEnbUser (EpcS1apSapEnb * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_s1apSapUser = s;
+}
+
+EpcS1apSapEnbProvider*
+EpcS1apEnb::GetEpcS1apSapEnbProvider ()
+{
+  NS_LOG_FUNCTION (this);
+  return m_s1apSapProvider;
+}
+
+
+void
+EpcS1apEnb::AddS1apInterface (uint16_t enbId, Ipv4Address enbAddress,
+                       uint16_t mmeId, Ipv4Address mmeAddress,
+                       Ptr<Socket> localS1apSocket)
+{
+  NS_LOG_FUNCTION (this << enbId << enbAddress << mmeId << mmeAddress);
+
+  localS1apSocket->SetRecvCallback (MakeCallback (&EpcS1apEnb::RecvFromS1apSocket, this));
+
+  NS_ASSERT_MSG (m_s1apInterfaceSockets.find (mmeId) == m_s1apInterfaceSockets.end (),
+                 "Mapping for mmeId = " << mmeId << " is already known");
+  m_s1apInterfaceSockets [mmeId] = Create<S1apIfaceInfo> (mmeAddress, localS1apSocket);
+
+  // TODO m_mmeId is initialized once since one mme is connected to this enb interface, consider when extending
+  m_mmeId = mmeId;
+}
+
+
+void 
+EpcS1apEnb::RecvFromS1apSocket (Ptr<Socket> socket)
+{
+  NS_LOG_FUNCTION (this << socket);
+
+  NS_LOG_LOGIC ("Recv S1ap message: S1AP eNB: from Socket at time " << Simulator::Now ().GetSeconds());
+  Ptr<Packet> packet = socket->Recv ();
+  NS_LOG_LOGIC ("packetLen = " << packet->GetSize ());
+
+  EpcS1APHeader s1apHeader;
+  packet->RemoveHeader (s1apHeader);
+
+  NS_LOG_LOGIC ("S1ap header: " << s1apHeader);
+
+  uint8_t procedureCode = s1apHeader.GetProcedureCode ();
+
+  if (procedureCode == EpcS1APHeader::InitialContextSetupRequest)
+  {
+    NS_LOG_LOGIC ("Recv S1ap message: INITIAL CONTEXT SETUP REQUEST");
+    EpcS1APInitialContextSetupRequestHeader reqHeader;
+    packet->RemoveHeader(reqHeader);
+
+    NS_LOG_INFO ("S1ap Initial Context Setup Request " << reqHeader);
+
+    uint64_t mmeUeS1apId = reqHeader.GetMmeUeS1Id();
+    uint16_t enbUeS1apId = reqHeader.GetEnbUeS1Id();
+    std::list<EpcS1apSap::ErabToBeSetupItem> erabToBeSetup = reqHeader.GetErabToBeSetupItem ();
+    
+    NS_LOG_LOGIC ("mmeUeS1apId " << mmeUeS1apId);
+    NS_LOG_LOGIC ("enbUeS1apId " << enbUeS1apId);
+
+    m_s1apSapUser->InitialContextSetupRequest(mmeUeS1apId, enbUeS1apId, erabToBeSetup);
+  } 
+  else if (procedureCode == EpcS1APHeader::PathSwitchRequestAck)
+  {
+    NS_LOG_LOGIC ("Recv S1ap message: PATH SWITCH REQUEST ACK");
+    EpcS1APPathSwitchRequestAcknowledgeHeader reqHeader;
+    packet->RemoveHeader(reqHeader);
+
+    NS_LOG_INFO ("S1ap Path Switch Request Acknowledge Header " << reqHeader);
+
+    uint64_t mmeUeS1apId = reqHeader.GetMmeUeS1Id();
+    uint16_t enbUeS1apId = reqHeader.GetEnbUeS1Id();
+    uint16_t ecgi = reqHeader.GetEcgi();
+    std::list<EpcS1apSap::ErabSwitchedInUplinkItem> pathErab = reqHeader.GetErabSwitchedInUplinkItemList ();
+    
+    NS_LOG_LOGIC ("mmeUeS1apId " << mmeUeS1apId);
+    NS_LOG_LOGIC ("enbUeS1apId " << enbUeS1apId);
+    NS_LOG_LOGIC ("ecgi " << ecgi);
+
+    m_s1apSapUser->PathSwitchRequestAcknowledge(enbUeS1apId, mmeUeS1apId, ecgi, pathErab);
+  }  
+  else
+  {
+    NS_ASSERT_MSG (false, "ProcedureCode NOT SUPPORTED!!!");
+  }
+}
+
+
+//
+// Implementation of the S1ap SAP Provider
+//
+void
+EpcS1apEnb::DoSendInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) 
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+  NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+  NS_LOG_LOGIC("stmsi = " << stmsi);
+  NS_LOG_LOGIC("ecgi = " << ecgi);
+
+  // TODO check if an assert is needed
+
+  Ptr<S1apIfaceInfo> socketInfo = m_s1apInterfaceSockets [m_mmeId]; // in case of multiple mme, extend the call
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address mmeIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("mmeIpAddr = " << mmeIpAddr);
+
+  NS_LOG_INFO ("Send S1ap message: INITIAL UE MESSAGE " << Simulator::Now ().GetSeconds());
+
+  // build the header
+  EpcS1APInitialUeMessageHeader initialMessage;
+  initialMessage.SetMmeUeS1Id(mmeUeS1Id);
+  initialMessage.SetEnbUeS1Id(enbUeS1Id);
+  initialMessage.SetSTmsi(stmsi);
+  initialMessage.SetEcgi(ecgi);
+  NS_LOG_INFO ("S1ap Initial Message header " << initialMessage);
+
+  EpcS1APHeader s1apHeader;
+  s1apHeader.SetProcedureCode (EpcS1APHeader::InitialUeMessage);
+  s1apHeader.SetLengthOfIes (initialMessage.GetLengthOfIes ());
+  s1apHeader.SetNumberOfIes (initialMessage.GetNumberOfIes ());
+  NS_LOG_INFO ("S1ap header: " << s1apHeader);
+
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (initialMessage);
+  packet->AddHeader (s1apHeader);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the S1ap message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (mmeIpAddr, m_s1apUdpPort));
+}
+
+void 
+EpcS1apEnb::DoSendErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSap::ErabToBeReleasedIndication> erabToBeReleaseIndication )
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+  NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+
+  // TODO check if an assert is needed
+
+  Ptr<S1apIfaceInfo> socketInfo = m_s1apInterfaceSockets [m_mmeId]; // in case of multiple mme, extend the call
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address mmeIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("mmeIpAddr = " << mmeIpAddr);
+
+  NS_LOG_INFO ("Send S1ap message: E-RAB RELEASE INDICATION " << Simulator::Now ().GetSeconds());
+
+  EpcS1APErabReleaseIndicationHeader indHeader;
+  
+  indHeader.SetMmeUeS1Id(mmeUeS1Id);
+  indHeader.SetEnbUeS1Id(enbUeS1Id);
+  indHeader.SetErabReleaseIndication(erabToBeReleaseIndication);
+  NS_LOG_INFO ("S1ap E-rab Release Indication header " << indHeader);
+
+  EpcS1APHeader s1apHeader;
+  s1apHeader.SetProcedureCode (EpcS1APHeader::ErabReleaseIndication);
+  s1apHeader.SetLengthOfIes (indHeader.GetLengthOfIes ());
+  s1apHeader.SetNumberOfIes (indHeader.GetNumberOfIes ());
+  NS_LOG_INFO ("S1ap header: " << s1apHeader);
+
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (indHeader);
+  packet->AddHeader (s1apHeader);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the S1ap message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (mmeIpAddr, m_s1apUdpPort));
+}
+
+void 
+EpcS1apEnb::DoSendInitialContextSetupResponse (uint64_t mmeUeS1Id,
+              uint16_t enbUeS1Id,
+              std::list<EpcS1apSap::ErabSetupItem> erabSetupList) 
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+  NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+
+  // TODO check if an assert is needed
+
+  Ptr<S1apIfaceInfo> socketInfo = m_s1apInterfaceSockets [m_mmeId]; // in case of multiple mme, extend the call
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address mmeIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("mmeIpAddr = " << mmeIpAddr);
+
+  NS_LOG_INFO ("Send S1ap message: INITIAL CONTEXT SETUP RESPONSE " << Simulator::Now ().GetSeconds());
+
+  EpcS1APInitialContextSetupResponseHeader indHeader;
+  
+  indHeader.SetMmeUeS1Id(mmeUeS1Id);
+  indHeader.SetEnbUeS1Id(enbUeS1Id);
+  indHeader.SetErabSetupItem(erabSetupList);
+  NS_LOG_INFO ("S1AP Initial Context Setup Response header " << indHeader);
+
+  EpcS1APHeader s1apHeader;
+  s1apHeader.SetProcedureCode (EpcS1APHeader::InitialContextSetupResponse);
+  s1apHeader.SetLengthOfIes (indHeader.GetLengthOfIes ());
+  s1apHeader.SetNumberOfIes (indHeader.GetNumberOfIes ());
+  NS_LOG_INFO ("S1ap header: " << s1apHeader);
+
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (indHeader);
+  packet->AddHeader (s1apHeader);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the S1ap message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (mmeIpAddr, m_s1apUdpPort));
+}
+
+void 
+EpcS1apEnb::DoSendPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, 
+            std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+  NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+  NS_LOG_LOGIC("ecgi = " << gci);
+
+  // TODO check if an assert is needed
+
+  Ptr<S1apIfaceInfo> socketInfo = m_s1apInterfaceSockets [m_mmeId]; // in case of multiple mme, extend the call
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address mmeIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("mmeIpAddr = " << mmeIpAddr);
+
+  NS_LOG_INFO ("Send S1ap message: PATH SWITCH REQUEST " << Simulator::Now ().GetSeconds());
+
+  EpcS1APPathSwitchRequestHeader indHeader;
+  
+  indHeader.SetMmeUeS1Id(mmeUeS1Id);
+  indHeader.SetEnbUeS1Id(enbUeS1Id);
+  indHeader.SetEcgi(gci);
+  indHeader.SetErabSwitchedInDownlinkItemList(erabToBeSwitchedInDownlinkList);
+  NS_LOG_INFO ("S1AP Path Switch Request header " << indHeader);
+
+  EpcS1APHeader s1apHeader;
+  s1apHeader.SetProcedureCode (EpcS1APHeader::PathSwitchRequest);
+  s1apHeader.SetLengthOfIes (indHeader.GetLengthOfIes ());
+  s1apHeader.SetNumberOfIes (indHeader.GetNumberOfIes ());
+  NS_LOG_INFO ("S1ap header: " << s1apHeader);
+
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (indHeader);
+  packet->AddHeader (s1apHeader);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the S1ap message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (mmeIpAddr, m_s1apUdpPort));
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+
+///////////////////////////////////////////
+NS_OBJECT_ENSURE_REGISTERED (EpcS1apMme);
+
+EpcS1apMme::EpcS1apMme (const Ptr<Socket> s1apSocket, uint16_t mmeId)
+  : m_s1apUdpPort (36412) // As defined by IANA
+{
+  NS_LOG_FUNCTION (this);
+  m_localS1APSocket = s1apSocket;
+  m_s1apSapProvider = new MemberEpcS1apSapMmeProvider<EpcS1apMme> (this);
+  m_localS1APSocket->SetRecvCallback (MakeCallback (&EpcS1apMme::RecvFromS1apSocket, this));
+  m_mmeId = mmeId;
+}
+
+EpcS1apMme::~EpcS1apMme ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+void
+EpcS1apMme::DoDispose (void)
+{
+  NS_LOG_FUNCTION (this);
+
+  m_s1apInterfaceSockets.clear ();
+  m_s1apInterfaceCellIds.clear ();
+  delete m_s1apSapProvider;
+}
+
+TypeId
+EpcS1apMme::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1apMme")
+    .SetParent<Object> ()
+    .SetGroupName("Lte");
+  return tid;
+}
+
+void
+EpcS1apMme::SetEpcS1apSapMmeUser (EpcS1apSapMme * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_s1apSapUser = s;
+}
+
+EpcS1apSapMmeProvider*
+EpcS1apMme::GetEpcS1apSapMmeProvider ()
+{
+  NS_LOG_FUNCTION (this);
+  return m_s1apSapProvider;
+}
+
+
+void
+EpcS1apMme::AddS1apInterface (uint16_t enbId, Ipv4Address enbAddress)
+{
+  NS_LOG_FUNCTION (this << enbId << enbAddress << m_mmeId);
+
+  NS_ASSERT_MSG (m_s1apInterfaceSockets.find (enbId) == m_s1apInterfaceSockets.end (),
+                 "Mapping for enbId = " << enbId << " is already known");
+  m_s1apInterfaceSockets [enbId] = Create<S1apIfaceInfo> (enbAddress, m_localS1APSocket); // TODO m_localS1APSocket is useless
+}
+
+
+void 
+EpcS1apMme::RecvFromS1apSocket (Ptr<Socket> socket)
+{
+  NS_LOG_FUNCTION (this << socket);
+
+  NS_LOG_LOGIC ("Recv S1ap message: S1AP MME: from Socket " << Simulator::Now ().GetSeconds());
+  Ptr<Packet> packet = socket->Recv ();
+  NS_LOG_LOGIC ("packetLen = " << packet->GetSize ());
+
+  EpcS1APHeader s1apHeader;
+  packet->RemoveHeader (s1apHeader);
+
+  NS_LOG_LOGIC ("S1ap header: " << s1apHeader);
+
+  uint8_t procedureCode = s1apHeader.GetProcedureCode ();
+
+  if (procedureCode == EpcS1APHeader::InitialUeMessage)
+  {
+    NS_LOG_LOGIC ("Recv S1ap message: INITIAL UE MESSAGE");
+    EpcS1APInitialUeMessageHeader initialMessage;
+    packet->RemoveHeader(initialMessage);
+    NS_LOG_INFO ("S1ap Initial Message header " << initialMessage);
+
+    uint64_t mmeUeS1Id = initialMessage.GetMmeUeS1Id();
+    uint16_t enbUeS1Id = initialMessage.GetEnbUeS1Id();
+    uint64_t stmsi = initialMessage.GetSTmsi();
+    uint16_t ecgi = initialMessage.GetEcgi();
+
+    NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+    NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+    NS_LOG_LOGIC("stmsi = " << stmsi);
+    NS_LOG_LOGIC("ecgi = " << ecgi);
+
+    // TODO check if ASSERT is needed
+
+    m_s1apSapUser->InitialUeMessage(mmeUeS1Id, enbUeS1Id, stmsi, ecgi);
+
+  }
+  else if (procedureCode == EpcS1APHeader::PathSwitchRequest)
+  {
+    NS_LOG_LOGIC ("Recv S1ap message: PATH SWITCH REQUEST " << Simulator::Now ().GetSeconds());
+    EpcS1APPathSwitchRequestHeader psrHeader;
+    packet->RemoveHeader(psrHeader);
+    NS_LOG_INFO ("S1ap Path Switch Request header " << psrHeader);
+    
+    uint64_t mmeUeS1Id = psrHeader.GetMmeUeS1Id();
+    uint16_t enbUeS1Id = psrHeader.GetEnbUeS1Id();
+    uint16_t ecgi = psrHeader.GetEcgi();
+
+    std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> erabToBeSwitched = psrHeader.GetErabSwitchedInDownlinkItemList ();
+
+
+    NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+    NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+    NS_LOG_LOGIC("ecgi = " << ecgi);
+
+    m_s1apSapUser->PathSwitchRequest (enbUeS1Id, mmeUeS1Id, ecgi, erabToBeSwitched);
+  }
+  else if (procedureCode == EpcS1APHeader::ErabReleaseIndication)
+  {
+   NS_LOG_LOGIC ("Recv S1ap message: E-RAB RELEASE INDICATION " << Simulator::Now ().GetSeconds());
+    EpcS1APErabReleaseIndicationHeader eriHeader;
+    packet->RemoveHeader(eriHeader);
+    NS_LOG_INFO ("S1ap Erab Release Indication header " << eriHeader);
+    
+    uint64_t mmeUeS1Id = eriHeader.GetMmeUeS1Id();
+    uint16_t enbUeS1Id = eriHeader.GetEnbUeS1Id();
+
+    std::list<EpcS1apSap::ErabToBeReleasedIndication> erabToBeReleaseIndication = eriHeader.GetErabToBeReleaseIndication ();
+
+    NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+    NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+
+    m_s1apSapUser->ErabReleaseIndication (mmeUeS1Id, enbUeS1Id, erabToBeReleaseIndication);
+  }
+  else
+  {
+    NS_ASSERT_MSG (false, "ProcedureCode NOT SUPPORTED!!!");
+  }
+}
+
+void 
+EpcS1apMme::DoSendInitialContextSetupRequest (uint64_t mmeUeS1Id,
+                                           uint16_t enbUeS1Id,
+                                           std::list<EpcS1apSap::ErabToBeSetupItem> erabToBeSetupList,
+                                           uint16_t cellId)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+  NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+  NS_LOG_LOGIC("eNB id = " << cellId);
+
+  NS_ASSERT_MSG (m_s1apInterfaceSockets.find (cellId) != m_s1apInterfaceSockets.end (),
+               "Missing infos for cellId = " << cellId);
+
+  Ptr<S1apIfaceInfo> socketInfo = m_s1apInterfaceSockets [cellId];
+  Ipv4Address enbIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("enbIpAddr = " << enbIpAddr);
+
+  NS_LOG_INFO ("Send S1ap message: INITIAL CONTEXT SETUP REQUEST " << Simulator::Now ().GetSeconds());
+
+  EpcS1APInitialContextSetupRequestHeader reqHeader;
+  
+  reqHeader.SetMmeUeS1Id(mmeUeS1Id);
+  reqHeader.SetEnbUeS1Id(enbUeS1Id);
+  reqHeader.SetErabToBeSetupItem(erabToBeSetupList);
+  NS_LOG_INFO ("S1AP Initial Context Setup Request header " << reqHeader);
+
+  EpcS1APHeader s1apHeader;
+  s1apHeader.SetProcedureCode (EpcS1APHeader::InitialContextSetupRequest);
+  s1apHeader.SetLengthOfIes (reqHeader.GetLengthOfIes ());
+  s1apHeader.SetNumberOfIes (reqHeader.GetNumberOfIes ());
+  NS_LOG_INFO ("S1ap header: " << s1apHeader);
+
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (reqHeader);
+  packet->AddHeader (s1apHeader);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the S1ap message through the socket
+  m_localS1APSocket->SendTo (packet, 0, InetSocketAddress (enbIpAddr, m_s1apUdpPort));
+}
+
+void 
+EpcS1apMme::DoSendPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, 
+                                        std::list<EpcS1apSap::ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList)
+{
+  // cgi is the cellId of the other endpoint of this interface
+  uint16_t cellId = cgi;
+
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+  NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+  NS_LOG_LOGIC("eNB id = " << cellId);
+
+  NS_ASSERT_MSG (m_s1apInterfaceSockets.find (cellId) != m_s1apInterfaceSockets.end (),
+               "Missing infos for cellId = " << cellId);
+
+  Ptr<S1apIfaceInfo> socketInfo = m_s1apInterfaceSockets [cellId];
+  Ipv4Address enbIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("enbIpAddr = " << enbIpAddr);
+
+  NS_LOG_INFO ("Send S1ap message: PATH SWITCH REQUEST ACKNOWLEDGE " << Simulator::Now ().GetSeconds());
+
+  EpcS1APPathSwitchRequestAcknowledgeHeader reqHeader;
+  
+  reqHeader.SetMmeUeS1Id(mmeUeS1Id);
+  reqHeader.SetEnbUeS1Id(enbUeS1Id);
+  reqHeader.SetEcgi(cgi);
+  reqHeader.SetErabSwitchedInUplinkItemList(erabToBeSwitchedInUplinkList);
+  NS_LOG_INFO ("S1AP PathSwitchRequestAcknowledge header " << reqHeader);
+
+  EpcS1APHeader s1apHeader;
+  s1apHeader.SetProcedureCode (EpcS1APHeader::PathSwitchRequestAck);
+  s1apHeader.SetLengthOfIes (reqHeader.GetLengthOfIes ());
+  s1apHeader.SetNumberOfIes (reqHeader.GetNumberOfIes ());
+  NS_LOG_INFO ("S1ap header: " << s1apHeader);
+
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (reqHeader);
+  packet->AddHeader (s1apHeader);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the S1ap message through the socket
+  m_localS1APSocket->SendTo (packet, 0, InetSocketAddress (enbIpAddr, m_s1apUdpPort));
+}
+
+
+
+} // namespace ns3
diff -Naru a/model/epc-s1ap.h b/model/epc-s1ap.h
--- a/model/epc-s1ap.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-s1ap.h	2018-08-03 16:39:02.875957522 +0200
@@ -0,0 +1,256 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com> 
+ */
+
+#ifndef EPC_S1AP_H
+#define EPC_S1AP_H
+
+#include "ns3/socket.h"
+#include "ns3/callback.h"
+#include "ns3/ptr.h"
+#include "ns3/object.h"
+
+#include "ns3/epc-s1ap-sap.h"
+
+#include <map>
+
+namespace ns3 {
+
+
+class S1apIfaceInfo : public SimpleRefCount<S1apIfaceInfo>
+{
+public:
+  S1apIfaceInfo (Ipv4Address remoteIpAddr, Ptr<Socket> localCtrlPlaneSocket);
+  virtual ~S1apIfaceInfo (void);
+
+  S1apIfaceInfo& operator= (const S1apIfaceInfo &);
+
+public:
+  Ipv4Address   m_remoteIpAddr;
+  Ptr<Socket>   m_localCtrlPlaneSocket;
+};
+
+
+class S1apConnectionInfo : public SimpleRefCount<S1apConnectionInfo>
+{
+public:
+  S1apConnectionInfo (uint16_t enbId, uint16_t mmeId);
+  virtual ~S1apConnectionInfo (void);
+
+  S1apConnectionInfo& operator= (const S1apConnectionInfo &);
+
+public:
+  uint16_t m_enbId;
+  uint16_t m_mmeId;
+};
+
+
+/**
+ * \ingroup lte
+ *
+ * This entity is installed inside an eNB and provides the functionality for the S1AP interface
+ */
+class EpcS1apEnb : public Object
+{
+  friend class MemberEpcS1apSapEnbProvider<EpcS1apEnb>;
+
+public:
+  /** 
+   * Constructor
+   */
+  EpcS1apEnb (Ptr<Socket> localSocket, Ipv4Address enbAddress, Ipv4Address mmeAddress, uint16_t cellId, uint16_t mmeId);
+
+  /**
+   * Destructor
+   */
+  virtual ~EpcS1apEnb (void);
+
+  static TypeId GetTypeId (void);
+  virtual void DoDispose (void);
+
+
+  /**
+   * \param s the S1ap SAP User to be used by this EPC S1ap eNB entity in order to call methods of epcEnbApplication
+   */
+  void SetEpcS1apSapEnbUser (EpcS1apSapEnb * s);
+
+  /**
+   * \return the S1ap SAP Provider interface offered by this EPC S1ap entity
+   */
+  EpcS1apSapEnbProvider* GetEpcS1apSapEnbProvider ();
+
+
+  /**
+   * Add an S1ap interface to this EPC S1ap entity
+   * \param enbId the cell ID of the eNodeB on which this is installed
+   * \param enbAddress the address of the eNodeB on which this is installed
+   * \param mmeId the ID of the MME to which the eNB is connected
+   * \param mmeAddress the address of the MME to which the eNB is connected
+   * \param the socket created in the Epc Helper
+   */
+  void AddS1apInterface (uint16_t enbId, Ipv4Address enbAddress,
+                       uint16_t mmeId, Ipv4Address mmeAddress, Ptr<Socket> localS1apSocket);
+
+
+  /** 
+   * Method to be assigned to the recv callback of the S1ap-C (S1ap Control Plane) socket.
+   * It is called when the eNB receives a packet from the MME on the S1ap interface
+   * 
+   * \param socket socket of the S1ap interface
+   */
+  void RecvFromS1apSocket (Ptr<Socket> socket);
+
+
+protected:
+  // Interface provided by EpcS1apSapEnbProvider
+  virtual void DoSendInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi);
+  virtual void DoSendErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSap::ErabToBeReleasedIndication> erabToBeReleaseIndication );
+  virtual void DoSendInitialContextSetupResponse (uint64_t mmeUeS1Id,
+                                                  uint16_t enbUeS1Id,
+                                                  std::list<EpcS1apSap::ErabSetupItem> erabSetupList);
+  virtual void DoSendPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList)
+  ;
+
+  EpcS1apSapEnb* m_s1apSapUser;
+  EpcS1apSapEnbProvider* m_s1apSapProvider;
+
+
+private:
+
+  /**
+   * Map the mmeId to the corresponding (sourceSocket, remoteIpAddr) to be used
+   * to send the S1ap message
+   */
+  std::map < uint16_t, Ptr<S1apIfaceInfo> > m_s1apInterfaceSockets;
+
+  /**
+   * Map the localSocket (the one receiving the S1ap message) 
+   * to the corresponding (sourceCellId, targetCellId) associated with the S1ap interface
+   */
+  std::map < Ptr<Socket>, Ptr<S1apConnectionInfo> > m_s1apInterfaceCellIds;
+
+  /**
+   * UDP port to be used for the S1ap interfaces: S1ap
+   */
+  uint16_t m_s1apUdpPort;
+
+  /**
+   * Mme ID, stored as a private variable until more than one MME will be implemented
+   */
+  uint16_t m_mmeId; 
+
+};
+
+
+/**
+ * \ingroup lte
+ *
+ * This entity is installed inside an eNB and provides the functionality for the S1AP interface
+ */
+class EpcS1apMme : public Object
+{
+  friend class MemberEpcS1apSapMmeProvider<EpcS1apMme>;
+
+public:
+  /** 
+   * Constructor
+   * \param the socket opened on the node in which this object is installed
+   */
+  EpcS1apMme (const Ptr<Socket> s1apSocket, uint16_t mmeId);
+
+  /**
+   * Destructor
+   */
+  virtual ~EpcS1apMme (void);
+
+  static TypeId GetTypeId (void);
+  virtual void DoDispose (void);
+
+
+  /**
+   * \param s the S1ap SAP User to be used by this EPC S1ap Mme entity in order to call methods of epcMmeApplication
+   */
+  void SetEpcS1apSapMmeUser (EpcS1apSapMme * s);
+
+  /**
+   * \return the S1ap SAP Provider interface offered by this EPC S1ap entity
+   */
+  EpcS1apSapMmeProvider* GetEpcS1apSapMmeProvider ();
+
+
+  /**
+   * Add an S1ap interface to this EPC S1ap entity
+   * \param enbId the cell ID of the eNodeB which the MME is connected to
+   * \param enbAddress the address of the eNodeB which the MME is connected to
+   */
+  void AddS1apInterface (uint16_t enbId, Ipv4Address enbAddress);
+
+
+  /** 
+   * Method to be assigned to the recv callback of the S1ap-C (S1ap Control Plane) socket.
+   * It is called when the MME receives a packet from the eNB on the S1ap interface
+   * 
+   * \param socket socket of the S1ap interface
+   */
+  void RecvFromS1apSocket (Ptr<Socket> socket);
+
+
+protected:
+  // Interface provided by EpcS1apSapMmeProvider
+  virtual void DoSendInitialContextSetupRequest (uint64_t mmeUeS1Id,
+                                           uint16_t enbUeS1Id,
+                                           std::list<EpcS1apSap::ErabToBeSetupItem> erabToBeSetupList,
+                                           uint16_t cellId);
+
+  virtual void DoSendPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, 
+                                        std::list<EpcS1apSap::ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList);
+
+  EpcS1apSapMme* m_s1apSapUser;
+  EpcS1apSapMmeProvider* m_s1apSapProvider;
+
+
+private:
+
+  /**
+   * Map the enbId to the corresponding (sourceSocket, remoteIpAddr) to be used
+   * to send the S1ap message
+   */
+  std::map < uint16_t, Ptr<S1apIfaceInfo> > m_s1apInterfaceSockets;
+
+  /**
+   * Map the localSocket (the one receiving the S1ap message) 
+   * to the corresponding (sourceCellId, targetCellId) associated with the S1ap interface
+   */
+  std::map < Ptr<Socket>, Ptr<S1apConnectionInfo> > m_s1apInterfaceCellIds;
+
+  /**
+   * UDP port to be used for the S1ap interfaces: S1ap
+   */
+  uint16_t m_s1apUdpPort;
+
+  uint16_t m_mmeId; // ID of the MME to which this S1AP endpoint is installed
+
+  Ptr<Socket> m_localS1APSocket; // local socket to receive from the eNBs S1AP endpoints
+
+};
+
+} //namespace ns3
+
+#endif // EPC_S1AP_H
diff -Naru a/model/epc-s1ap-header.cc b/model/epc-s1ap-header.cc
--- a/model/epc-s1ap-header.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-s1ap-header.cc	2018-08-03 16:39:02.875957522 +0200
@@ -0,0 +1,1303 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com>
+ * Inspired by epc-x2-header.cc
+ */
+
+#include "ns3/log.h"
+#include "ns3/epc-s1ap-header.h"
+#include <list>
+
+
+// TODO 
+// According to 36.413 9.2.3.4: enbUeS1Id should be 3 byte, but in the SAP interface 
+// already defined in the ns-3 release is 2 byte
+// The same holds for mmeUeS1Id, which should be 4 byte, but is 8 byte in the SAP interface
+
+namespace ns3 {
+
+
+NS_LOG_COMPONENT_DEFINE ("EpcS1APHeader");
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APHeader);
+
+EpcS1APHeader::EpcS1APHeader ()
+  : m_procedureCode (0xfa),
+    m_lengthOfIes (0xfa),
+    m_numberOfIes (0xfa)
+{
+}
+
+EpcS1APHeader::~EpcS1APHeader ()
+{
+  m_procedureCode = 0xfb;
+  m_lengthOfIes = 0xfb;
+  m_numberOfIes = 0xfb;
+}
+
+TypeId
+EpcS1APHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APHeader::GetSerializedSize (void) const
+{
+  return 6; // 6 bytes in this header
+}
+
+void
+EpcS1APHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteU8 (m_procedureCode);
+
+  i.WriteU8 (0x00); // 36.413 9.1.2.2 Criticality - if not recognized, 0 == reject
+  i.WriteU8 (m_lengthOfIes + 3);
+  i.WriteHtonU16 (0);
+  i.WriteU8 (m_numberOfIes);
+}
+
+uint32_t
+EpcS1APHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_procedureCode = i.ReadU8 ();
+
+  i.ReadU8 ();
+  m_lengthOfIes = i.ReadU8 () - 3;
+  i.ReadNtohU16 ();
+  m_numberOfIes = i.ReadU8 ();
+  
+  return GetSerializedSize ();
+}
+
+void
+EpcS1APHeader::Print (std::ostream &os) const
+{
+  os << " ProcedureCode=" << (uint32_t) m_procedureCode;
+  os << " LengthOfIEs=" << (uint32_t) m_lengthOfIes;
+  os << " NumberOfIEs=" << (uint32_t) m_numberOfIes;
+}
+
+uint8_t
+EpcS1APHeader::GetProcedureCode () const
+{
+  return m_procedureCode;
+}
+
+void
+EpcS1APHeader::SetProcedureCode (uint8_t procedureCode)
+{
+  m_procedureCode = procedureCode;
+}
+
+
+void
+EpcS1APHeader::SetLengthOfIes (uint32_t lengthOfIes)
+{
+  m_lengthOfIes = lengthOfIes;
+}
+
+void
+EpcS1APHeader::SetNumberOfIes (uint32_t numberOfIes)
+{
+  m_numberOfIes = numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APInitialUeMessageHeader);
+
+EpcS1APInitialUeMessageHeader::EpcS1APInitialUeMessageHeader ()
+  : m_numberOfIes (1 + 1 + 1 + 1 + 1 + 1 + 1),
+    m_headerLength (3 + 2 + 6 + 4 + 2 + 9 + 9),
+    m_stmsi (0xfffffffa),
+    m_mmeUeS1Id (0xfffffffa),
+    m_enbUeS1Id (0xfffa),
+    m_ecgi (0xfffa)
+{
+}
+
+EpcS1APInitialUeMessageHeader::~EpcS1APInitialUeMessageHeader ()
+{ 
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_stmsi = 0xfffffffb;
+  m_enbUeS1Id = 0xfffb;
+  m_ecgi = 0xfffb;
+  m_mmeUeS1Id = 0xfffffffb;
+}
+
+TypeId
+EpcS1APInitialUeMessageHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APInitialUeMessageHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APInitialUeMessageHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APInitialUeMessageHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APInitialUeMessageHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcS1APInitialUeMessageHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  // message type is already in EpcS1APHeader
+  i.WriteHtonU16 (m_enbUeS1Id);     // m_enbUeS1Id
+  i.WriteU8 (0);                    // criticality = REJECT
+
+  i.WriteU8 (0);                    // NAS PDU, not implemented
+  i.WriteU8 (0);                    // criticality = REJECT
+
+  i.WriteU32 (0);                   // TAI, not implemented
+  i.WriteU8 (0);
+  i.WriteU8 (0);                    // criticality = REJECT
+
+  i.WriteHtonU16 (m_ecgi);          // E-UTRAN CGI, it should have a different size
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  i.WriteU8 (0);                    // RRC Establishment cause
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  i.WriteU64 (m_stmsi);             // S-TMSI
+  i.WriteU8 (0);                    // criticality = REJECT
+
+  i.WriteU64 (m_mmeUeS1Id);         // mmeUeS1Id, not in the standard?
+  i.WriteU8 (0);                    // criticality = REJECT
+
+}
+
+uint32_t
+EpcS1APInitialUeMessageHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_enbUeS1Id = i.ReadNtohU16 ();
+  i.ReadU8 ();
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  i.ReadU8();
+  i.ReadU8();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  i.ReadU32 ();                   // TAI, not implemented
+  i.ReadU8 ();
+  i.ReadU8 ();                    
+  m_headerLength += 6;
+  m_numberOfIes++;
+
+  m_ecgi = i.ReadNtohU16 ();    // E-UTRAN CGI, it should have a different size
+  i.ReadU8();
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  i.ReadU8();
+  i.ReadU8();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_stmsi = i.ReadU64 ();             // S-TMSI
+  i.ReadU8 ();      
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  m_mmeUeS1Id = i.ReadU64 ();             // MME UE ID
+  i.ReadU8 ();      
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  return GetSerializedSize();
+}
+
+void
+EpcS1APInitialUeMessageHeader::Print (std::ostream &os) const
+{
+  os << "MmeUeS1apId = " << m_mmeUeS1Id;
+  os << " EnbUeS1Id = " << m_enbUeS1Id;
+  os << " ECGI = " << m_ecgi;
+  os << " S-TMSI = " << m_stmsi;
+}
+
+uint64_t 
+EpcS1APInitialUeMessageHeader::GetMmeUeS1Id () const 
+{
+  return m_mmeUeS1Id;
+}
+
+void 
+EpcS1APInitialUeMessageHeader::SetMmeUeS1Id (uint64_t mmeUeS1Id) 
+{
+  m_mmeUeS1Id = mmeUeS1Id;
+}
+
+uint16_t 
+EpcS1APInitialUeMessageHeader::GetEnbUeS1Id () const
+{
+  return m_enbUeS1Id;
+}
+
+void 
+EpcS1APInitialUeMessageHeader::SetEnbUeS1Id (uint16_t enbUeS1Id)
+{
+  m_enbUeS1Id = enbUeS1Id;
+}
+
+uint64_t 
+EpcS1APInitialUeMessageHeader::GetSTmsi () const 
+{
+  return m_stmsi;
+}
+
+void 
+EpcS1APInitialUeMessageHeader::SetSTmsi (uint64_t stmsi) 
+{
+  m_stmsi = stmsi;
+}
+
+uint16_t 
+EpcS1APInitialUeMessageHeader::GetEcgi () const 
+{
+  return m_ecgi;
+}
+
+void 
+EpcS1APInitialUeMessageHeader::SetEcgi (uint16_t ecgi)
+{
+  m_ecgi = ecgi;
+}
+
+uint32_t
+EpcS1APInitialUeMessageHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcS1APInitialUeMessageHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APErabReleaseIndicationHeader);
+
+EpcS1APErabReleaseIndicationHeader::EpcS1APErabReleaseIndicationHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (9 + 3 + 4 + 1),
+    m_enbUeS1Id (0xfffa),
+    m_mmeUeS1Id (0xfffffffa)
+{
+  m_erabToBeReleaseIndication.clear();
+}
+
+EpcS1APErabReleaseIndicationHeader::~EpcS1APErabReleaseIndicationHeader ()
+{ 
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_enbUeS1Id = 0xfffb;
+  m_mmeUeS1Id = 0xfffffffb;
+  m_erabToBeReleaseIndication.clear();
+}
+
+TypeId
+EpcS1APErabReleaseIndicationHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APErabReleaseIndicationHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APErabReleaseIndicationHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APErabReleaseIndicationHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APErabReleaseIndicationHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcS1APErabReleaseIndicationHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  // message type is already in EpcS1APHeader
+  i.WriteU64 (m_mmeUeS1Id);         // mmeUeS1Id
+  i.WriteU8 (0);                    // criticality = REJECT
+
+  i.WriteHtonU16 (m_enbUeS1Id);     // m_enbUeS1Id
+  i.WriteU8 (0);                    // criticality = REJECT
+
+  std::list <EpcS1apSap::ErabToBeReleasedIndication>::size_type sz = m_erabToBeReleaseIndication.size (); 
+  i.WriteHtonU32 (sz);              // number of bearers
+  for (std::list <EpcS1apSap::ErabToBeReleasedIndication>::const_iterator l_iter = m_erabToBeReleaseIndication.begin(); l_iter != m_erabToBeReleaseIndication.end(); ++l_iter) // content of ErabToBeReleasedIndication
+  {
+    i.WriteU8 (l_iter->erabId);
+  }
+  i.WriteU8(0); // criticality = REJECT, just one for the whole list
+
+}
+
+uint32_t
+EpcS1APErabReleaseIndicationHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_mmeUeS1Id = i.ReadU64 ();         // mmeUeS1Id
+  i.ReadU8 ();                 
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  m_enbUeS1Id = i.ReadNtohU16 ();     // m_enbUeS1Id
+  i.ReadU8 ();           
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  int sz = i.ReadNtohU32(); // number of bearers
+  m_headerLength += 4;
+
+  for (int j = 0; j < (int) sz; j++) // content of ErabToBeReleasedIndication
+  {
+    EpcS1apSap::ErabToBeReleasedIndication erabItem;
+    erabItem.erabId = i.ReadU8 ();
+
+    m_erabToBeReleaseIndication.push_back(erabItem);
+    m_headerLength += 1;
+  }
+  i.ReadU8();
+  m_headerLength += 1;
+  m_numberOfIes++;
+  
+  return GetSerializedSize();
+}
+
+void
+EpcS1APErabReleaseIndicationHeader::Print (std::ostream &os) const
+{
+  os << "MmeUeS1apId = " << m_mmeUeS1Id;
+  os << " EnbUeS1Id = " << m_enbUeS1Id;
+  for(std::list <EpcS1apSap::ErabToBeReleasedIndication>::const_iterator l_iter = m_erabToBeReleaseIndication.begin(); l_iter != m_erabToBeReleaseIndication.end(); ++l_iter)
+  { 
+    os << " ErabId " << l_iter->erabId;
+  }
+
+}
+
+uint64_t 
+EpcS1APErabReleaseIndicationHeader::GetMmeUeS1Id () const 
+{
+  return m_mmeUeS1Id;
+}
+
+void 
+EpcS1APErabReleaseIndicationHeader::SetMmeUeS1Id (uint64_t mmeUeS1Id) 
+{
+  m_mmeUeS1Id = mmeUeS1Id;
+}
+
+uint16_t 
+EpcS1APErabReleaseIndicationHeader::GetEnbUeS1Id () const
+{
+  return m_enbUeS1Id;
+}
+
+void 
+EpcS1APErabReleaseIndicationHeader::SetEnbUeS1Id (uint16_t enbUeS1Id)
+{
+  m_enbUeS1Id = enbUeS1Id;
+}
+
+std::list<EpcS1apSap::ErabToBeReleasedIndication>
+EpcS1APErabReleaseIndicationHeader::GetErabToBeReleaseIndication () const 
+{
+  return m_erabToBeReleaseIndication;
+}
+
+void 
+EpcS1APErabReleaseIndicationHeader::SetErabReleaseIndication (std::list<EpcS1apSap::ErabToBeReleasedIndication> erabToBeReleaseIndication)
+{
+  m_headerLength += erabToBeReleaseIndication.size();
+  m_erabToBeReleaseIndication = erabToBeReleaseIndication;
+}
+
+uint32_t
+EpcS1APErabReleaseIndicationHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcS1APErabReleaseIndicationHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APInitialContextSetupResponseHeader);
+
+EpcS1APInitialContextSetupResponseHeader::EpcS1APInitialContextSetupResponseHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (9 + 3 + 4 + 1),
+    m_enbUeS1Id (0xfffa),
+    m_mmeUeS1Id (0xfffffffa)
+{
+  m_erabSetupList.clear();
+}
+
+EpcS1APInitialContextSetupResponseHeader::~EpcS1APInitialContextSetupResponseHeader ()
+{ 
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_enbUeS1Id = 0xfffb;
+  m_mmeUeS1Id = 0xfffffffb;
+  m_erabSetupList.clear();
+}
+
+TypeId
+EpcS1APInitialContextSetupResponseHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APInitialContextSetupResponseHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APInitialContextSetupResponseHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APInitialContextSetupResponseHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APInitialContextSetupResponseHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcS1APInitialContextSetupResponseHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  // message type is already in EpcS1APHeader
+  i.WriteU64 (m_mmeUeS1Id);         // mmeUeS1Id
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  i.WriteHtonU16 (m_enbUeS1Id);     // m_enbUeS1Id
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  std::list <EpcS1apSap::ErabSetupItem>::size_type sz = m_erabSetupList.size (); 
+  i.WriteHtonU32 (sz);              // number of bearers
+  for (std::list <EpcS1apSap::ErabSetupItem>::const_iterator l_iter = m_erabSetupList.begin(); l_iter != m_erabSetupList.end(); ++l_iter) // content of m_erabSetupList
+  {
+    i.WriteU8 (l_iter->erabId);
+    i.WriteHtonU32 (l_iter->enbTransportLayerAddress.Get ());
+    i.WriteHtonU32 (l_iter->enbTeid);
+    i.WriteU8 (1 << 6);               // criticality = IGNORE each
+  }
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+}
+
+uint32_t
+EpcS1APInitialContextSetupResponseHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_mmeUeS1Id = i.ReadU64 ();         // mmeUeS1Id
+  i.ReadU8 ();                 
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  m_enbUeS1Id = i.ReadNtohU16 ();     // m_enbUeS1Id
+  i.ReadU8 ();           
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  int sz = i.ReadNtohU32(); // number of bearers
+  m_headerLength += 4;
+
+  for (int j = 0; j < (int) sz; j++) // content of ErabToBeReleasedIndication
+  {
+    EpcS1apSap::ErabSetupItem erabItem;
+    erabItem.erabId = i.ReadU8 ();
+    erabItem.enbTransportLayerAddress = Ipv4Address (i.ReadNtohU32 ());
+    erabItem.enbTeid = i.ReadNtohU32 ();
+    i.ReadU8 ();
+
+    m_erabSetupList.push_back(erabItem);
+    m_headerLength += 10;
+  }
+  i.ReadU8();
+  m_headerLength += 1;
+  m_numberOfIes++;
+  
+  return GetSerializedSize();
+}
+
+void
+EpcS1APInitialContextSetupResponseHeader::Print (std::ostream &os) const
+{
+  os << "MmeUeS1apId = " << m_mmeUeS1Id;
+  os << " EnbUeS1Id = " << m_enbUeS1Id;
+  for (std::list <EpcS1apSap::ErabSetupItem>::const_iterator l_iter = m_erabSetupList.begin(); l_iter != m_erabSetupList.end(); ++l_iter) // content of m_erabSetupList
+  {
+    os << " ErabId " << l_iter->erabId;
+    os << " enbTransportLayerAddress " << l_iter->enbTransportLayerAddress;
+    os << " enbTeid " << l_iter->enbTeid;
+  }
+
+}
+
+uint64_t 
+EpcS1APInitialContextSetupResponseHeader::GetMmeUeS1Id () const 
+{
+  return m_mmeUeS1Id;
+}
+
+void 
+EpcS1APInitialContextSetupResponseHeader::SetMmeUeS1Id (uint64_t mmeUeS1Id) 
+{
+  m_mmeUeS1Id = mmeUeS1Id;
+}
+
+uint16_t 
+EpcS1APInitialContextSetupResponseHeader::GetEnbUeS1Id () const
+{
+  return m_enbUeS1Id;
+}
+
+void 
+EpcS1APInitialContextSetupResponseHeader::SetEnbUeS1Id (uint16_t enbUeS1Id)
+{
+  m_enbUeS1Id = enbUeS1Id;
+}
+
+std::list<EpcS1apSap::ErabSetupItem>
+EpcS1APInitialContextSetupResponseHeader::GetErabSetupItem () const 
+{
+  return m_erabSetupList;
+}
+
+void 
+EpcS1APInitialContextSetupResponseHeader::SetErabSetupItem (std::list<EpcS1apSap::ErabSetupItem> erabSetupList)
+{
+  m_headerLength += erabSetupList.size() * 10;
+  m_erabSetupList = erabSetupList;
+}
+
+uint32_t
+EpcS1APInitialContextSetupResponseHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcS1APInitialContextSetupResponseHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APPathSwitchRequestHeader);
+
+EpcS1APPathSwitchRequestHeader::EpcS1APPathSwitchRequestHeader ()
+  : m_numberOfIes (1 + 1 + 1 + 1 + 1),
+    m_headerLength (3 + 4 + 1 +9 + 3 + 6),
+    m_enbUeS1Id (0xfffa),
+    m_ecgi (0xfffa),
+    m_mmeUeS1Id (0xfffffffa)
+{
+  m_erabToBeSwitchedInDownlinkList.clear();
+}
+
+EpcS1APPathSwitchRequestHeader::~EpcS1APPathSwitchRequestHeader ()
+{ 
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_enbUeS1Id = 0xfffb;
+  m_ecgi = 0xfffb;
+  m_mmeUeS1Id = 0xfffffffb;
+  m_erabToBeSwitchedInDownlinkList.clear();
+}
+
+TypeId
+EpcS1APPathSwitchRequestHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APPathSwitchRequestHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APPathSwitchRequestHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APPathSwitchRequestHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APPathSwitchRequestHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+
+void
+EpcS1APPathSwitchRequestHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  // message type is already in EpcS1APHeader 
+  i.WriteHtonU16 (m_enbUeS1Id);     // m_enbUeS1Id
+  i.WriteU8 (0);               // criticality = REJECT
+
+  std::list <EpcS1apSap::ErabSwitchedInDownlinkItem>::size_type sz = m_erabToBeSwitchedInDownlinkList.size (); 
+  i.WriteHtonU32 (sz);              // number of bearers
+  for (std::list <EpcS1apSap::ErabSwitchedInDownlinkItem>::const_iterator l_iter = m_erabToBeSwitchedInDownlinkList.begin(); l_iter != m_erabToBeSwitchedInDownlinkList.end(); ++l_iter) // content of ErabToBeReleasedIndication // content of m_erabToBeSwitchedInDownlinkList
+  {
+    i.WriteU8 (l_iter->erabId);
+    i.WriteHtonU32 (l_iter->enbTransportLayerAddress.Get ());
+    i.WriteHtonU32 (l_iter->enbTeid);
+    i.WriteU8 (0);               // criticality = REJECT each
+  }
+  i.WriteU8 (0);               // criticality = REJECT
+
+  i.WriteU64 (m_mmeUeS1Id);         // mmeUeS1Id
+  i.WriteU8 (0);               // criticality = REJECT
+
+  i.WriteU16 (m_ecgi);      // ecgi
+  i.WriteU8 (1 << 6);       // criticality = IGNORE
+
+  i.WriteU32 (0);                   // TAI, not implemented
+  i.WriteU8 (0);
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  // TODO add 9.2.1.40
+
+}
+
+uint32_t
+EpcS1APPathSwitchRequestHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_enbUeS1Id = i.ReadNtohU16 ();     // m_enbUeS1Id
+  i.ReadU8 ();           
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  int sz = i.ReadNtohU32(); // number of bearers
+  m_headerLength += 4;
+
+  for (int j = 0; j < (int) sz; j++) // content of ErabToBeReleasedIndication
+  {
+    EpcS1apSap::ErabSwitchedInDownlinkItem erabItem;
+    erabItem.erabId = i.ReadU8 ();
+    erabItem.enbTransportLayerAddress = Ipv4Address (i.ReadNtohU32 ());
+    erabItem.enbTeid = i.ReadNtohU32 ();
+    i.ReadU8 ();
+
+    m_erabToBeSwitchedInDownlinkList.push_back(erabItem);
+    m_headerLength += 10;
+  }
+  i.ReadU8();
+  m_headerLength += 1;
+  m_numberOfIes++;
+
+  m_mmeUeS1Id = i.ReadU64 ();         // mmeUeS1Id
+  i.ReadU8 ();                 
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  m_ecgi = i.ReadU16 ();      // ecgi
+  i.ReadU8();
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  i.ReadU32 ();                   // TAI, not implemented
+  i.ReadU8 ();
+  i.ReadU8 ();               // criticality = IGNORE
+
+  m_headerLength += 6;
+  m_numberOfIes++;
+
+  return GetSerializedSize();
+}
+
+void
+EpcS1APPathSwitchRequestHeader::Print (std::ostream &os) const
+{
+  os << "MmeUeS1apId = " << m_mmeUeS1Id;
+  os << " EnbUeS1Id = " << m_enbUeS1Id;
+  os << " ECGI = " << m_ecgi; 
+  for (std::list <EpcS1apSap::ErabSwitchedInDownlinkItem>::const_iterator l_iter = m_erabToBeSwitchedInDownlinkList.begin(); l_iter != m_erabToBeSwitchedInDownlinkList.end(); ++l_iter) // content of ErabToBeReleasedIndication // content of m_erabToBeSwitchedInDownlinkList
+  {
+    os << " ErabId " << l_iter->erabId;
+    os << " enbTransportLayerAddress " << l_iter->enbTransportLayerAddress;
+    os << " enbTeid " << l_iter->enbTeid;
+  }
+
+}
+
+uint64_t 
+EpcS1APPathSwitchRequestHeader::GetMmeUeS1Id () const 
+{
+  return m_mmeUeS1Id;
+}
+
+void 
+EpcS1APPathSwitchRequestHeader::SetMmeUeS1Id (uint64_t mmeUeS1Id) 
+{
+  m_mmeUeS1Id = mmeUeS1Id;
+}
+
+uint16_t 
+EpcS1APPathSwitchRequestHeader::GetEnbUeS1Id () const
+{
+  return m_enbUeS1Id;
+}
+
+void 
+EpcS1APPathSwitchRequestHeader::SetEnbUeS1Id (uint16_t enbUeS1Id)
+{
+  m_enbUeS1Id = enbUeS1Id;
+}
+
+std::list<EpcS1apSap::ErabSwitchedInDownlinkItem>
+EpcS1APPathSwitchRequestHeader::GetErabSwitchedInDownlinkItemList () const 
+{
+  return m_erabToBeSwitchedInDownlinkList;
+}
+
+void 
+EpcS1APPathSwitchRequestHeader::SetErabSwitchedInDownlinkItemList (std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> erabSetupList)
+{
+	m_headerLength += erabSetupList.size()*10;
+  m_erabToBeSwitchedInDownlinkList = erabSetupList;
+}
+
+uint16_t
+EpcS1APPathSwitchRequestHeader::GetEcgi() const
+{
+  return m_ecgi;
+}
+
+void
+EpcS1APPathSwitchRequestHeader::SetEcgi(uint16_t ecgi) 
+{
+  m_ecgi = ecgi;
+}
+
+uint32_t
+EpcS1APPathSwitchRequestHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcS1APPathSwitchRequestHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APInitialContextSetupRequestHeader);
+
+EpcS1APInitialContextSetupRequestHeader::EpcS1APInitialContextSetupRequestHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (9 + 3 + 9 + 4 + 1),
+    m_enbUeS1Id (0xfffa),
+    m_mmeUeS1Id (0xfffffffa)
+{
+  m_erabsToBeSetupList.clear();
+}
+
+EpcS1APInitialContextSetupRequestHeader::~EpcS1APInitialContextSetupRequestHeader ()
+{ 
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_enbUeS1Id = 0xfffb;
+  m_mmeUeS1Id = 0xfffffffb;
+  m_erabsToBeSetupList.clear();
+}
+
+TypeId
+EpcS1APInitialContextSetupRequestHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APInitialContextSetupRequestHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APInitialContextSetupRequestHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APInitialContextSetupRequestHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APInitialContextSetupRequestHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcS1APInitialContextSetupRequestHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  // message type is already in EpcS1APHeader
+  i.WriteU64 (m_mmeUeS1Id);         // mmeUeS1Id
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  i.WriteHtonU16 (m_enbUeS1Id);     // m_enbUeS1Id
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  i.WriteHtonU64 (0);               // aggregate maximum bitrate, not implemented
+  i.WriteU8 (0);
+
+  std::list <EpcS1apSap::ErabToBeSetupItem>::size_type sz = m_erabsToBeSetupList.size (); 
+  i.WriteHtonU32 (sz);              // number of bearers
+  for (std::list <EpcS1apSap::ErabToBeSetupItem>::const_iterator l_iter = m_erabsToBeSetupList.begin(); l_iter != m_erabsToBeSetupList.end(); ++l_iter) // content of m_erabsToBeSetupList
+    {
+      i.WriteU8 (l_iter->erabId);
+      i.WriteHtonU16 (l_iter->erabLevelQosParameters.qci);
+      i.WriteHtonU64 (l_iter->erabLevelQosParameters.gbrQosInfo.gbrDl);
+      i.WriteHtonU64 (l_iter->erabLevelQosParameters.gbrQosInfo.gbrUl);
+      i.WriteHtonU64 (l_iter->erabLevelQosParameters.gbrQosInfo.mbrDl);
+      i.WriteHtonU64 (l_iter->erabLevelQosParameters.gbrQosInfo.mbrUl);
+      i.WriteU8 (l_iter->erabLevelQosParameters.arp.priorityLevel);
+      i.WriteU8 (l_iter->erabLevelQosParameters.arp.preemptionCapability);
+      i.WriteU8 (l_iter->erabLevelQosParameters.arp.preemptionVulnerability);
+      i.WriteHtonU32 (l_iter->transportLayerAddress.Get ());
+      i.WriteHtonU32 (l_iter->sgwTeid);
+
+      i.WriteU8(0); // a criticaloty each, REJECT
+    }
+  i.WriteU8 (0);               // criticality = REJECT
+
+  //TODO 9.2.140, 9.2.1.41
+
+}
+
+uint32_t
+EpcS1APInitialContextSetupRequestHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_mmeUeS1Id = i.ReadU64 ();         // mmeUeS1Id
+  i.ReadU8 ();                 
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  m_enbUeS1Id = i.ReadNtohU16 ();     // m_enbUeS1Id
+  i.ReadU8 ();           
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  i.ReadU64 ();               // aggregate maximum bitrate, not implemented
+  i.ReadU8 ();
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  int sz = i.ReadNtohU32(); // number of bearers
+  m_headerLength += 4;
+
+  for (int j = 0; j < (int) sz; j++) // content of m_erabToBeSetupList
+  {
+    EpcS1apSap::ErabToBeSetupItem erabItem;
+    erabItem.erabId = i.ReadU8 ();
+ 
+    erabItem.erabLevelQosParameters = EpsBearer ((EpsBearer::Qci) i.ReadNtohU16 ());
+    erabItem.erabLevelQosParameters.gbrQosInfo.gbrDl = i.ReadNtohU64 ();
+    erabItem.erabLevelQosParameters.gbrQosInfo.gbrUl = i.ReadNtohU64 ();
+    erabItem.erabLevelQosParameters.gbrQosInfo.mbrDl = i.ReadNtohU64 ();
+    erabItem.erabLevelQosParameters.gbrQosInfo.mbrUl = i.ReadNtohU64 ();
+    erabItem.erabLevelQosParameters.arp.priorityLevel = i.ReadU8 ();
+    erabItem.erabLevelQosParameters.arp.preemptionCapability = i.ReadU8 ();
+    erabItem.erabLevelQosParameters.arp.preemptionVulnerability = i.ReadU8 ();
+
+    erabItem.transportLayerAddress = Ipv4Address (i.ReadNtohU32 ());
+    erabItem.sgwTeid = i.ReadNtohU32 ();
+
+    i.ReadU8 ();
+
+    m_erabsToBeSetupList.push_back (erabItem);
+    m_headerLength += 46;
+  }
+  i.ReadU8();
+  m_headerLength += 1;
+  m_numberOfIes++;
+  
+  return GetSerializedSize();
+}
+
+void
+EpcS1APInitialContextSetupRequestHeader::Print (std::ostream &os) const
+{
+  os << " MmeUeS1Id = " << m_mmeUeS1Id;
+  os << " EnbUeS1Id = " << m_enbUeS1Id;
+  os << " NumOfBearers = " << m_erabsToBeSetupList.size ();
+
+  std::list <EpcS1apSap::ErabToBeSetupItem>::size_type sz = m_erabsToBeSetupList.size ();
+  if (sz > 0)
+    {
+      os << " [";
+    }
+  int j = 0;  
+  for (std::list <EpcS1apSap::ErabToBeSetupItem>::const_iterator l_iter = m_erabsToBeSetupList.begin(); l_iter != m_erabsToBeSetupList.end(); ++l_iter) // content of m_erabsToBeSetupList
+  {
+    os << l_iter->erabId;
+    if (j < (int) sz - 1)
+      {
+        os << ", ";
+      }
+    else
+      {
+        os << "]";
+      }
+    j++;  
+  }
+}
+
+uint64_t 
+EpcS1APInitialContextSetupRequestHeader::GetMmeUeS1Id () const 
+{
+  return m_mmeUeS1Id;
+}
+
+void 
+EpcS1APInitialContextSetupRequestHeader::SetMmeUeS1Id (uint64_t mmeUeS1Id) 
+{
+  m_mmeUeS1Id = mmeUeS1Id;
+}
+
+uint16_t 
+EpcS1APInitialContextSetupRequestHeader::GetEnbUeS1Id () const
+{
+  return m_enbUeS1Id;
+}
+
+void 
+EpcS1APInitialContextSetupRequestHeader::SetEnbUeS1Id (uint16_t enbUeS1Id)
+{
+  m_enbUeS1Id = enbUeS1Id;
+}
+
+std::list<EpcS1apSap::ErabToBeSetupItem>
+EpcS1APInitialContextSetupRequestHeader::GetErabToBeSetupItem () const 
+{
+  return m_erabsToBeSetupList;
+}
+
+void 
+EpcS1APInitialContextSetupRequestHeader::SetErabToBeSetupItem (std::list<EpcS1apSap::ErabToBeSetupItem> erabSetupList)
+{
+  m_headerLength += erabSetupList.size()*47;
+  m_erabsToBeSetupList = erabSetupList;
+}
+
+uint32_t
+EpcS1APInitialContextSetupRequestHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcS1APInitialContextSetupRequestHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APPathSwitchRequestAcknowledgeHeader);
+
+EpcS1APPathSwitchRequestAcknowledgeHeader::EpcS1APPathSwitchRequestAcknowledgeHeader ()
+  : m_numberOfIes (1 + 1 + 1 + 1),
+    m_headerLength (3 + 4 + 1 + 9 + 3 + 6),
+    m_enbUeS1Id (0xfffa),
+    m_ecgi (0xfffa),
+    m_mmeUeS1Id (0xfffffffa)
+{
+  m_erabToBeSwitchedInUplinkList.clear();
+}
+
+EpcS1APPathSwitchRequestAcknowledgeHeader::~EpcS1APPathSwitchRequestAcknowledgeHeader ()
+{ 
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_enbUeS1Id = 0xfffb;
+  m_ecgi = 0xfffb;
+  m_mmeUeS1Id = 0xfffffffb;
+  m_erabToBeSwitchedInUplinkList.clear();
+}
+
+TypeId
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APPathSwitchRequestAcknowledgeHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APPathSwitchRequestAcknowledgeHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+
+void
+EpcS1APPathSwitchRequestAcknowledgeHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  // message type is already in EpcS1APHeader 
+  i.WriteHtonU16 (m_enbUeS1Id);     // m_enbUeS1Id
+  i.WriteU8 (0);               // criticality = REJECT
+
+  std::vector <EpcS1apSap::ErabSwitchedInUplinkItem>::size_type sz = m_erabToBeSwitchedInUplinkList.size (); 
+  i.WriteHtonU32 (sz);              // number of bearers
+  for (std::list <EpcS1apSap::ErabSwitchedInUplinkItem>::const_iterator l_iter = m_erabToBeSwitchedInUplinkList.begin(); l_iter != m_erabToBeSwitchedInUplinkList.end(); ++l_iter) // content of m_erabsToBeSetupList
+  {
+    i.WriteU8 (l_iter->erabId);
+    i.WriteHtonU32 (l_iter->transportLayerAddress.Get ());
+    i.WriteHtonU32 (l_iter->enbTeid);
+    i.WriteU8 (0);               // criticality = REJECT each
+  }
+  i.WriteU8 (0);               // criticality = REJECT
+
+  i.WriteU64 (m_mmeUeS1Id);         // mmeUeS1Id
+  i.WriteU8 (0);               // criticality = REJECT
+
+  i.WriteU16 (m_ecgi);      // ecgi
+  i.WriteU8 (1 << 6);       // criticality = IGNORE
+
+  i.WriteU32 (0);                   // TAI, not implemented
+  i.WriteU8 (0);
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  // TODO add 9.2.1.40
+
+}
+
+uint32_t
+EpcS1APPathSwitchRequestAcknowledgeHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_enbUeS1Id = i.ReadNtohU16 ();     // m_enbUeS1Id
+  i.ReadU8 ();           
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  int sz = i.ReadNtohU32(); // number of bearers
+  m_headerLength += 4;
+
+  for (int j = 0; j < (int) sz; j++) // content of ErabToBeReleasedIndication
+  {
+    EpcS1apSap::ErabSwitchedInUplinkItem erabItem;
+    erabItem.erabId = i.ReadU8 ();
+    erabItem.transportLayerAddress = Ipv4Address (i.ReadNtohU32 ());
+    erabItem.enbTeid = i.ReadNtohU32 ();
+    i.ReadU8 ();
+
+    m_erabToBeSwitchedInUplinkList.push_back(erabItem);
+    m_headerLength += 9;
+  }
+  i.ReadU8();
+  m_headerLength += 1;
+  m_numberOfIes++;
+
+  m_mmeUeS1Id = i.ReadU64 ();         // mmeUeS1Id
+  i.ReadU8 ();                 
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  m_ecgi = i.ReadU16 ();      // ecgi
+  i.ReadU8();
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  i.ReadU32 ();                   // TAI, not implemented
+  i.ReadU8 ();
+  i.ReadU8 ();               // criticality = IGNORE
+
+  m_headerLength += 6;
+  m_numberOfIes++;
+
+  return GetSerializedSize();
+}
+
+void
+EpcS1APPathSwitchRequestAcknowledgeHeader::Print (std::ostream &os) const
+{
+  os << "MmeUeS1apId = " << m_mmeUeS1Id;
+  os << " EnbUeS1Id = " << m_enbUeS1Id;
+  os << " ECGI = " << m_ecgi; 
+  for (std::list <EpcS1apSap::ErabSwitchedInUplinkItem>::const_iterator l_iter = m_erabToBeSwitchedInUplinkList.begin(); l_iter != m_erabToBeSwitchedInUplinkList.end(); ++l_iter) // content of m_erabsToBeSetupList
+  {
+    os << " ErabId " << l_iter->erabId;
+    os << " TransportLayerAddress " << l_iter->transportLayerAddress;
+    os << " enbTeid " << l_iter->enbTeid;
+  }
+
+}
+
+uint64_t 
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetMmeUeS1Id () const 
+{
+  return m_mmeUeS1Id;
+}
+
+void 
+EpcS1APPathSwitchRequestAcknowledgeHeader::SetMmeUeS1Id (uint64_t mmeUeS1Id) 
+{
+  m_mmeUeS1Id = mmeUeS1Id;
+}
+
+uint16_t 
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetEnbUeS1Id () const
+{
+  return m_enbUeS1Id;
+}
+
+void 
+EpcS1APPathSwitchRequestAcknowledgeHeader::SetEnbUeS1Id (uint16_t enbUeS1Id)
+{
+  m_enbUeS1Id = enbUeS1Id;
+}
+
+std::list<EpcS1apSap::ErabSwitchedInUplinkItem>
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetErabSwitchedInUplinkItemList () const 
+{
+  return m_erabToBeSwitchedInUplinkList;
+}
+
+void 
+EpcS1APPathSwitchRequestAcknowledgeHeader::SetErabSwitchedInUplinkItemList (std::list<EpcS1apSap::ErabSwitchedInUplinkItem> erabSetupList)
+{
+  m_headerLength += erabSetupList.size() * 10;
+  m_erabToBeSwitchedInUplinkList = erabSetupList;
+}
+
+uint16_t
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetEcgi() const
+{
+  return m_ecgi;
+}
+
+void
+EpcS1APPathSwitchRequestAcknowledgeHeader::SetEcgi(uint16_t ecgi) 
+{
+  m_ecgi = ecgi;
+}
+
+uint32_t
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+}; // end of namespace ns3
\ No newline at end of file
diff -Naru a/model/epc-s1ap-header.h b/model/epc-s1ap-header.h
--- a/model/epc-s1ap-header.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-s1ap-header.h	2018-08-03 16:39:02.875957522 +0200
@@ -0,0 +1,295 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com>
+ * Inspired by epc-x2-header.h
+ */
+
+#ifndef EPC_S1AP_HEADER_H
+#define EPC_S1AP_HEADER_H
+
+#include "ns3/epc-s1ap-sap.h"
+#include "ns3/header.h"
+
+#include <list>
+
+
+namespace ns3 {
+
+
+class EpcS1APHeader : public Header
+{
+public:
+  EpcS1APHeader ();
+  virtual ~EpcS1APHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+  uint8_t GetProcedureCode () const;
+  void SetProcedureCode (uint8_t procedureCode);
+
+  void SetLengthOfIes (uint32_t lengthOfIes);
+  void SetNumberOfIes (uint32_t numberOfIes);
+
+
+  enum ProcedureCode_t {
+    InitialUeMessage        = 71,
+    PathSwitchRequest       = 58,
+    ErabReleaseIndication   = 37,
+    InitialContextSetupResponse = 43,
+    InitialContextSetupRequest = 41,
+    PathSwitchRequestAck = 59
+  };
+
+
+private:
+  uint8_t m_procedureCode;
+
+  uint32_t m_lengthOfIes;
+  uint32_t m_numberOfIes;
+};
+
+
+// Header for initial Ue message
+class EpcS1APInitialUeMessageHeader : public Header
+{
+public:
+  EpcS1APInitialUeMessageHeader ();
+  virtual ~EpcS1APInitialUeMessageHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint64_t GetMmeUeS1Id () const;
+  void SetMmeUeS1Id (uint64_t mmeUeS1Id);
+
+  uint16_t GetEnbUeS1Id () const;
+  void SetEnbUeS1Id (uint16_t enbUeS1Id);
+
+  uint64_t GetSTmsi () const;
+  void SetSTmsi (uint64_t stmsi);
+
+  uint16_t GetEcgi () const;
+  void SetEcgi (uint16_t ecgi);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+  uint64_t          m_stmsi;
+  uint64_t          m_mmeUeS1Id;
+  uint16_t          m_enbUeS1Id;
+  uint16_t          m_ecgi;
+};
+
+
+
+class EpcS1APErabReleaseIndicationHeader : public Header
+{
+public:
+  EpcS1APErabReleaseIndicationHeader ();
+  virtual ~EpcS1APErabReleaseIndicationHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint64_t GetMmeUeS1Id () const;
+  void SetMmeUeS1Id (uint64_t mmeUeS1Id);
+
+  uint16_t GetEnbUeS1Id () const;
+  void SetEnbUeS1Id (uint16_t enbUeS1Id);
+
+  std::list<EpcS1apSap::ErabToBeReleasedIndication> GetErabToBeReleaseIndication () const;
+  void SetErabReleaseIndication (std::list<EpcS1apSap::ErabToBeReleasedIndication> erabToBeReleaseIndication);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+  uint16_t          m_enbUeS1Id;
+  uint64_t          m_mmeUeS1Id;
+  std::list<EpcS1apSap::ErabToBeReleasedIndication> m_erabToBeReleaseIndication;
+};
+
+
+class EpcS1APInitialContextSetupResponseHeader : public Header
+{
+public:
+  EpcS1APInitialContextSetupResponseHeader ();
+  virtual ~EpcS1APInitialContextSetupResponseHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint64_t GetMmeUeS1Id () const;
+  void SetMmeUeS1Id (uint64_t mmeUeS1Id);
+
+  uint16_t GetEnbUeS1Id () const;
+  void SetEnbUeS1Id (uint16_t enbUeS1Id);
+
+  std::list<EpcS1apSap::ErabSetupItem> GetErabSetupItem () const;
+  void SetErabSetupItem (std::list<EpcS1apSap::ErabSetupItem> erabSetupList);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+  uint16_t          m_enbUeS1Id;
+  uint64_t          m_mmeUeS1Id;
+  std::list<EpcS1apSap::ErabSetupItem> m_erabSetupList;
+};
+
+class EpcS1APPathSwitchRequestHeader : public Header
+{
+public:
+  EpcS1APPathSwitchRequestHeader ();
+  virtual ~EpcS1APPathSwitchRequestHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint64_t GetMmeUeS1Id () const;
+  void SetMmeUeS1Id (uint64_t mmeUeS1Id);
+
+  uint16_t GetEnbUeS1Id () const;
+  void SetEnbUeS1Id (uint16_t enbUeS1Id);
+
+  uint16_t GetEcgi () const;
+  void SetEcgi (uint16_t ecgi);
+
+  std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> GetErabSwitchedInDownlinkItemList () const;
+  void SetErabSwitchedInDownlinkItemList (std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+  uint16_t          m_enbUeS1Id;
+  uint16_t          m_ecgi;
+  uint64_t          m_mmeUeS1Id;
+  std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> m_erabToBeSwitchedInDownlinkList;
+};
+
+class EpcS1APInitialContextSetupRequestHeader : public Header
+{
+public:
+  EpcS1APInitialContextSetupRequestHeader ();
+  virtual ~EpcS1APInitialContextSetupRequestHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint64_t GetMmeUeS1Id () const;
+  void SetMmeUeS1Id (uint64_t mmeUeS1Id);
+
+  uint16_t GetEnbUeS1Id () const;
+  void SetEnbUeS1Id (uint16_t enbUeS1Id);
+
+  std::list<EpcS1apSap::ErabToBeSetupItem> GetErabToBeSetupItem () const;
+  void SetErabToBeSetupItem (std::list<EpcS1apSap::ErabToBeSetupItem> erabToBeSetupList);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+  uint16_t          m_enbUeS1Id;
+  uint64_t          m_mmeUeS1Id;
+  std::list<EpcS1apSap::ErabToBeSetupItem> m_erabsToBeSetupList;
+};
+
+class EpcS1APPathSwitchRequestAcknowledgeHeader : public Header
+{
+public:
+  EpcS1APPathSwitchRequestAcknowledgeHeader ();
+  virtual ~EpcS1APPathSwitchRequestAcknowledgeHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint64_t GetMmeUeS1Id () const;
+  void SetMmeUeS1Id (uint64_t mmeUeS1Id);
+
+  uint16_t GetEnbUeS1Id () const;
+  void SetEnbUeS1Id (uint16_t enbUeS1Id);
+
+  uint16_t GetEcgi () const;
+  void SetEcgi (uint16_t ecgi);
+
+  std::list<EpcS1apSap::ErabSwitchedInUplinkItem> GetErabSwitchedInUplinkItemList () const;
+  void SetErabSwitchedInUplinkItemList (std::list<EpcS1apSap::ErabSwitchedInUplinkItem> erabToBeSwitchedInDownlinkList);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+  uint16_t          m_enbUeS1Id;
+  uint16_t          m_ecgi;
+  uint64_t          m_mmeUeS1Id;
+  std::list<EpcS1apSap::ErabSwitchedInUplinkItem> m_erabToBeSwitchedInUplinkList;
+};
+
+}
+
+#endif //EPC_S1AP_HEADER_H
\ No newline at end of file
diff -Naru a/model/epc-s1ap-sap.h b/model/epc-s1ap-sap.h
--- a/model/epc-s1ap-sap.h	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-s1ap-sap.h	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.cat>
+ * Modified by: Michele Polese <michele.polese@gmail.com>
  */
 
 #ifndef EPC_S1AP_SAP_H
@@ -31,31 +33,80 @@
 
 namespace ns3 {
 
-/**
- * \ingroup lte
- *
- * Base class that defines EPC S1-AP Service Access Point (SAP) interface.
- */
 class EpcS1apSap
 {
 public:
   virtual ~EpcS1apSap ();
 
+  // useful structures as defined in 3GPP ts 36.413 
+
+  /**
+   *  E-RAB Release Indication Item IEs, 3GPP TS 36.413 version 9.8.0 section 9.1.3.7
+   *
+   */
+  struct ErabToBeReleasedIndication
+  {
+    uint8_t erabId;
+  };
+
+  /**
+   *  E-RAB Setup Item IEs, see 3GPP TS 36.413 9.1.4.2 
+   * 
+   */
+  struct ErabSetupItem
+  {
+    uint16_t    erabId;
+    Ipv4Address enbTransportLayerAddress;
+    uint32_t    enbTeid;    
+  };
+
+
+  /**
+   * E-RABs Switched in Downlink Item IE, see 3GPP TS 36.413 9.1.5.8
+   * 
+   */
+  struct ErabSwitchedInDownlinkItem
+  {
+    uint16_t    erabId;
+    Ipv4Address enbTransportLayerAddress;
+    uint32_t    enbTeid;    
+  };
+
+  struct ErabToBeSetupItem
+  {
+    uint8_t    erabId;
+    EpsBearer   erabLevelQosParameters;
+    Ipv4Address transportLayerAddress;
+    uint32_t    sgwTeid;    
+  };
+
+  /**
+   * E-RABs Switched in Uplink Item IE, see 3GPP TS 36.413 9.1.5.9
+   * 
+   */
+  struct ErabSwitchedInUplinkItem
+  {
+    uint8_t    erabId;
+    Ipv4Address transportLayerAddress;
+    uint32_t    enbTeid;    
+  };
+
 };
 
 
 /**
  * \ingroup lte
  *
- * MME side of the S1-AP Service Access Point (SAP), provides the MME
- * methods to be called when an S1-AP message is received by the MME. 
+ * MME side of the S1-AP Service Access Point (SAP) user, provides the MME
+ * methods to be called when an S1-AP message is received by the MME S1-AP object. 
+ * S1-AP ---> MME
  */
 class EpcS1apSapMme : public EpcS1apSap
 {
 public:
 
   /** 
-   * 
+   * 3GPP TS 36.413 V13.1.0 section 9.1.7.1
    * \param mmeUeS1Id in practice, we use the IMSI
    * \param enbUeS1Id in practice, we use the RNTI
    * \param stmsi in practice, the imsi
@@ -64,37 +115,16 @@
    */
   virtual void InitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) = 0;
 
-
-  /**
-   *  E-RAB Release Indication Item IEs, 3GPP TS 36.413 version 9.8.0 section 9.1.3.7
-   *
-   */
-  struct ErabToBeReleasedIndication
-  {
-    uint8_t erabId; ///< E-RAB ID
-  };
-
   /**
     * \brief As per 3GPP TS 23.401 Release 9 V9.5.0 Figure 5.4.4.2-1  eNB sends indication of Bearer Release to MME
     * \brief As per 3GPP TS version 9.8.0 section 8.2.3.2.2, the eNB initiates the procedure by sending an E-RAB RELEASE INDICATION message towards MME
     * \param mmeUeS1Id in practice, we use the IMSI
     * \param enbUeS1Id in practice, we use the RNTI
-    * \param erabToBeReleaseIndication the List of bearers to be deactivated
+    * \param erabToBeReleaseIndication, List of bearers to be deactivated
     *
     */
   virtual void ErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeReleasedIndication> erabToBeReleaseIndication ) = 0;
 
-  /**
-   *  E-RAB Setup Item IEs, see 3GPP TS 36.413 9.1.4.2 
-   * 
-   */
-  struct ErabSetupItem
-  {
-    uint16_t    erabId; ///< E-RAB ID
-    Ipv4Address enbTransportLayerAddress; ///< transport layer address
-    uint32_t    enbTeid; ///< TEID
-  };
-
   /** 
    * INITIAL CONTEXT SETUP RESPONSE message,  see 3GPP TS 36.413 9.1.4.2 
    * 
@@ -107,82 +137,66 @@
                                             uint16_t enbUeS1Id,
                                             std::list<ErabSetupItem> erabSetupList) = 0;
 
-
-  /**
-   * E-RABs Switched in Downlink Item IE, see 3GPP TS 36.413 9.1.5.8
-   * 
-   */
-  struct ErabSwitchedInDownlinkItem
-  {
-    uint16_t    erabId; ///< ERAB ID
-    Ipv4Address enbTransportLayerAddress; ///< address 
-    uint32_t    enbTeid; ///< TEID   
-  };
-
   /**
    * PATH SWITCH REQUEST message, see 3GPP TS 36.413 9.1.5.8
    * 
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param gci
-   * \param erabToBeSwitchedInDownlinkList
    */
   virtual void PathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList) = 0;
 };
 
 
+/**
+ * \ingroup lte
+ *
+ * eNB side of the S1-AP Service Access Point (SAP) provider, provides the S1-AP methods 
+ * to be called when the eNB wants to send an S1-AP message
+ * eNB ---> S1-AP 
+ */
+class EpcS1apSapEnbProvider : public EpcS1apSap
+{
+public: 
+   
+  virtual void SendInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) = 0;
+
+  virtual void SendErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeReleasedIndication> erabToBeReleaseIndication ) = 0;
+
+  virtual void SendInitialContextSetupResponse (uint64_t mmeUeS1Id,
+                                            uint16_t enbUeS1Id,
+                                            std::list<ErabSetupItem> erabSetupList) = 0;
+
+  virtual void SendPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList) = 0;
+
+};
+
+
 
 /**
  * \ingroup lte
  *
- * eNB side of the S1-AP Service Access Point (SAP), provides the eNB
- * methods to be called when an S1-AP message is received by the eNB. 
+ * eNB side of the S1-AP Service Access Point (SAP) user, provides the eNB
+ * methods to be called when an S1-AP message is received by the eNB S1-AP object.
+ * S1-AP ---> eNB 
  */
 class EpcS1apSapEnb : public EpcS1apSap
 {
 public:
 
-
-  /// ErabToBeSetupItem structure
-  struct ErabToBeSetupItem
-  {
-    uint8_t    erabId; ///< ERAB iD
-    EpsBearer   erabLevelQosParameters; ///< Level QOS parameters
-    Ipv4Address transportLayerAddress; ///< transport layer address
-    uint32_t    sgwTeid; ///< TEID
-  };
-
   /** 
-   * Initial context setup request
    * 
+   * 3GPP TS 36.413 9.1.4.1
    * \param mmeUeS1Id in practice, we use the IMSI
    * \param enbUeS1Id in practice, we use the RNTI
    * \param erabToBeSetupList
+   * \param cellId, to select the enb to which the MME wants to communicate
    * 
    */
   virtual void InitialContextSetupRequest (uint64_t mmeUeS1Id,
                                            uint16_t enbUeS1Id,
                                            std::list<ErabToBeSetupItem> erabToBeSetupList) = 0;
 
-
-  /**
-   * E-RABs Switched in Uplink Item IE, see 3GPP TS 36.413 9.1.5.9
-   * 
-   */
-  struct ErabSwitchedInUplinkItem
-  {
-    uint8_t    erabId; ///< E_RAB ID
-    Ipv4Address transportLayerAddress; ///< transport layer address
-    uint32_t    enbTeid; ///< TEID
-  };
-
   /**
    * PATH SWITCH REQUEST ACKNOWLEDGE message, see 3GPP TS 36.413 9.1.5.9
    * 
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param cgi
-   * \param erabToBeSwitchedInUplinkList
    */
   virtual void PathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList) = 0;
 
@@ -190,12 +204,31 @@
 };
 
 
+/**
+ * \ingroup lte
+ *
+ * MME side of the S1-AP Service Access Point (SAP) provider, provides the S1-AP methods 
+ * to be called when the MME wants to send an S1-AP message
+ * MME ---> S1-AP
+ */
+class EpcS1apSapMmeProvider : public EpcS1apSap
+{
+public:
+  
+  virtual void SendInitialContextSetupRequest (uint64_t mmeUeS1Id,
+                                           uint16_t enbUeS1Id,
+                                           std::list<ErabToBeSetupItem> erabToBeSetupList,
+                                           uint16_t cellId) = 0;
+
+  virtual void SendPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList) = 0;
+
+};
 
 
 
 
 /**
- * Template for the implementation of the EpcS1apSapMme as a member
+ * Template for the implementation of the EpcS1apSapMmeUser as a member
  * of an owner class of type C to which all methods are forwarded
  * 
  */
@@ -203,49 +236,18 @@
 class MemberEpcS1apSapMme : public EpcS1apSapMme
 {
 public:
-/**
- * Constructor
- *
- * \param owner the owner class
- */
   MemberEpcS1apSapMme (C* owner);
 
   // inherited from EpcS1apSapMme
-  /**
-   * Initial UE Message function
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param imsi the IMSI
-   * \param ecgi
-   */
   virtual void InitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t ecgi);
-  /**
-   * ERAB Release Indiation function
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param erabToBeReleaseIndication
-   */
   virtual void ErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeReleasedIndication> erabToBeReleaseIndication );
 
-  /**
-   * Initial context setup response
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param erabSetupList
-   */
   virtual void InitialContextSetupResponse (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabSetupItem> erabSetupList);
-  /**
-   * Path switch request
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param cgi
-   * \param erabToBeSwitchedInDownlinkList
-   */
   virtual void PathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList);
 
 private:
   MemberEpcS1apSapMme ();
-  C* m_owner; ///< owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -285,7 +287,63 @@
 
 
 
+/**
+ * Template for the implementation of the EpcS1apSapEnbProvider as a member
+ * of an owner class of type C to which all methods are forwarded
+ * 
+ */
+template <class C>
+class MemberEpcS1apSapEnbProvider : public EpcS1apSapEnbProvider
+{
+public:
+  MemberEpcS1apSapEnbProvider (C* owner);
+
+  // inherited from MemberEpcS1apSapEnbProvider
+  virtual void SendInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t ecgi);
+  virtual void SendErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeReleasedIndication> erabToBeReleaseIndication );
+
+  virtual void SendInitialContextSetupResponse (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabSetupItem> erabSetupList);
+  virtual void SendPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList);
+
+private:
+  MemberEpcS1apSapEnbProvider ();
+  C* m_owner;
+};
 
+template <class C>
+MemberEpcS1apSapEnbProvider<C>::MemberEpcS1apSapEnbProvider (C* owner)
+  : m_owner (owner)
+{
+}
+
+template <class C>
+MemberEpcS1apSapEnbProvider<C>::MemberEpcS1apSapEnbProvider ()
+{
+}
+
+template <class C>
+void MemberEpcS1apSapEnbProvider<C>::SendInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t ecgi)
+{
+  m_owner->DoSendInitialUeMessage (mmeUeS1Id, enbUeS1Id, imsi, ecgi);
+}
+
+template <class C>
+void MemberEpcS1apSapEnbProvider<C>::SendErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeReleasedIndication> erabToBeReleaseIndication)
+{
+  m_owner->DoSendErabReleaseIndication (mmeUeS1Id, enbUeS1Id, erabToBeReleaseIndication);
+}
+
+template <class C>
+void MemberEpcS1apSapEnbProvider<C>::SendInitialContextSetupResponse (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabSetupItem> erabSetupList)
+{
+  m_owner->DoSendInitialContextSetupResponse (mmeUeS1Id, enbUeS1Id, erabSetupList);
+}
+
+template <class C>
+void MemberEpcS1apSapEnbProvider<C>::SendPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList)
+{
+  m_owner->DoSendPathSwitchRequest (enbUeS1Id, mmeUeS1Id, cgi, erabToBeSwitchedInDownlinkList);
+}
 
 
 
@@ -298,33 +356,15 @@
 class MemberEpcS1apSapEnb : public EpcS1apSapEnb
 {
 public:
-/**
- * Constructor
- *
- * \param owner the owner class
- */
   MemberEpcS1apSapEnb (C* owner);
 
   // inherited from EpcS1apSapEnb
-  /**
-   * Initial context setup request function
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param erabToBeSetupList
-   */
   virtual void InitialContextSetupRequest (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeSetupItem> erabToBeSetupList);
-  /**
-   * Path switch request acknowledge function
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param cgi
-   * \param erabToBeSwitchedInUplinkList
-   */
   virtual void PathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList);
 
 private:
   MemberEpcS1apSapEnb ();
-  C* m_owner; ///< owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -351,7 +391,48 @@
 }
 
 
+/**
+ * Template for the implementation of the EpcS1apSapMmeProvider as a member
+ * of an owner class of type C to which all methods are forwarded
+ * 
+ */
+template <class C>
+class MemberEpcS1apSapMmeProvider : public EpcS1apSapMmeProvider
+{
+public:
+  MemberEpcS1apSapMmeProvider (C* owner);
+
+  // inherited from EpcS1apSapMmeProvider
+  virtual void SendInitialContextSetupRequest (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeSetupItem> erabToBeSetupList, uint16_t cellId);
+  virtual void SendPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList);
 
+private:
+  MemberEpcS1apSapMmeProvider ();
+  C* m_owner;
+};
+
+template <class C>
+MemberEpcS1apSapMmeProvider<C>::MemberEpcS1apSapMmeProvider (C* owner)
+  : m_owner (owner)
+{
+}
+
+template <class C>
+MemberEpcS1apSapMmeProvider<C>::MemberEpcS1apSapMmeProvider ()
+{
+}
+
+template <class C>
+void MemberEpcS1apSapMmeProvider<C>::SendInitialContextSetupRequest (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeSetupItem> erabToBeSetupList, uint16_t cellId)
+{
+  m_owner->DoSendInitialContextSetupRequest (mmeUeS1Id, enbUeS1Id, erabToBeSetupList, cellId);
+}
+
+template <class C>
+void MemberEpcS1apSapMmeProvider<C>::SendPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList)
+{
+  m_owner->DoSendPathSwitchRequestAcknowledge (enbUeS1Id, mmeUeS1Id, cgi, erabToBeSwitchedInUplinkList);
+}
 
 
 
diff -Naru a/model/epc-sgw-pgw-application.cc b/model/epc-sgw-pgw-application.cc
--- a/model/epc-sgw-pgw-application.cc	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-sgw-pgw-application.cc	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Jaume Nin <jnin@cttc.cat>
  *         Nicola Baldo <nbaldo@cttc.cat>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -65,11 +69,11 @@
   NS_LOG_FUNCTION (this << p);
   // we hardcode DOWNLINK direction since the PGW is espected to
   // classify only downlink packets (uplink packets will go to the
-  // internet without any classification). 
+  // internet without any classification).
   return m_tftClassifier.Classify (p, EpcTft::DOWNLINK);
 }
 
-Ipv4Address 
+Ipv4Address
 EpcSgwPgwApplication::UeInfo::GetEnbAddr ()
 {
   return m_enbAddr;
@@ -81,7 +85,7 @@
   m_enbAddr = enbAddr;
 }
 
-Ipv4Address 
+Ipv4Address
 EpcSgwPgwApplication::UeInfo::GetUeAddr ()
 {
   return m_ueAddr;
@@ -93,7 +97,7 @@
   m_ueAddr = ueAddr;
 }
 
-Ipv6Address 
+Ipv6Address
 EpcSgwPgwApplication::UeInfo::GetUeAddr6 ()
 {
   return m_ueAddr6;
@@ -137,7 +141,7 @@
   delete (m_s11SapSgw);
 }
 
-  
+
 EpcSgwPgwApplication::EpcSgwPgwApplication (const Ptr<VirtualNetDevice> tunDevice, const Ptr<Socket> s1uSocket)
   : m_s1uSocket (s1uSocket),
     m_tunDevice (tunDevice),
@@ -150,7 +154,7 @@
   m_s11SapSgw = new MemberEpcS11SapSgw<EpcSgwPgwApplication> (this);
 }
 
-  
+
 EpcSgwPgwApplication::~EpcSgwPgwApplication ()
 {
   NS_LOG_FUNCTION (this);
@@ -178,53 +182,53 @@
       // find corresponding UeInfo address
       std::map<Ipv4Address, Ptr<UeInfo> >::iterator it = m_ueInfoByAddrMap.find (ueAddr);
       if (it == m_ueInfoByAddrMap.end ())
-        {        
-          NS_LOG_WARN ("unknown UE address " << ueAddr);
-        }
-      else
         {
-          Ipv4Address enbAddr = it->second->GetEnbAddr ();      
-          uint32_t teid = it->second->Classify (packet);   
-          if (teid == 0)
-            {
-              NS_LOG_WARN ("no matching bearer for this packet");                   
-            }
-          else
-            {
-              SendToS1uSocket (packet, enbAddr, teid);
-            }
-        }
-    }
-  else if (ipType == 0x06)
-    {
-      Ipv6Header ipv6Header;
-      pCopy->RemoveHeader (ipv6Header);
-      Ipv6Address ueAddr =  ipv6Header.GetDestinationAddress ();
-      NS_LOG_LOGIC ("packet addressed to UE " << ueAddr);
-      // find corresponding UeInfo address
-      std::map<Ipv6Address, Ptr<UeInfo> >::iterator it = m_ueInfoByAddrMap6.find (ueAddr);
-      if (it == m_ueInfoByAddrMap6.end ())
-        {        
           NS_LOG_WARN ("unknown UE address " << ueAddr);
         }
       else
         {
-          Ipv4Address enbAddr = it->second->GetEnbAddr ();      
-          uint32_t teid = it->second->Classify (packet);   
+          Ipv4Address enbAddr = it->second->GetEnbAddr ();
+          uint32_t teid = it->second->Classify (packet);
           if (teid == 0)
             {
-              NS_LOG_WARN ("no matching bearer for this packet");                   
+              NS_LOG_WARN ("no matching bearer for this packet");
             }
           else
             {
               SendToS1uSocket (packet, enbAddr, teid);
             }
         }
-    }
-  else
-    {
-      NS_ABORT_MSG ("EpcSgwPgwApplication::RecvFromTunDevice - Unknown IP type...");
-    }
+      }
+    else if (ipType == 0x06)
+      {
+        Ipv6Header ipv6Header;
+        pCopy->RemoveHeader (ipv6Header);
+        Ipv6Address ueAddr =  ipv6Header.GetDestinationAddress ();
+        NS_LOG_LOGIC ("packet addressed to UE " << ueAddr);
+        // find corresponding UeInfo address
+        std::map<Ipv6Address, Ptr<UeInfo> >::iterator it = m_ueInfoByAddrMap6.find (ueAddr);
+        if (it == m_ueInfoByAddrMap6.end ())
+          {
+            NS_LOG_WARN ("unknown UE address " << ueAddr);
+          }
+        else
+          {
+            Ipv4Address enbAddr = it->second->GetEnbAddr ();
+            uint32_t teid = it->second->Classify (packet);
+            if (teid == 0)
+              {
+                NS_LOG_WARN ("no matching bearer for this packet");
+              }
+            else
+              {
+                SendToS1uSocket (packet, enbAddr, teid);
+              }
+          }
+      }
+    else
+      {
+        NS_ABORT_MSG ("EpcSgwPgwApplication::RecvFromTunDevice - Unknown IP type...");
+      }
 
   // there is no reason why we should notify the TUN
   // VirtualNetDevice that he failed to send the packet: if we receive
@@ -233,22 +237,27 @@
   return succeeded;
 }
 
-void 
+void
 EpcSgwPgwApplication::RecvFromS1uSocket (Ptr<Socket> socket)
 {
-  NS_LOG_FUNCTION (this << socket);  
+  NS_LOG_FUNCTION (this << socket);
   NS_ASSERT (socket == m_s1uSocket);
   Ptr<Packet> packet = socket->Recv ();
   GtpuHeader gtpu;
   packet->RemoveHeader (gtpu);
   uint32_t teid = gtpu.GetTeid ();
 
+  /// \internal
+  /// Workaround for \bugid{231}
+  //SocketAddressTag tag;
+  //packet->RemovePacketTag (tag);
+
   SendToTunDevice (packet, teid);
 
   m_rxS1uPktTrace (packet->Copy ());
 }
 
-void 
+void
 EpcSgwPgwApplication::SendToTunDevice (Ptr<Packet> packet, uint32_t teid)
 {
   NS_LOG_FUNCTION (this << packet << teid);
@@ -272,7 +281,7 @@
     }
 }
 
-void 
+void
 EpcSgwPgwApplication::SendToS1uSocket (Ptr<Packet> packet, Ipv4Address enbAddr, uint32_t teid)
 {
   NS_LOG_FUNCTION (this << packet << enbAddr << teid);
@@ -281,26 +290,26 @@
   gtpu.SetTeid (teid);
   // From 3GPP TS 29.281 v10.0.0 Section 5.1
   // Length of the payload + the non obligatory GTP-U header
-  gtpu.SetLength (packet->GetSize () + gtpu.GetSerializedSize () - 8);  
+  gtpu.SetLength (packet->GetSize () + gtpu.GetSerializedSize () - 8);
   packet->AddHeader (gtpu);
   uint32_t flags = 0;
   m_s1uSocket->SendTo (packet, flags, InetSocketAddress (enbAddr, m_gtpuUdpPort));
 }
 
 
-void 
+void
 EpcSgwPgwApplication::SetS11SapMme (EpcS11SapMme * s)
 {
   m_s11SapMme = s;
 }
 
-EpcS11SapSgw* 
+EpcS11SapSgw*
 EpcSgwPgwApplication::GetS11SapSgw ()
 {
   return m_s11SapSgw;
 }
 
-void 
+void
 EpcSgwPgwApplication::AddEnb (uint16_t cellId, Ipv4Address enbAddr, Ipv4Address sgwAddr)
 {
   NS_LOG_FUNCTION (this << cellId << enbAddr << sgwAddr);
@@ -310,7 +319,7 @@
   m_enbInfoByCellId[cellId] = enbInfo;
 }
 
-void 
+void
 EpcSgwPgwApplication::AddUe (uint64_t imsi)
 {
   NS_LOG_FUNCTION (this << imsi);
@@ -318,35 +327,35 @@
   m_ueInfoByImsiMap[imsi] = ueInfo;
 }
 
-void 
+void
 EpcSgwPgwApplication::SetUeAddress (uint64_t imsi, Ipv4Address ueAddr)
 {
   NS_LOG_FUNCTION (this << imsi << ueAddr);
   std::map<uint64_t, Ptr<UeInfo> >::iterator ueit = m_ueInfoByImsiMap.find (imsi);
-  NS_ASSERT_MSG (ueit != m_ueInfoByImsiMap.end (), "unknown IMSI " << imsi); 
+  NS_ASSERT_MSG (ueit != m_ueInfoByImsiMap.end (), "unknown IMSI " << imsi);
   m_ueInfoByAddrMap[ueAddr] = ueit->second;
   ueit->second->SetUeAddr (ueAddr);
 }
 
-void 
+void
 EpcSgwPgwApplication::SetUeAddress6 (uint64_t imsi, Ipv6Address ueAddr)
 {
   NS_LOG_FUNCTION (this << imsi << ueAddr);
   std::map<uint64_t, Ptr<UeInfo> >::iterator ueit = m_ueInfoByImsiMap.find (imsi);
-  NS_ASSERT_MSG (ueit != m_ueInfoByImsiMap.end (), "unknown IMSI " << imsi); 
+  NS_ASSERT_MSG (ueit != m_ueInfoByImsiMap.end (), "unknown IMSI " << imsi);
   m_ueInfoByAddrMap6[ueAddr] = ueit->second;
   ueit->second->SetUeAddr6 (ueAddr);
 }
 
-void 
+void
 EpcSgwPgwApplication::DoCreateSessionRequest (EpcS11SapSgw::CreateSessionRequestMessage req)
 {
   NS_LOG_FUNCTION (this << req.imsi);
   std::map<uint64_t, Ptr<UeInfo> >::iterator ueit = m_ueInfoByImsiMap.find (req.imsi);
-  NS_ASSERT_MSG (ueit != m_ueInfoByImsiMap.end (), "unknown IMSI " << req.imsi); 
+  NS_ASSERT_MSG (ueit != m_ueInfoByImsiMap.end (), "unknown IMSI " << req.imsi);
   uint16_t cellId = req.uli.gci;
   std::map<uint16_t, EnbInfo>::iterator enbit = m_enbInfoByCellId.find (cellId);
-  NS_ASSERT_MSG (enbit != m_enbInfoByCellId.end (), "unknown CellId " << cellId); 
+  NS_ASSERT_MSG (enbit != m_enbInfoByCellId.end (), "unknown CellId " << cellId);
   Ipv4Address enbAddr = enbit->second.enbAddr;
   ueit->second->SetEnbAddr (enbAddr);
 
@@ -359,33 +368,33 @@
     {
       // simple sanity check. If you ever need more than 4M teids
       // throughout your simulation, you'll need to implement a smarter teid
-      // management algorithm. 
+      // management algorithm.
       NS_ABORT_IF (m_teidCount == 0xFFFFFFFF);
-      uint32_t teid = ++m_teidCount;  
+      uint32_t teid = ++m_teidCount;
       ueit->second->AddBearer (bit->tft, bit->epsBearerId, teid);
 
       EpcS11SapMme::BearerContextCreated bearerContext;
       bearerContext.sgwFteid.teid = teid;
       bearerContext.sgwFteid.address = enbit->second.sgwAddr;
-      bearerContext.epsBearerId =  bit->epsBearerId; 
-      bearerContext.bearerLevelQos = bit->bearerLevelQos; 
+      bearerContext.epsBearerId =  bit->epsBearerId;
+      bearerContext.bearerLevelQos = bit->bearerLevelQos;
       bearerContext.tft = bit->tft;
       res.bearerContextsCreated.push_back (bearerContext);
     }
   m_s11SapMme->CreateSessionResponse (res);
-  
+
 }
 
-void 
+void
 EpcSgwPgwApplication::DoModifyBearerRequest (EpcS11SapSgw::ModifyBearerRequestMessage req)
 {
   NS_LOG_FUNCTION (this << req.teid);
   uint64_t imsi = req.teid; // trick to avoid the need for allocating TEIDs on the S11 interface
   std::map<uint64_t, Ptr<UeInfo> >::iterator ueit = m_ueInfoByImsiMap.find (imsi);
-  NS_ASSERT_MSG (ueit != m_ueInfoByImsiMap.end (), "unknown IMSI " << imsi); 
+  NS_ASSERT_MSG (ueit != m_ueInfoByImsiMap.end (), "unknown IMSI " << imsi);
   uint16_t cellId = req.uli.gci;
   std::map<uint16_t, EnbInfo>::iterator enbit = m_enbInfoByCellId.find (cellId);
-  NS_ASSERT_MSG (enbit != m_enbInfoByCellId.end (), "unknown CellId " << cellId); 
+  NS_ASSERT_MSG (enbit != m_enbInfoByCellId.end (), "unknown CellId " << cellId);
   Ipv4Address enbAddr = enbit->second.enbAddr;
   ueit->second->SetEnbAddr (enbAddr);
   // no actual bearer modification: for now we just support the minimum needed for path switch request (handover)
@@ -394,7 +403,7 @@
   res.cause = EpcS11SapMme::ModifyBearerResponseMessage::REQUEST_ACCEPTED;
   m_s11SapMme->ModifyBearerResponse (res);
 }
- 
+
 void
 EpcSgwPgwApplication::DoDeleteBearerCommand (EpcS11SapSgw::DeleteBearerCommandMessage req)
 {
diff -Naru a/model/epc-sgw-pgw-application.h b/model/epc-sgw-pgw-application.h
--- a/model/epc-sgw-pgw-application.h	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-sgw-pgw-application.h	2018-08-03 16:39:02.875957522 +0200
@@ -70,95 +70,95 @@
 
   EpcSgwPgwApplication (const Ptr<VirtualNetDevice> tunDevice, const Ptr<Socket> s1uSocket);
 
-  /** 
+  /**
    * Destructor
    */
   virtual ~EpcSgwPgwApplication (void);
-  
-  /** 
+
+  /**
    * Method to be assigned to the callback of the Gi TUN VirtualNetDevice. It
    * is called when the SGW/PGW receives a data packet from the
    * internet (including IP headers) that is to be sent to the UE via
    * its associated eNB, tunneling IP over GTP-U/UDP/IP.
-   * 
-   * \param packet 
-   * \param source 
-   * \param dest 
-   * \param protocolNumber 
-   * \return true always 
+   *
+   * \param packet
+   * \param source
+   * \param dest
+   * \param protocolNumber
+   * \return true always
    */
   bool RecvFromTunDevice (Ptr<Packet> packet, const Address& source, const Address& dest, uint16_t protocolNumber);
 
 
-  /** 
+  /**
    * Method to be assigned to the recv callback of the S1-U socket. It
    * is called when the SGW/PGW receives a data packet from the eNB
-   * that is to be forwarded to the internet. 
-   * 
+   * that is to be forwarded to the internet.
+   *
    * \param socket pointer to the S1-U socket
    */
   void RecvFromS1uSocket (Ptr<Socket> socket);
 
-  /** 
+  /**
    * Send a packet to the internet via the Gi interface of the SGW/PGW
-   * 
-   * \param packet 
+   *
+   * \param packet
    * \param teid the Tunnel Enpoint Identifier
    */
   void SendToTunDevice (Ptr<Packet> packet, uint32_t teid);
 
 
-  /** 
+  /**
    * Send a packet to the SGW via the S1-U interface
-   * 
+   *
    * \param packet packet to be sent
    * \param enbS1uAddress the address of the eNB
    * \param teid the Tunnel Enpoint IDentifier
    */
   void SendToS1uSocket (Ptr<Packet> packet, Ipv4Address enbS1uAddress, uint32_t teid);
-  
 
-  /** 
-   * Set the MME side of the S11 SAP 
-   * 
-   * \param s the MME side of the S11 SAP 
+
+  /**
+   * Set the MME side of the S11 SAP
+   *
+   * \param s the MME side of the S11 SAP
    */
   void SetS11SapMme (EpcS11SapMme * s);
 
-  /** 
-   * 
-   * \return the SGW side of the S11 SAP 
+  /**
+   *
+   * \return the SGW side of the S11 SAP
    */
   EpcS11SapSgw* GetS11SapSgw ();
 
 
-  /** 
-   * Let the SGW be aware of a new eNB 
-   * 
+  /**
+   * Let the SGW be aware of a new eNB
+   *
    * \param cellId the cell identifier
    * \param enbAddr the address of the eNB
    * \param sgwAddr the address of the SGW
    */
   void AddEnb (uint16_t cellId, Ipv4Address enbAddr, Ipv4Address sgwAddr);
 
-  /** 
+  /**
    * Let the SGW be aware of a new UE
-   * 
+   *
    * \param imsi the unique identifier of the UE
    */
   void AddUe (uint64_t imsi);
 
-  /** 
+  /**
    * set the address of a previously added UE
-   * 
+   *
    * \param imsi the unique identifier of the UE
    * \param ueAddr the IPv4 address of the UE
    */
   void SetUeAddress (uint64_t imsi, Ipv4Address ueAddr);
 
-  /** 
+  /**
    * set the address of a previously added UE
-   * 
+   *
    * \param imsi the unique identifier of the UE
    * \param ueAddr the IPv6 address of the UE
    */
@@ -184,7 +184,7 @@
    * Modify bearer request function
    * \param msg EpcS11SapSgw::ModifyBearerRequestMessage
    */
-  void DoModifyBearerRequest (EpcS11SapSgw::ModifyBearerRequestMessage msg);  
+  void DoModifyBearerRequest (EpcS11SapSgw::ModifyBearerRequestMessage msg);
 
   /**
    * Delete bearer command function
@@ -204,53 +204,53 @@
   class UeInfo : public SimpleRefCount<UeInfo>
   {
 public:
-    UeInfo ();  
+    UeInfo ();
 
-    /** 
-     * 
+    /**
+     *
      * \param tft the Traffic Flow Template of the new bearer to be added
      * \param epsBearerId the ID of the EPS Bearer to be activated
      * \param teid  the TEID of the new bearer
      */
     void AddBearer (Ptr<EpcTft> tft, uint8_t epsBearerId, uint32_t teid);
 
-    /** 
+    /**
      * \brief Function, deletes contexts of bearer on SGW and PGW side
      * \param bearerId the Bearer Id whose contexts to be removed
      */
     void RemoveBearer (uint8_t bearerId);
 
     /**
-     * 
-     * 
+     *
+     *
      * \param p the IP packet from the internet to be classified
-     * 
+     *
      * \return the corresponding bearer ID > 0 identifying the bearer
      * among all the bearers of this UE;  returns 0 if no bearers
      * matches with the previously declared TFTs
      */
     uint32_t Classify (Ptr<Packet> p);
 
-    /** 
+    /**
      * \return the address of the eNB to which the UE is connected
      */
     Ipv4Address GetEnbAddr ();
 
-    /** 
+    /**
      * set the address of the eNB to which the UE is connected
-     * 
+     *
      * \param addr the address of the eNB
      */
     void SetEnbAddr (Ipv4Address addr);
 
-    /** 
+    /**
      * \return the IPv4 address of the UE
      */
     Ipv4Address GetUeAddr ();
 
-    /** 
+    /**
      * set the IPv4 address of the UE
-     * 
+     *
      * \param addr the IPv4 address of the UE
      */
     void SetUeAddr (Ipv4Address addr);
@@ -280,25 +280,25 @@
   * UDP socket to send and receive GTP-U packets to and from the S1-U interface
   */
   Ptr<Socket> m_s1uSocket;
-  
+
   /**
    * TUN VirtualNetDevice used for tunneling/detunneling IP packets
-   * from/to the internet over GTP-U/UDP/IP on the S1 interface 
+   * from/to the internet over GTP-U/UDP/IP on the S1 interface
    */
   Ptr<VirtualNetDevice> m_tunDevice;
 
   /**
-   * Map telling for each UE IPv4 address the corresponding UE info 
+   * Map telling for each UE IPv4 address the corresponding UE info
    */
   std::map<Ipv4Address, Ptr<UeInfo> > m_ueInfoByAddrMap;
 
   /**
-   * Map telling for each UE IPv6 address the corresponding UE info 
+   * Map telling for each UE IPv6 address the corresponding UE info
    */
   std::map<Ipv6Address, Ptr<UeInfo> > m_ueInfoByAddrMap6;
 
   /**
-   * Map telling for each IMSI the corresponding UE info 
+   * Map telling for each IMSI the corresponding UE info
    */
   std::map<uint64_t, Ptr<UeInfo> > m_ueInfoByImsiMap;
 
@@ -314,13 +314,13 @@
 
   /**
    * MME side of the S11 SAP
-   * 
+   *
    */
   EpcS11SapMme* m_s11SapMme;
 
   /**
    * SGW side of the S11 SAP
-   * 
+   *
    */
   EpcS11SapSgw* m_s11SapSgw;
 
@@ -347,4 +347,3 @@
 } //namespace ns3
 
 #endif /* EPC_SGW_PGW_APPLICATION_H */
-
diff -Naru a/model/epc-tft.cc b/model/epc-tft.cc
--- a/model/epc-tft.cc	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-tft.cc	2018-08-03 16:39:02.875957522 +0200
@@ -95,7 +95,7 @@
   NS_LOG_FUNCTION (this);
 }
 
-bool 
+bool
 EpcTft::PacketFilter::Matches (Direction d,
                                Ipv4Address ra,
                                Ipv4Address la,
@@ -149,10 +149,10 @@
     {
       NS_LOG_LOGIC ("d doesn't match: d=0x" << std::hex << d << " f.d=0x" << std::hex << direction << std::dec);
     }
-  return false;      
+  return false;
 }
 
-bool 
+bool
 EpcTft::PacketFilter::Matches (Direction d,
                                Ipv6Address ra,
                                Ipv6Address la,
@@ -200,11 +200,11 @@
     {
       NS_LOG_LOGIC ("d doesn't match: d=0x" << std::hex << d << " f.d=0x" << std::hex << direction << std::dec);
     }
-  return false;      
+  return false;
 }
 
 
-Ptr<EpcTft> 
+Ptr<EpcTft>
 EpcTft::Default ()
 {
   Ptr<EpcTft> tft = Create<EpcTft> ();
@@ -220,7 +220,7 @@
   NS_LOG_FUNCTION (this);
 }
 
-uint8_t 
+uint8_t
 EpcTft::Add (PacketFilter f)
 {
   NS_LOG_FUNCTION (this << f);
@@ -231,13 +231,13 @@
       (it != m_filters.end ()) && (it->precedence <= f.precedence);
       ++it)
     {
-    }  
-  m_filters.insert (it, f);  
+    }
+  m_filters.insert (it, f);
   ++m_numFilters;
   return (m_numFilters - 1);
 }
 
-bool 
+bool
 EpcTft::Matches (Direction direction,
                  Ipv4Address remoteAddress,
                  Ipv4Address localAddress,
@@ -254,11 +254,11 @@
         {
           return true;
         }
-    }  
+    }
   return false;
 }
 
-bool 
+bool
 EpcTft::Matches (Direction direction,
                  Ipv6Address remoteAddress,
                  Ipv6Address localAddress,
@@ -275,7 +275,7 @@
         {
           return true;
         }
-    }  
+    }
   return false;
 }
 
diff -Naru a/model/epc-tft-classifier.cc b/model/epc-tft-classifier.cc
--- a/model/epc-tft-classifier.cc	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-tft-classifier.cc	2018-08-03 16:39:02.875957522 +0200
@@ -16,9 +16,9 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Authors: 
+ * Authors:
  *   Nicola Baldo <nbaldo@cttc.es> (the EpcTftClassifier class)
- *   Giuseppe Piro <g.piro@poliba.it> (part of the code in EpcTftClassifier::Classify () 
+ *   Giuseppe Piro <g.piro@poliba.it> (part of the code in EpcTftClassifier::Classify ()
  *       which comes from RrcEntity::Classify of the GSoC 2010 LTE module)
  *
  */
@@ -62,8 +62,8 @@
   m_tftMap.erase (id);
 }
 
- 
-uint32_t 
+
+uint32_t
 EpcTftClassifier::Classify (Ptr<Packet> p, EpcTft::Direction direction)
 {
   NS_LOG_FUNCTION (this << p << p->GetSize () << direction);
diff -Naru a/model/epc-tft-classifier.h b/model/epc-tft-classifier.h
--- a/model/epc-tft-classifier.h	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-tft-classifier.h	2018-08-03 16:39:02.875957522 +0200
@@ -54,38 +54,38 @@
 class EpcTftClassifier : public SimpleRefCount<EpcTftClassifier>
 {
 public:
-  
+
   EpcTftClassifier ();
-  
-  /** 
+
+  /**
    * add a TFT to the Classifier
-   * 
+   *
    * \param tft the TFT to be added
    * \param id the ID of the bearer which will be classified by specified TFT classifier
-   * 
+   *
    */
   void Add (Ptr<EpcTft> tft, uint32_t id);
 
-  /** 
+  /**
    * delete an existing TFT from the classifier
-   * 
+   *
    * \param id the identifier of the TFT to be deleted
    */
   void Delete (uint32_t id);
-  
 
-  /** 
+
+  /**
    * classify an IP packet
-   * 
+   *
    * \param p the IP packet. It is assumed that the outmost header is an IPv4 header.
    * \param direction the EPC TFT direction (can be downlink, uplink or bi-directional)
-   * 
+   *
    * \return the identifier (>0) of the first TFT that matches with the IP packet; 0 if no TFT matched.
    */
   uint32_t Classify (Ptr<Packet> p, EpcTft::Direction direction);
-  
+
 protected:
-  
+
   std::map <uint32_t, Ptr<EpcTft> > m_tftMap; ///< TFT map
 
   std::map < std::tuple<uint32_t, uint32_t, uint8_t, uint16_t>,
@@ -102,5 +102,5 @@
 
 
 } // namespace ns3
-  
-#endif /* TFT_CLASSIFIER_H */ 
+
+#endif /* TFT_CLASSIFIER_H */
diff -Naru a/model/epc-tft.h b/model/epc-tft.h
--- a/model/epc-tft.h	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-tft.h	2018-08-03 16:39:02.875957522 +0200
@@ -35,8 +35,8 @@
 
 /**
  * This class implements the EPS bearer Traffic Flow Template (TFT),
- * which is the set of all packet filters associated with an EPS bearer. 
- * 
+ * which is the set of all packet filters associated with an EPS bearer.
+ *
  */
 class EpcTft : public SimpleRefCount<EpcTft>
 {
@@ -44,26 +44,26 @@
 public:
 
 
-  /** 
+  /**
    * creates a TFT matching any traffic
    *
    * \return a newly created TFT that will match any traffic
    */
   static Ptr<EpcTft> Default ();
-  
+
   /**
-   * Indicates the direction of the traffic that is to be classified. 
+   * Indicates the direction of the traffic that is to be classified.
    */
   enum Direction {DOWNLINK = 1,
 		  UPLINK = 2,
 		  BIDIRECTIONAL = 3};
-  
+
   /**
    * Implement the data structure representing a TrafficFlowTemplate
    * Packet Filter.
    * See 3GPP TS 24.008 version 8.7.0 Release 8, Table 10.5.162/3GPP TS
-   * 24.008: Traffic flow template information element  
-   * 
+   * 24.008: Traffic flow template information element
+   *
    * With respect to the Packet Filter specification in the above doc,
    * the following features are NOT supported:
    *  - IPv6 filtering (including flow labels)
@@ -75,51 +75,51 @@
   {
     PacketFilter ();
 
-    /** 
-     * 
-     * \param d the direction 
-     * \param ra the remote address 
-     * \param la the local address 
-     * \param rp the remote port 
-     * \param lp the local port 
-     * \param tos the type of service 
-     * 
+    /**
+     *
+     * \param d the direction
+     * \param ra the remote address
+     * \param la the local address
+     * \param rp the remote port
+     * \param lp the local port
+     * \param tos the type of service
+     *
      * \return true if the parameters match with the PacketFilter,
      * false otherwise.
      */
     bool Matches (Direction d,
-		  Ipv4Address ra, 
+		  Ipv4Address ra,
 		  Ipv4Address la,
 		  uint16_t rp,
 		  uint16_t lp,
 		  uint8_t tos);
 
-    /** 
-     * 
-     * \param d the direction 
-     * \param ra the remote address 
-     * \param la the local address 
-     * \param rp the remote port 
-     * \param lp the local port 
-     * \param tos the type of service 
-     * 
+    /**
+     *
+     * \param d the direction
+     * \param ra the remote address
+     * \param la the local address
+     * \param rp the remote port
+     * \param lp the local port
+     * \param tos the type of service
+     *
      * \return true if the parameters match with the PacketFilter,
      * false otherwise.
      */
     bool Matches (Direction d,
-		  Ipv6Address ra, 
+		  Ipv6Address ra,
 		  Ipv6Address la,
 		  uint16_t rp,
 		  uint16_t lp,
 		  uint8_t tos);
 
- 
+
 
     uint8_t precedence;  /**< used to specify the precedence for the
 			  * packet filter among all packet filters in
 			  * the TFT; higher values will be evaluated
-			  * last. 
-			  */ 
+			  * last.
+			  */
 
     Direction direction; /**< whether the filter needs to be applied
 			    to uplink / downlink only, or in both cases*/
@@ -130,38 +130,38 @@
     Ipv4Address localAddress;       /**< IPv4 address of the UE */
     Ipv6Address localAddress6;      /**< IPv6 address of the UE */
     Ipv4Mask localMask;  /**< IPv4 address mask of the UE */
-  
+
     uint16_t remotePortStart;  /**< start of the port number range of the remote host */
     uint16_t remotePortEnd;    /**< end of the port number range of the remote host */
     uint16_t localPortStart;   /**< start of the port number range of the UE */
     uint16_t localPortEnd;     /**< end of the port number range of the UE */
-  
+
     uint8_t typeOfService;     /**< type of service field */
     uint8_t typeOfServiceMask; /**< type of service field mask */
   };
-  
+
   EpcTft ();
-  
 
-  /** 
+
+  /**
    * add a PacketFilter to the Traffic Flow Template
-   * 
+   *
    * \param f the PacketFilter to be added
-   * 
+   *
    * \return the id( 0 <= id < 16) of the newly added filter, if the addition was successful. Will fail if you try to add more than 15 filters. This is to be compliant with TS 24.008.
    */
   uint8_t Add (PacketFilter f);
 
 
-    /** 
-     * 
-     * \param direction 
-     * \param remoteAddress 
-     * \param localAddress 
-     * \param remotePort 
-     * \param localPort 
-     * \param typeOfService 
-     * 
+    /**
+     *
+     * \param direction
+     * \param remoteAddress
+     * \param localAddress
+     * \param remotePort
+     * \param localPort
+     * \param typeOfService
+     *
      * \return true if any PacketFilter in the TFT matches with the
      * parameters, false otherwise.
      */
@@ -172,15 +172,15 @@
 		  uint16_t localPort,
 		  uint8_t typeOfService);
 
-    /** 
-     * 
-     * \param direction 
-     * \param remoteAddress 
-     * \param localAddress 
-     * \param remotePort 
-     * \param localPort 
-     * \param typeOfService 
-     * 
+    /**
+     *
+     * \param direction
+     * \param remoteAddress
+     * \param localAddress
+     * \param remotePort
+     * \param localPort
+     * \param typeOfService
+     *
      * \return true if any PacketFilter in the TFT matches with the
      * parameters, false otherwise.
      */
@@ -196,7 +196,7 @@
 
   std::list<PacketFilter> m_filters; ///< packet filter list
   uint8_t m_numFilters; ///< number of packet filters applied to this TFT
-  
+
 };
 
 
@@ -204,7 +204,5 @@
 
 
 } // namespace ns3
-  
-#endif /* EPC_TFT_H */ 
-
 
+#endif /* EPC_TFT_H */
diff -Naru a/model/epc-ue-nas.cc b/model/epc-ue-nas.cc
--- a/model/epc-ue-nas.cc	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-ue-nas.cc	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/fatal-error.h>
@@ -65,6 +69,7 @@
 {
   NS_LOG_FUNCTION (this);
   m_asSapUser = new MemberLteAsSapUser<EpcUeNas> (this);
+  m_mmWaveAsSapProvider = 0;
 }
 
 
@@ -95,14 +100,14 @@
   return tid;
 }
 
-void 
+void
 EpcUeNas::SetDevice (Ptr<NetDevice> dev)
 {
   NS_LOG_FUNCTION (this << dev);
   m_device = dev;
 }
 
-void 
+void
 EpcUeNas::SetImsi (uint64_t imsi)
 {
   NS_LOG_FUNCTION (this << imsi);
@@ -139,6 +144,13 @@
 }
 
 void
+EpcUeNas::SetMmWaveAsSapProvider (LteAsSapProvider* s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_mmWaveAsSapProvider = s;
+}
+
+void
 EpcUeNas::SetForwardUpCallback (Callback <void, Ptr<Packet> > cb)
 {
   NS_LOG_FUNCTION (this);
@@ -152,7 +164,7 @@
   m_asSapProvider->StartCellSelection (dlEarfcn);
 }
 
-void 
+void
 EpcUeNas::Connect ()
 {
   NS_LOG_FUNCTION (this);
@@ -173,8 +185,23 @@
   m_asSapProvider->Connect ();
 }
 
+void
+EpcUeNas::ConnectMc (uint16_t cellId, uint16_t dlEarfcn, uint16_t mmWaveCellId)
+{
+  NS_LOG_FUNCTION (this << cellId << dlEarfcn);
+
+  // force the UE RRC to be camped on a specific eNB
+  m_asSapProvider->ForceCampedOnEnb (cellId, dlEarfcn);
 
-void 
+  // tell RRC to go into connected mode
+  m_asSapProvider->Connect ();
+
+  m_mmWaveCellId = mmWaveCellId;
+  m_dlEarfcn = dlEarfcn;
+}
+
+
+void
 EpcUeNas::Disconnect ()
 {
   NS_LOG_FUNCTION (this);
@@ -183,7 +210,7 @@
 }
 
 
-void 
+void
 EpcUeNas::ActivateEpsBearer (EpsBearer bearer, Ptr<EpcTft> tft)
 {
   NS_LOG_FUNCTION (this);
@@ -220,7 +247,7 @@
           }
         else
           {
-            m_asSapProvider->SendData (packet, bid); 
+            m_asSapProvider->SendData (packet, bid);
             return true;
           }
       }
@@ -233,12 +260,79 @@
     }
 }
 
-void 
-EpcUeNas::DoNotifyConnectionSuccessful ()
+void
+EpcUeNas::DoNotifyConnectionSuccessful (uint16_t rnti)
+{
+  NS_LOG_FUNCTION (this);
+  switch (m_state)
+  {
+    case ACTIVE: // this means the Master LTE Cell was already connected
+      {
+        // notify the LTE eNB RRC that a secondary cell is available
+        m_asSapProvider->NotifySecondaryCellConnected(rnti, m_mmWaveCellId);
+      }
+      break;
+
+    default:
+      SwitchToState (ACTIVE); // will eventually activate dedicated bearers
+      break;
+  }
+}
+
+void
+EpcUeNas::DoNotifyHandoverSuccessful (uint16_t rnti, uint16_t mmWaveCellId)
 {
+  m_mmWaveCellId = mmWaveCellId;
   NS_LOG_FUNCTION (this);
+  switch (m_state)
+  {
+    case ACTIVE: // this means the Master LTE Cell was already connected
+      {
+        // notify the LTE eNB RRC that a secondary cell is available
+        m_asSapProvider->NotifySecondaryCellConnected(rnti, m_mmWaveCellId);
+      }
+      break;
+
+    default:
+      SwitchToState (ACTIVE); // will eventually activate dedicated bearers
+      break;
+  }
+}
+
+void
+EpcUeNas::DoNotifyConnectToMmWave(uint16_t mmWaveCellId)
+{
+  NS_LOG_LOGIC(mmWaveCellId);
+  m_mmWaveCellId = mmWaveCellId;
+
+  if(m_mmWaveAsSapProvider != 0) {
+
+    NS_ASSERT_MSG(mmWaveCellId > 0, "Invalid CellId");
+
+    NS_LOG_INFO("Connect to cell " << mmWaveCellId);
+    // force the UE RRC to be camped on a specific eNB
+    m_mmWaveAsSapProvider->ForceCampedOnEnb (mmWaveCellId, m_dlEarfcn); // TODO probably the second argument is useless
+
+    // tell RRC to go into connected mode
+    m_mmWaveAsSapProvider->Connect ();
+  } else {
+    NS_LOG_WARN("Trying to connect to a secondary cell a non MC capable device");
+  }
+
+}
+
+void
+EpcUeNas::DoNotifySecondaryCellHandoverStarted (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated rrcd)
+{
+  m_mmWaveCellId = mmWaveCellId;
+  NS_ASSERT(m_asSapProvider != 0);
+
+  NS_ASSERT_MSG(mmWaveCellId > 0, "Invalid CellId");
+
+  NS_LOG_INFO("Notify the LTE RRC of the secondary cell HO to " << mmWaveCellId);
+  // Notify the LTE RRC of the secondary cell HO
+  m_asSapProvider->NotifySecondaryCellHandover(oldRnti, newRnti, mmWaveCellId, rrcd);
 
-  SwitchToState (ACTIVE); // will eventually activate dedicated bearers
 }
 
 void
@@ -257,14 +351,14 @@
   m_forwardUpCallback (packet);
 }
 
-void 
+void
 EpcUeNas::DoNotifyConnectionReleased ()
 {
   NS_LOG_FUNCTION (this);
   SwitchToState (OFF);
 }
 
-void 
+void
 EpcUeNas::DoActivateEpsBearer (EpsBearer bearer, Ptr<EpcTft> tft)
 {
   NS_LOG_FUNCTION (this);
@@ -280,7 +374,7 @@
   return m_state;
 }
 
-void 
+void
 EpcUeNas::SwitchToState (State newState)
 {
   NS_LOG_FUNCTION (this << ToString (newState));
@@ -309,4 +403,3 @@
 
 
 } // namespace ns3
-
diff -Naru a/model/epc-ue-nas.h b/model/epc-ue-nas.h
--- a/model/epc-ue-nas.h	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-ue-nas.h	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef EPC_UE_NAS_H
@@ -37,12 +41,12 @@
   friend class MemberLteAsSapUser<EpcUeNas>;
 public:
 
-  /** 
+  /**
    * Constructor
    */
   EpcUeNas ();
 
-  /** 
+  /**
    * Destructor
    */
   virtual ~EpcUeNas ();
@@ -56,15 +60,15 @@
   static TypeId GetTypeId (void);
 
 
-  /** 
-   * 
+  /**
+   *
    * \param dev the UE NetDevice
    */
   void SetDevice (Ptr<NetDevice> dev);
 
-  /** 
-   * 
-   * 
+  /**
+   *
+   *
    * \param imsi the unique UE identifier
    */
   void SetImsi (uint64_t imsi);
@@ -96,6 +100,13 @@
   LteAsSapUser* GetAsSapUser ();
 
   /**
+   * Set the SAP provider to interact with the MmWave light RRC entity (if set)
+   *
+   * \param s the AS SAP provider
+   */
+  void SetMmWaveAsSapProvider (LteAsSapProvider* s);
+
+  /**
    * set the callback used to forward data packets up the stack
    *
    * \param cb the callback
@@ -111,7 +122,7 @@
 
   /**
    * \brief Causes NAS to tell AS to go to ACTIVE state.
-   * 
+   *
    * The end result is equivalent with EMM Registered + ECM Connected states.
    */
   void Connect ();
@@ -127,27 +138,38 @@
    * RRC to be camped on a specific eNB.
    */
   void Connect (uint16_t cellId, uint32_t dlEarfcn);
- 
-  /** 
+
+  /**
+   * \brief Causes NAS to tell AS to camp to a specific cell and go to ACTIVE
+   *        state. It also specify which is the cellId for the MmWave BS to which
+   *        the UE will connect later on
+   * \param cellId the id of the eNB to camp on
+   * \param dlEarfcn the DL frequency of the eNB
+   * \param mmWaveCellId the id of the MmWave cell
+   *
+   */
+  void ConnectMc (uint16_t cellId, uint16_t dlEarfcn, uint16_t mmWaveCellId);
+
+  /**
    * instruct the NAS to disconnect
-   * 
+   *
    */
   void Disconnect ();
 
 
-  /** 
+  /**
    * Activate an EPS bearer
-   * 
+   *
    * \param bearer the characteristics of the bearer to be created
    * \param tft the TFT identifying the traffic that will go on this bearer
    */
   void ActivateEpsBearer (EpsBearer bearer, Ptr<EpcTft> tft);
 
-  /** 
+  /**
    * Enqueue an IP packet on the proper bearer for uplink transmission
-   * 
+   *
    * \param p the packet
-   * 
+   *
    * \return true if successful, false if an error occurred
    */
   bool Send (Ptr<Packet> p);
@@ -156,9 +178,9 @@
   /**
    * Definition of NAS states as per "LTE - From theory to practice",
    * Section 3.2.3.2 "Connection Establishment and Release"
-   * 
+   *
    */
-  enum State 
+  enum State
   {
     OFF = 0,
     ATTACHING,
@@ -181,12 +203,15 @@
    */
   typedef void (* StateTracedCallback)
     (const State oldState, const State newState);
- 
+
 private:
 
   // LTE AS SAP methods
   /// Notify successful connection
-  void DoNotifyConnectionSuccessful ();
+
+  void DoNotifyConnectionSuccessful (uint16_t rnti);
+  void DoNotifyHandoverSuccessful (uint16_t rnti, uint16_t mmWaveCellId);
+  void DoNotifyConnectToMmWave (uint16_t mmWaveCellId);
   /// Notify connection failed
   void DoNotifyConnectionFailed ();
   /// Notify connection released
@@ -196,6 +221,8 @@
    * \param packet the packet
    */
   void DoRecvData (Ptr<Packet> packet);
+  void DoNotifySecondaryCellHandoverStarted (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated rrcd);
+
 
   // internal methods
   /**
@@ -233,6 +260,7 @@
   LteAsSapProvider* m_asSapProvider;
   /// LTE SAP user
   LteAsSapUser* m_asSapUser;
+  LteAsSapProvider* m_mmWaveAsSapProvider;
 
   uint8_t m_bidCounter; ///< bid counter
   EpcTftClassifier m_tftClassifier; ///< tft classifier
@@ -248,6 +276,9 @@
 
   std::list<BearerToBeActivated> m_bearersToBeActivatedList; ///< bearers to be activated list
 
+  uint16_t m_mmWaveCellId;
+  uint16_t m_dlEarfcn; // TODO maybe useless
+
 };
 
 
diff -Naru a/model/epc-x2.cc b/model/epc-x2.cc
--- a/model/epc-x2.cc	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-x2.cc	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/log.h"
@@ -23,6 +27,8 @@
 #include "ns3/packet.h"
 #include "ns3/node.h"
 #include "ns3/epc-gtpu-header.h"
+#include "ns3/epc-x2-tag.h"
+#include "ns3/lte-pdcp-tag.h"
 
 #include "ns3/epc-x2-header.h"
 #include "ns3/epc-x2.h"
@@ -88,6 +94,8 @@
   NS_LOG_FUNCTION (this);
 
   m_x2SapProvider = new EpcX2SpecificEpcX2SapProvider<EpcX2> (this);
+  m_x2PdcpProvider = new EpcX2PdcpSpecificProvider<EpcX2> (this);
+  m_x2RlcProvider = new EpcX2RlcSpecificProvider<EpcX2> (this);
 }
 
 EpcX2::~EpcX2 ()
@@ -102,7 +110,11 @@
 
   m_x2InterfaceSockets.clear ();
   m_x2InterfaceCellIds.clear ();
+  m_x2RlcUserMap.clear ();
+  m_x2PdcpUserMap.clear ();
   delete m_x2SapProvider;
+  delete m_x2RlcProvider;
+  delete m_x2PdcpProvider;
 }
 
 TypeId
@@ -110,7 +122,11 @@
 {
   static TypeId tid = TypeId ("ns3::EpcX2")
     .SetParent<Object> ()
-    .SetGroupName("Lte");
+    .SetGroupName("Lte")
+    .AddTraceSource ("RxPDU",
+                     "PDU received.",
+                     MakeTraceSourceAccessor (&EpcX2::m_rxPdu),
+                     "ns3::EpcX2::ReceiveTracedCallback");
   return tid;
 }
 
@@ -128,8 +144,42 @@
   return m_x2SapProvider;
 }
 
+// Get and Set interfaces with PDCP and RLC
+EpcX2PdcpProvider*
+EpcX2::GetEpcX2PdcpProvider ()
+{
+  NS_LOG_FUNCTION(this);
+  return m_x2PdcpProvider;
+}
+
+EpcX2RlcProvider*
+EpcX2::GetEpcX2RlcProvider ()
+{
+  return m_x2RlcProvider;
+}
 
 void
+EpcX2::SetMcEpcX2RlcUser (uint32_t teid, EpcX2RlcUser* rlcUser)
+{
+  // TODO it may change (for the same teid) on handover between secondary cells, as in LteEnbRrc::RecvRlcSetupRequest
+  //NS_ASSERT_MSG(m_x2RlcUserMap.find(teid) == m_x2RlcUserMap.end(), "Teid " << teid
+  //  << " is already setup\n");
+  NS_LOG_INFO("Add EpcX2RlcUser for teid " << teid);
+  m_x2RlcUserMap[teid] = rlcUser;
+}
+
+void
+EpcX2::SetMcEpcX2PdcpUser (uint32_t teid, EpcX2PdcpUser* pdcpUser)
+{
+  // TODO it may change (for the same teid) on handover between secondary cells, as in LteEnbRrc::RecvRlcSetupRequest
+  //NS_ASSERT_MSG(m_x2PdcpUserMap.find(teid) == m_x2PdcpUserMap.end(), "Teid " << teid
+  //  << " is already setup\n");
+  NS_LOG_INFO("Add EpcX2PdcpUser for teid " << teid);
+  m_x2PdcpUserMap[teid] = pdcpUser;
+}
+
+// Add X2 endpoint
+void
 EpcX2::AddX2Interface (uint16_t localCellId, Ipv4Address localX2Address, uint16_t remoteCellId, Ipv4Address remoteX2Address)
 {
   NS_LOG_FUNCTION (this << localCellId << localX2Address << remoteCellId << remoteX2Address);
@@ -165,6 +215,22 @@
   m_x2InterfaceCellIds [localX2uSocket] = Create<X2CellInfo> (localCellId, remoteCellId);
 }
 
+void
+EpcX2::DoAddTeidToBeForwarded(uint32_t gtpTeid, uint16_t targetCellId)
+{
+  NS_LOG_FUNCTION(this << " add an entry to the map of teids to be forwarded: teid " << gtpTeid << " targetCellId " << targetCellId);
+  NS_ASSERT_MSG(m_teidToBeForwardedMap.find(gtpTeid) == m_teidToBeForwardedMap.end(), "TEID already in the map");
+  m_teidToBeForwardedMap.insert(std::pair<uint32_t, uint16_t> (gtpTeid, targetCellId));
+}
+
+void 
+EpcX2::DoRemoveTeidToBeForwarded(uint32_t gtpTeid)
+{
+  NS_LOG_FUNCTION(this << " remove and entry from the map of teids to be forwarded: teid " << gtpTeid);
+  NS_ASSERT_MSG(m_teidToBeForwardedMap.find(gtpTeid) != m_teidToBeForwardedMap.end(), "TEID not in the map");
+  m_teidToBeForwardedMap.erase(m_teidToBeForwardedMap.find(gtpTeid));
+}
+
 
 void 
 EpcX2::RecvFromX2cSocket (Ptr<Socket> socket)
@@ -179,6 +245,16 @@
                  "Missing infos of local and remote CellId");
   Ptr<X2CellInfo> cellsInfo = m_x2InterfaceCellIds [socket];
 
+  EpcX2Tag epcX2Tag;
+  Time delay;
+  if (packet->PeekPacketTag(epcX2Tag))
+    {
+      delay = Simulator::Now() - epcX2Tag.GetSenderTimestamp ();
+      packet->RemovePacketTag(epcX2Tag);
+    }
+
+  m_rxPdu(cellsInfo->m_remoteCellId, cellsInfo->m_localCellId, packet->GetSize (), delay.GetNanoSeconds (), 0);
+
   EpcX2Header x2Header;
   packet->RemoveHeader (x2Header);
 
@@ -207,7 +283,10 @@
           params.ueAggregateMaxBitRateDownlink = x2HoReqHeader.GetUeAggregateMaxBitRateDownlink ();
           params.ueAggregateMaxBitRateUplink   = x2HoReqHeader.GetUeAggregateMaxBitRateUplink ();
           params.bearers        = x2HoReqHeader.GetBearers ();
+          // RlcRequests for secondary cell HO
+          params.rlcRequests    = x2HoReqHeader.GetRlcSetupRequests();
           params.rrcContext     = packet;
+          params.isMc           = x2HoReqHeader.GetIsMc ();
 
           NS_LOG_LOGIC ("oldEnbUeX2apId = " << params.oldEnbUeX2apId);
           NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
@@ -329,6 +408,7 @@
           EpcX2SapUser::UeContextReleaseParams params;
           params.oldEnbUeX2apId = x2UeCtxReleaseHeader.GetOldEnbUeX2apId ();
           params.newEnbUeX2apId = x2UeCtxReleaseHeader.GetNewEnbUeX2apId ();
+          params.sourceCellId = cellsInfo->m_remoteCellId;
 
           NS_LOG_LOGIC ("oldEnbUeX2apId = " << params.oldEnbUeX2apId);
           NS_LOG_LOGIC ("newEnbUeX2apId = " << params.newEnbUeX2apId);
@@ -360,6 +440,132 @@
           m_x2SapUser->RecvResourceStatusUpdate (params);
         }
     }
+  else if (procedureCode == EpcX2Header::RlcSetupRequest)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: RLC SETUP REQUEST");
+
+      EpcX2RlcSetupRequestHeader x2RlcHeader;
+      packet->RemoveHeader (x2RlcHeader);
+
+      NS_LOG_INFO ("X2 RlcSetupRequest header: " << x2RlcHeader);
+
+      EpcX2SapUser::RlcSetupRequest params;
+      params.targetCellId = x2RlcHeader.GetTargetCellId();
+      params.sourceCellId = x2RlcHeader.GetSourceCellId ();
+      params.mmWaveRnti = x2RlcHeader.GetMmWaveRnti ();
+      params.gtpTeid = x2RlcHeader.GetGtpTeid ();
+      params.lteRnti = x2RlcHeader.GetLteRnti ();
+      params.drbid = x2RlcHeader.GetDrbid ();
+      params.lcinfo = x2RlcHeader.GetLcInfo();
+      params.rlcConfig = x2RlcHeader.GetRlcConfig();
+      params.logicalChannelConfig = x2RlcHeader.GetLogicalChannelConfig();
+
+      NS_LOG_LOGIC ("GtpTeid = " << params.gtpTeid);
+      NS_LOG_LOGIC ("MmWaveRnti = " << params.mmWaveRnti);
+      NS_LOG_LOGIC ("SourceCellID = " << params.sourceCellId);
+      NS_LOG_LOGIC ("TargetCellID = " << params.targetCellId);
+      NS_LOG_LOGIC ("Drbid = " << params.drbid);
+
+      m_x2SapUser->RecvRlcSetupRequest (params);
+    }
+  else if (procedureCode == EpcX2Header::RlcSetupCompleted)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: RLC SETUP COMPLETED");
+
+      EpcX2RlcSetupCompletedHeader x2RlcHeader;
+      packet->RemoveHeader (x2RlcHeader);
+
+      NS_LOG_INFO ("X2 RlcSetupCompleted header: " << x2RlcHeader);
+
+      EpcX2SapUser::UeDataParams params;
+      params.targetCellId = x2RlcHeader.GetTargetCellId();
+      params.sourceCellId = x2RlcHeader.GetSourceCellId ();
+      params.gtpTeid = x2RlcHeader.GetGtpTeid ();
+
+      NS_LOG_LOGIC ("GtpTeid = " << params.gtpTeid);
+      NS_LOG_LOGIC ("SourceCellID = " << params.sourceCellId);
+      NS_LOG_LOGIC ("TargetCellID = " << params.targetCellId);
+
+      m_x2SapUser->RecvRlcSetupCompleted (params);
+    }
+  else if(procedureCode == EpcX2Header::UpdateUeSinr)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: UPDATE UE SINR");
+      
+      EpcX2UeImsiSinrUpdateHeader x2ueSinrUpdateHeader;
+      packet->RemoveHeader(x2ueSinrUpdateHeader);
+
+      NS_LOG_INFO ("X2 SinrUpdateHeader header: " << x2ueSinrUpdateHeader);
+
+      EpcX2SapUser::UeImsiSinrParams params;
+      params.ueImsiSinrMap = x2ueSinrUpdateHeader.GetUeImsiSinrMap();
+      params.sourceCellId = x2ueSinrUpdateHeader.GetSourceCellId();
+
+      m_x2SapUser->RecvUeSinrUpdate(params);  
+    }
+  else if (procedureCode == EpcX2Header::RequestMcHandover)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: REQUEST MC HANDOVER");
+      
+      EpcX2McHandoverHeader x2mcHeader;
+      packet->RemoveHeader(x2mcHeader);
+
+      NS_LOG_INFO ("X2 RequestMcHandover header: " << x2mcHeader);
+
+      EpcX2SapUser::SecondaryHandoverParams params;
+      params.targetCellId = x2mcHeader.GetTargetCellId();
+      params.imsi = x2mcHeader.GetImsi();
+      params.oldCellId = x2mcHeader.GetOldCellId();
+
+      m_x2SapUser->RecvMcHandoverRequest(params);  
+    }
+  else if (procedureCode == EpcX2Header::NotifyMmWaveLteHandover)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: NOTIFY MMWAVE HANDOVER TO LTE");
+      
+      EpcX2McHandoverHeader x2mcHeader;
+      packet->RemoveHeader(x2mcHeader);
+
+      NS_LOG_INFO ("X2 McHandover header: " << x2mcHeader);
+
+      EpcX2SapUser::SecondaryHandoverParams params;
+      params.targetCellId = x2mcHeader.GetTargetCellId(); // the new MmWave cell to which the UE is connected
+      params.imsi = x2mcHeader.GetImsi(); 
+      params.oldCellId = x2mcHeader.GetOldCellId(); // actually, the LTE cell ID
+
+      m_x2SapUser->RecvLteMmWaveHandoverCompleted(params);  
+    }
+  else if (procedureCode == EpcX2Header::SwitchConnection)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: SWITCH CONNECTION");
+      
+      EpcX2ConnectionSwitchHeader x2mcHeader;
+      packet->RemoveHeader(x2mcHeader);
+
+      NS_LOG_INFO ("X2 SwitchConnection header: " << x2mcHeader);
+
+      EpcX2SapUser::SwitchConnectionParams params;
+      params.mmWaveRnti = x2mcHeader.GetMmWaveRnti();
+      params.useMmWaveConnection = x2mcHeader.GetUseMmWaveConnection();
+      params.drbid = x2mcHeader.GetDrbid();
+
+      m_x2SapUser->RecvConnectionSwitchToMmWave(params);
+    }
+  else if (procedureCode == EpcX2Header::SecondaryCellHandoverCompleted)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: SECONDARY CELL HANDOVER COMPLETED");
+
+      EpcX2SecondaryCellHandoverCompletedHeader x2hoHeader;
+      packet->RemoveHeader(x2hoHeader);
+
+      EpcX2SapUser::SecondaryHandoverCompletedParams params;
+      params.mmWaveRnti = x2hoHeader.GetMmWaveRnti();
+      params.imsi = x2hoHeader.GetImsi();
+      params.oldEnbUeX2apId = x2hoHeader.GetOldEnbUeX2apId();
+      params.cellId = cellsInfo->m_remoteCellId;
+
+      m_x2SapUser->RecvSecondaryCellHandoverCompleted(params);
+    }
   else
     {
       NS_ASSERT_MSG (false, "ProcedureCode NOT SUPPORTED!!!");
@@ -380,8 +586,22 @@
                  "Missing infos of local and remote CellId");
   Ptr<X2CellInfo> cellsInfo = m_x2InterfaceCellIds [socket];
 
+  NS_LOG_INFO("localCellId = " << cellsInfo->m_localCellId);
+  NS_LOG_INFO("remoteCellId = " << cellsInfo->m_remoteCellId);
+
+  EpcX2Tag epcX2Tag;
+  Time delay;
+  if (packet->PeekPacketTag(epcX2Tag))
+    {
+      delay = Simulator::Now() - epcX2Tag.GetSenderTimestamp ();
+      packet->RemovePacketTag(epcX2Tag);
+    }
+  m_rxPdu(cellsInfo->m_localCellId, cellsInfo->m_remoteCellId, packet->GetSize (), delay.GetNanoSeconds (), 1);
+
   GtpuHeader gtpu;
   packet->RemoveHeader (gtpu);
+  //SocketAddressTag satag;
+  //packet->RemovePacketTag(satag);
 
   NS_LOG_LOGIC ("GTP-U header: " << gtpu);
 
@@ -391,9 +611,46 @@
   params.gtpTeid = gtpu.GetTeid ();
   params.ueData = packet;
 
-  m_x2SapUser->RecvUeData (params);
-}
+  NS_LOG_LOGIC("Received packet on X2 u, size " << packet->GetSize() 
+    << " source " << params.sourceCellId << " target " << params.targetCellId << " type " << gtpu.GetMessageType());
 
+  if(m_teidToBeForwardedMap.find(params.gtpTeid) == m_teidToBeForwardedMap.end())
+  {
+    if(gtpu.GetMessageType() == EpcX2Header::McForwardDownlinkData)
+    {
+      // add PdcpTag
+      PdcpTag pdcpTag (Simulator::Now ());
+      params.ueData->AddByteTag (pdcpTag);
+      // call rlc interface
+      EpcX2RlcUser* user = m_x2RlcUserMap.find(params.gtpTeid)->second;
+      if(user != 0)
+      {
+        user -> SendMcPdcpSdu(params);
+      }
+      else
+      {
+        NS_LOG_INFO("Not implemented: Forward to the other cell or to LTE");
+      }
+    } 
+    else if (gtpu.GetMessageType() == EpcX2Header::McForwardUplinkData)
+    {
+      // call pdcp interface
+      NS_LOG_INFO("Call PDCP interface");
+      m_x2PdcpUserMap[params.gtpTeid] -> ReceiveMcPdcpPdu(params);
+    }
+    else
+    {
+      m_x2SapUser->RecvUeData (params);
+    }
+  }
+  else // the packet was received during a secondary cell HO, forward to the target cell
+  {
+    params.sourceCellId = cellsInfo->m_remoteCellId;
+    params.targetCellId = m_teidToBeForwardedMap.find(params.gtpTeid)->second;
+    NS_LOG_LOGIC("Forward from " << cellsInfo->m_localCellId << " to " << params.targetCellId);
+    DoSendMcPdcpPdu(params);
+  }
+}
 
 //
 // Implementation of the X2 SAP Provider
@@ -428,6 +685,9 @@
   x2HoReqHeader.SetUeAggregateMaxBitRateDownlink (params.ueAggregateMaxBitRateDownlink);
   x2HoReqHeader.SetUeAggregateMaxBitRateUplink (params.ueAggregateMaxBitRateUplink);
   x2HoReqHeader.SetBearers (params.bearers);
+  // For secondary cell handover
+  x2HoReqHeader.SetRlcSetupRequests (params.rlcRequests);
+  x2HoReqHeader.SetIsMc (params.isMc);
 
   EpcX2Header x2Header;
   x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
@@ -442,6 +702,66 @@
   Ptr<Packet> packet = (params.rrcContext != 0) ? (params.rrcContext) : (Create <Packet> ());
   packet->AddHeader (x2HoReqHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+void
+EpcX2::DoSendRlcSetupRequest (EpcX2SapProvider::RlcSetupRequest params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+  NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+  NS_LOG_LOGIC ("teid  = " << params.gtpTeid);
+  NS_LOG_LOGIC ("rnti = " << params.mmWaveRnti);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.targetCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for targetCellId = " << params.targetCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.targetCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: RLC SETUP REQUEST");
+
+  // Build the X2 message
+  EpcX2RlcSetupRequestHeader x2RlcHeader;
+  x2RlcHeader.SetSourceCellId(params.sourceCellId);
+  x2RlcHeader.SetTargetCellId(params.targetCellId);
+  x2RlcHeader.SetGtpTeid(params.gtpTeid);
+  x2RlcHeader.SetMmWaveRnti(params.mmWaveRnti);
+  x2RlcHeader.SetLteRnti(params.lteRnti);
+  x2RlcHeader.SetDrbid(params.drbid);
+  x2RlcHeader.SetLcInfo(params.lcinfo);
+  x2RlcHeader.SetRlcConfig(params.rlcConfig);
+  x2RlcHeader.SetLogicalChannelConfig(params.logicalChannelConfig);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
+  x2Header.SetProcedureCode (EpcX2Header::RlcSetupRequest);
+  x2Header.SetLengthOfIes (x2RlcHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2RlcHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 RlcSetupRequest header: " << x2RlcHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2RlcHeader);
+  packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -450,6 +770,55 @@
 
 
 void
+EpcX2::DoSendRlcSetupCompleted (EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+  NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+  NS_LOG_LOGIC ("teid  = " << params.gtpTeid);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.targetCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for targetCellId = " << params.targetCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.targetCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: RLC SETUP COMPLETED");
+
+  // Build the X2 message
+  EpcX2RlcSetupCompletedHeader x2RlcHeader;
+  x2RlcHeader.SetSourceCellId(params.sourceCellId);
+  x2RlcHeader.SetTargetCellId(params.targetCellId);
+  x2RlcHeader.SetGtpTeid(params.gtpTeid);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
+  x2Header.SetProcedureCode (EpcX2Header::RlcSetupCompleted);
+  x2Header.SetLengthOfIes (x2RlcHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2RlcHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 RlcSetupCompleted header: " << x2RlcHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2RlcHeader);
+  packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+void
 EpcX2::DoSendHandoverRequestAck (EpcX2SapProvider::HandoverRequestAckParams params)
 {
   NS_LOG_FUNCTION (this);
@@ -491,6 +860,10 @@
   Ptr<Packet> packet = (params.rrcContext != 0) ? (params.rrcContext) : (Create <Packet> ());
   packet->AddHeader (x2HoAckHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -539,6 +912,60 @@
   Ptr<Packet> packet = Create <Packet> ();
   packet->AddHeader (x2HoPrepFailHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the X2 message through the socket
+  localSocket->SendTo (packet, 0, InetSocketAddress (remoteIpAddr, m_x2cUdpPort));
+}
+
+void
+EpcX2::DoNotifyCoordinatorHandoverFailed(EpcX2SapProvider::HandoverFailedParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("coordinator cellId " << params.coordinatorId);
+  NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+  NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+  NS_LOG_LOGIC ("imsi = " << params.imsi);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.coordinatorId) != m_x2InterfaceSockets.end (),
+                 "Socket infos not defined for coordinatorId = " << params.coordinatorId);
+
+  Ptr<Socket> localSocket = m_x2InterfaceSockets [params.coordinatorId]->m_localCtrlPlaneSocket;
+  Ipv4Address remoteIpAddr = m_x2InterfaceSockets [params.coordinatorId]->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("localSocket = " << localSocket);
+  NS_LOG_LOGIC ("remoteIpAddr = " << remoteIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: NOTIFY HANDOVER FAILED");
+
+  // Build the X2 message
+  EpcX2NotifyCoordinatorHandoverFailedHeader x2failHeader;
+  x2failHeader.SetSourceCellId (params.sourceCellId);
+  x2failHeader.SetTargetCellId (params.targetCellId);
+  x2failHeader.SetImsi (params.imsi);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::UnsuccessfulOutcome);
+  x2Header.SetProcedureCode (EpcX2Header::NotifyCoordinatorHandoverFailed);
+  x2Header.SetLengthOfIes (x2failHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2failHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 HandoverPrepFail header: " << x2failHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2failHeader);
+  packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -587,6 +1014,10 @@
   Ptr<Packet> packet = Create <Packet> ();
   packet->AddHeader (x2SnStatusXferHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -632,6 +1063,10 @@
   Ptr<Packet> packet = Create <Packet> ();
   packet->AddHeader (x2UeCtxReleaseHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -675,6 +1110,10 @@
   Ptr<Packet> packet = Create <Packet> ();
   packet->AddHeader (x2LoadInfoHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -723,6 +1162,10 @@
   Ptr<Packet> packet = Create <Packet> ();
   packet->AddHeader (x2ResourceStatUpdHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -757,8 +1200,319 @@
   Ptr<Packet> packet = params.ueData;
   packet->AddHeader (gtpu);
 
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("Forward UE DATA through X2 interface");
   sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2uUdpPort));
 }
 
+void
+EpcX2::DoSendMcPdcpPdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+  NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+  NS_LOG_LOGIC ("gtpTeid = " << params.gtpTeid);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.targetCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for targetCellId = " << params.targetCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.targetCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localUserPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  // add a message type to the gtpu header, so that it is possible to distinguish at receiver
+  GtpuHeader gtpu;
+  gtpu.SetTeid (params.gtpTeid);
+  gtpu.SetMessageType(EpcX2Header::McForwardDownlinkData);
+  gtpu.SetLength (params.ueData->GetSize () + gtpu.GetSerializedSize () - 8); /// \todo This should be done in GtpuHeader
+  NS_LOG_INFO ("GTP-U header: " << gtpu);
+
+  Ptr<Packet> packet = params.ueData;
+  packet->AddHeader (gtpu);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  NS_LOG_INFO ("Forward MC UE DATA through X2 interface");
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2uUdpPort));  
+}
+
+void
+EpcX2::DoReceiveMcPdcpSdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+  NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+  NS_LOG_LOGIC ("gtpTeid = " << params.gtpTeid);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.targetCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for targetCellId = " << params.targetCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.targetCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localUserPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  // add a message type to the gtpu header, so that it is possible to distinguish at receiver
+  GtpuHeader gtpu;
+  gtpu.SetTeid (params.gtpTeid);
+  gtpu.SetMessageType(EpcX2Header::McForwardUplinkData);
+  gtpu.SetLength (params.ueData->GetSize () + gtpu.GetSerializedSize () - 8); /// \todo This should be done in GtpuHeader
+  NS_LOG_INFO ("GTP-U header: " << gtpu);
+
+  Ptr<Packet> packet = params.ueData;
+  packet->AddHeader (gtpu);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  NS_LOG_INFO ("Forward MC UE DATA through X2 interface");
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2uUdpPort));  
+}
+
+void
+EpcX2::DoSendUeSinrUpdate(EpcX2Sap::UeImsiSinrParams params)
+{
+  NS_LOG_FUNCTION(this);
+
+  NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+  NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.targetCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for targetCellId = " << params.targetCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.targetCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localUserPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  // Build the X2 message
+  EpcX2UeImsiSinrUpdateHeader x2imsiSinrHeader;
+  x2imsiSinrHeader.SetUeImsiSinrMap (params.ueImsiSinrMap);
+  x2imsiSinrHeader.SetSourceCellId (params.sourceCellId);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
+  x2Header.SetProcedureCode (EpcX2Header::UpdateUeSinr);
+  x2Header.SetLengthOfIes (x2imsiSinrHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2imsiSinrHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 UeImsiSinrUpdate header: " << x2imsiSinrHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2imsiSinrHeader);
+  packet->AddHeader (x2Header);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+
+void
+EpcX2::DoSendMcHandoverRequest (EpcX2SapProvider::SecondaryHandoverParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("oldCellId = " << params.oldCellId);
+  NS_LOG_LOGIC ("imsi = " << params.imsi);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.oldCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for oldCellId = " << params.oldCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.oldCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: REQUEST MC HANDOVER");
+
+  // Build the X2 message
+  EpcX2McHandoverHeader x2mcHeader;
+  x2mcHeader.SetTargetCellId(params.targetCellId);
+  x2mcHeader.SetImsi(params.imsi);
+  x2mcHeader.SetOldCellId(params.oldCellId);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
+  x2Header.SetProcedureCode (EpcX2Header::RequestMcHandover);
+  x2Header.SetLengthOfIes (x2mcHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2mcHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 RequestMcHandover header: " << x2mcHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2mcHeader);
+  packet->AddHeader (x2Header);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+void
+EpcX2::DoNotifyLteMmWaveHandoverCompleted (EpcX2SapProvider::SecondaryHandoverParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("lteCellId = " << params.oldCellId);
+  NS_LOG_LOGIC ("imsi = " << params.imsi);
+  NS_LOG_LOGIC ("MmWave cellId = " << params.targetCellId);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.oldCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for oldCellId = " << params.oldCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.oldCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: NOTIFY MMWAVE HANDOVER TO LTE");
+
+  // Build the X2 message
+  EpcX2McHandoverHeader x2mcHeader;
+  x2mcHeader.SetTargetCellId(params.targetCellId);
+  x2mcHeader.SetImsi(params.imsi);
+  x2mcHeader.SetOldCellId(params.oldCellId);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
+  x2Header.SetProcedureCode (EpcX2Header::NotifyMmWaveLteHandover);
+  x2Header.SetLengthOfIes (x2mcHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2mcHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 RequestMcHandover header: " << x2mcHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2mcHeader);
+  packet->AddHeader (x2Header);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+void
+EpcX2::DoSendSwitchConnectionToMmWave(EpcX2SapProvider::SwitchConnectionParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("MmWaveCellId = " << params.mmWaveCellId);
+  NS_LOG_LOGIC ("MmWaveRnti = " << params.mmWaveRnti);
+  NS_LOG_LOGIC ("UseMmWaveConnection " << params.useMmWaveConnection);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.mmWaveCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for mmWaveCellId = " << params.mmWaveCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.mmWaveCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: SEND CONNECTION SWITCH MESSAGE");
+
+  // Build the X2 message
+  EpcX2ConnectionSwitchHeader x2mcHeader;
+  x2mcHeader.SetMmWaveRnti(params.mmWaveRnti);
+  x2mcHeader.SetUseMmWaveConnection(params.useMmWaveConnection);
+  x2mcHeader.SetDrbid(params.drbid);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
+  x2Header.SetProcedureCode (EpcX2Header::SwitchConnection);
+  x2Header.SetLengthOfIes (x2mcHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2mcHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 RequestMcHandover header: " << x2mcHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2mcHeader);
+  packet->AddHeader (x2Header);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+void 
+EpcX2::DoSendSecondaryCellHandoverCompleted(EpcX2SapProvider::SecondaryHandoverCompletedParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("MmWaveRnti = " << params.mmWaveRnti);
+  NS_LOG_LOGIC ("Imsi = " << params.imsi);
+  NS_LOG_LOGIC ("oldEnbUeX2apId = " << params.oldEnbUeX2apId);
+  NS_LOG_LOGIC ("Dst cellId = " << params.cellId);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.cellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for cellId = " << params.cellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.cellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: SEND SECONDARY CELL HANDOVER COMPLETED MESSAGE");
+
+  // Build the X2 message
+  EpcX2SecondaryCellHandoverCompletedHeader x2hoHeader;
+  x2hoHeader.SetMmWaveRnti(params.mmWaveRnti);
+  x2hoHeader.SetImsi(params.imsi);
+  x2hoHeader.SetOldEnbUeX2apId(params.oldEnbUeX2apId);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::SuccessfulOutcome);
+  x2Header.SetProcedureCode (EpcX2Header::SecondaryCellHandoverCompleted);
+  x2Header.SetLengthOfIes (x2hoHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2hoHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 SecondaryCellHandoverCompleted header: " << x2hoHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2hoHeader);
+  packet->AddHeader (x2Header);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+
 } // namespace ns3
diff -Naru a/model/epc-x2.h b/model/epc-x2.h
--- a/model/epc-x2.h	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-x2.h	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef EPC_X2_H
@@ -25,6 +29,8 @@
 #include "ns3/callback.h"
 #include "ns3/ptr.h"
 #include "ns3/object.h"
+ #include "ns3/traced-value.h"
+#include "ns3/trace-source-accessor.h"
 
 #include "ns3/epc-x2-sap.h"
 
@@ -52,7 +58,7 @@
   /**
    * Assignment operator
    *
-   * \returns X2IfaceInfo& 
+   * \returns X2IfaceInfo&
    */
   X2IfaceInfo& operator= (const X2IfaceInfo &);
 
@@ -81,7 +87,7 @@
   /**
    * Assignment operator
    *
-   * \returns X2CellInfo&  
+   * \returns X2CellInfo&
    */
   X2CellInfo& operator= (const X2CellInfo &);
 
@@ -100,9 +106,11 @@
 {
   /// allow EpcX2SpecificEpcX2SapProvider<EpcX2> class friend access
   friend class EpcX2SpecificEpcX2SapProvider<EpcX2>;
+  friend class EpcX2PdcpSpecificProvider<EpcX2>;
+  friend class EpcX2RlcSpecificProvider<EpcX2>;
 
 public:
-  /** 
+  /**
    * Constructor
    */
   EpcX2 ();
@@ -130,6 +138,28 @@
    */
   EpcX2SapProvider* GetEpcX2SapProvider ();
 
+  /**
+   * \return the X2 Pdcp Provider interface offered by this EPC X2 entity
+   */
+  EpcX2PdcpProvider* GetEpcX2PdcpProvider ();
+
+  /**
+   * \return the X2 Rlc Provider interface offered by this EPC X2 entity
+   */
+  EpcX2RlcProvider* GetEpcX2RlcProvider ();
+
+  /**
+   * \param the teid of the MC device
+   * \param the X2 Rlc User interface associated to the teid
+   */
+  void SetMcEpcX2RlcUser (uint32_t teid, EpcX2RlcUser* rlcUser);
+
+  /**
+   * \param the teid of the MC device
+   * \param the X2 Pdcp User interface associated to the teid
+   */
+  void SetMcEpcX2PdcpUser (uint32_t teid, EpcX2PdcpUser* pdcpUser);
+
 
   /**
    * Add an X2 interface to this EPC X2 entity
@@ -142,22 +172,32 @@
                        uint16_t enb2CellId, Ipv4Address enb2X2Address);
 
 
-  /** 
+  /**
    * Method to be assigned to the recv callback of the X2-C (X2 Control Plane) socket.
    * It is called when the eNB receives a packet from the peer eNB of the X2-C interface
-   * 
+   *
    * \param socket socket of the X2-C interface
    */
   void RecvFromX2cSocket (Ptr<Socket> socket);
 
-  /** 
+  /**
    * Method to be assigned to the recv callback of the X2-U (X2 User Plane) socket.
    * It is called when the eNB receives a packet from the peer eNB of the X2-U interface
-   * 
+   *
    * \param socket socket of the X2-U interface
    */
   void RecvFromX2uSocket (Ptr<Socket> socket);
 
+  /**
+   * TracedCallback signature for
+   *
+   * \param [in] source
+   * \param [in] target
+   * \param [in] bytes The packet size.
+   * \param [in] delay Delay since sender timestamp, in ns.
+   */
+  typedef void (* ReceiveTracedCallback)
+    (uint16_t sourceCellId, uint16_t targetCellId, uint32_t bytes, uint64_t delay, bool data);
 
 protected:
   // Interface provided by EpcX2SapProvider
@@ -166,6 +206,8 @@
    * \param params the send handover request parameters
    */
   virtual void DoSendHandoverRequest (EpcX2SapProvider::HandoverRequestParams params);
+  virtual void DoSendRlcSetupRequest (EpcX2SapProvider::RlcSetupRequest params);
+  virtual void DoSendRlcSetupCompleted (EpcX2SapProvider::UeDataParams);
   /**
    * Send handover request ack function
    * \param params the send handover request ack parameters
@@ -178,7 +220,7 @@
   virtual void DoSendHandoverPreparationFailure (EpcX2SapProvider::HandoverPreparationFailureParams params);
   /**
    * Send SN status transfer function
-   * \param params the SN status transfer parameters 
+   * \param params the SN status transfer parameters
    */
   virtual void DoSendSnStatusTransfer (EpcX2SapProvider::SnStatusTransferParams params);
   /**
@@ -202,10 +244,34 @@
    * \param params EpcX2SapProvider::UeDataParams
    */
   virtual void DoSendUeData (EpcX2SapProvider::UeDataParams params);
-
-  EpcX2SapUser* m_x2SapUser; ///< X2 SAP user
-  EpcX2SapProvider* m_x2SapProvider; ///< X2 SAP provider
-
+  virtual void DoSendMcPdcpPdu (EpcX2SapProvider::UeDataParams params);
+  virtual void DoReceiveMcPdcpSdu (EpcX2SapProvider::UeDataParams params);
+  virtual void DoSendUeSinrUpdate(EpcX2Sap::UeImsiSinrParams params);
+  virtual void DoSendMcHandoverRequest (EpcX2SapProvider::SecondaryHandoverParams params);
+  virtual void DoNotifyLteMmWaveHandoverCompleted (EpcX2SapProvider::SecondaryHandoverParams params);
+  virtual void DoNotifyCoordinatorHandoverFailed(EpcX2SapProvider::HandoverFailedParams params);
+  virtual void DoSendSwitchConnectionToMmWave(EpcX2SapProvider::SwitchConnectionParams params);
+  virtual void DoSendSecondaryCellHandoverCompleted(EpcX2SapProvider::SecondaryHandoverCompletedParams params);
+
+  // these methods are not used to send messages but to change the internal state of the EpcX2
+  virtual void DoAddTeidToBeForwarded(uint32_t teid, uint16_t targetCellId);
+  virtual void DoRemoveTeidToBeForwarded(uint32_t teid);
+
+  EpcX2SapUser* m_x2SapUser;
+  EpcX2SapProvider* m_x2SapProvider;
+
+  /**
+   * Map the PdcpUser to a certain teid
+   */
+  std::map < uint32_t, EpcX2PdcpUser* > m_x2PdcpUserMap;
+  // The PdcpProvider offered by this X2 interface
+  EpcX2PdcpProvider* m_x2PdcpProvider;
+  /**
+   * Map the RlcUser to a certain teid
+   */
+  std::map < uint32_t, EpcX2RlcUser* > m_x2RlcUserMap;
+  // The RlcProvider offered by this X2 interface
+  EpcX2RlcProvider* m_x2RlcProvider;
 
 private:
 
@@ -216,19 +282,24 @@
   std::map < uint16_t, Ptr<X2IfaceInfo> > m_x2InterfaceSockets;
 
   /**
-   * Map the localSocket (the one receiving the X2 message) 
+   * Map the localSocket (the one receiving the X2 message)
    * to the corresponding (sourceCellId, targetCellId) associated with the X2 interface
    */
   std::map < Ptr<Socket>, Ptr<X2CellInfo> > m_x2InterfaceCellIds;
 
   /**
-   * UDP ports to be used for the X2-C interface
+   * UDP ports to be used for the X2 interfaces: X2-C and X2-U
    */
   uint16_t m_x2cUdpPort;
+  uint16_t m_x2uUdpPort;
+
+  TracedCallback<uint16_t, uint16_t, uint32_t, uint64_t, bool> m_rxPdu;
+
   /**
-   * UDP ports to be used for the X2-U interface
+   * Map the gtpTeid to the targetCellId to which the packet should be forwarded
+   * during a secondary cell handover
    */
-  uint16_t m_x2uUdpPort;
+  std::map <uint32_t, uint16_t> m_teidToBeForwardedMap;
 
 };
 
diff -Naru a/model/epc-x2-header.cc b/model/epc-x2-header.cc
--- a/model/epc-x2-header.cc	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-x2-header.cc	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/log.h"
@@ -148,12 +152,13 @@
 NS_OBJECT_ENSURE_REGISTERED (EpcX2HandoverRequestHeader);
 
 EpcX2HandoverRequestHeader::EpcX2HandoverRequestHeader ()
-  : m_numberOfIes (1 + 1 + 1 + 1),
-    m_headerLength (6 + 5 + 12 + (3 + 4 + 8 + 8 + 4)),
+  : m_numberOfIes (1 + 1 + 1 + 1 + 1 + 1),
+    m_headerLength (6 + 5 + 12 + (3 + 4 + 8 + 8 + 4) + 1 + 4),
     m_oldEnbUeX2apId (0xfffa),
     m_cause (0xfffa),
     m_targetCellId (0xfffa),
-    m_mmeUeS1apId (0xfffffffa)
+    m_mmeUeS1apId (0xfffffffa),
+    m_isMc (0xfa)
 {
   m_erabsToBeSetupList.clear ();
 }
@@ -166,7 +171,9 @@
   m_cause = 0xfffb;
   m_targetCellId = 0xfffb;
   m_mmeUeS1apId = 0xfffffffb;
+  m_isMc = 0xfb;
   m_erabsToBeSetupList.clear ();
+  m_rlcRequestsList.clear();
 }
 
 TypeId
@@ -238,6 +245,40 @@
       i.WriteHtonU32 (m_erabsToBeSetupList [j].gtpTeid);
     }
 
+  // RlcSteupRequest vector - for secondary cell HO
+  std::vector <EpcX2Sap::RlcSetupRequest>::size_type sz_rlc = m_rlcRequestsList.size (); 
+  i.WriteHtonU32 (sz_rlc);              // number of RLCs to be setup
+  for (int j = 0; j < (int) sz_rlc; j++)
+  {
+    i.WriteHtonU16 (m_rlcRequestsList[j].sourceCellId);
+    i.WriteHtonU16 (m_rlcRequestsList[j].targetCellId); 
+    i.WriteHtonU32 (m_rlcRequestsList[j].gtpTeid); 
+    i.WriteHtonU16 (m_rlcRequestsList[j].mmWaveRnti); 
+    i.WriteHtonU16 (m_rlcRequestsList[j].lteRnti);
+    i.WriteU8 (m_rlcRequestsList[j].drbid);
+
+    // LcInfo
+    i.WriteHtonU16  (m_rlcRequestsList[j].lcinfo.rnti); // TODO consider if unnecessary
+    i.WriteU8       (m_rlcRequestsList[j].lcinfo.lcId);
+    i.WriteU8       (m_rlcRequestsList[j].lcinfo.lcGroup);
+    i.WriteU8       (m_rlcRequestsList[j].lcinfo.qci);
+    i.WriteU8       (m_rlcRequestsList[j].lcinfo.isGbr);
+    i.WriteHtonU64  (m_rlcRequestsList[j].lcinfo.mbrUl);
+    i.WriteHtonU64  (m_rlcRequestsList[j].lcinfo.mbrDl);
+    i.WriteHtonU64  (m_rlcRequestsList[j].lcinfo.gbrUl);
+    i.WriteHtonU64  (m_rlcRequestsList[j].lcinfo.gbrDl);
+
+    // RlcConfig
+    i.WriteHtonU32 (m_rlcRequestsList[j].rlcConfig.choice); // TODO check size
+
+    // LogicalChannelConfiguration
+    i.WriteU8      (m_rlcRequestsList[j].logicalChannelConfig.priority);
+    i.WriteHtonU16 (m_rlcRequestsList[j].logicalChannelConfig.prioritizedBitRateKbps);
+    i.WriteHtonU16 (m_rlcRequestsList[j].logicalChannelConfig.bucketSizeDurationMs);
+    i.WriteU8      (m_rlcRequestsList[j].logicalChannelConfig.logicalChannelGroup);
+  }
+
+  i.WriteU8(m_isMc);
 }
 
 uint32_t
@@ -302,6 +343,65 @@
       m_headerLength += 48;
     }
 
+  sz = i.ReadNtohU32 ();  
+ 
+  for (int j = 0; j < sz; j++)
+  {
+    EpcX2Sap::RlcSetupRequest rlcReq;
+
+    rlcReq.sourceCellId = i.ReadNtohU16 ();
+    rlcReq.targetCellId = i.ReadNtohU16 (); 
+    rlcReq.gtpTeid = i.ReadNtohU32 (); 
+    rlcReq.mmWaveRnti = i.ReadNtohU16 (); 
+    rlcReq.lteRnti = i.ReadNtohU16 ();
+    rlcReq.drbid = i.ReadU8 ();
+
+    // LcInfo
+    rlcReq.lcinfo.rnti = i.ReadNtohU16 (); // TODO consider if unnecessary
+    rlcReq.lcinfo.lcId = i.ReadU8      ();
+    rlcReq.lcinfo.lcGroup = i.ReadU8   ();
+    rlcReq.lcinfo.qci = i.ReadU8       ();
+    rlcReq.lcinfo.isGbr = i.ReadU8     ();
+    rlcReq.lcinfo.mbrUl = i.ReadNtohU64();
+    rlcReq.lcinfo.mbrDl = i.ReadNtohU64();
+    rlcReq.lcinfo.gbrUl = i.ReadNtohU64();
+    rlcReq.lcinfo.gbrDl = i.ReadNtohU64();
+
+    // RlcConfig
+    uint32_t val = i.ReadNtohU32 ();
+    if (val == LteRrcSap::RlcConfig::AM) {
+      rlcReq.rlcConfig.choice = LteRrcSap::RlcConfig::AM;
+    }
+    else if (val == LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL) {
+      rlcReq.rlcConfig.choice = LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL;
+    }
+    else if (val == LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_UL) {
+      rlcReq.rlcConfig.choice = LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_UL;
+    }
+    else if (val == LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_DL) {
+      rlcReq.rlcConfig.choice = LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_DL;
+    }
+    else if (val == LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL_LOWLAT) {
+      rlcReq.rlcConfig.choice = LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL_LOWLAT;
+    }
+    else {
+      NS_FATAL_ERROR("Unknown value for RlcConfig " << val);
+    }
+
+    // LogicalChannelConfiguration
+    rlcReq.logicalChannelConfig.priority = i.ReadU8     ();
+    rlcReq.logicalChannelConfig.prioritizedBitRateKbps = i.ReadNtohU16();
+    rlcReq.logicalChannelConfig.bucketSizeDurationMs = i.ReadNtohU16();
+    rlcReq.logicalChannelConfig.logicalChannelGroup = i.ReadU8     ();
+
+    m_rlcRequestsList.push_back(rlcReq);
+    m_headerLength += 61;
+  }
+
+  m_isMc = i.ReadU8();
+  m_numberOfIes++;
+  m_headerLength++;
+
   return GetSerializedSize ();
 }
 
@@ -315,6 +415,8 @@
   os << " UeAggrMaxBitRateDownlink = " << m_ueAggregateMaxBitRateDownlink;
   os << " UeAggrMaxBitRateUplink = " << m_ueAggregateMaxBitRateUplink;
   os << " NumOfBearers = " << m_erabsToBeSetupList.size ();
+  os << " NumOfRlcRequests = " << m_rlcRequestsList.size ();
+  os << " isMc = " << m_isMc;
 
   std::vector <EpcX2Sap::ErabToBeSetupItem>::size_type sz = m_erabsToBeSetupList.size ();
   if (sz > 0)
@@ -333,6 +435,7 @@
           os << "]";
         }
     }
+
 }
 
 uint16_t
@@ -359,6 +462,18 @@
   m_cause = cause;
 }
 
+bool
+EpcX2HandoverRequestHeader::GetIsMc () const
+{
+  return m_isMc;
+}
+
+void
+EpcX2HandoverRequestHeader::SetIsMc (bool isMc)
+{
+  m_isMc = isMc;
+}
+
 uint16_t
 EpcX2HandoverRequestHeader::GetTargetCellId () const
 {
@@ -383,6 +498,19 @@
   m_mmeUeS1apId = mmeUeS1apId;
 }
 
+std::vector <EpcX2Sap::RlcSetupRequest>
+EpcX2HandoverRequestHeader::GetRlcSetupRequests () const
+{
+  return m_rlcRequestsList;
+}
+
+void
+EpcX2HandoverRequestHeader::SetRlcSetupRequests (std::vector <EpcX2Sap::RlcSetupRequest> rlcRequests)
+{
+  m_headerLength += 61 * rlcRequests.size ();
+  m_rlcRequestsList = rlcRequests;
+}
+
 std::vector <EpcX2Sap::ErabToBeSetupItem>
 EpcX2HandoverRequestHeader::GetBearers () const
 {
@@ -434,6 +562,844 @@
 
 /////////////////////////////////////////////////////////////////////
 
+NS_OBJECT_ENSURE_REGISTERED (EpcX2RlcSetupRequestHeader);
+
+EpcX2RlcSetupRequestHeader::EpcX2RlcSetupRequestHeader ()
+  : m_numberOfIes (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1),
+    m_headerLength (2 + 2 + 4 + 2 + 2 + 1 + 38 + 4 + 6),
+    m_sourceCellId (0xfffa),
+    m_targetCellId (0xfffa),
+    m_gtpTeid (0xfffffffa),
+    m_mmWaveRnti (0xfffa),
+    m_lteRnti (0xfffa),
+    m_drbid (0xfa)
+{
+}
+
+EpcX2RlcSetupRequestHeader::~EpcX2RlcSetupRequestHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_sourceCellId = 0xfffb;
+  m_targetCellId = 0xfffb;
+  m_gtpTeid = 0xfffffffb;
+  m_mmWaveRnti = 0xfffb;
+  m_lteRnti = 0xfffb;
+  m_drbid = 0xfb;
+}
+
+TypeId
+EpcX2RlcSetupRequestHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2RlcSetupRequestHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2RlcSetupRequestHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2RlcSetupRequestHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2RlcSetupRequestHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2RlcSetupRequestHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_sourceCellId);
+  i.WriteHtonU16 (m_targetCellId); 
+  i.WriteHtonU32 (m_gtpTeid); 
+  i.WriteHtonU16 (m_mmWaveRnti); 
+  i.WriteHtonU16 (m_lteRnti);
+  i.WriteU8 (m_drbid);
+
+  // LcInfo
+  i.WriteHtonU16 (m_lcInfo.rnti); // TODO consider if unnecessary
+  i.WriteU8 (m_lcInfo.lcId);
+  i.WriteU8 (m_lcInfo.lcGroup);
+  i.WriteU8 (m_lcInfo.qci);
+  i.WriteU8 (m_lcInfo.isGbr);
+  i.WriteHtonU64 (m_lcInfo.mbrUl);
+  i.WriteHtonU64 (m_lcInfo.mbrDl);
+  i.WriteHtonU64 (m_lcInfo.gbrUl);
+  i.WriteHtonU64 (m_lcInfo.gbrDl);
+
+  // RlcConfig
+  i.WriteHtonU32 (m_rlcConfig.choice); // TODO check size
+
+  // LogicalChannelConfiguration
+  i.WriteU8 (m_lcConfig.priority);
+  i.WriteHtonU16 (m_lcConfig.prioritizedBitRateKbps);
+  i.WriteHtonU16 (m_lcConfig.bucketSizeDurationMs);
+  i.WriteU8 (m_lcConfig.logicalChannelGroup);
+}
+
+uint32_t
+EpcX2RlcSetupRequestHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_sourceCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+  
+  m_targetCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_gtpTeid = i.ReadNtohU32 ();
+  m_headerLength += 4;
+  m_numberOfIes++;
+
+  m_mmWaveRnti = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_lteRnti = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_drbid = i.ReadU8 ();
+  m_headerLength += 1;
+  m_numberOfIes++;
+
+  m_lcInfo.rnti = i.ReadNtohU16 (); // TODO consider if unnecessary
+  m_lcInfo.lcId = i.ReadU8 ();
+  m_lcInfo.lcGroup = i.ReadU8 ();
+  m_lcInfo.qci = i.ReadU8 ();
+  m_lcInfo.isGbr = i.ReadU8 ();
+  m_lcInfo.mbrUl = i.ReadNtohU64 ();
+  m_lcInfo.mbrDl = i.ReadNtohU64 ();
+  m_lcInfo.gbrUl = i.ReadNtohU64 ();
+  m_lcInfo.gbrDl = i.ReadNtohU64 ();
+  m_headerLength += 38;
+  m_numberOfIes++;
+
+  uint32_t val = i.ReadNtohU32 ();
+  if (val == LteRrcSap::RlcConfig::AM) {
+    m_rlcConfig.choice = LteRrcSap::RlcConfig::AM;
+  }
+  else if (val == LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL) {
+    m_rlcConfig.choice = LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL;
+  }
+  else if (val == LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_UL) {
+    m_rlcConfig.choice = LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_UL;
+  }
+  else if (val == LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_DL) {
+    m_rlcConfig.choice = LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_DL;
+  }
+  else if (val == LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL_LOWLAT) {
+    m_rlcConfig.choice = LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL_LOWLAT;
+  }
+  else {
+    NS_FATAL_ERROR("Unknown value for RlcConfig " << val);
+  }
+  m_headerLength += 4;
+  m_numberOfIes++;
+
+  // LogicalChannelConfiguration
+  m_lcConfig.priority               = i.ReadU8      ();
+  m_lcConfig.prioritizedBitRateKbps = i.ReadNtohU16 ();
+  m_lcConfig.bucketSizeDurationMs   = i.ReadNtohU16 ();
+  m_lcConfig.logicalChannelGroup    = i.ReadU8      ();
+  m_headerLength += 6;
+  m_numberOfIes++;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2RlcSetupRequestHeader::Print (std::ostream &os) const
+{
+  os << "SourceCellId = " << m_sourceCellId;
+  os << " TargetCellId = " << m_targetCellId;
+  os << " gtpTeid = " << m_gtpTeid;
+  os << " MmWaveRnti = " << m_mmWaveRnti;
+  os << " LteRnti = " << m_lteRnti;
+  os << " DrbId = " << (uint32_t)m_drbid;
+  os << " RlcConfig " << m_rlcConfig.choice;
+  os << " bucketSizeDurationMs " << m_lcConfig.bucketSizeDurationMs;
+  // TODO complete print
+}
+
+uint16_t
+EpcX2RlcSetupRequestHeader::GetSourceCellId () const
+{
+  return m_sourceCellId;
+}
+
+void
+EpcX2RlcSetupRequestHeader::SetSourceCellId (uint16_t cellId)
+{
+  m_sourceCellId = cellId;
+}
+
+uint16_t
+EpcX2RlcSetupRequestHeader::GetTargetCellId () const
+{
+  return m_targetCellId;
+}
+
+void
+EpcX2RlcSetupRequestHeader::SetTargetCellId (uint16_t targetCellId)
+{
+  m_targetCellId = targetCellId;
+}
+
+uint32_t
+EpcX2RlcSetupRequestHeader::GetGtpTeid () const
+{
+  return m_gtpTeid;
+}
+
+void
+EpcX2RlcSetupRequestHeader::SetGtpTeid (uint32_t gtpTeid)
+{
+  m_gtpTeid = gtpTeid;
+}
+
+void
+EpcX2RlcSetupRequestHeader::SetMmWaveRnti (uint16_t rnti)
+{
+  m_mmWaveRnti = rnti;
+}
+
+uint16_t
+EpcX2RlcSetupRequestHeader::GetMmWaveRnti () const
+{
+  return m_mmWaveRnti;
+}
+
+void
+EpcX2RlcSetupRequestHeader::SetLteRnti (uint16_t rnti)
+{
+  m_lteRnti = rnti;
+}
+
+uint16_t
+EpcX2RlcSetupRequestHeader::GetLteRnti () const
+{
+  return m_lteRnti;
+}
+
+uint32_t
+EpcX2RlcSetupRequestHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2RlcSetupRequestHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+void
+EpcX2RlcSetupRequestHeader::SetDrbid (uint8_t drbid)
+{
+  m_drbid = drbid;
+}
+
+uint8_t
+EpcX2RlcSetupRequestHeader::GetDrbid () const
+{
+  return m_drbid;
+}
+
+LteEnbCmacSapProvider::LcInfo 
+EpcX2RlcSetupRequestHeader::GetLcInfo() const
+{
+  return m_lcInfo;
+}
+
+void 
+EpcX2RlcSetupRequestHeader::SetLcInfo(LteEnbCmacSapProvider::LcInfo lcInfo)
+{
+  m_lcInfo = lcInfo;
+}
+
+LteRrcSap::RlcConfig 
+EpcX2RlcSetupRequestHeader::GetRlcConfig() const
+{
+  return m_rlcConfig;
+}
+
+void 
+EpcX2RlcSetupRequestHeader::SetRlcConfig(LteRrcSap::RlcConfig rlcConfig)
+{
+  m_rlcConfig = rlcConfig;
+}
+
+LteRrcSap::LogicalChannelConfig 
+EpcX2RlcSetupRequestHeader::GetLogicalChannelConfig()
+{
+  return m_lcConfig;
+}
+
+void 
+EpcX2RlcSetupRequestHeader::SetLogicalChannelConfig(LteRrcSap::LogicalChannelConfig conf)
+{
+  m_lcConfig = conf;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2RlcSetupCompletedHeader);
+
+EpcX2RlcSetupCompletedHeader::EpcX2RlcSetupCompletedHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (2 + 2 + 4),
+    m_sourceCellId (0xfffa),
+    m_targetCellId (0xfffa),
+    m_gtpTeid (0xfffffffa)
+{
+}
+
+EpcX2RlcSetupCompletedHeader::~EpcX2RlcSetupCompletedHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_sourceCellId = 0xfffb;
+  m_targetCellId = 0xfffb;
+  m_gtpTeid = 0xfffffffb;
+}
+
+TypeId
+EpcX2RlcSetupCompletedHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2RlcSetupCompletedHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2RlcSetupCompletedHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2RlcSetupCompletedHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2RlcSetupCompletedHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2RlcSetupCompletedHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_sourceCellId);
+  i.WriteHtonU16 (m_targetCellId); 
+  i.WriteHtonU32 (m_gtpTeid); 
+}
+
+uint32_t
+EpcX2RlcSetupCompletedHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_sourceCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+  
+  m_targetCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_gtpTeid = i.ReadNtohU32 ();
+  m_headerLength += 4;
+  m_numberOfIes++;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2RlcSetupCompletedHeader::Print (std::ostream &os) const
+{
+  os << "SourceCellId = " << m_sourceCellId;
+  os << " TargetCellId = " << m_targetCellId;
+  os << " gtpTeid = " << m_gtpTeid;
+}
+
+uint16_t
+EpcX2RlcSetupCompletedHeader::GetSourceCellId () const
+{
+  return m_sourceCellId;
+}
+
+void
+EpcX2RlcSetupCompletedHeader::SetSourceCellId (uint16_t cellId)
+{
+  m_sourceCellId = cellId;
+}
+
+uint16_t
+EpcX2RlcSetupCompletedHeader::GetTargetCellId () const
+{
+  return m_targetCellId;
+}
+
+void
+EpcX2RlcSetupCompletedHeader::SetTargetCellId (uint16_t targetCellId)
+{
+  m_targetCellId = targetCellId;
+}
+
+uint32_t
+EpcX2RlcSetupCompletedHeader::GetGtpTeid () const
+{
+  return m_gtpTeid;
+}
+
+void
+EpcX2RlcSetupCompletedHeader::SetGtpTeid (uint32_t gtpTeid)
+{
+  m_gtpTeid = gtpTeid;
+}
+
+
+uint32_t
+EpcX2RlcSetupCompletedHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2RlcSetupCompletedHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2McHandoverHeader);
+
+EpcX2McHandoverHeader::EpcX2McHandoverHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (2 + 2 + 8),
+    m_targetCellId (0xfffa),
+    m_oldCellId (0xfffa),
+    m_imsi (0xfffffffffffffffa)
+{
+}
+
+EpcX2McHandoverHeader::~EpcX2McHandoverHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_targetCellId = 0xfffb;
+  m_oldCellId = 0xfffb;
+  m_imsi = 0xfffffffffffffffb;
+}
+
+TypeId
+EpcX2McHandoverHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2McHandoverHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2McHandoverHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2McHandoverHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2McHandoverHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2McHandoverHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_targetCellId); 
+  i.WriteHtonU16 (m_oldCellId); 
+  i.WriteHtonU64 (m_imsi); 
+}
+
+uint32_t
+EpcX2McHandoverHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+  
+  m_targetCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_oldCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_imsi = i.ReadNtohU64 ();
+  m_headerLength += 8;
+  m_numberOfIes++;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2McHandoverHeader::Print (std::ostream &os) const
+{
+  os << " TargetCellId = " << m_targetCellId;
+  os << " oldCellId = " << m_oldCellId;
+  os << " imsi = " << m_imsi;
+}
+
+uint16_t
+EpcX2McHandoverHeader::GetTargetCellId () const
+{
+  return m_targetCellId;
+}
+
+void
+EpcX2McHandoverHeader::SetTargetCellId (uint16_t targetCellId)
+{
+  m_targetCellId = targetCellId;
+}
+
+uint64_t
+EpcX2McHandoverHeader::GetImsi () const
+{
+  return m_imsi;
+}
+
+void
+EpcX2McHandoverHeader::SetImsi (uint64_t imsi)
+{
+  m_imsi = imsi;
+}
+
+uint16_t
+EpcX2McHandoverHeader::GetOldCellId () const
+{
+  return m_oldCellId;
+}
+
+void
+EpcX2McHandoverHeader::SetOldCellId (uint16_t oldCellId)
+{
+  m_oldCellId = oldCellId;
+}
+
+
+uint32_t
+EpcX2McHandoverHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2McHandoverHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2SecondaryCellHandoverCompletedHeader);
+
+EpcX2SecondaryCellHandoverCompletedHeader::EpcX2SecondaryCellHandoverCompletedHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (2 + 2 + 8),
+    m_mmWaveRnti (0xfffa),
+    m_oldEnbUeX2apId (0xfffa),
+    m_imsi (0xfffffffffffffffa)
+{
+}
+
+EpcX2SecondaryCellHandoverCompletedHeader::~EpcX2SecondaryCellHandoverCompletedHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_mmWaveRnti = 0xfffb;
+  m_oldEnbUeX2apId = 0xfffb;
+  m_imsi = 0xfffffffffffffffb;
+}
+
+TypeId
+EpcX2SecondaryCellHandoverCompletedHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2SecondaryCellHandoverCompletedHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2SecondaryCellHandoverCompletedHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2SecondaryCellHandoverCompletedHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2SecondaryCellHandoverCompletedHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2SecondaryCellHandoverCompletedHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_mmWaveRnti); 
+  i.WriteHtonU16 (m_oldEnbUeX2apId); 
+  i.WriteHtonU64 (m_imsi); 
+}
+
+uint32_t
+EpcX2SecondaryCellHandoverCompletedHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+  
+  m_mmWaveRnti = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_oldEnbUeX2apId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_imsi = i.ReadNtohU64 ();
+  m_headerLength += 8;
+  m_numberOfIes++;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2SecondaryCellHandoverCompletedHeader::Print (std::ostream &os) const
+{
+  os << " MmWaveRnti = " << m_mmWaveRnti;
+  os << " oldEnbUeX2apId = " << m_oldEnbUeX2apId;
+  os << " imsi = " << m_imsi;
+}
+
+uint16_t
+EpcX2SecondaryCellHandoverCompletedHeader::GetMmWaveRnti () const
+{
+  return m_mmWaveRnti;
+}
+
+void
+EpcX2SecondaryCellHandoverCompletedHeader::SetMmWaveRnti (uint16_t rnti)
+{
+  m_mmWaveRnti = rnti;
+}
+
+uint64_t
+EpcX2SecondaryCellHandoverCompletedHeader::GetImsi () const
+{
+  return m_imsi;
+}
+
+void
+EpcX2SecondaryCellHandoverCompletedHeader::SetImsi (uint64_t imsi)
+{
+  m_imsi = imsi;
+}
+
+uint16_t
+EpcX2SecondaryCellHandoverCompletedHeader::GetOldEnbUeX2apId () const
+{
+  return m_oldEnbUeX2apId;
+}
+
+void
+EpcX2SecondaryCellHandoverCompletedHeader::SetOldEnbUeX2apId (uint16_t oldId)
+{
+  m_oldEnbUeX2apId = oldId;
+}
+
+
+uint32_t
+EpcX2SecondaryCellHandoverCompletedHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2SecondaryCellHandoverCompletedHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2NotifyCoordinatorHandoverFailedHeader);
+
+EpcX2NotifyCoordinatorHandoverFailedHeader::EpcX2NotifyCoordinatorHandoverFailedHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (2 + 2 + 8),
+    m_targetCellId (0xfffa),
+    m_sourceCellId (0xfffa),
+    m_imsi (0xfffffffffffffffa)
+{
+}
+
+EpcX2NotifyCoordinatorHandoverFailedHeader::~EpcX2NotifyCoordinatorHandoverFailedHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_targetCellId = 0xfffb;
+  m_sourceCellId = 0xfffb;
+  m_imsi = 0xfffffffffffffffb;
+}
+
+TypeId
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2NotifyCoordinatorHandoverFailedHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2NotifyCoordinatorHandoverFailedHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2NotifyCoordinatorHandoverFailedHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_targetCellId); 
+  i.WriteHtonU16 (m_sourceCellId); 
+  i.WriteHtonU64 (m_imsi); 
+}
+
+uint32_t
+EpcX2NotifyCoordinatorHandoverFailedHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+  
+  m_targetCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_sourceCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_imsi = i.ReadNtohU64 ();
+  m_headerLength += 8;
+  m_numberOfIes++;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2NotifyCoordinatorHandoverFailedHeader::Print (std::ostream &os) const
+{
+  os << " TargetCellId = " << m_targetCellId;
+  os << " oldCellId = " << m_sourceCellId;
+  os << " imsi = " << m_imsi;
+}
+
+uint16_t
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetTargetCellId () const
+{
+  return m_targetCellId;
+}
+
+void
+EpcX2NotifyCoordinatorHandoverFailedHeader::SetTargetCellId (uint16_t targetCellId)
+{
+  m_targetCellId = targetCellId;
+}
+
+uint64_t
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetImsi () const
+{
+  return m_imsi;
+}
+
+void
+EpcX2NotifyCoordinatorHandoverFailedHeader::SetImsi (uint64_t imsi)
+{
+  m_imsi = imsi;
+}
+
+uint16_t
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetSourceCellId () const
+{
+  return m_sourceCellId;
+}
+
+void
+EpcX2NotifyCoordinatorHandoverFailedHeader::SetSourceCellId (uint16_t oldCellId)
+{
+  m_sourceCellId = oldCellId;
+}
+
+
+uint32_t
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+
+
+/////////////////////////////////////////////////////////////////////
+
 NS_OBJECT_ENSURE_REGISTERED (EpcX2HandoverRequestAckHeader);
 
 EpcX2HandoverRequestAckHeader::EpcX2HandoverRequestAckHeader ()
@@ -1489,4 +2455,325 @@
   return m_numberOfIes;
 }
 
+////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2UeImsiSinrUpdateHeader);
+
+EpcX2UeImsiSinrUpdateHeader::EpcX2UeImsiSinrUpdateHeader ()
+  : m_numberOfIes (1 + 1),
+    m_headerLength (2 + 2)
+{
+  m_map.clear ();
+}
+
+EpcX2UeImsiSinrUpdateHeader::~EpcX2UeImsiSinrUpdateHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_map.clear ();
+}
+
+TypeId
+EpcX2UeImsiSinrUpdateHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2UeImsiSinrUpdateHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2UeImsiSinrUpdateHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2UeImsiSinrUpdateHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2UeImsiSinrUpdateHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2UeImsiSinrUpdateHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_sourceCellId);
+
+  std::map <uint64_t, double>::size_type sz = m_map.size ();
+  i.WriteHtonU16 (sz);              // number of elements in the map
+
+  for (std::map<uint64_t, double>::const_iterator iter = m_map.begin(); iter != m_map.end(); ++iter)
+    {
+      i.WriteHtonU64 (iter->first); // imsi
+      i.WriteHtonU64 (pack754(iter->second)); // sinr
+    }
+}
+
+uint32_t
+EpcX2UeImsiSinrUpdateHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+
+  m_sourceCellId = i.ReadNtohU16();
+  m_headerLength += 2;
+  m_numberOfIes = 1;
+
+  int sz = i.ReadNtohU16 ();
+  for (int j = 0; j < sz; j++)
+    {
+      uint64_t imsi = i.ReadNtohU64();
+      double sinr = unpack754(i.ReadNtohU64());
+      m_map[imsi] = sinr;
+    }
+
+  m_headerLength += 2 + sz * 16;
+  m_numberOfIes += 1 + sz;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2UeImsiSinrUpdateHeader::Print (std::ostream &os) const
+{
+  os << "SourceCellId " << m_sourceCellId;
+  for(std::map<uint64_t, double>::const_iterator iter = m_map.begin(); iter != m_map.end(); ++iter)
+  {
+    os << " Imsi " << iter->first << " sinr " << 10*std::log10(iter->second);
+  }
+}
+
+uint16_t 
+EpcX2UeImsiSinrUpdateHeader::GetSourceCellId () const
+{
+  return m_sourceCellId;
+}
+
+void
+EpcX2UeImsiSinrUpdateHeader::SetSourceCellId(uint16_t cellId)
+{
+  m_sourceCellId = cellId;
+}
+
+std::map <uint64_t, double>
+EpcX2UeImsiSinrUpdateHeader::GetUeImsiSinrMap () const
+{
+  return m_map;
+}
+
+void
+EpcX2UeImsiSinrUpdateHeader::SetUeImsiSinrMap (std::map <uint64_t, double> map)
+{
+  m_map = map;
+
+  std::map <uint64_t, double>::size_type sz = m_map.size ();
+  m_headerLength += sz * 16;
+  m_numberOfIes += sz;
+}
+
+uint32_t
+EpcX2UeImsiSinrUpdateHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2UeImsiSinrUpdateHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+uint64_t 
+EpcX2UeImsiSinrUpdateHeader::pack754(long double f)
+{
+  uint16_t bits = 64;
+  uint16_t expbits = 11;
+  long double fnorm;
+  int shift;
+  long long sign, exp, significand;
+  unsigned significandbits = bits - expbits - 1; // -1 for sign bit
+
+  if (f == 0.0) return 0; // get this special case out of the way
+
+  // check sign and begin normalization
+  if (f < 0) { sign = 1; fnorm = -f; }
+  else { sign = 0; fnorm = f; }
+
+  // get the normalized form of f and track the exponent
+  shift = 0;
+  while(fnorm >= 2.0) { fnorm /= 2.0; shift++; }
+  while(fnorm < 1.0) { fnorm *= 2.0; shift--; }
+  fnorm = fnorm - 1.0;
+
+  // calculate the binary form (non-float) of the significand data
+  significand = fnorm * ((1LL<<significandbits) + 0.5f);
+
+  // get the biased exponent
+  exp = shift + ((1<<(expbits-1)) - 1); // shift + bias
+
+  // return the final answer
+  return (sign<<(bits-1)) | (exp<<(bits-expbits-1)) | significand;
+}
+
+long double 
+EpcX2UeImsiSinrUpdateHeader::unpack754(uint64_t i)
+{
+  uint16_t bits = 64;
+  uint16_t expbits = 11;
+  long double result;
+  long long shift;
+  unsigned bias;
+  unsigned significandbits = bits - expbits - 1; // -1 for sign bit
+
+  if (i == 0) return 0.0;
+
+  // pull the significand
+  result = (i&((1LL<<significandbits)-1)); // mask
+  result /= (1LL<<significandbits); // convert back to float
+  result += 1.0f; // add the one back on
+
+  // deal with the exponent
+  bias = (1<<(expbits-1)) - 1;
+  shift = ((i>>significandbits)&((1LL<<expbits)-1)) - bias;
+  while(shift > 0) { result *= 2.0; shift--; }
+  while(shift < 0) { result /= 2.0; shift++; }
+
+  // sign it
+  result *= (i>>(bits-1))&1? -1.0: 1.0;
+
+  return result;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2ConnectionSwitchHeader);
+
+EpcX2ConnectionSwitchHeader::EpcX2ConnectionSwitchHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (2 + 1 + 1),
+    m_mmWaveRnti (0xfffa),
+    m_drbid (0xfa),
+    m_useMmWaveConnection (0)
+{
+
+}
+
+EpcX2ConnectionSwitchHeader::~EpcX2ConnectionSwitchHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_mmWaveRnti          = 0xfffb;
+  m_drbid = 0xfb;
+  m_useMmWaveConnection = 0;
+}
+
+TypeId
+EpcX2ConnectionSwitchHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2ConnectionSwitchHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2ConnectionSwitchHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2ConnectionSwitchHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2ConnectionSwitchHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2ConnectionSwitchHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_mmWaveRnti);
+  i.WriteU8 (m_drbid);
+  i.WriteU8 (m_useMmWaveConnection);
+}
+
+uint32_t
+EpcX2ConnectionSwitchHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_mmWaveRnti = i.ReadNtohU16 ();
+  m_drbid = i.ReadU8();
+  m_useMmWaveConnection = (bool)i.ReadU8 ();
+  m_numberOfIes = 3;
+  m_headerLength = 4;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2ConnectionSwitchHeader::Print (std::ostream &os) const
+{
+  os << "m_mmWaveRnti = " << m_mmWaveRnti;
+  os << " m_useMmWaveConnection = " << m_useMmWaveConnection;
+  os << " m_drbid = " << (uint16_t)m_drbid;
+}
+
+uint16_t
+EpcX2ConnectionSwitchHeader::GetMmWaveRnti () const
+{
+  return m_mmWaveRnti;
+}
+
+void
+EpcX2ConnectionSwitchHeader::SetMmWaveRnti (uint16_t rnti)
+{
+  m_mmWaveRnti = rnti;
+}
+
+bool
+EpcX2ConnectionSwitchHeader::GetUseMmWaveConnection () const
+{
+  return m_useMmWaveConnection;
+}
+
+void
+EpcX2ConnectionSwitchHeader::SetUseMmWaveConnection (bool useMmWaveConnection)
+{
+  m_useMmWaveConnection = useMmWaveConnection;
+}
+
+uint8_t
+EpcX2ConnectionSwitchHeader::GetDrbid () const
+{
+  return m_drbid;
+}
+
+void
+EpcX2ConnectionSwitchHeader::SetDrbid (uint8_t bid)
+{
+  m_drbid = bid;
+}
+
+uint32_t
+EpcX2ConnectionSwitchHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2ConnectionSwitchHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+
 } // namespace ns3
diff -Naru a/model/epc-x2-header.h b/model/epc-x2-header.h
--- a/model/epc-x2-header.h	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-x2-header.h	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef EPC_X2_HEADER_H
@@ -88,14 +92,26 @@
     LoadIndication          = 2,
     SnStatusTransfer        = 4,
     UeContextRelease        = 5,
-    ResourceStatusReporting = 10
+    ResourceStatusReporting = 10,
+    RlcSetupRequest         = 11, // added for MC functionalities
+    RlcSetupCompleted       = 12,
+    NotifyMcConnection      = 13,
+    UpdateUeSinr            = 14,
+    RequestMcHandover       = 15,
+    NotifyMmWaveLteHandover = 16,
+    NotifyCoordinatorHandoverFailed = 17,
+    SwitchConnection        = 18,
+    SecondaryCellHandoverCompleted = 19
+
   };
 
   /// Type of message enumeration
   enum TypeOfMessage_t {
     InitiatingMessage       = 0,
     SuccessfulOutcome       = 1,
-    UnsuccessfulOutcome     = 2
+    UnsuccessfulOutcome     = 2,
+    McForwardDownlinkData   = 3, // added for MC functionalities
+    McForwardUplinkData     = 4
   };
 
 private:
@@ -150,6 +166,9 @@
    */
   void SetCause (uint16_t cause);
 
+  bool GetIsMc () const;
+  void SetIsMc (bool isMc);
+
   /**
    * Get target cell id function
    * \returns the target cell ID
@@ -180,9 +199,12 @@
   /**
    * Set bearers function
    * \param bearers std::vector <EpcX2Sap::ErabToBeSetupItem>
-   */ 
+   */
   void SetBearers (std::vector <EpcX2Sap::ErabToBeSetupItem> bearers);
 
+  std::vector <EpcX2Sap::RlcSetupRequest> GetRlcSetupRequests () const;
+  void SetRlcSetupRequests (std::vector <EpcX2Sap::RlcSetupRequest> rlcRequests);
+
   /**
    * Get UE Aggregate Max Bit Rate Downlink function
    * \returns the UE aggregate max bit rate downlink
@@ -227,6 +249,203 @@
   uint64_t          m_ueAggregateMaxBitRateDownlink; ///< aggregate max bit rate downlink
   uint64_t          m_ueAggregateMaxBitRateUplink; ///< aggregate max bit rate uplink
   std::vector <EpcX2Sap::ErabToBeSetupItem> m_erabsToBeSetupList; ///< ERAB to be setup list
+  std::vector <EpcX2Sap::RlcSetupRequest> m_rlcRequestsList;
+  bool              m_isMc;
+};
+
+
+class EpcX2RlcSetupRequestHeader : public Header
+{
+public:
+  EpcX2RlcSetupRequestHeader ();
+  virtual ~EpcX2RlcSetupRequestHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+  uint16_t GetSourceCellId () const;
+  void SetSourceCellId (uint16_t sourceCellId);
+
+  uint16_t GetTargetCellId () const;
+  void SetTargetCellId (uint16_t targetCellId);
+
+  uint32_t GetGtpTeid () const;
+  void SetGtpTeid (uint32_t gtpTeid);
+
+  uint16_t GetMmWaveRnti () const;
+  void SetMmWaveRnti (uint16_t rnti);
+
+  uint16_t GetLteRnti () const;
+  void SetLteRnti (uint16_t rnti);
+
+  uint8_t GetDrbid () const;
+  void SetDrbid (uint8_t drbid);
+
+  LteEnbCmacSapProvider::LcInfo GetLcInfo() const;
+  void SetLcInfo(LteEnbCmacSapProvider::LcInfo lcInfo);
+
+  LteRrcSap::RlcConfig GetRlcConfig() const;
+  void SetRlcConfig(LteRrcSap::RlcConfig rlcConfig);
+
+  LteRrcSap::LogicalChannelConfig GetLogicalChannelConfig();
+  void SetLogicalChannelConfig(LteRrcSap::LogicalChannelConfig conf);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t          m_sourceCellId;
+  uint16_t          m_targetCellId;
+  uint32_t          m_gtpTeid;
+  uint16_t          m_mmWaveRnti;
+  uint16_t          m_lteRnti;
+  uint8_t           m_drbid;
+  LteEnbCmacSapProvider::LcInfo m_lcInfo;
+  LteRrcSap::RlcConfig m_rlcConfig;
+  LteRrcSap::LogicalChannelConfig m_lcConfig;
+};
+
+class EpcX2RlcSetupCompletedHeader : public Header
+{
+public:
+  EpcX2RlcSetupCompletedHeader ();
+  virtual ~EpcX2RlcSetupCompletedHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+  uint16_t GetSourceCellId () const;
+  void SetSourceCellId (uint16_t sourceCellId);
+
+  uint16_t GetTargetCellId () const;
+  void SetTargetCellId (uint16_t targetCellId);
+
+  uint32_t GetGtpTeid () const;
+  void SetGtpTeid (uint32_t gtpTeid);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t          m_sourceCellId;
+  uint16_t          m_targetCellId;
+  uint32_t          m_gtpTeid;
+};
+
+class EpcX2McHandoverHeader : public Header
+{
+public:
+  EpcX2McHandoverHeader ();
+  virtual ~EpcX2McHandoverHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+  uint16_t GetTargetCellId () const;
+  void SetTargetCellId (uint16_t targetCellId);
+
+  uint16_t GetOldCellId () const;
+  void SetOldCellId (uint16_t oldCellId);
+
+  uint64_t GetImsi () const;
+  void SetImsi (uint64_t imsi);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t          m_targetCellId;
+  uint16_t          m_oldCellId;
+  uint64_t          m_imsi;
+};
+
+class EpcX2SecondaryCellHandoverCompletedHeader : public Header
+{
+public:
+  EpcX2SecondaryCellHandoverCompletedHeader ();
+  virtual ~EpcX2SecondaryCellHandoverCompletedHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+  uint16_t GetMmWaveRnti () const;
+  void SetMmWaveRnti (uint16_t mmWaveRnti);
+
+  uint16_t GetOldEnbUeX2apId () const;
+  void SetOldEnbUeX2apId (uint16_t oldEnbUeX2apId);
+
+  uint64_t GetImsi () const;
+  void SetImsi (uint64_t imsi);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t          m_mmWaveRnti;
+  uint16_t          m_oldEnbUeX2apId;
+  uint64_t          m_imsi;
+};
+
+class EpcX2NotifyCoordinatorHandoverFailedHeader : public Header
+{
+public:
+  EpcX2NotifyCoordinatorHandoverFailedHeader ();
+  virtual ~EpcX2NotifyCoordinatorHandoverFailedHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+  uint16_t GetTargetCellId () const;
+  void SetTargetCellId (uint16_t targetCellId);
+
+  uint16_t GetSourceCellId () const;
+  void SetSourceCellId (uint16_t oldCellId);
+
+  uint64_t GetImsi () const;
+  void SetImsi (uint64_t imsi);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t          m_targetCellId;
+  uint16_t          m_sourceCellId;
+  uint64_t          m_imsi;
 };
 
 /**
@@ -460,7 +679,7 @@
   uint32_t          m_numberOfIes; ///< number of IEs
   uint32_t          m_headerLength; ///< header length
 
-  uint16_t          m_oldEnbUeX2apId; ///< old ENB UE X2 AP ID 
+  uint16_t          m_oldEnbUeX2apId; ///< old ENB UE X2 AP ID
   uint16_t          m_newEnbUeX2apId; ///< new ENB UE X2 AP ID
   std::vector <EpcX2Sap::ErabsSubjectToStatusTransferItem> m_erabsSubjectToStatusTransferList; ///< ERABs subject to status transfer list
 };
@@ -556,7 +775,7 @@
   std::vector <EpcX2Sap::CellInformationItem> GetCellInformationList () const;
   /**
    * Set cell information list function
-   * \param cellInformationList std::vector <EpcX2Sap::CellInformationItem> 
+   * \param cellInformationList std::vector <EpcX2Sap::CellInformationItem>
    */
   void SetCellInformationList (std::vector <EpcX2Sap::CellInformationItem> cellInformationList);
 
@@ -625,7 +844,7 @@
   /**
    * Get cell measurement results list function
    * \returns the cell measurement results list
-   */ 
+   */
   std::vector <EpcX2Sap::CellMeasurementResultItem> GetCellMeasurementResultList () const;
   /**
    * Set cell measurement results list function
@@ -653,6 +872,76 @@
   std::vector <EpcX2Sap::CellMeasurementResultItem> m_cellMeasurementResultList; ///< cell measurement result list
 };
 
+class EpcX2UeImsiSinrUpdateHeader : public Header
+{
+public:
+  EpcX2UeImsiSinrUpdateHeader ();
+  virtual ~EpcX2UeImsiSinrUpdateHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  std::map <uint64_t, double> GetUeImsiSinrMap () const;
+  void SetUeImsiSinrMap (std::map<uint64_t, double> map);
+
+  uint16_t GetSourceCellId () const;
+  void SetSourceCellId (uint16_t sourceCellId);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  // from http://beej.us/guide/bgnet/examples/ieee754.c, to convert
+  // uint64_t to double and viceversa according to IEEE754 format
+  static uint64_t pack754(long double f);
+  static long double unpack754(uint64_t i);
+
+  std::map <uint64_t, double> m_map;
+  uint16_t m_sourceCellId;
+};
+
+class EpcX2ConnectionSwitchHeader : public Header
+{
+public:
+  EpcX2ConnectionSwitchHeader ();
+  virtual ~EpcX2ConnectionSwitchHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint16_t GetMmWaveRnti () const;
+  void SetMmWaveRnti (uint16_t rnti);
+
+  bool GetUseMmWaveConnection () const;
+  void SetUseMmWaveConnection (bool useMmWaveConnection);
+
+  uint8_t GetDrbid () const;
+  void SetDrbid (uint8_t bid);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t m_mmWaveRnti;
+  uint8_t m_drbid;
+  bool     m_useMmWaveConnection;
+};
 
 } // namespace ns3
 
diff -Naru a/model/epc-x2-sap.cc b/model/epc-x2-sap.cc
--- a/model/epc-x2-sap.cc	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-x2-sap.cc	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/epc-x2-sap.h"
@@ -40,4 +44,20 @@
 {
 }
 
+EpcX2PdcpUser::~EpcX2PdcpUser()
+{
+}
+
+EpcX2PdcpProvider::~EpcX2PdcpProvider()
+{
+}
+
+EpcX2RlcUser::~EpcX2RlcUser()
+{
+}
+
+EpcX2RlcProvider::~EpcX2RlcProvider()
+{
+}
+
 } // namespace ns3
diff -Naru a/model/epc-x2-sap.h b/model/epc-x2-sap.h
--- a/model/epc-x2-sap.h	2018-08-03 16:38:46.539805747 +0200
+++ b/model/epc-x2-sap.h	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,16 +17,20 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef EPC_X2_SAP_H
 #define EPC_X2_SAP_H
 
 #include "ns3/packet.h"
-#include "ns3/eps-bearer.h"
 #include "ns3/ipv4-address.h"
-
+#include <ns3/lte-rrc-sap.h>
+#include <ns3/lte-enb-cmac-sap.h>
 #include <bitset>
+#include <map>
 
 namespace ns3 {
 
@@ -34,12 +39,12 @@
 
 /**
  * The X2 SAP defines the service between the X2 entity and the RRC entity.
- * 
+ *
  * The X2 SAP follows the specification 3GPP TS 36.423: "X2 application protocol (X2AP)"
- * 
- * The service primitives corresponds to the X2AP procedures and messages and 
+ *
+ * The service primitives corresponds to the X2AP procedures and messages and
  * the service parameters corresponds to the Information Elements
- * 
+ *
  * Note: Any reference in this file refers to the 3GPP TS 36.423 specification
  */
 
@@ -50,7 +55,7 @@
 {
 public:
   virtual ~EpcX2Sap ();
-  
+
   /**
    * E-RABs to be setup item as
    * it is used in the HANDOVER REQUEST message.
@@ -135,7 +140,7 @@
    * Relative Narrowband Tx Power (RNTP) as
    * it is used in the LOAD INFORMATION message.
    * See section 9.2.19 for further info about the parameters
-   * 
+   *
    * Note: You can use INT16_MIN value for -infinite value
    *       in the rntpThreshold field
    */
@@ -219,6 +224,26 @@
     TimeCriticalHandover
   };
 
+  /**
+   * \brief Parameters of the RlcSetupRequest to handle MC connectivity
+   *
+   * Forward UE params during the MC setup
+   */
+  struct RlcSetupRequest
+  {
+    uint16_t    sourceCellId;
+    uint16_t    targetCellId;
+    uint32_t    gtpTeid;
+    uint16_t    mmWaveRnti;
+    uint16_t    lteRnti;
+    uint8_t     drbid;
+    LteEnbCmacSapProvider::LcInfo lcinfo;
+    LteRrcSap::RlcConfig rlcConfig;
+    LteRrcSap::LogicalChannelConfig logicalChannelConfig;
+    TypeId      rlcType;
+  };
+
+
 
   /**
    * \brief Parameters of the HANDOVER REQUEST message.
@@ -227,14 +252,17 @@
    */
   struct HandoverRequestParams
   {
-    uint16_t            oldEnbUeX2apId; ///< old ENB UE X2 AP ID
-    uint16_t            cause; ///< cause
+    uint16_t            oldEnbUeX2apId;  ///< old ENB UE X2 AP ID
+    uint16_t            cause;  ///< cause
     uint16_t            sourceCellId; ///< source cell ID
-    uint16_t            targetCellId; ///< target cell ID
-    uint32_t            mmeUeS1apId; ///< MME UE S1 AP ID
+    uint16_t            targetCellId;  ///< target cell ID
+    uint32_t            mmeUeS1apId;  ///< MME UE S1 AP ID
     uint64_t            ueAggregateMaxBitRateDownlink; ///< UE aggregrate max bit rate downlink
-    uint64_t            ueAggregateMaxBitRateUplink; ///< UE aggregrate max bit rate uplink 
+    uint64_t            ueAggregateMaxBitRateUplink; ///< UE aggregrate max bit rate uplink
+    bool                isMc;
     std::vector <ErabToBeSetupItem> bearers; ///< bearers
+    // list of RlcSetupRequest for secondary cell handovers (otherwise empty)
+    std::vector <RlcSetupRequest> rlcRequests;
     Ptr<Packet>         rrcContext; ///< RRC context
   };
 
@@ -333,10 +361,111 @@
     Ptr<Packet> ueData; ///< UE data
   };
 
+  struct SecondaryHandoverParams
+  {
+    uint64_t imsi;
+    uint16_t oldCellId;
+    uint16_t targetCellId;
+  };
+
+  struct SecondaryHandoverCompletedParams
+  {
+    uint64_t imsi;
+    uint16_t mmWaveRnti;
+    uint16_t cellId;
+    uint16_t oldEnbUeX2apId;
+  };
+
+  struct UeImsiSinrParams
+  {
+    uint16_t    sourceCellId;
+    uint16_t    targetCellId;
+    std::map<uint64_t, double> ueImsiSinrMap;
+  };
+
+  struct HandoverFailedParams
+  {
+    uint64_t imsi;
+    uint16_t coordinatorId;
+    uint16_t sourceCellId;
+    uint16_t targetCellId;
+  };
+
+  struct SwitchConnectionParams
+  {
+    uint32_t mmWaveRnti;
+    uint16_t mmWaveCellId;
+    uint8_t drbid;
+    bool useMmWaveConnection;
+  };
+
+};
+
+
+/**
+ * MC primitives. Part of X2 entity, called by PDCP
+ */
+class EpcX2PdcpProvider : public EpcX2Sap
+{
+public:
+  virtual ~EpcX2PdcpProvider ();
+
+  /*
+   * Service primitives
+   */
+  // X2 sends a Pdcp PDU in downlink to the MmWave eNB for transmission to the UE
+  virtual void SendMcPdcpPdu (UeDataParams params) = 0;
 };
 
 
 /**
+ * MC primitives. Part of PDCP entity, called by X2
+ */
+class EpcX2PdcpUser : public EpcX2Sap
+{
+public:
+  virtual ~EpcX2PdcpUser ();
+
+  /*
+   * Service primitives
+   */
+  // Receive a PDCP PDU in uplink from the MmWave eNB for transmission to CN
+  virtual void ReceiveMcPdcpPdu (UeDataParams params) = 0;
+};
+
+
+/**
+ * MC primitives. Part of X2 entity, called by RLC
+ */
+class EpcX2RlcProvider : public EpcX2Sap
+{
+public:
+  virtual ~EpcX2RlcProvider ();
+
+  /*
+   * Service primitives
+   */
+  // Receive a PDCP SDU from RLC for uplink transmission to PDCP in LTE eNB
+  virtual void ReceiveMcPdcpSdu (UeDataParams params) = 0;
+};
+
+
+/**
+ * MC primitives. Part of RLC entity, called by X2
+ */
+class EpcX2RlcUser : public EpcX2Sap
+{
+public:
+  virtual ~EpcX2RlcUser ();
+
+  /*
+   * Service primitives
+   */
+  // X2 sends a PDCP SDU to RLC for downlink transmission to the UE
+  virtual void SendMcPdcpSdu (UeDataParams params) = 0;
+};
+
+/**
  * These service primitives of this part of the X2 SAP
  * are provided by the X2 entity and issued by RRC entity
  */
@@ -345,57 +474,55 @@
 public:
   virtual ~EpcX2SapProvider ();
 
-  //
-  // Service primitives
-  //
-
   /**
-   * Send handover request function
-   * \param params handover request parameters
+   * Service primitives
    */
+
   virtual void SendHandoverRequest (HandoverRequestParams params) = 0;
 
-  /**
-   * Send handover request ack function
-   * \param params the handover request ack parameters
-   */
   virtual void SendHandoverRequestAck (HandoverRequestAckParams params) = 0;
 
-  /**
-   * Send handover preparation failure function
-   * \param params the handover preparation failure
-   */
   virtual void SendHandoverPreparationFailure (HandoverPreparationFailureParams params) = 0;
 
-  /**
-   * Send SN status transfer function
-   * \param params the SN status transfer parameters
-   */
   virtual void SendSnStatusTransfer (SnStatusTransferParams params) = 0;
 
-  /**
-   * Send UE context release function
-   * \param params the UE context release parameters
-   */
   virtual void SendUeContextRelease (UeContextReleaseParams params) = 0;
 
-  /**
-   * Send load information function
-   * \param params the load information parameters
-   */
   virtual void SendLoadInformation (LoadInformationParams params) = 0;
 
-  /**
-   * Send resource status update function
-   * \param params the resource statue update paramweters
-   */
   virtual void SendResourceStatusUpdate (ResourceStatusUpdateParams params) = 0;
 
-  /**
-   * Send UE data function
-   * \param params the UE data parameters
-   */
   virtual void SendUeData (UeDataParams params) = 0;
+
+  virtual void SetEpcX2PdcpUser (uint32_t teid, EpcX2PdcpUser * s) = 0;
+
+  virtual void SetEpcX2RlcUser (uint32_t teid, EpcX2RlcUser * s) = 0;
+
+  virtual void SendRlcSetupRequest (RlcSetupRequest params) = 0;
+
+  virtual void SendRlcSetupCompleted (UeDataParams params) = 0;
+
+  virtual void SendUeSinrUpdate (UeImsiSinrParams params) = 0;
+
+  virtual void NotifyLteMmWaveHandoverCompleted (SecondaryHandoverParams params) = 0;
+
+  virtual void NotifyCoordinatorHandoverFailed (HandoverFailedParams params) = 0;
+
+  // send the switch command to the mmwave eNB
+  virtual void SendSwitchConnectionToMmWave (SwitchConnectionParams params) = 0;
+
+  // for secondary cell HO
+  // the coordinator requests to a mmWave eNB to start an handover
+  virtual void SendMcHandoverRequest (SecondaryHandoverParams params) = 0;
+  // notify the coordinator that the secondary cell handover is completed
+  virtual void SendSecondaryCellHandoverCompleted (SecondaryHandoverCompletedParams params) = 0;
+  // notify the EpcX2 class that packets for a certain TEID must be forwarded to the targetCell
+  virtual void AddTeidToBeForwarded (uint32_t gtpTeid, uint16_t targetCellId) = 0;
+  // notify the EpcX2 class that packets for a certain TEID must not be forwarded anymore
+  virtual void RemoveTeidToBeForwarded (uint32_t gtpTeid) = 0;
+  // to forward the packets in the RLC buffers in the source cell as if they were generated by a PDCP
+  virtual void ForwardRlcPdu (UeDataParams params) = 0;
+
 };
 
 
@@ -427,7 +554,7 @@
   /**
    * Receive handover preparation failure function
    * \param params the handover preparation failure parameters
-   */ 
+   */
   virtual void RecvHandoverPreparationFailure (HandoverPreparationFailureParams params) = 0;
 
   /**
@@ -447,18 +574,33 @@
    * \param params the load information parameters
    */
   virtual void RecvLoadInformation (LoadInformationParams params) = 0;
-  
+
   /**
    * Receive resource status update function
    * \param params the resource status update parameters
    */
   virtual void RecvResourceStatusUpdate (ResourceStatusUpdateParams params) = 0;
 
+  virtual void RecvRlcSetupRequest (RlcSetupRequest params) = 0;
+
+  virtual void RecvRlcSetupCompleted (UeDataParams params) = 0;
+
   /**
    * Receive UE data function
    * \param params UE data parameters
    */
   virtual void RecvUeData (UeDataParams params) = 0;
+
+  virtual void RecvUeSinrUpdate(UeImsiSinrParams params) = 0;
+
+  virtual void RecvMcHandoverRequest (SecondaryHandoverParams params) = 0;
+
+  virtual void RecvLteMmWaveHandoverCompleted (SecondaryHandoverParams params) = 0;
+
+  virtual void RecvConnectionSwitchToMmWave (SwitchConnectionParams params) = 0;
+
+  virtual void RecvSecondaryCellHandoverCompleted (SecondaryHandoverCompletedParams params) = 0;
+
 };
 
 ///////////////////////////////////////
@@ -529,6 +671,32 @@
    */
   virtual void SendUeData (UeDataParams params);
 
+  virtual void SetEpcX2PdcpUser (uint32_t teid, EpcX2PdcpUser * s);
+
+  virtual void SetEpcX2RlcUser (uint32_t teid, EpcX2RlcUser * s);
+
+  virtual void SendRlcSetupRequest (RlcSetupRequest params);
+
+  virtual void SendRlcSetupCompleted (UeDataParams params);
+
+  virtual void SendUeSinrUpdate (UeImsiSinrParams params);
+
+  virtual void SendMcHandoverRequest (SecondaryHandoverParams params);
+
+  virtual void NotifyLteMmWaveHandoverCompleted (SecondaryHandoverParams params);
+
+  virtual void NotifyCoordinatorHandoverFailed (HandoverFailedParams params);
+
+  virtual void SendSwitchConnectionToMmWave (SwitchConnectionParams params);
+
+  virtual void SendSecondaryCellHandoverCompleted (SecondaryHandoverCompletedParams params);
+
+  virtual void AddTeidToBeForwarded (uint32_t gtpTeid, uint16_t targetCellId);
+
+  virtual void RemoveTeidToBeForwarded (uint32_t gtpTeid);
+
+  virtual void ForwardRlcPdu (UeDataParams params);
+
 private:
   EpcX2SpecificEpcX2SapProvider ();
   C* m_x2; ///< owner class
@@ -605,6 +773,99 @@
  * EpcX2SpecificEpcX2SapUser
  */
 template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SetEpcX2RlcUser (uint32_t teid, EpcX2RlcUser * s)
+{
+  m_x2->SetMcEpcX2RlcUser (teid, s);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SetEpcX2PdcpUser (uint32_t teid, EpcX2PdcpUser * s)
+{
+  m_x2->SetMcEpcX2PdcpUser (teid, s);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SendRlcSetupRequest (RlcSetupRequest params)
+{
+  m_x2->DoSendRlcSetupRequest (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SendRlcSetupCompleted (UeDataParams params)
+{
+  m_x2->DoSendRlcSetupCompleted (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SendUeSinrUpdate (UeImsiSinrParams params)
+{
+  m_x2->DoSendUeSinrUpdate (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SendMcHandoverRequest (SecondaryHandoverParams params)
+{
+  m_x2->DoSendMcHandoverRequest (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::NotifyLteMmWaveHandoverCompleted (SecondaryHandoverParams params)
+{
+  m_x2->DoNotifyLteMmWaveHandoverCompleted(params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::NotifyCoordinatorHandoverFailed (HandoverFailedParams params)
+{
+  m_x2->DoNotifyCoordinatorHandoverFailed(params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SendSwitchConnectionToMmWave (SwitchConnectionParams params)
+{
+  m_x2->DoSendSwitchConnectionToMmWave(params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SendSecondaryCellHandoverCompleted (SecondaryHandoverCompletedParams params)
+{
+  m_x2->DoSendSecondaryCellHandoverCompleted(params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::AddTeidToBeForwarded (uint32_t gtpTeid, uint16_t targetCellId)
+{
+  m_x2->DoAddTeidToBeForwarded(gtpTeid, targetCellId);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::RemoveTeidToBeForwarded (uint32_t gtpTeid)
+{
+  m_x2->DoRemoveTeidToBeForwarded(gtpTeid);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::ForwardRlcPdu(UeDataParams params)
+{
+  m_x2->DoSendMcPdcpPdu(params);
+}
+
+///////////////////////////////////////
+
+template <class C>
 class EpcX2SpecificEpcX2SapUser : public EpcX2SapUser
 {
 public:
@@ -661,12 +922,27 @@
    */
   virtual void RecvResourceStatusUpdate (ResourceStatusUpdateParams params);
 
+  virtual void RecvRlcSetupRequest (RlcSetupRequest params);
+
+  virtual void RecvRlcSetupCompleted (UeDataParams params);
+
   /**
    * Receive UE data function
    * \param params the UE data parameters
    */
   virtual void RecvUeData (UeDataParams params);
 
+  virtual void RecvUeSinrUpdate (UeImsiSinrParams params);
+
+  virtual void RecvMcHandoverRequest (SecondaryHandoverParams params);
+
+  virtual void RecvLteMmWaveHandoverCompleted (SecondaryHandoverParams params);
+
+  virtual void RecvConnectionSwitchToMmWave (SwitchConnectionParams params);
+
+  virtual void RecvSecondaryCellHandoverCompleted (SecondaryHandoverCompletedParams params);
+
+
 private:
   EpcX2SpecificEpcX2SapUser ();
   C* m_rrc; ///< owner class
@@ -734,11 +1010,193 @@
 
 template <class C>
 void
+EpcX2SpecificEpcX2SapUser<C>::RecvRlcSetupRequest (RlcSetupRequest params)
+{
+  m_rrc->DoRecvRlcSetupRequest (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapUser<C>::RecvRlcSetupCompleted (UeDataParams params)
+{
+  m_rrc->DoRecvRlcSetupCompleted (params);
+}
+
+template <class C>
+void
 EpcX2SpecificEpcX2SapUser<C>::RecvUeData (UeDataParams params)
 {
   m_rrc->DoRecvUeData (params);
 }
 
+template <class C>
+void
+EpcX2SpecificEpcX2SapUser<C>::RecvUeSinrUpdate (UeImsiSinrParams params)
+{
+  m_rrc->DoRecvUeSinrUpdate (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapUser<C>::RecvMcHandoverRequest (SecondaryHandoverParams params)
+{
+  m_rrc->DoRecvMcHandoverRequest (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapUser<C>::RecvLteMmWaveHandoverCompleted (SecondaryHandoverParams params)
+{
+  m_rrc->DoRecvLteMmWaveHandoverCompleted (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapUser<C>::RecvConnectionSwitchToMmWave (SwitchConnectionParams params)
+{
+  m_rrc->DoRecvConnectionSwitchToMmWave (params);
+}
+
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapUser<C>::RecvSecondaryCellHandoverCompleted (SecondaryHandoverCompletedParams params)
+{
+  m_rrc->DoRecvSecondaryCellHandoverCompleted(params);
+}
+
+/////////////////////////////////////////////
+template <class C>
+class EpcX2PdcpSpecificProvider : public EpcX2PdcpProvider
+{
+public:
+  EpcX2PdcpSpecificProvider (C* x2);
+
+  // Inherited
+  virtual void SendMcPdcpPdu (UeDataParams params);
+
+private:
+  EpcX2PdcpSpecificProvider ();
+  C* m_x2;
+};
+
+template <class C>
+EpcX2PdcpSpecificProvider<C>::EpcX2PdcpSpecificProvider (C* x2)
+  : m_x2 (x2)
+{
+}
+
+template <class C>
+EpcX2PdcpSpecificProvider<C>::EpcX2PdcpSpecificProvider ()
+{
+}
+
+template <class C>
+void
+EpcX2PdcpSpecificProvider<C>::SendMcPdcpPdu(UeDataParams params)
+{
+  m_x2->DoSendMcPdcpPdu(params);
+}
+
+/////////////////////////////////////////////
+template <class C>
+class EpcX2RlcSpecificProvider : public EpcX2RlcProvider
+{
+public:
+  EpcX2RlcSpecificProvider (C* x2);
+
+  // Inherited
+  virtual void ReceiveMcPdcpSdu (UeDataParams params);
+
+private:
+  EpcX2RlcSpecificProvider ();
+  C* m_x2;
+};
+
+template <class C>
+EpcX2RlcSpecificProvider<C>::EpcX2RlcSpecificProvider (C* x2)
+  : m_x2 (x2)
+{
+}
+
+template <class C>
+EpcX2RlcSpecificProvider<C>::EpcX2RlcSpecificProvider ()
+{
+}
+
+template <class C>
+void
+EpcX2RlcSpecificProvider<C>::ReceiveMcPdcpSdu(UeDataParams params)
+{
+  m_x2->DoReceiveMcPdcpSdu(params);
+}
+
+/////////////////////////////////////////////
+template <class C>
+class EpcX2PdcpSpecificUser : public EpcX2PdcpUser
+{
+public:
+  EpcX2PdcpSpecificUser (C* pdcp);
+
+  // Inherited
+  virtual void ReceiveMcPdcpPdu (UeDataParams params);
+
+private:
+  EpcX2PdcpSpecificUser ();
+  C* m_pdcp;
+};
+
+template <class C>
+EpcX2PdcpSpecificUser<C>::EpcX2PdcpSpecificUser (C* pdcp)
+  : m_pdcp (pdcp)
+{
+}
+
+template <class C>
+EpcX2PdcpSpecificUser<C>::EpcX2PdcpSpecificUser ()
+{
+}
+
+template <class C>
+void
+EpcX2PdcpSpecificUser<C>::ReceiveMcPdcpPdu(UeDataParams params)
+{
+  m_pdcp->DoReceiveMcPdcpPdu(params);
+}
+
+/////////////////////////////////////////////
+template <class C>
+class EpcX2RlcSpecificUser : public EpcX2RlcUser
+{
+public:
+  EpcX2RlcSpecificUser (C* rlc);
+
+  // Inherited
+  virtual void SendMcPdcpSdu (UeDataParams params);
+
+private:
+  EpcX2RlcSpecificUser ();
+  C* m_rlc;
+};
+
+template <class C>
+EpcX2RlcSpecificUser<C>::EpcX2RlcSpecificUser (C* rlc)
+  : m_rlc (rlc)
+{
+}
+
+template <class C>
+EpcX2RlcSpecificUser<C>::EpcX2RlcSpecificUser ()
+{
+}
+
+template <class C>
+void
+EpcX2RlcSpecificUser<C>::SendMcPdcpSdu(UeDataParams params)
+{
+  m_rlc->DoSendMcPdcpSdu(params);
+}
+
 } // namespace ns3
 
 #endif // EPC_X2_SAP_H
diff -Naru a/model/epc-x2-tag.cc b/model/epc-x2-tag.cc
--- a/model/epc-x2-tag.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-x2-tag.cc	2018-08-03 16:39:02.875957522 +0200
@@ -0,0 +1,92 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 CTTC
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Jaume Nin <jaume.nin@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
+ */
+
+#include "epc-x2-tag.h"
+#include "ns3/tag.h"
+#include "ns3/uinteger.h"
+
+namespace ns3 {
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2Tag);
+
+EpcX2Tag::EpcX2Tag ()
+  : m_senderTimestamp (Seconds (0))
+{
+  // Nothing to do here
+}
+
+
+EpcX2Tag::EpcX2Tag (Time senderTimestamp)
+  : m_senderTimestamp (senderTimestamp)
+
+{
+  // Nothing to do here
+}
+
+TypeId
+EpcX2Tag::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2Tag")
+    .SetParent<Tag> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2Tag> ();
+  return tid;
+}
+
+TypeId
+EpcX2Tag::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2Tag::GetSerializedSize (void) const
+{
+  return sizeof(Time);
+}
+
+void
+EpcX2Tag::Serialize (TagBuffer i) const
+{
+  int64_t senderTimestamp = m_senderTimestamp.GetNanoSeconds ();
+  i.Write ((const uint8_t *)&senderTimestamp, sizeof(int64_t));
+}
+
+void
+EpcX2Tag::Deserialize (TagBuffer i)
+{
+  int64_t senderTimestamp;
+  i.Read ((uint8_t *)&senderTimestamp, 8);
+  m_senderTimestamp   = NanoSeconds (senderTimestamp);
+
+}
+
+void
+EpcX2Tag::Print (std::ostream &os) const
+{
+  os << m_senderTimestamp;
+}
+
+} // namespace ns3
+
diff -Naru a/model/epc-x2-tag.h b/model/epc-x2-tag.h
--- a/model/epc-x2-tag.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-x2-tag.h	2018-08-03 16:39:02.875957522 +0200
@@ -0,0 +1,85 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 CTTC
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Jaume Nin <jaume.nin@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
+ */
+
+#ifndef X2_TAG_H
+#define X2_TAG_H
+
+#include "ns3/packet.h"
+#include "ns3/nstime.h"
+
+
+namespace ns3 {
+
+class Tag;
+
+/**
+ * Tag to calculate the per-PDU delay on X2 links
+ */
+
+class EpcX2Tag : public Tag
+{
+public:
+  static TypeId  GetTypeId (void);
+  virtual TypeId  GetInstanceTypeId (void) const;
+
+  /**
+   * Create an empty X2 tag
+   */
+  EpcX2Tag ();
+  /**
+   * Create an X2 tag with the given senderTimestamp
+   */
+  EpcX2Tag (Time senderTimestamp);
+
+  virtual void  Serialize (TagBuffer i) const;
+  virtual void  Deserialize (TagBuffer i);
+  virtual uint32_t  GetSerializedSize () const;
+  virtual void Print (std::ostream &os) const;
+
+  /**
+   * Get the instant when the X2 delivers the PDU to the MAC SAP provider
+   * @return the sender timestamp
+   */
+  Time  GetSenderTimestamp (void) const
+  {
+    return m_senderTimestamp;
+  }
+
+  /**
+   * Set the sender timestamp
+   * @param senderTimestamp time stamp of the instant when the X2 delivers the PDU
+   */
+  void  SetSenderTimestamp (Time senderTimestamp)
+  {
+    this->m_senderTimestamp = senderTimestamp;
+  }
+
+private:
+  Time m_senderTimestamp;
+
+};
+
+} //namespace ns3
+
+#endif /* X2_TAG_H */
diff -Naru a/model/eps-bearer.cc b/model/eps-bearer.cc
--- a/model/eps-bearer.cc	2018-08-03 16:38:46.539805747 +0200
+++ b/model/eps-bearer.cc	2018-08-03 16:39:02.875957522 +0200
@@ -67,6 +67,7 @@
     case GBR_CONV_VIDEO:
     case GBR_GAMING:
     case GBR_NON_CONV_VIDEO:
+    case GBR_ULTRA_LOW_LAT:
       return true;
     case NGBR_IMS:
     case NGBR_VIDEO_TCP_OPERATOR:
@@ -104,6 +105,8 @@
       return 8;
     case NGBR_VIDEO_TCP_DEFAULT:
       return 9;
+    case GBR_ULTRA_LOW_LAT:
+      return 1;
     default:
       NS_FATAL_ERROR ("unknown QCI value " << qci);
       return 0;
@@ -134,6 +137,8 @@
       return 300;
     case NGBR_VIDEO_TCP_DEFAULT:
       return 300;
+    case GBR_ULTRA_LOW_LAT:
+      return 1;
     default:
       NS_FATAL_ERROR ("unknown QCI value " << qci);
       return 0;
@@ -164,6 +169,8 @@
       return 1.0e-6;
     case NGBR_VIDEO_TCP_DEFAULT:
       return 1.0e-6;
+    case GBR_ULTRA_LOW_LAT:
+    	return 1.0e-6;
     default:
       NS_FATAL_ERROR ("unknown QCI value " << qci);
       return 0;
diff -Naru a/model/eps-bearer.h b/model/eps-bearer.h
--- a/model/eps-bearer.h	2018-08-03 16:38:46.539805747 +0200
+++ b/model/eps-bearer.h	2018-08-03 16:39:02.875957522 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -32,7 +36,7 @@
  */
 struct GbrQosInformation
 {
-  /** 
+  /**
    * Default constructor, initializes member variables to zero or equivalent
    */
   GbrQosInformation ();
@@ -50,7 +54,7 @@
  */
 struct AllocationRetentionPriority
 {
-  /** 
+  /**
    * Default constructor, initializes member variables to zero or equivalent
    */
   AllocationRetentionPriority ();
@@ -85,6 +89,7 @@
     NGBR_VOICE_VIDEO_GAMING = 7,
     NGBR_VIDEO_TCP_PREMIUM  = 8,
     NGBR_VIDEO_TCP_DEFAULT  = 9,
+		GBR_ULTRA_LOW_LAT				= 99,
   } qci; ///< Qos class indicator
 
   GbrQosInformation gbrQosInfo; ///< GBR QOS information
@@ -92,7 +97,7 @@
 
   /**
    * Default constructor. QCI will be initialized to NGBR_VIDEO_TCP_DEFAULT
-   * 
+   *
    */
   EpsBearer ();
 
diff -Naru a/model/fdbet-ff-mac-scheduler.cc b/model/fdbet-ff-mac-scheduler.cc
--- a/model/fdbet-ff-mac-scheduler.cc	2018-08-03 16:38:46.663806898 +0200
+++ b/model/fdbet-ff-mac-scheduler.cc	2018-08-03 16:39:02.891957671 +0200
@@ -920,7 +920,7 @@
           NS_LOG_INFO ("Skip this flow, CQI==0, rnti:"<<(*itFlow).first);
         }
     }
- 
+
   if (estAveThr.size () != 0)
     {
       // Find UE with largest priority metric
@@ -938,7 +938,7 @@
 
       // The scheduler tries the best to achieve the equal throughput among all UEs
       int i = 0;
-      do 
+      do
         {
           NS_LOG_INFO (this << " ALLOCATION for RBG " << i << " of " << rbgNum);
           if (rbgMap.at (i) == false)
@@ -957,7 +957,7 @@
                   (*itMap).second.push_back (i);
                 }
 
-              // calculate expected throughput for current UE
+              // caculate expected throughput for current UE
               std::map <uint16_t,uint8_t>::iterator itCqi;
               itCqi = m_p10CqiRxed.find ((*itMax).first);
               std::map <uint16_t,uint8_t>::iterator itTxMode;
@@ -968,7 +968,7 @@
                 }
               int nLayer = TransmissionModesLayers::TxMode2LayerNum ((*itTxMode).second);
               std::vector <uint8_t> mcs;
-              for (uint8_t j = 0; j < nLayer; j++) 
+              for (uint8_t j = 0; j < nLayer; j++)
                 {
                   if (itCqi == m_p10CqiRxed.end ())
                     {
@@ -1015,7 +1015,7 @@
 
           i++;
 
-        } 
+        }
       while ( i < rbgNum ); // end for RBGs
 
     } // end if estAveThr
@@ -1991,7 +1991,7 @@
               // for SRB1 (using RLC AM) it's better to
               // overestimate RLC overhead rather than
               // underestimate it and risk unneeded
-              // segmentation which increases delay 
+              // segmentation which increases delay
               rlcOverhead = 4;
             }
           else
diff -Naru a/model/fdmt-ff-mac-scheduler.cc b/model/fdmt-ff-mac-scheduler.cc
--- a/model/fdmt-ff-mac-scheduler.cc	2018-08-03 16:38:46.663806898 +0200
+++ b/model/fdmt-ff-mac-scheduler.cc	2018-08-03 16:39:02.891957671 +0200
@@ -243,7 +243,7 @@
 FdMtFfMacScheduler::DoCschedUeReleaseReq (const struct FfMacCschedSapProvider::CschedUeReleaseReqParameters& params)
 {
   NS_LOG_FUNCTION (this);
-  
+
   m_uesTxMode.erase (params.m_rnti);
   m_dlHarqCurrentProcessId.erase (params.m_rnti);
   m_dlHarqProcessesStatus.erase  (params.m_rnti);
@@ -445,7 +445,7 @@
           if ((*itTimers).second.at (i) == HARQ_DL_TIMEOUT)
             {
               // reset HARQ process
-              
+
               NS_LOG_DEBUG (this << " Reset HARQ proc " << i << " for RNTI " << (*itTimers).first);
               std::map <uint16_t, DlHarqProcessesStatus_t>::iterator itStat = m_dlHarqProcessesStatus.find ((*itTimers).first);
               if (itStat == m_dlHarqProcessesStatus.end ())
@@ -461,7 +461,7 @@
             }
         }
     }
-  
+
 }
 
 
@@ -938,7 +938,7 @@
                         }
                     }
                 }   // end if cqi
-              
+
             } // end for m_rlcBufferReq
 
           if (itMax == m_flowStatsDl.end ())
@@ -1145,7 +1145,7 @@
   NS_LOG_FUNCTION (this);
 
   m_rachList = params.m_rachList;
-  
+
   return;
 }
 
@@ -1276,7 +1276,7 @@
     {
       //   Process UL HARQ feedback
       for (uint16_t i = 0; i < params.m_ulInfoList.size (); i++)
-        {        
+        {
           if (params.m_ulInfoList.at (i).m_receptionStatus == UlInfoListElement_s::NotOk)
             {
               // retx correspondent block: retrieve the UL-DCI
@@ -1366,7 +1366,7 @@
           m_allocationMaps.insert (std::pair <uint16_t, std::vector <uint16_t> > (params.m_sfnSf, rbgAllocationMap));
           m_schedSapUser->SchedUlConfigInd (ret);
         }
-        
+
       return;  // no flows to be scheduled
     }
 
@@ -1421,7 +1421,7 @@
           if (rbPerFlow < 3)
             {
               // terminate allocation
-              rbPerFlow = 0;      
+              rbPerFlow = 0;
             }
         }
 
@@ -1465,7 +1465,7 @@
               if (rbPerFlow < 3)
                 {
                   // terminate allocation
-                  rbPerFlow = 0;                 
+                  rbPerFlow = 0;
                 }
             }
         }
@@ -1639,7 +1639,7 @@
               uint8_t bsrId = params.m_macCeList.at (i).m_macCeValue.m_bufferStatus.at (lcg);
               buffer += BufferSizeLevelBsr::BsrId2BufferSize (bsrId);
             }
-          
+
           uint16_t rnti = params.m_macCeList.at (i).m_rnti;
           NS_LOG_LOGIC (this << "RNTI=" << rnti << " buffer=" << buffer);
           it = m_ceBsrRxed.find (rnti);
@@ -1917,8 +1917,8 @@
               // for SRB1 (using RLC AM) it's better to
               // overestimate RLC overhead rather than
               // underestimate it and risk unneeded
-              // segmentation which increases delay 
-              rlcOverhead = 4;                                  
+              // segmentation which increases delay
+              rlcOverhead = 4;
             }
           else
             {
@@ -1931,7 +1931,7 @@
               (*it).second.m_rlcTransmissionQueueSize = 0;
             }
           else
-            {                    
+            {
               (*it).second.m_rlcTransmissionQueueSize -= size - rlcOverhead;
             }
         }
diff -Naru a/model/fdtbfq-ff-mac-scheduler.cc b/model/fdtbfq-ff-mac-scheduler.cc
--- a/model/fdtbfq-ff-mac-scheduler.cc	2018-08-03 16:38:46.663806898 +0200
+++ b/model/fdtbfq-ff-mac-scheduler.cc	2018-08-03 16:39:02.891957671 +0200
@@ -301,7 +301,7 @@
 FdTbfqFfMacScheduler::DoCschedUeReleaseReq (const struct FfMacCschedSapProvider::CschedUeReleaseReqParameters& params)
 {
   NS_LOG_FUNCTION (this);
-  
+
   m_uesTxMode.erase (params.m_rnti);
   m_dlHarqCurrentProcessId.erase (params.m_rnti);
   m_dlHarqProcessesStatus.erase  (params.m_rnti);
@@ -503,7 +503,7 @@
           if ((*itTimers).second.at (i) == HARQ_DL_TIMEOUT)
             {
               // reset HARQ process
-              
+
               NS_LOG_DEBUG (this << " Reset HARQ proc " << i << " for RNTI " << (*itTimers).first);
               std::map <uint16_t, DlHarqProcessesStatus_t>::iterator itStat = m_dlHarqProcessesStatus.find ((*itTimers).first);
               if (itStat == m_dlHarqProcessesStatus.end ())
@@ -519,7 +519,7 @@
             }
         }
     }
-  
+
 }
 
 
@@ -965,7 +965,7 @@
   std::map <uint16_t, fdtbfqsFlowPerf_t>::iterator itStats;
   for (itStats = m_flowStatsDl.begin (); itStats != m_flowStatsDl.end (); itStats++)
     {
-      if ( (*itStats).second.tokenGenerationRate / 1000 +  (*itStats).second.tokenPoolSize > (*itStats).second.maxTokenPoolSize )     
+      if ( (*itStats).second.tokenGenerationRate / 1000 +  (*itStats).second.tokenPoolSize > (*itStats).second.maxTokenPoolSize )
         {
           (*itStats).second.counter +=  (*itStats).second.tokenGenerationRate / 1000 - ( (*itStats).second.maxTokenPoolSize -  (*itStats).second.tokenPoolSize );
           (*itStats).second.tokenPoolSize = (*itStats).second.maxTokenPoolSize;
@@ -1048,9 +1048,9 @@
             {
               continue;
             }
-  
+
           double metric = ( ( (double)(*it).second.counter ) / ( (double)(*it).second.tokenGenerationRate ) );
-  
+
           if (firstRnti == true)
            {
              metricMax = metric;
@@ -1062,9 +1062,9 @@
           {
             metricMax = metric;
             itMax = it;
-          } 
+          }
        } // end for m_flowStatsDl
-  
+
       if (itMax == m_flowStatsDl.end())
         {
           // all UEs are allocated RBG or all UEs already allocated for HARQ or without HARQ process available
@@ -1092,8 +1092,8 @@
           // there are no tokens for this UE
           continue;
         }
-      else 
-        {	
+      else
+        {
           // calculate rlc buffer size
           uint32_t rlcBufSize = 0;
           uint8_t lcid = 0;
@@ -1111,7 +1111,7 @@
             budget = rlcBufSize;
         }
 
-      // assign RBGs to this UE 
+      // assign RBGs to this UE
       uint32_t bytesTxed = 0;
       uint32_t bytesTxedTmp = 0;
       int rbgIndex = 0;
@@ -1170,11 +1170,11 @@
                     {
                       // this UE has data to transmit
 	              double achievableRate = 0.0;
-                      for (uint8_t j = 0; j < nLayer; j++) 
+                      for (uint8_t j = 0; j < nLayer; j++)
                         {
-                          uint8_t mcs = 0; 
+                          uint8_t mcs = 0;
                           if (sbCqi.size () > j)
-                            {                       
+                            {
                               mcs = m_amc->GetMcsFromCqi (sbCqi.at (j));
                             }
                           else
@@ -1223,7 +1223,7 @@
               (*itMap).second.push_back (rbgIndex);
             }
           rbgMap.at (rbgIndex) = true;  // Mark this RBG as allocated
- 
+
           RbgPerRnti = (*itMap).second.size();
 
           // calculate tb size
@@ -1234,7 +1234,7 @@
                 {
                   if ((*itCqi).second.m_higherLayerSelected.size () > (*itMap).second.at (k))
                     {
-                      for (uint8_t j = 0; j < nLayer; j++) 
+                      for (uint8_t j = 0; j < nLayer; j++)
                         {
                           if ((*itCqi).second.m_higherLayerSelected.at ((*itMap).second.at (k)).m_sbCqi.size () > j)
                             {
@@ -1266,12 +1266,12 @@
                   worstCqi.at (j) = 1; // try with lowest MCS in RBG with no info on channel
                 }
             }
- 
+
           bytesTxedTmp = bytesTxed;
           bytesTxed = 0;
           for (uint8_t j = 0; j < nLayer; j++)
             {
-              int tbSize = (m_amc->GetDlTbSizeFromMcs (m_amc->GetMcsFromCqi (worstCqi.at (j)), RbgPerRnti * rbgSize) / 8); // (size of TB in bytes according to table 7.1.7.2.1-1 of 36.213) 
+              int tbSize = (m_amc->GetDlTbSizeFromMcs (m_amc->GetMcsFromCqi (worstCqi.at (j)), RbgPerRnti * rbgSize) / 8); // (size of TB in bytes according to table 7.1.7.2.1-1 of 36.213)
               bytesTxed += tbSize;
             }
 
@@ -1300,7 +1300,7 @@
           (*itMax).second.tokenPoolSize = 0;
           if (bankSize <= ( bytesTxed -  (*itMax).second.tokenPoolSize ))
             bankSize = 0;
-          else 
+          else
             bankSize = bankSize - ( bytesTxed -  (*itMax).second.tokenPoolSize );
         }
     } // end of RBGs
@@ -1483,7 +1483,7 @@
   NS_LOG_FUNCTION (this);
 
   m_rachList = params.m_rachList;
-  
+
   return;
 }
 
@@ -1630,7 +1630,7 @@
     {
       //   Process UL HARQ feedback
       for (uint16_t i = 0; i < params.m_ulInfoList.size (); i++)
-        {        
+        {
           if (params.m_ulInfoList.at (i).m_receptionStatus == UlInfoListElement_s::NotOk)
             {
               // retx correspondent block: retrieve the UL-DCI
@@ -1720,7 +1720,7 @@
           m_allocationMaps.insert (std::pair <uint16_t, std::vector <uint16_t> > (params.m_sfnSf, rbgAllocationMap));
           m_schedSapUser->SchedUlConfigInd (ret);
         }
-        
+
       return;  // no flows to be scheduled
     }
 
@@ -1778,7 +1778,7 @@
           if (rbPerFlow < 3)
             {
               // terminate allocation
-              rbPerFlow = 0;      
+              rbPerFlow = 0;
             }
         }
 
@@ -1829,7 +1829,7 @@
               if (rbPerFlow < 3)
                 {
                   // terminate allocation
-                  rbPerFlow = 0;                 
+                  rbPerFlow = 0;
                 }
             }
         }
@@ -2003,7 +2003,7 @@
               uint8_t bsrId = params.m_macCeList.at (i).m_macCeValue.m_bufferStatus.at (lcg);
               buffer += BufferSizeLevelBsr::BsrId2BufferSize (bsrId);
             }
-          
+
           uint16_t rnti = params.m_macCeList.at (i).m_rnti;
           NS_LOG_LOGIC (this << "RNTI=" << rnti << " buffer=" << buffer);
           it = m_ceBsrRxed.find (rnti);
@@ -2281,8 +2281,8 @@
               // for SRB1 (using RLC AM) it's better to
               // overestimate RLC overhead rather than
               // underestimate it and risk unneeded
-              // segmentation which increases delay 
-              rlcOverhead = 4;                                  
+              // segmentation which increases delay
+              rlcOverhead = 4;
             }
           else
             {
@@ -2295,7 +2295,7 @@
               (*it).second.m_rlcTransmissionQueueSize = 0;
             }
           else
-            {                    
+            {
               (*it).second.m_rlcTransmissionQueueSize -= size - rlcOverhead;
             }
         }
diff -Naru a/model/lte-amc.cc b/model/lte-amc.cc
--- a/model/lte-amc.cc	2018-08-03 16:38:46.663806898 +0200
+++ b/model/lte-amc.cc	2018-08-03 16:39:02.891957671 +0200
@@ -62,7 +62,7 @@
  * - in R1-081483, a valid MCS index is in the range of 1-30 (not 0-28).
  */
 static const int ModulationSchemeForMcs[32] = {
-  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
+  2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
   4, 4, 4, 4, 4, 4, 4,
   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
   2,  // reserved
@@ -236,7 +236,7 @@
 
 
 LteAmc::~LteAmc ()
-{ 
+{
 }
 
 TypeId
@@ -333,7 +333,7 @@
 
   std::vector<int> cqi;
   Values::const_iterator it;
-  
+
   if (m_amcModel == PiroEW2010)
     {
 
@@ -390,7 +390,7 @@
                     break;
                   }
                 mcs++;
-                
+
               }
             if (mcs > 0)
               {
@@ -423,9 +423,9 @@
               }
             rbgMap.clear ();
          }
-        
+
       }
-      
+
     }
 
   return cqi;
diff -Naru a/model/lte-amc.h b/model/lte-amc.h
--- a/model/lte-amc.h	2018-08-03 16:38:46.663806898 +0200
+++ b/model/lte-amc.h	2018-08-03 16:39:02.891957671 +0200
@@ -46,10 +46,10 @@
    * \return the object TypeId
    */
   static TypeId GetTypeId (void);
-  
+
   LteAmc ();
   virtual ~LteAmc();
-  
+
   /// Types of AMC model.
   enum AmcModel
     {
@@ -66,7 +66,7 @@
        */
       MiErrorModel
     };
-  
+
   /**
    * \brief Get the Modulation and Coding Scheme for
    * a CQI value
@@ -116,9 +116,9 @@
    * \return the CQI value
    */
   int GetCqiFromSpectralEfficiency (double s);
-  
+
 private:
-  
+
   /**
    * The `Ber` attribute.
    *
diff -Naru a/model/lte-asn1-header.cc b/model/lte-asn1-header.cc
--- a/model/lte-asn1-header.cc	2018-08-03 16:38:46.663806898 +0200
+++ b/model/lte-asn1-header.cc	2018-08-03 16:39:02.891957671 +0200
@@ -309,7 +309,7 @@
     // Never extended attributes
     SerializeBoolean(false);
   }
-  
+
   // Clause 23.4 ITU-T X.691
   if (numOptions < 2)
     {
@@ -321,8 +321,13 @@
 
 void Asn1Header::SerializeInteger (int n, int nmin, int nmax) const
 {
-  NS_ASSERT_MSG (nmin <= n && n <= nmax,
-                 "Integer " << n << " is outside range [" << nmin << ", " << nmax << "]");
+  // Misusage check: Ensure nmax>nmin ...
+  if (nmin > nmax)
+    {
+      int aux = nmin;
+      nmin = nmax;
+      nmax = aux;
+    }
 
   // Clause 11.5.3 ITU-T X.691
   int range = nmax - nmin + 1;
@@ -577,15 +582,15 @@
       bIterator = DeserializeBitset<1> (&bitsRead1,bIterator);
       *n = (int)bitsRead1.to_ulong ();
       break;
-    case 2: 
+    case 2:
       bIterator = DeserializeBitset<2> (&bitsRead2,bIterator);
       *n = (int)bitsRead2.to_ulong ();
       break;
-    case 3: 
+    case 3:
       bIterator = DeserializeBitset<3> (&bitsRead3,bIterator);
       *n = (int)bitsRead3.to_ulong ();
       break;
-    case 4: 
+    case 4:
       bIterator = DeserializeBitset<4> (&bitsRead4,bIterator);
       *n = (int)bitsRead4.to_ulong ();
       break;
diff -Naru a/model/lte-as-sap.h b/model/lte-as-sap.h
--- a/model/lte-as-sap.h	2018-08-03 16:38:46.663806898 +0200
+++ b/model/lte-as-sap.h	2018-08-03 16:39:02.891957671 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -25,6 +29,7 @@
 #include <stdint.h>
 #include <ns3/ptr.h>
 #include <ns3/packet.h>
+#include <ns3/lte-rrc-sap.h>
 
 namespace ns3 {
 
@@ -36,7 +41,7 @@
  * In particular, this class implements the
  * Provider part of the SAP, i.e., the methods exported by the
  * LteUeRrc and called by the EpcUeNas.
- * 
+ *
  */
 class LteAsSapProvider
 {
@@ -58,7 +63,7 @@
    */
   virtual void StartCellSelection (uint32_t dlEarfcn) = 0;
 
-  /** 
+  /**
    * \brief Force the RRC entity to stay camped on a certain eNodeB.
    *
    * \param cellId the cell ID identifying the eNodeB
@@ -76,7 +81,7 @@
    */
   virtual void Connect (void) = 0;
 
-  /** 
+  /**
    * \brief Send a data packet.
    *
    * \param packet the packet
@@ -85,50 +90,73 @@
   virtual void SendData (Ptr<Packet> packet, uint8_t bid) = 0;
 
 
-  /** 
+  /**
    * \brief Tell the RRC entity to release the connection.
    *
    */
   virtual void Disconnect () = 0;
 
+  /**
+   * \brief Tell the RRC that a secondary cell was connected
+   *
+   */
+  virtual void NotifySecondaryCellConnected (uint16_t rnti, uint16_t mmWaveCellId) = 0;
+
+  /**
+   * \brief Tell the LTE RRC in the UE that a secondary cell handover was performed,
+   * and trigger the RLC instances update
+   *
+   */
+  virtual void NotifySecondaryCellHandover (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated) = 0;
+
 };
 
 
 /**
  * This class implements the Access Stratum (AS) Service Access Point
  * (SAP), i.e., the interface between the EpcUeNas and the LteUeRrc
- * In particular, this class implements the 
+ * In particular, this class implements the
  * User part of the SAP, i.e., the methods exported by the
  * EpcUeNas and called by the LteUeRrc.
- * 
+ *
  */
 class LteAsSapUser
 {
 public:
   virtual ~LteAsSapUser ();
 
-  /** 
+  /**
    * \brief Notify the NAS that RRC Connection Establishment was successful.
-   * 
+   *
+   */
+  virtual void NotifyConnectionSuccessful (uint16_t rnti) = 0;
+
+  virtual void NotifyHandoverSuccessful (uint16_t rnti, uint16_t mmWaveCellId) = 0;
+
+  virtual void NotifySecondaryCellHandoverStarted (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated) = 0;
+
+  /**
+   * \brief Notify the NAS that LTE RRC received an indication to connect to a MmWave eNB
+   *
    */
-  virtual void NotifyConnectionSuccessful () = 0;
+  virtual void NotifyConnectToMmWave (uint16_t mmWaveCellId) = 0;
 
-  /** 
+  /**
    * \brief Notify the NAS that RRC Connection Establishment failed.
-   * 
+   *
    */
   virtual void NotifyConnectionFailed () = 0;
 
 
-  /** 
+  /**
    * Notify the NAS that RRC Connection was released
-   * 
+   *
    */
   virtual void NotifyConnectionReleased () = 0;
 
-  /** 
+  /**
    * receive a data packet
-   * 
+   *
    * \param packet the packet
    */
   virtual void RecvData (Ptr<Packet> packet) = 0;
@@ -141,7 +169,7 @@
 /**
  * Template for the implementation of the LteAsSapProvider as a member
  * of an owner class of type C to which all methods are forwarded
- * 
+ *
  */
 template <class C>
 class MemberLteAsSapProvider : public LteAsSapProvider
@@ -161,6 +189,8 @@
   virtual void Connect (void);
   virtual void SendData (Ptr<Packet> packet, uint8_t bid);
   virtual void Disconnect ();
+  virtual void NotifySecondaryCellConnected (uint16_t rnti, uint16_t mmWaveCellId);
+  virtual void NotifySecondaryCellHandover (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated);
 
 private:
   MemberLteAsSapProvider ();
@@ -200,7 +230,7 @@
 }
 
 template <class C>
-void 
+void
 MemberLteAsSapProvider<C>::Connect ()
 {
   m_owner->DoConnect ();
@@ -214,17 +244,31 @@
 }
 
 template <class C>
-void 
+void
 MemberLteAsSapProvider<C>::Disconnect ()
 {
   m_owner->DoDisconnect ();
 }
 
+template <class C>
+void
+MemberLteAsSapProvider<C>::NotifySecondaryCellConnected (uint16_t rnti, uint16_t mmWaveCellId)
+{
+  m_owner->DoNotifySecondaryCellConnected (rnti, mmWaveCellId);
+}
+
+template <class C>
+void
+MemberLteAsSapProvider<C>::NotifySecondaryCellHandover (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated)
+{
+  m_owner->DoNotifySecondaryCellHandover (oldRnti, newRnti, mmWaveCellId, radioResourceConfigDedicated);
+}
+
 
 /**
  * Template for the implementation of the LteAsSapUser as a member
  * of an owner class of type C to which all methods are forwarded
- * 
+ *
  */
 template <class C>
 class MemberLteAsSapUser : public LteAsSapUser
@@ -238,10 +282,13 @@
   MemberLteAsSapUser (C* owner);
 
   // inherited from LteAsSapUser
-  virtual void NotifyConnectionSuccessful ();
+  virtual void NotifyConnectionSuccessful (uint16_t rnti);
+  virtual void NotifyHandoverSuccessful (uint16_t rnti, uint16_t mmWaveCellId);
+  virtual void NotifyConnectToMmWave (uint16_t mmWaveCellId);
   virtual void NotifyConnectionFailed ();
   virtual void RecvData (Ptr<Packet> packet);
   virtual void NotifyConnectionReleased ();
+  virtual void NotifySecondaryCellHandoverStarted (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated);
 
 private:
   MemberLteAsSapUser ();
@@ -260,34 +307,55 @@
 }
 
 template <class C>
-void 
-MemberLteAsSapUser<C>::NotifyConnectionSuccessful ()
+void
+MemberLteAsSapUser<C>::NotifyConnectionSuccessful (uint16_t rnti)
 {
-  m_owner->DoNotifyConnectionSuccessful ();
+  m_owner->DoNotifyConnectionSuccessful (rnti);
 }
 
 template <class C>
-void 
+void
+MemberLteAsSapUser<C>::NotifyHandoverSuccessful (uint16_t rnti, uint16_t mmWaveCellId)
+{
+  m_owner->DoNotifyHandoverSuccessful (rnti, mmWaveCellId);
+}
+
+template <class C>
+void
+MemberLteAsSapUser<C>::NotifyConnectToMmWave (uint16_t mmWaveCellId)
+{
+  m_owner->DoNotifyConnectToMmWave (mmWaveCellId);
+}
+
+template <class C>
+void
 MemberLteAsSapUser<C>::NotifyConnectionFailed ()
 {
   m_owner->DoNotifyConnectionFailed ();
 }
 
 template <class C>
-void 
+void
 MemberLteAsSapUser<C>::RecvData (Ptr<Packet> packet)
 {
   m_owner->DoRecvData (packet);
 }
 
 template <class C>
-void 
+void
 MemberLteAsSapUser<C>::NotifyConnectionReleased ()
 {
   m_owner->DoNotifyConnectionReleased ();
 }
 
 
+template <class C>
+void
+MemberLteAsSapUser<C>::NotifySecondaryCellHandoverStarted (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated)
+{
+  m_owner->DoNotifySecondaryCellHandoverStarted (oldRnti, newRnti, mmWaveCellId, radioResourceConfigDedicated);
+}
+
 } // namespace ns3
 
 #endif // LTE_AS_SAP_H
diff -Naru a/model/lte-ccm-rrc-sap.h b/model/lte-ccm-rrc-sap.h
--- a/model/lte-ccm-rrc-sap.h	2018-08-03 16:38:46.663806898 +0200
+++ b/model/lte-ccm-rrc-sap.h	2018-08-03 16:39:02.891957671 +0200
@@ -131,6 +131,7 @@
 
   /**
    * \brief Add the Signal Bearer for a specific Ue in LteEnbComponenCarrierManager
+   * \brief Add the Signal Bearer for a specific Ue in LteEnbComponenCarrierManager
    * \param lcInfo this structure it is hard-coded in the LteEnbRrc
    * \param rlcMacSapUser it is the MacSapUser of the Rlc istance
    * \return the LteMacSapUser of the ComponentCarrierManager
diff -Naru a/model/lte-common.h b/model/lte-common.h
--- a/model/lte-common.h	2018-08-03 16:38:46.663806898 +0200
+++ b/model/lte-common.h	2018-08-03 16:39:02.891957671 +0200
@@ -73,7 +73,7 @@
 };
 
 /**
-* \brief Parameters for configuring the UE 
+* \brief Parameters for configuring the UE
 */
 struct LteUeConfig_t
 {
@@ -122,7 +122,7 @@
 public:
   /**
    * Convert from double to fixed point S11.3 notation
-   * 
+   *
    * \param val double value
    * \returns fixed point S11.3 value
    */
@@ -132,7 +132,7 @@
    *
    * \param val fixed point S11.3 value
    * \returns double value
-   */ 
+   */
   static double fpS11dot3toDouble (uint16_t val);
   /**
    * Get minimum fixed point S11.3 value
@@ -204,7 +204,7 @@
    * \todo The argument should be passed by const reference, since it's large.
    */
   typedef void (* TracedCallback)(const PhyTransmissionStatParameters params);
-  
+
 };
 
 
@@ -231,7 +231,7 @@
    * \todo The argument should be passed by const reference, since it's large.
    */
   typedef void (* TracedCallback)(const PhyReceptionStatParameters params);
-  
+
 };
 
 
@@ -246,70 +246,70 @@
   uint8_t  mcsTb2; ///< MCS TB2
   uint16_t sizeTb2; ///< size TB2
   uint8_t  componentCarrierId; ///< component carrier ID
-}; 
+};
 
 /**
  * Implements the E-UTRA measurement mappings defined in  3GPP TS
- * 36.133 section 9.1 E-UTRAN measurements 
- * 
+ * 36.133 section 9.1 E-UTRAN measurements
+ *
  */
 class EutranMeasurementMapping
 {
 public:
-  /** 
-   * converts an RSRP range to dBm as per 
+  /**
+   * converts an RSRP range to dBm as per
    * 3GPP TS 36.133 section 9.1.4 RSRP Measurement Report Mapping
    *
    * \param range the RSRP range value
-   * 
+   *
    * \return the corresponding RSRP value in dBm
    */
   static double RsrpRange2Dbm (uint8_t range);
 
-  /** 
-   * convert an RSRP value in dBm to the corresponding range as per 
+  /**
+   * convert an RSRP value in dBm to the corresponding range as per
    * 3GPP TS 36.133 section 9.1.4 RSRP Measurement Report Mapping
-   * 
+   *
    * \param dbm the RSRP value in dBm
-   * 
+   *
    * \return the corresponding range
    */
   static uint8_t Dbm2RsrpRange (double dbm);
 
-  /** 
-   * converts an RSRQ range to dB as per 
+  /**
+   * converts an RSRQ range to dB as per
    * 3GPP TS 36.133 section 9.1.7 RSRQ Measurement Report Mapping
    *
    * \param range the RSRQ range value
-   * 
+   *
    * \return the corresponding RSRQ value in dB
    */
   static double RsrqRange2Db (uint8_t range);
 
-  /** 
-   * convert an RSRQ value in dB to the corresponding range as per 
+  /**
+   * convert an RSRQ value in dB to the corresponding range as per
    * 3GPP TS 36.133 section 9.1.7 RSRQ Measurement Report Mapping
-   * 
+   *
    * \param db the RSRQ value in dB
-   * 
+   *
    * \return the corresponding range
    */
   static uint8_t Db2RsrqRange (double db);
 
-  /** 
+  /**
    * Quantize an RSRP value according to the measurement mapping of TS 36.133
-   * 
+   *
    * \param v RSRP value in dBm
-   * 
+   *
    * \return the quantized RSRP value in dBm
    */
   static double QuantizeRsrp (double v);
 
-  /** 
+  /**
    * Quantize an RSRQ value according to the measurement mapping of TS 36.133
-   * 
+   *
    * \param v RSRQ value in dB
-   * 
+   *
    * \return the quantized RSRQ value in dB
    */
   static double QuantizeRsrq (double v);
diff -Naru a/model/lte-enb-cmac-sap.h b/model/lte-enb-cmac-sap.h
--- a/model/lte-enb-cmac-sap.h	2018-08-03 16:38:46.663806898 +0200
+++ b/model/lte-enb-cmac-sap.h	2018-08-03 16:39:02.891957671 +0200
@@ -54,14 +54,14 @@
   /**
    * Add UE function
    *
-   * \param rnti 
+   * \param rnti
    */
   virtual void AddUe (uint16_t rnti) = 0;
 
-  /** 
+  /**
    * remove the UE, e.g., after handover or termination of the RRC connection
-   * 
-   * \param rnti 
+   *
+   * \param rnti
    */
   virtual void RemoveUe (uint16_t rnti) = 0;
 
@@ -106,9 +106,9 @@
    * \param lcid
    */
   virtual void ReleaseLc (uint16_t rnti, uint8_t lcid) = 0;
-  
+
   /**
-   * \brief Parameters for [re]configuring the UE 
+   * \brief Parameters for [re]configuring the UE
    */
   struct UeConfig
   {
@@ -122,17 +122,17 @@
     uint8_t   m_transmissionMode;
   };
 
-  /** 
+  /**
    * update the configuration of the UE
-   * 
-   * \param params 
+   *
+   * \param params
    */
   virtual void UeUpdateConfigurationReq (UeConfig params) = 0;
 
 
   /**
    * struct defining the RACH configuration of the MAC
-   * 
+   *
    */
   struct RachConfig
   {
@@ -141,15 +141,15 @@
     uint8_t raResponseWindowSize; ///< RA response window size
   };
 
-  /** 
-   * 
+  /**
+   *
    * \return the current RACH configuration of the MAC
    */
   virtual RachConfig GetRachConfig () = 0;
 
   /**
    * \brief AllocateNcRaPreambleReturnValue structure
-   * 
+   *
    */
   struct AllocateNcRaPreambleReturnValue
   {
@@ -158,12 +158,12 @@
     uint8_t raPrachMaskIndex; ///< PRACH mask index
   };
 
-  /** 
+  /**
    * Allocate a random access preamble for non-contention based random access (e.g., for handover).
-   * 
+   *
    * \param rnti the RNTI of the UE who will perform non-contention based random access
-   * 
-   * \return  the newly allocated random access preamble 
+   *
+   * \return  the newly allocated random access preamble
    */
   virtual AllocateNcRaPreambleReturnValue AllocateNcRaPreamble (uint16_t rnti) = 0;
 
@@ -182,8 +182,8 @@
 public:
   virtual ~LteEnbCmacSapUser ();
 
-  /** 
-   * request the allocation of a Temporary C-RNTI 
+  /**
+   * request the allocation of a Temporary C-RNTI
    *
    * \return the T-C-RNTI
    */
@@ -199,7 +199,7 @@
   virtual void NotifyLcConfigResult (uint16_t rnti, uint8_t lcid, bool success) = 0;
 
   /**
-   * \brief Parameters for [re]configuring the UE 
+   * \brief Parameters for [re]configuring the UE
    */
   struct UeConfig
   {
@@ -213,10 +213,10 @@
     uint8_t   m_transmissionMode;
   };
 
-  /** 
+  /**
    * Notify the RRC of a UE config updated requested by the MAC (normally, by the scheduler)
-   * 
-   * \param params 
+   *
+   * \param params
    */
   virtual void RrcConfigurationUpdateInd (UeConfig params) = 0;
 };
diff -Naru a/model/lte-enb-component-carrier-manager.cc b/model/lte-enb-component-carrier-manager.cc
--- a/model/lte-enb-component-carrier-manager.cc	2018-08-03 16:38:46.663806898 +0200
+++ b/model/lte-enb-component-carrier-manager.cc	2018-08-03 16:39:02.891957671 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2015 Danilo Abrignani
+ * Copyright (c) 2018, University of Padova, Dep. of Information Engineering, SIGNET lab.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,8 @@
  *
  * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
  *
+ * Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+ *								 Integration of Carrier Aggregation for the mmWave module
  */
 
 #include "lte-enb-component-carrier-manager.h"
@@ -80,7 +83,7 @@
   return m_ccmMacSapUser;
 }
 
-bool 
+bool
 LteEnbComponentCarrierManager::SetMacSapProvider (uint8_t componentCarrierId, LteMacSapProvider* sap)
 {
   NS_LOG_FUNCTION (this);
@@ -100,24 +103,24 @@
       res = true;
     }
   return res;
-  
+
 }
 
-bool 
+bool
 LteEnbComponentCarrierManager::SetCcmMacSapProviders (uint8_t componentCarrierId, LteCcmMacSapProvider* sap)
 {
   NS_LOG_FUNCTION (this);
   bool res = false;
   std::map< uint8_t,LteCcmMacSapProvider*>::iterator it =  m_ccmMacSapProviderMap.find (componentCarrierId);
-  
+
   if (it == m_ccmMacSapProviderMap.end ())
     {
       m_ccmMacSapProviderMap.insert (std::pair <uint8_t,LteCcmMacSapProvider*> (componentCarrierId, sap));
     }
- 
+
   res = true;
   return res;
-  
+
 }
 
 void
@@ -133,4 +136,10 @@
   m_rrc = rrc;
 }
 
+void
+LteEnbComponentCarrierManager::SetBandwidthMap (std::map<uint8_t, double> bandwidthMap)
+{
+  m_bandwidthMap = bandwidthMap;
+}
+
 } // end of namespace ns3
diff -Naru a/model/lte-enb-component-carrier-manager.h b/model/lte-enb-component-carrier-manager.h
--- a/model/lte-enb-component-carrier-manager.h	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-enb-component-carrier-manager.h	2018-08-03 16:39:02.891957671 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2015 Danilo Abrignani
+ * Copyright (c) 2018, University of Padova, Dep. of Information Engineering, SIGNET lab.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,8 @@
  *
  * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
  *
+ * Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+ *								 Integration of Carrier Aggregation for the mmWave module
  */
 
 #ifndef LTE_ENB_COMPONENT_CARRIER_MANAGER_H
@@ -108,7 +111,7 @@
    * received, or to notify CCM about PRB occupancy, and similar. Functions that are
    * specific for the communication between MAC and CCM.
    *
-   * \returns LteCcmMacSapUser* 
+   * \returns LteCcmMacSapUser*
    */
   virtual LteCcmMacSapUser* GetLteCcmMacSapUser ();
 
@@ -120,7 +123,7 @@
    * component carriers based on the logic implemented in the
    * specific component carrier manager.
    *
-   * \returns LteMacSapProvider* 
+   * \returns LteMacSapProvider*
    */
   virtual LteMacSapProvider* GetLteMacSapProvider ();
 
@@ -157,6 +160,8 @@
    */
   virtual void SetRrc (const Ptr<LteEnbRrc> rrc);
 
+  virtual void SetBandwidthMap (std::map<uint8_t, double> bandwidthMap);
+
 protected:
 
   // inherited from Object
@@ -207,6 +212,7 @@
   LteCcmRrcSapUser* m_ccmRrcSapUser; //!< A pointer to SAP interface of RRC instance, i.e. to configure measurements reporting for CCM.
   LteCcmRrcSapProvider* m_ccmRrcSapProvider; //!< A pointer to the SAP interface of the CCM instance to receive API calls from the eNodeB RRC instance.
 
+  std::map<uint8_t, double> m_bandwidthMap;
 }; // end of class LteEnbComponentCarrierManager
 
 
diff -Naru a/model/lte-enb-cphy-sap.h b/model/lte-enb-cphy-sap.h
--- a/model/lte-enb-cphy-sap.h	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-enb-cphy-sap.h	2018-08-03 16:39:02.891957671 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011, 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,12 +18,16 @@
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>,
  *         Marco Miozzo <mmiozzo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_ENB_CPHY_SAP_H
 #define LTE_ENB_CPHY_SAP_H
 
 #include <stdint.h>
+#include <map>
 #include <ns3/ptr.h>
 
 #include <ns3/lte-rrc-sap.h>
@@ -41,14 +46,14 @@
 {
 public:
 
-  /** 
+  /**
    * destructor
    */
   virtual ~LteEnbCphySapProvider ();
 
-  /** 
-   * 
-   * 
+  /**
+   *
+   *
    * \param cellId the Cell Identifier
    */
   virtual void SetCellId (uint16_t cellId) = 0;
@@ -64,21 +69,21 @@
    * \param dlEarfcn the DL EARFCN
    */
   virtual void SetEarfcn (uint32_t ulEarfcn, uint32_t dlEarfcn) = 0;
-  
-  /** 
+
+  /**
    * Add a new UE to the cell
-   * 
+   *
    * \param rnti the UE id relative to this cell
    */
   virtual void AddUe (uint16_t rnti) = 0;
 
-  /** 
-   * Remove an UE from the cell
-   * 
+  /**
+  * Remove an UE from the cell
+   *
    * \param rnti the UE id relative to this cell
    */
   virtual void RemoveUe (uint16_t rnti) = 0;
-  
+
   /**
    * Set the UE transmission power offset P_A
    *
@@ -99,8 +104,8 @@
    */
   virtual void SetSrsConfigurationIndex (uint16_t rnti, uint16_t srsCi) = 0;
 
-  /** 
-   * 
+  /**
+   *
    * \param mib the Master Information Block to be sent on the BCH
    */
   virtual void SetMasterInformationBlock (LteRrcSap::MasterInformationBlock mib) = 0;
@@ -128,19 +133,27 @@
 class LteEnbCphySapUser
 {
 public:
-  
-  /** 
+
+  /**
    * destructor
    */
   virtual ~LteEnbCphySapUser ();
 
+  struct UeAssociatedSinrInfo
+  {
+    uint8_t componentCarrierId;
+    std::map<uint64_t, double> ueImsiSinrMap;
+  };
+
+  virtual void UpdateUeSinrEstimate(LteEnbCphySapUser::UeAssociatedSinrInfo info) = 0;
+
 };
 
 
 /**
  * Template for the implementation of the LteEnbCphySapProvider as a member
  * of an owner class of type C to which all methods are forwarded
- * 
+ *
  */
 template <class C>
 class MemberLteEnbCphySapProvider : public LteEnbCphySapProvider
@@ -165,7 +178,7 @@
   virtual void SetMasterInformationBlock (LteRrcSap::MasterInformationBlock mib);
   virtual void SetSystemInformationBlockType1 (LteRrcSap::SystemInformationBlockType1 sib1);
   virtual int8_t GetReferenceSignalPower ();
-  
+
 private:
   MemberLteEnbCphySapProvider ();
   C* m_owner; ///< the owner class
@@ -183,7 +196,7 @@
 }
 
 template <class C>
-void 
+void
 MemberLteEnbCphySapProvider<C>::SetCellId (uint16_t cellId)
 {
   m_owner->DoSetCellId (cellId);
@@ -191,35 +204,35 @@
 
 
 template <class C>
-void 
+void
 MemberLteEnbCphySapProvider<C>::SetBandwidth (uint8_t ulBandwidth, uint8_t dlBandwidth)
 {
   m_owner->DoSetBandwidth (ulBandwidth, dlBandwidth);
 }
 
 template <class C>
-void 
+void
 MemberLteEnbCphySapProvider<C>::SetEarfcn (uint32_t ulEarfcn, uint32_t dlEarfcn)
 {
   m_owner->DoSetEarfcn (ulEarfcn, dlEarfcn);
 }
 
 template <class C>
-void 
+void
 MemberLteEnbCphySapProvider<C>::AddUe (uint16_t rnti)
 {
   m_owner->DoAddUe (rnti);
 }
 
 template <class C>
-void 
+void
 MemberLteEnbCphySapProvider<C>::RemoveUe (uint16_t rnti)
 {
   m_owner->DoRemoveUe (rnti);
 }
 
 template <class C>
-void 
+void
 MemberLteEnbCphySapProvider<C>::SetPa (uint16_t rnti, double pa)
 {
   m_owner->DoSetPa (rnti, pa);
@@ -233,14 +246,14 @@
 }
 
 template <class C>
-void 
+void
 MemberLteEnbCphySapProvider<C>::SetSrsConfigurationIndex (uint16_t  rnti, uint16_t srsCi)
 {
   m_owner->DoSetSrsConfigurationIndex (rnti, srsCi);
 }
 
-template <class C> 
-void 
+template <class C>
+void
 MemberLteEnbCphySapProvider<C>::SetMasterInformationBlock (LteRrcSap::MasterInformationBlock mib)
 {
   m_owner->DoSetMasterInformationBlock (mib);
@@ -263,7 +276,7 @@
 /**
  * Template for the implementation of the LteEnbCphySapUser as a member
  * of an owner class of type C to which all methods are forwarded
- * 
+ *
  */
 template <class C>
 class MemberLteEnbCphySapUser : public LteEnbCphySapUser
@@ -275,6 +288,7 @@
    * \param owner the owner class
    */
   MemberLteEnbCphySapUser (C* owner);
+  virtual void UpdateUeSinrEstimate(UeAssociatedSinrInfo info);
 
   // methods inherited from LteEnbCphySapUser go here
 
@@ -294,6 +308,12 @@
 {
 }
 
+template <class C>
+void
+MemberLteEnbCphySapUser<C>::UpdateUeSinrEstimate(UeAssociatedSinrInfo info)
+{
+  return m_owner->DoUpdateUeSinrEstimate(info);
+}
 
 
 
diff -Naru a/model/lte-enb-mac.cc b/model/lte-enb-mac.cc
--- a/model/lte-enb-mac.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-enb-mac.cc	2018-08-03 16:39:02.891957671 +0200
@@ -1,7 +1,8 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
- *
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation;
@@ -20,6 +21,8 @@
  * Modified by:
  *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
  *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -76,7 +79,7 @@
   virtual void UeUpdateConfigurationReq (UeConfig params);
   virtual RachConfig GetRachConfig ();
   virtual AllocateNcRaPreambleReturnValue AllocateNcRaPreamble (uint16_t rnti);
-  
+
 
 private:
   LteEnbMac* m_mac; ///< the MAC
@@ -130,13 +133,13 @@
   m_mac->DoUeUpdateConfigurationReq (params);
 }
 
-LteEnbCmacSapProvider::RachConfig 
+LteEnbCmacSapProvider::RachConfig
 EnbMacMemberLteEnbCmacSapProvider::GetRachConfig ()
 {
   return m_mac->DoGetRachConfig ();
 }
- 
-LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue 
+
+LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue
 EnbMacMemberLteEnbCmacSapProvider::AllocateNcRaPreamble (uint16_t rnti)
 {
   return m_mac->DoAllocateNcRaPreamble (rnti);
@@ -149,7 +152,7 @@
 public:
   /**
    * Constructor
-   * 
+   *
    * \param mac the MAC
    */
   EnbMacMemberFfMacSchedSapUser (LteEnbMac* mac);
@@ -508,6 +511,12 @@
     {
       FfMacSchedSapProvider::SchedDlCqiInfoReqParameters dlcqiInfoReq;
       dlcqiInfoReq.m_sfnSf = ((0x3FF & frameNo) << 4) | (0xF & subframeNo);
+
+      int cqiNum = m_dlCqiReceived.size ();
+      if (cqiNum > MAX_CQI_LIST)
+        {
+          cqiNum = MAX_CQI_LIST;
+        }
       dlcqiInfoReq.m_cqiList.insert (dlcqiInfoReq.m_cqiList.begin (), m_dlCqiReceived.begin (), m_dlCqiReceived.end ());
       m_dlCqiReceived.erase (m_dlCqiReceived.begin (), m_dlCqiReceived.end ());
       m_schedSapProvider->SchedDlCqiInfoReq (dlcqiInfoReq);
@@ -528,7 +537,7 @@
             {
               NS_LOG_INFO ("preambleId " << (uint32_t) it->first << ": collision");
               // in case of collision we assume that no preamble is
-              // successfully received, hence no RAR is sent 
+              // successfully received, hence no RAR is sent
             }
           else
             {
@@ -538,7 +547,6 @@
                 {
                   rnti = jt->second.rnti;
                   NS_LOG_INFO ("preambleId previously allocated for NC based RA, RNTI =" << (uint32_t) rnti << ", sending RAR");
-                  
                 }
               else
                 {
@@ -585,10 +593,11 @@
 
   // --- UPLINK ---
   // Send UL-CQI info to the scheduler
+
   for (uint16_t i = 0; i < m_ulCqiReceived.size (); i++)
     {
       if (subframeNo > 1)
-        {        
+        {
           m_ulCqiReceived.at (i).m_sfnSf = ((0x3FF & frameNo) << 4) | (0xF & (subframeNo - 1));
         }
       else
@@ -598,7 +607,7 @@
       m_schedSapProvider->SchedUlCqiInfoReq (m_ulCqiReceived.at (i));
     }
     m_ulCqiReceived.clear ();
-  
+
   // Send BSR reports to the scheduler
   if (m_ulCeReceived.size () > 0)
     {
@@ -674,7 +683,7 @@
 
 void
 LteEnbMac::DoUlCqiReport (FfMacSchedSapProvider::SchedUlCqiInfoReqParameters ulcqi)
-{ 
+{
   if (ulcqi.m_ulCqi.m_type == UlCqi_s::PUSCH)
     {
       NS_LOG_DEBUG (this << " eNB rxed an PUSCH UL-CQI");
@@ -743,7 +752,7 @@
 //       ulinfonew.m_receptionStatus = UlInfoListElement_s::Ok;
 //       ulinfonew.m_tpc = 0; // Tx power control not implemented at this stage
 //       m_ulInfoListElements.insert (std::pair<uint16_t, UlInfoListElement_s > (tag.GetRnti (), ulinfonew));
-// 
+//
 //     }
 //   else
 //     {
@@ -797,8 +806,8 @@
 {
   NS_LOG_FUNCTION (this << " rnti=" << rnti);
   std::map<uint8_t, LteMacSapUser*> empty;
-  std::pair <std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> >::iterator, bool> 
-    ret = m_rlcAttached.insert (std::pair <uint16_t,  std::map<uint8_t, LteMacSapUser*> > 
+  std::pair <std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> >::iterator, bool>
+    ret = m_rlcAttached.insert (std::pair <uint16_t,  std::map<uint8_t, LteMacSapUser*> >
                                 (rnti, empty));
   NS_ASSERT_MSG (ret.second, "element already present, RNTI already existed");
 
@@ -846,9 +855,9 @@
   NS_LOG_FUNCTION (this << lcinfo.rnti << (uint16_t) lcinfo.lcId);
 
   std::map <LteFlowId_t, LteMacSapUser* >::iterator it;
-  
+
   LteFlowId_t flow (lcinfo.rnti, lcinfo.lcId);
-  
+
   std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> >::iterator rntiIt = m_rlcAttached.find (lcinfo.rnti);
   NS_ASSERT_MSG (rntiIt != m_rlcAttached.end (), "RNTI not found");
   std::map<uint8_t, LteMacSapUser*>::iterator lcidIt = rntiIt->second.find (lcinfo.lcId);
@@ -861,9 +870,9 @@
       NS_LOG_ERROR ("LC already exists");
     }
 
-  // CCCH (LCID 0) is pre-configured 
+  // CCCH (LCID 0) is pre-configured
   // see FF LTE MAC Scheduler
-  // Interface Specification v1.11, 
+  // Interface Specification v1.11,
   // 4.3.4 logicalChannelConfigListElement
   if (lcinfo.lcId != 0)
     {
@@ -921,7 +930,7 @@
   m_cschedSapProvider->CschedUeConfigReq (req);
 }
 
-LteEnbCmacSapProvider::RachConfig 
+LteEnbCmacSapProvider::RachConfig
 LteEnbMac::DoGetRachConfig ()
 {
   struct LteEnbCmacSapProvider::RachConfig rc;
@@ -930,8 +939,8 @@
   rc.raResponseWindowSize = m_raResponseWindowSize;
   return rc;
 }
- 
-LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue 
+
+LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue
 LteEnbMac::DoAllocateNcRaPreamble (uint16_t rnti)
 {
   bool found = false;
@@ -944,8 +953,8 @@
         {
           found = true;
           NcRaPreambleInfo preambleInfo;
-          uint32_t expiryIntervalMs = (uint32_t) m_preambleTransMax * ((uint32_t) m_raResponseWindowSize + 5); 
-          
+          uint32_t expiryIntervalMs = (uint32_t) m_preambleTransMax * ((uint32_t) m_raResponseWindowSize + 5);
+
           preambleInfo.expiryTime = Simulator::Now () + MilliSeconds (expiryIntervalMs);
           preambleInfo.rnti = rnti;
           NS_LOG_INFO ("allocated preamble for NC based RA: preamble " << preambleId << ", RNTI " << preambleInfo.rnti << ", exiryTime " << preambleInfo.expiryTime);
@@ -986,8 +995,8 @@
   // Store pkt in HARQ buffer
   std::map <uint16_t, DlHarqProcessesBuffer_t>::iterator it =  m_miDlHarqProcessesPackets.find (params.rnti);
   NS_ASSERT (it != m_miDlHarqProcessesPackets.end ());
-  NS_LOG_DEBUG (this << " LAYER " << (uint16_t)tag.GetLayer () << " HARQ ID " << (uint16_t)params.harqProcessId);
-  
+  NS_LOG_DEBUG (this << " LteEnbMac tx pdu LAYER " << (uint16_t)tag.GetLayer () << " HARQ ID " << (uint16_t)params.harqProcessId);
+
   //(*it).second.at (params.layer).at (params.harqProcessId) = params.pdu;//->Copy ();
   (*it).second.at (params.layer).at (params.harqProcessId)->AddPacket (params.pdu);
   m_enbPhySapProvider->SendMacPdu (params.pdu);
diff -Naru a/model/lte-enb-net-device.cc b/model/lte-enb-net-device.cc
--- a/model/lte-enb-net-device.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-enb-net-device.cc	2018-08-03 16:39:02.891957671 +0200
@@ -19,6 +19,9 @@
  * Author: Marco Miozzo <mmiozzo@cttc.es> : Update to FF API Architecture
  * Author: Nicola Baldo <nbaldo@cttc.es>  : Integrated with new RRC and MAC architecture
  * Author: Danilo Abrignani <danilo.abrignani@unibo.it> : Integrated with new architecture - GSoC 2015 - Carrier Aggregation
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/llc-snap-header.h>
@@ -94,14 +97,14 @@
                    MakeObjectMapChecker<ComponentCarrierEnb> ())
     .AddAttribute ("UlBandwidth",
                    "Uplink Transmission Bandwidth Configuration in number of Resource Blocks",
-                   UintegerValue (25),
-                   MakeUintegerAccessor (&LteEnbNetDevice::SetUlBandwidth, 
+                   UintegerValue (100),
+                   MakeUintegerAccessor (&LteEnbNetDevice::SetUlBandwidth,
                                          &LteEnbNetDevice::GetUlBandwidth),
                    MakeUintegerChecker<uint8_t> ())
     .AddAttribute ("DlBandwidth",
                    "Downlink Transmission Bandwidth Configuration in number of Resource Blocks",
-                   UintegerValue (25),
-                   MakeUintegerAccessor (&LteEnbNetDevice::SetDlBandwidth, 
+                   UintegerValue (100),
+                   MakeUintegerAccessor (&LteEnbNetDevice::SetDlBandwidth,
                                          &LteEnbNetDevice::GetDlBandwidth),
                    MakeUintegerChecker<uint8_t> ())
     .AddAttribute ("CellId",
@@ -178,7 +181,7 @@
       m_ccMap.at (i)->Dispose ();
       m_ccMap.at (i) = 0;
     }
-   
+
   LteNetDevice::DoDispose ();
 }
 
@@ -197,13 +200,13 @@
 }
 
 Ptr<LteEnbMac>
-LteEnbNetDevice::GetMac (uint8_t index) 
+LteEnbNetDevice::GetMac (uint8_t index)
 {
   return m_ccMap.at (index)->GetMac ();
 }
 
 Ptr<LteEnbPhy>
-LteEnbNetDevice::GetPhy(uint8_t index)  
+LteEnbNetDevice::GetPhy(uint8_t index)
 {
   return m_ccMap.at (index)->GetPhy ();
 }
@@ -239,18 +242,18 @@
   return false;
 }
 
-uint8_t 
+uint8_t
 LteEnbNetDevice::GetUlBandwidth () const
 {
   return m_ulBandwidth;
 }
 
-void 
+void
 LteEnbNetDevice::SetUlBandwidth (uint8_t bw)
-{ 
+{
   NS_LOG_FUNCTION (this << uint16_t (bw));
   switch (bw)
-    { 
+    {
     case 6:
     case 15:
     case 25:
@@ -266,18 +269,18 @@
     }
 }
 
-uint8_t 
+uint8_t
 LteEnbNetDevice::GetDlBandwidth () const
 {
   return m_dlBandwidth;
 }
 
-void 
+void
 LteEnbNetDevice::SetDlBandwidth (uint8_t bw)
 {
   NS_LOG_FUNCTION (this << uint16_t (bw));
   switch (bw)
-    { 
+    {
     case 6:
     case 15:
     case 25:
@@ -293,28 +296,28 @@
     }
 }
 
-uint32_t 
+uint32_t
 LteEnbNetDevice::GetDlEarfcn () const
 {
   return m_dlEarfcn;
 }
 
-void 
+void
 LteEnbNetDevice::SetDlEarfcn (uint32_t earfcn)
-{ 
+{
   NS_LOG_FUNCTION (this << earfcn);
   m_dlEarfcn = earfcn;
 }
 
-uint32_t 
+uint32_t
 LteEnbNetDevice::GetUlEarfcn () const
 {
   return m_ulEarfcn;
 }
 
-void 
+void
 LteEnbNetDevice::SetUlEarfcn (uint32_t earfcn)
-{ 
+{
   NS_LOG_FUNCTION (this << earfcn);
   m_ulEarfcn = earfcn;
 }
@@ -360,7 +363,7 @@
   m_ccMap = ccm;
 }
 
-void 
+void
 LteEnbNetDevice::DoInitialize (void)
 {
   NS_LOG_FUNCTION (this);
diff -Naru a/model/lte-enb-phy.cc b/model/lte-enb-phy.cc
--- a/model/lte-enb-phy.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-enb-phy.cc	2018-08-03 16:39:02.891957671 +0200
@@ -17,6 +17,9 @@
  *
  * Author: Giuseppe Piro  <g.piro@poliba.it>
  *         Marco Miozzo <mmiozzo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/object-factory.h>
@@ -83,8 +86,6 @@
 
   // inherited from LteEnbPhySapProvider
   virtual void SendMacPdu (Ptr<Packet> p);
-  virtual void SendLteControlMessage (Ptr<LteControlMessage> msg);
-  virtual uint8_t GetMacChTtiDelay ();
   /**
    * Set bandwidth function
    *
@@ -98,6 +99,8 @@
    * \param cellId the cell ID
    */
   virtual void SetCellId (uint16_t cellId);
+  virtual void SendLteControlMessage (Ptr<LteControlMessage> msg);
+  virtual uint8_t GetMacChTtiDelay ();
 
 
 private:
@@ -180,7 +183,7 @@
     .AddAttribute ("TxPower",
                    "Transmission power in dBm",
                    DoubleValue (30.0),
-                   MakeDoubleAccessor (&LteEnbPhy::SetTxPower, 
+                   MakeDoubleAccessor (&LteEnbPhy::SetTxPower,
                                        &LteEnbPhy::GetTxPower),
                    MakeDoubleChecker<double> ())
     .AddAttribute ("NoiseFigure",
@@ -194,7 +197,7 @@
                    "are connected to sources at the standard noise "
                    "temperature T0.\"  In this model, we consider T0 = 290K.",
                    DoubleValue (5.0),
-                   MakeDoubleAccessor (&LteEnbPhy::SetNoiseFigure, 
+                   MakeDoubleAccessor (&LteEnbPhy::SetNoiseFigure,
                                        &LteEnbPhy::GetNoiseFigure),
                    MakeDoubleChecker<double> ())
     .AddAttribute ("MacToChannelDelay",
@@ -204,7 +207,7 @@
                    "intended to be used to model the latency of real PHY "
                    "and MAC implementations.",
                    UintegerValue (2),
-                   MakeUintegerAccessor (&LteEnbPhy::SetMacChDelay, 
+                   MakeUintegerAccessor (&LteEnbPhy::SetMacChDelay,
                                          &LteEnbPhy::GetMacChDelay),
                    MakeUintegerChecker<uint8_t> ())
     .AddTraceSource ("ReportUeSinr",
@@ -633,9 +636,9 @@
     }
 
   if (m_srsPeriodicity>0)
-    { 
+    {
       // might be 0 in case the eNB has no UEs attached
-      NS_ASSERT_MSG (m_nrFrames > 1, "the SRS index check code assumes that frameNo starts at 1");
+      NS_ASSERT_MSG (m_nrFrames >= 1, "the SRS index check code assumes that frameNo starts at 1");
       NS_ASSERT_MSG (m_nrSubFrames > 0 && m_nrSubFrames <= 10, "the SRS index check code assumes that subframeNo starts at 1");
       m_currentSrsOffset = (((m_nrFrames-1)*10 + (m_nrSubFrames-1)) % m_srsPeriodicity);
     }
@@ -657,7 +660,7 @@
         }
       else
         {
-          // send info of TB to LteSpectrumPhy 
+          // send info of TB to LteSpectrumPhy
           // translate to allocation map
           std::vector <int> rbMap;
           for (int i = (*dciIt).GetDci ().m_rbStart; i < (*dciIt).GetDci ().m_rbStart + (*dciIt).GetDci ().m_rbLen; i++)
@@ -838,7 +841,7 @@
 }
 
 
-void 
+void
 LteEnbPhy::GenerateCtrlCqiReport (const SpectrumValue& sinr)
 {
   NS_LOG_FUNCTION (this << sinr << Simulator::Now () << m_srsStartTime);
@@ -897,7 +900,7 @@
       i++;
     }
   return (ulcqi);
-	
+
 }
 
 
@@ -924,7 +927,7 @@
     }
 }
 
-void 
+void
 LteEnbPhy::DoSetEarfcn (uint32_t ulEarfcn, uint32_t dlEarfcn)
 {
   NS_LOG_FUNCTION (this << ulEarfcn << dlEarfcn);
@@ -933,11 +936,11 @@
 }
 
 
-void 
+void
 LteEnbPhy::DoAddUe (uint16_t rnti)
 {
   NS_LOG_FUNCTION (this << rnti);
- 
+
   bool success = AddUePhy (rnti);
   NS_ASSERT_MSG (success, "AddUePhy() failed");
 
@@ -945,11 +948,11 @@
   DoSetPa (rnti, 0);
 }
 
-void 
+void
 LteEnbPhy::DoRemoveUe (uint16_t rnti)
 {
   NS_LOG_FUNCTION (this << rnti);
- 
+
   bool success = DeleteUePhy (rnti);
   NS_ASSERT_MSG (success, "DeleteUePhy() failed");
 
@@ -1103,7 +1106,7 @@
 }
 
 
-void 
+void
 LteEnbPhy::DoSetMasterInformationBlock (LteRrcSap::MasterInformationBlock mib)
 {
   NS_LOG_FUNCTION (this);
diff -Naru a/model/lte-enb-phy.h b/model/lte-enb-phy.h
--- a/model/lte-enb-phy.h	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-enb-phy.h	2018-08-03 16:39:02.891957671 +0200
@@ -148,7 +148,7 @@
 
   /**
    * \brief set the resource blocks (a.k.a. sub channels) to be used in the downlink for transmission
-   * 
+   *
    * \param mask a vector of integers, if the i-th value is j it means
    * that the j-th resource block is used for transmission in the
    * downlink. If there is no i such that the value of the i-th
@@ -167,7 +167,7 @@
    */
   void SetDownlinkSubChannelsWithPowerAllocation (std::vector<int> mask);
   /**
-   * 
+   *
    * \return  a vector of integers, if the i-th value is j it means
    * that the j-th resource block is used for transmission in the
    * downlink. If there is no i such that the value of the i-th
@@ -273,8 +273,8 @@
   void PhyPduReceived (Ptr<Packet> p);
 
   /**
-   * \brief PhySpectrum received a new list of LteControlMessage
-   */
+  * \brief PhySpectrum received a new list of LteControlMessage
+  */
   virtual void ReceiveLteControlMessageList (std::list<Ptr<LteControlMessage> >);
 
   // inherited from LtePhy
@@ -286,9 +286,9 @@
 
 
   /**
-   * \brief PhySpectrum generated a new UL HARQ feedback
+  * \brief PhySpectrum generated a new UL HARQ feedback
    * \param mes UlInfoListElement_s
-   */
+  */
   virtual void ReceiveLteUlHarqFeedback (UlInfoListElement_s mes);
 
   /**
diff -Naru a/model/lte-enb-phy-sap.h b/model/lte-enb-phy-sap.h
--- a/model/lte-enb-phy-sap.h	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-enb-phy-sap.h	2018-08-03 16:39:02.891957671 +0200
@@ -49,12 +49,12 @@
    */
   virtual void SendMacPdu (Ptr<Packet> p) = 0;
 
-  /** 
+  /**
    * \brief Send SendLteControlMessage (PDCCH map, CQI feedbacks) using the ideal control channel
    * \param msg the Ideal Control Message to send
    */
   virtual void SendLteControlMessage (Ptr<LteControlMessage> msg) = 0;
-  
+
   /**
   * \brief Get the delay from MAC to Channel expressed in TTIs
   * \returns MAC channel TTI delay
@@ -97,9 +97,9 @@
    */
   virtual void ReceiveLteControlMessage (Ptr<LteControlMessage> msg) = 0;
 
-  /** 
-   * notify the reception of a RACH preamble on the PRACH 
-   * 
+  /**
+   * notify the reception of a RACH preamble on the PRACH
+   *
    * \param prachId the ID of the preamble
    */
   virtual void ReceiveRachPreamble (uint32_t prachId) = 0;
diff -Naru a/model/lte-enb-rrc.cc b/model/lte-enb-rrc.cc
--- a/model/lte-enb-rrc.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-enb-rrc.cc	2018-08-03 16:39:02.891957671 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, 2018, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -20,6 +21,12 @@
  *          Manuel Requena <manuel.requena@cttc.es>
  * Modified by:  Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015),
  *               Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ *
+ * Modified by Michele Polese <michele.polese@gmail.com> for DC functionalities
+ * Lossless HO code from https://github.com/binhqnguyen/lena
+ *
+ * Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+ *							Integration of Carrier Aggregation for the mmWave module
  */
 
 #include "lte-enb-rrc.h"
@@ -41,8 +48,14 @@
 #include <ns3/lte-rlc-tm.h>
 #include <ns3/lte-rlc-um.h>
 #include <ns3/lte-rlc-am.h>
+#include <ns3/lte-rlc-am-header.h>
+#include <ns3/lte-rlc-sdu-status-tag.h>
 #include <ns3/lte-pdcp.h>
-
+#include <ns3/lte-pdcp-header.h>
+#include <ns3/lte-rlc-um-lowlat.h>
+#include <ns3/mc-enb-pdcp.h>
+#include "ns3/lte-pdcp-tag.h"
+#include <ns3/lte-rlc-sap.h>
 
 
 
@@ -120,6 +133,8 @@
   "HANDOVER_JOINING",
   "HANDOVER_PATH_SWITCH",
   "HANDOVER_LEAVING",
+  "PREPARE_MC_CONNECTION_RECONFIGURATION",
+  "MC_CONNECTION_RECONFIGURATION"
 };
 
 /**
@@ -150,12 +165,16 @@
     m_rrc (rrc),
     m_state (s),
     m_pendingRrcConnectionReconfiguration (false),
+    m_pendingConnectToMmWave (false),
     m_sourceX2apId (0),
     m_sourceCellId (0),
     m_needPhyMacConfiguration (false),
+    m_x2forwardingBufferSize (0),
+    m_maxx2forwardingBufferSize (2*1024),
+    m_allMmWaveInOutageAtInitialAccess (false),
     m_caSupportConfigured (false),
     m_pendingStartDataRadioBearers (false)
-{ 
+{
   NS_LOG_FUNCTION (this);
 }
 
@@ -174,7 +193,8 @@
   m_physicalConfigDedicated.havePdschConfigDedicated = true;
   m_physicalConfigDedicated.pdschConfigDedicated.pa = LteRrcSap::PdschConfigDedicated::dB0;
 
-  
+  m_rlcMap.clear();
+
   for (uint8_t i = 0; i < m_rrc->m_numberOfComponentCarriers; i++)
     {
       m_rrc->m_cmacSapProvider.at (i)->AddUe (m_rnti);
@@ -209,7 +229,7 @@
     lcinfo.gbrDl = 0;
 
     // MacSapUserForRlc in the ComponentCarrierManager MacSapUser
-    LteMacSapUser* lteMacSapUser = m_rrc->m_ccmRrcSapProvider->ConfigureSignalBearer(lcinfo, rlc->GetLteMacSapUser ()); 
+    LteMacSapUser* lteMacSapUser = m_rrc->m_ccmRrcSapProvider->ConfigureSignalBearer(lcinfo, rlc->GetLteMacSapUser ());
     // Signal Channel are only on Primary Carrier
     m_rrc->m_cmacSapProvider.at (m_componentCarrierId)->AddLc (lcinfo, lteMacSapUser);
     m_rrc->m_ccmRrcSapProvider->AddLc (lcinfo, lteMacSapUser);
@@ -251,7 +271,7 @@
     lcinfo.gbrUl = 1e4;
     lcinfo.gbrDl = 1e4;
     // MacSapUserForRlc in the ComponentCarrierManager MacSapUser
-    LteMacSapUser* MacSapUserForRlc = m_rrc->m_ccmRrcSapProvider->ConfigureSignalBearer(lcinfo, rlc->GetLteMacSapUser ()); 
+    LteMacSapUser* MacSapUserForRlc = m_rrc->m_ccmRrcSapProvider->ConfigureSignalBearer(lcinfo, rlc->GetLteMacSapUser ());
     // Signal Channel are only on Primary Carrier
     m_rrc->m_cmacSapProvider.at (m_componentCarrierId)->AddLc (lcinfo, MacSapUserForRlc);
     m_rrc->m_ccmRrcSapProvider->AddLc (lcinfo, MacSapUserForRlc);
@@ -294,7 +314,21 @@
       NS_FATAL_ERROR ("unexpected state " << ToString (m_state));
       break;
     }
-  m_caSupportConfigured =  false;
+
+  if (m_rrc->m_numberOfComponentCarriers > 1)
+  {
+    m_caSupportConfigured =  false; // if CA is used do CA configuration
+  }
+  else
+  {
+    m_caSupportConfigured = true; // if CA is not used we do not need to configure it
+  }
+  m_firstConnection = false;
+  m_mmWaveCellId = 0;
+  m_mmWaveRnti = 0;
+  m_mmWaveCellAvailableForMcSetup = false;
+  m_receivedLteMmWaveHandoverCompleted = false;
+  m_queuedHandoverRequestCellId = 0;
 }
 
 
@@ -306,6 +340,7 @@
 UeManager::DoDispose ()
 {
   delete m_drbPdcpSapUser;
+  m_rlcMap.clear();
   // delete eventual X2-U TEIDs
   for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it = m_drbMap.begin ();
        it != m_drbMap.end ();
@@ -325,6 +360,10 @@
                    ObjectMapValue (),
                    MakeObjectMapAccessor (&UeManager::m_drbMap),
                    MakeObjectMapChecker<LteDataRadioBearerInfo> ())
+                   .AddAttribute ("DataRadioRlcMap", "List of UE Secondary RLC by DRBID.",
+                                  ObjectMapValue (),
+                                  MakeObjectMapAccessor (&UeManager::m_rlcMap),
+                                  MakeObjectMapChecker<RlcBearerInfo> ())
     .AddAttribute ("Srb0", "SignalingRadioBearerInfo for SRB0",
                    PointerValue (),
                    MakePointerAccessor (&UeManager::m_srb0),
@@ -344,31 +383,58 @@
                      "UeManager at the eNB RRC",
                      MakeTraceSourceAccessor (&UeManager::m_stateTransitionTrace),
                      "ns3::UeManager::StateTracedCallback")
+     .AddTraceSource ("SecondaryRlcCreated",
+                      "fired upon receiving RecvRlcSetupRequest",
+                      MakeTraceSourceAccessor (&UeManager::m_secondaryRlcCreatedTrace),
+                      "ns3::UeManager::ImsiCidRntiTracedCallback")
   ;
   return tid;
 }
 
-void 
+void
 UeManager::SetSource (uint16_t sourceCellId, uint16_t sourceX2apId)
 {
   m_sourceX2apId = sourceX2apId;
   m_sourceCellId = sourceCellId;
 }
 
-void 
+std::pair<uint16_t, uint16_t>
+UeManager::GetSource (void)
+{
+  return std::pair<uint16_t, uint16_t> (m_sourceCellId, m_sourceX2apId);
+}
+void
 UeManager::SetImsi (uint64_t imsi)
 {
   m_imsi = imsi;
 }
 
 void
+UeManager::SetIsMc (bool isMc)
+{
+  m_isMc = isMc;
+}
+
+//void
+//UeManager::SetIsInterRatHoCapable (bool isInterRatHoCapable)
+//{
+//  m_isInterRatHoCapable = isInterRatHoCapable;
+//}
+
+bool
+UeManager::GetIsMc () const
+{
+  return m_isMc;
+}
+
+void
 UeManager::SetupDataRadioBearer (EpsBearer bearer, uint8_t bearerId, uint32_t gtpTeid, Ipv4Address transportLayerAddress)
 {
   NS_LOG_FUNCTION (this << (uint32_t) m_rnti);
 
   Ptr<LteDataRadioBearerInfo> drbInfo = CreateObject<LteDataRadioBearerInfo> ();
   uint8_t drbid = AddDataRadioBearerInfo (drbInfo);
-  uint8_t lcid = Drbid2Lcid (drbid); 
+  uint8_t lcid = Drbid2Lcid (drbid);
   uint8_t bid = Drbid2Bid (drbid);
   NS_ASSERT_MSG ( bearerId == 0 || bid == bearerId, "bearer ID mismatch (" << (uint32_t) bid << " != " << (uint32_t) bearerId << ", the assumption that ID are allocated in the same way by MME and RRC is not valid any more");
   drbInfo->m_epsBearer = bearer;
@@ -380,7 +446,7 @@
 
   if (m_state == HANDOVER_JOINING)
     {
-      // setup TEIDs for receiving data eventually forwarded over X2-U 
+      // setup TEIDs for receiving data eventually forwarded over X2-U
       LteEnbRrc::X2uTeidInfo x2uTeidInfo;
       x2uTeidInfo.rnti = m_rnti;
       x2uTeidInfo.drbid = drbid;
@@ -405,7 +471,8 @@
   // if we are using RLC/SM we don't care of anything above RLC
   if (rlcTypeId != LteRlcSm::GetTypeId ())
     {
-      Ptr<LtePdcp> pdcp = CreateObject<LtePdcp> ();
+      Ptr<McEnbPdcp> pdcp = CreateObject<McEnbPdcp> (); // Modified with McEnbPdcp to support MC
+                                                        // This will allow to add an X2 interface to pdcp
       pdcp->SetRnti (m_rnti);
       pdcp->SetLcId (lcid);
       pdcp->SetLtePdcpSapUser (m_drbPdcpSapUser);
@@ -461,6 +528,21 @@
     }
   drbInfo->m_logicalChannelConfig.bucketSizeDurationMs = 1000;
 
+  EpcX2Sap::RlcSetupRequest req;
+  req.sourceCellId = m_rrc->GetCellId();
+  req.gtpTeid = drbInfo->m_gtpTeid;
+  req.lteRnti = m_rnti;
+  req.drbid = drbid;
+  //req.lcinfo = lcinfo;
+  req.logicalChannelConfig = drbInfo->m_logicalChannelConfig;
+  req.rlcConfig = drbInfo->m_rlcConfig;
+  req.targetCellId = 0;
+  req.mmWaveRnti = 0;
+  // mmWaveRnti & targetCellId will be set before sending the request
+  drbInfo->m_rlcSetupRequest = req;
+
+  drbInfo->m_epsBearer = bearer;
+  drbInfo->m_isMc = false;
   ScheduleRrcConnectionReconfiguration ();
 }
 
@@ -521,7 +603,7 @@
   //populating RadioResourceConfigDedicated information element as per 3GPP TS 36.331 version 9.2.0
   rrcd.havePhysicalConfigDedicated = true;
   rrcd.physicalConfigDedicated = m_physicalConfigDedicated;
- 
+
   //populating RRCConnectionReconfiguration message as per 3GPP TS 36.331 version 9.2.0 Release 9
   LteRrcSap::RrcConnectionReconfiguration msg;
   msg.haveMeasConfig = false;
@@ -545,7 +627,7 @@
   m_s1SapProvider->DoSendReleaseIndication (imsi,rnti,bearerId);
 }
 
-void 
+void
 UeManager::ScheduleRrcConnectionReconfiguration ()
 {
   NS_LOG_FUNCTION (this);
@@ -572,13 +654,29 @@
       }
       break;
 
+    case PREPARE_MC_CONNECTION_RECONFIGURATION:
+      {
+        m_pendingRrcConnectionReconfiguration = false;
+        LteRrcSap::RrcConnectionReconfiguration msg = BuildRrcConnectionReconfiguration ();
+        msg.haveMeasConfig = false;
+        msg.haveMobilityControlInfo = false;
+        msg.radioResourceConfigDedicated.srbToAddModList.clear();
+        msg.radioResourceConfigDedicated.physicalConfigDedicated.haveAntennaInfoDedicated = false;
+        msg.radioResourceConfigDedicated.physicalConfigDedicated.haveSoundingRsUlConfigDedicated = false;
+        msg.radioResourceConfigDedicated.physicalConfigDedicated.havePdschConfigDedicated = false;
+        m_rrc->m_rrcSapUser->SendRrcConnectionReconfiguration (m_rnti, msg);
+        RecordDataRadioBearersToBeStarted ();
+        SwitchToState (MC_CONNECTION_RECONFIGURATION);
+      }
+      break;
+
     default:
       NS_FATAL_ERROR ("method unexpected in state " << ToString (m_state));
       break;
     }
 }
 
-void 
+void
 UeManager::PrepareHandover (uint16_t cellId)
 {
   NS_LOG_FUNCTION (this << cellId);
@@ -596,6 +694,10 @@
         params.ueAggregateMaxBitRateDownlink = 200 * 1000;
         params.ueAggregateMaxBitRateUplink = 100 * 1000;
         params.bearers = GetErabList ();
+        params.rlcRequests = m_rlcRequestVector;
+        // clear the vector to avoid keeping old information
+        // the target eNB will add the rlcRequests in its own vector
+        m_rlcRequestVector.clear();
 
         LteRrcSap::HandoverPreparationInfo hpi;
         hpi.asConfig.sourceUeIdentity = m_rnti;
@@ -616,6 +718,7 @@
         hpi.asConfig.sourceSystemInformationBlockType2.freqInfo.ulBandwidth = m_rrc->m_ulBandwidth;
         params.rrcContext = m_rrc->m_rrcSapUser->EncodeHandoverPreparationInformation (hpi);
 
+        params.isMc = m_isMc;
         NS_LOG_LOGIC ("oldEnbUeX2apId = " << params.oldEnbUeX2apId);
         NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
         NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
@@ -627,6 +730,13 @@
       }
       break;
 
+    case CONNECTION_RECONFIGURATION:
+    case HANDOVER_JOINING: // there may be some delays in the TX of RRC messages, thus an handover may be completed at UE side, but not at eNB side
+      {
+        m_queuedHandoverRequestCellId = cellId;
+        NS_LOG_INFO("UeManager is in CONNECTION_RECONFIGURATION, postpone the PrepareHandover command to cell " << m_queuedHandoverRequestCellId);
+      }
+      break;
     default:
       NS_FATAL_ERROR ("method unexpected in state " << ToString (m_state));
       break;
@@ -634,7 +744,70 @@
 
 }
 
-void 
+/*
+ * Merge 2 buffers of RlcAmPdus into 1 vector with increment order of Pdus
+ */
+std::vector < LteRlcAm::RetxPdu >
+UeManager::MergeBuffers(std::vector < LteRlcAm::RetxPdu > first, std::vector < LteRlcAm::RetxPdu > second)
+{
+  LteRlcAmHeader rlcamHeader_1, rlcamHeader_2;
+  std::vector < LteRlcAm::RetxPdu> result;
+  std::vector < LteRlcAm::RetxPdu>::iterator it_1 = first.begin();
+  std::vector < LteRlcAm::RetxPdu>::iterator it_2 = second.begin();
+  bool end_1_reached = false;
+  bool end_2_reached = false;
+  while (it_1 != first.end() && it_2 != second.end()){
+    while ((*it_1).m_pdu == 0){
+      ++it_1;
+      if(it_1 == first.end())
+      {
+        end_1_reached = true;
+        break;
+      }
+    }
+    while ((*it_2).m_pdu == 0){
+      ++it_2;
+      if(it_2 == second.end())
+      {
+        end_2_reached = true;
+        break;
+      }
+    }
+    if(!end_1_reached && !end_2_reached)
+    {
+      (*it_1).m_pdu->PeekHeader(rlcamHeader_1);
+      (*it_2).m_pdu->PeekHeader(rlcamHeader_2);
+      if (rlcamHeader_1.GetSequenceNumber() > rlcamHeader_2.GetSequenceNumber()){
+        result.push_back((*it_2));
+        ++it_2;
+      }
+      else if (rlcamHeader_2.GetSequenceNumber() > rlcamHeader_1.GetSequenceNumber()){
+        result.push_back((*it_1));
+        ++it_1;
+      }
+      else {
+        result.push_back((*it_1));
+        ++it_1;
+        ++it_2;
+      }
+      NS_LOG_DEBUG ("first,second = " << rlcamHeader_1.GetSequenceNumber() << "," << rlcamHeader_2.GetSequenceNumber());
+    }
+    else
+    {
+      break;
+    }
+  }
+  while (it_1 != first.end()){
+    result.push_back((*it_1));
+    it_1++;
+  }
+  while (it_2 != second.end()){
+    result.push_back((*it_2));
+    it_2++;
+  }
+  return result;
+}
+void
 UeManager::RecvHandoverRequestAck (EpcX2SapUser::HandoverRequestAckParams params)
 {
   NS_LOG_FUNCTION (this);
@@ -646,14 +819,14 @@
   // is expected to be sent transparently to the UE; however, here we
   // decode the message and eventually re-encode it. This way we can
   // support both a real RRC protocol implementation and an ideal one
-  // without actual RRC protocol encoding. 
+  // without actual RRC protocol encoding.
 
   Ptr<Packet> encodedHandoverCommand = params.rrcContext;
   LteRrcSap::RrcConnectionReconfiguration handoverCommand = m_rrc->m_rrcSapUser->DecodeHandoverCommand (encodedHandoverCommand);
   m_rrc->m_rrcSapUser->SendRrcConnectionReconfiguration (m_rnti, handoverCommand);
   SwitchToState (HANDOVER_LEAVING);
-  m_handoverLeavingTimeout = Simulator::Schedule (m_rrc->m_handoverLeavingTimeoutDuration, 
-                                                  &LteEnbRrc::HandoverLeavingTimeout, 
+  m_handoverLeavingTimeout = Simulator::Schedule (m_rrc->m_handoverLeavingTimeoutDuration,
+                                                  &LteEnbRrc::HandoverLeavingTimeout,
                                                   m_rrc, m_rnti);
   NS_ASSERT (handoverCommand.haveMobilityControlInfo);
   m_rrc->m_handoverStartTrace (m_imsi, m_rrc->ComponentCarrierToCellId (m_componentCarrierId), m_rnti, handoverCommand.mobilityControlInfo.targetPhysCellId);
@@ -678,6 +851,284 @@
         }
     }
   m_rrc->m_x2SapProvider->SendSnStatusTransfer (sst);
+
+  // on a mmWave eNB, for a UeManager of an MC device, notify the EpcX2 class that it has to forward the incoming packets
+  if(m_rrc->m_ismmWave && m_isMc)
+  {
+    NS_LOG_INFO("Notify the X2 that packets with a certain TEID must be forwarded to the targetCell");
+    for(std::map <uint8_t, Ptr<RlcBearerInfo> >::iterator rlcIt = m_rlcMap.begin ();
+          rlcIt != m_rlcMap.end ();
+          ++rlcIt)
+    {
+      m_rrc->m_x2SapProvider->AddTeidToBeForwarded(rlcIt->second->gtpTeid, params.targetCellId);
+    }
+  }
+
+  // LL HO
+  //Forward RlcTxBuffers to target eNodeb.
+  // TODO forwarding for secondary cell HO
+  NS_LOG_INFO("m_drbMap size " << m_drbMap.size() << " in cell " << m_rrc->m_cellId << " forward RLC buffers");
+  for ( std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator drbIt = m_drbMap.begin ();
+        drbIt != m_drbMap.end ();
+        ++drbIt)
+  {
+    ForwardRlcBuffers(drbIt->second->m_rlc, drbIt->second->m_pdcp, drbIt->second->m_gtpTeid, 0, 0, 0);
+  }
+
+  if(m_rrc->m_ismmWave && m_isMc) // for secondary cell HO
+  {
+    NS_LOG_INFO("m_rlcMap size " << m_rlcMap.size() << " in cell " << m_rrc->m_cellId << " forward RLC buffers");
+    for ( std::map <uint8_t, Ptr<RlcBearerInfo> >::iterator rlcIt = m_rlcMap.begin ();
+          rlcIt != m_rlcMap.end ();
+          ++rlcIt)
+    {
+      // the buffers are forwarded to m_targetCellId, which is set in PrepareHandover
+      // the target cell
+      ForwardRlcBuffers(rlcIt->second->m_rlc, 0, rlcIt->second->gtpTeid, 0, 1, 0);
+    }
+  }
+}
+
+// This code from the LL HO implementation is refactored in a function
+// in order to be used also when switching from LTE to MmWave and back
+void
+UeManager::ForwardRlcBuffers(Ptr<LteRlc> rlc, Ptr<LtePdcp> pdcp, uint32_t gtpTeid, bool mcLteToMmWaveForwarding, bool mcMmToMmWaveForwarding, uint8_t bid)
+{
+  // RlcBuffers forwarding only for RlcAm bearers.
+  if (0 != rlc->GetObject<LteRlcAm> ())
+  {
+    //Copy lte-rlc-am.m_txOnBuffer to X2 forwarding buffer.
+    Ptr<LteRlcAm> rlcAm = rlc->GetObject<LteRlcAm>();
+    uint32_t txonBufferSize = rlcAm->GetTxBufferSize();
+    std::vector < Ptr<Packet> > txonBuffer = rlcAm->GetTxBuffer();
+    //m_x2forwardingBufferSize =  drbIt->second->m_rlc->GetObject<LteRlcAm>()->GetTxBufferSize();
+    //m_x2forwardingBuffer = drbIt->second->m_rlc->GetObject<LteRlcAm>()->GetTxBuffer();
+    uint32_t txedBufferSize = rlcAm->GetTxedBufferSize();
+    std::vector < LteRlcAm::RetxPdu > txedBuffer = rlcAm->GetTxedBuffer();
+    uint32_t retxBufferSize = rlcAm->GetRetxBufferSize();
+    std::vector < LteRlcAm::RetxPdu > retxBuffer = rlcAm->GetRetxBuffer();
+
+    //Translate Pdus in Rlc txed/retx buffer into RLC Sdus
+    //and put these Sdus into rlcAm->m_transmittingRlcSdus.
+    NS_LOG_INFO("retxBuffer size = " << retxBufferSize);
+    NS_LOG_INFO("txedBuffer size = " << txedBufferSize);
+    //Merge txed and retx buffers into a single buffer before doing RlcPdusToRlc.
+    if ( retxBufferSize + txedBufferSize > 0 ){
+      std::vector< LteRlcAm::RetxPdu > sortedTxedRetxBuffer;
+      if (retxBufferSize == 0){
+        sortedTxedRetxBuffer = txedBuffer;
+      }
+      else if (txedBufferSize == 0){
+        sortedTxedRetxBuffer = retxBuffer;
+      }
+      else {
+        sortedTxedRetxBuffer = MergeBuffers(txedBuffer, retxBuffer);
+      }
+      rlcAm->RlcPdusToRlcSdus(sortedTxedRetxBuffer);
+    }
+
+    //Construct the forwarding buffer
+    //Forwarding buffer = retxBuffer + txedBuffer + txonBuffer.
+    //if ( txonBufferSize > 0 )
+    //{
+      LtePdcpHeader pdcpHeader;
+      uint32_t pos = 0;
+      for (std::vector< Ptr<Packet> >::iterator it = txonBuffer.begin(); it != txonBuffer.end(); ++it)
+      {
+        pos++;
+        if((*it)->GetSize() > 3)
+        {
+          (*it)->PeekHeader(pdcpHeader);
+          NS_LOG_DEBUG("txonBuffer SEQ = " << pdcpHeader.GetSequenceNumber() << " Size = " << (*it)->GetSize());
+        }
+        else
+        {
+          NS_LOG_UNCOND("Fragment too small in txonBuffer, pos " << pos);
+        }
+
+      }
+
+      // this cycle adds the SDUs given by the merge of txed and retxed buffers
+      if ( rlcAm->GetTransmittingRlcSduBufferSize() > 0 )
+      { //something inside the RLC AM's transmitting buffer
+        NS_LOG_DEBUG ("ADDING TRANSMITTING SDUS OF RLC AM TO X2FORWARDINGBUFFER... Size = " << rlcAm->GetTransmittingRlcSduBufferSize() );
+        //copy the RlcSdu buffer (map) to forwardingBuffer.
+        std::map < uint32_t, Ptr<Packet> > rlcAmTransmittingBuffer = rlcAm->GetTransmittingRlcSduBuffer();
+        NS_LOG_DEBUG (" *** SIZE = " << rlcAmTransmittingBuffer.size());
+        for (std::map< uint32_t, Ptr<Packet> >::iterator it = rlcAmTransmittingBuffer.begin(); it != rlcAmTransmittingBuffer.end(); ++it)
+        {
+          if (it->second != 0)
+          {
+            NS_LOG_DEBUG ( this << " add to forwarding buffer SEQ = " << it->first << " Ptr<Packet> = " << it->second );
+            m_x2forwardingBuffer.push_back(it->second);
+          }
+        }
+        NS_LOG_DEBUG(this << " ADDING TXONBUFFER OF RLC AM " << m_rnti << " Size = " << txonBufferSize) ;
+
+
+        Ptr<Packet> segmentedRlcsdu = rlcAm->GetSegmentedRlcsdu();
+        if (segmentedRlcsdu != NULL){
+          segmentedRlcsdu->PeekHeader(pdcpHeader);
+          NS_LOG_DEBUG(this << "SegmentedRlcSdu = " << segmentedRlcsdu->GetSize() << " SEQ = " << pdcpHeader.GetSequenceNumber());
+          //insert the complete version of the fragmented SDU to the front of txonBuffer.
+          txonBuffer.insert(txonBuffer.begin(),segmentedRlcsdu);
+        }
+        m_x2forwardingBuffer.insert(m_x2forwardingBuffer.end(), txonBuffer.begin(), txonBuffer.end());
+        m_x2forwardingBufferSize += rlcAm->GetTransmittingRlcSduBufferSize() + txonBufferSize;
+
+        //Get the rlcAm
+        std::vector < Ptr <Packet> > rlcAmTxedSduBuffer = rlcAm->GetTxedRlcSduBuffer();
+        LtePdcpHeader pdcpHeader_1;
+        m_x2forwardingBuffer.at(0)->PeekHeader(pdcpHeader_1);
+        uint16_t i = 0;
+        for (std::vector< Ptr<Packet> >::iterator it = rlcAmTxedSduBuffer.begin(); it != rlcAmTxedSduBuffer.end(); ++it)
+        {
+          if ((*it) != NULL)
+          {
+            (*it)->PeekHeader(pdcpHeader);
+            NS_LOG_DEBUG("rlcAmTxedSduBuffer SEQ = " << pdcpHeader.GetSequenceNumber() << " Size = " << (*it)->GetSize());
+
+            //add the previous SDU of the forwarding buffer to the forwarding buffer.
+            if (pdcpHeader.GetSequenceNumber() >= (pdcpHeader_1.GetSequenceNumber() - 2) && pdcpHeader.GetSequenceNumber() <= (pdcpHeader_1.GetSequenceNumber()) )
+            {
+              NS_LOG_DEBUG("Added previous SDU to forwarding buffer SEQ = " << pdcpHeader.GetSequenceNumber() << " Size = " << (*it)->GetSize());
+              m_x2forwardingBuffer.insert(m_x2forwardingBuffer.begin()+i, (*it)->Copy());
+              ++i;
+            }
+          }
+        }
+
+      }
+      else
+      { //TransmittingBuffer is empty. Only copy TxonBuffer.
+        NS_LOG_DEBUG(this << " ADDING TXONBUFFER OF RLC AM " << m_rnti << " Size = " << txonBufferSize) ;
+        m_x2forwardingBuffer = txonBuffer;
+        m_x2forwardingBufferSize += txonBufferSize;
+      }
+    //}
+  }
+  //For RlcUM, no forwarding available as the simulator itself (seamless HO).
+  //However, as the LTE-UMTS book, PDCP txbuffer should be forwarded for seamless
+  //HO. Enable this code for txbuffer forwarding in seamless HO (which is believe to
+  //be correct).
+  else if (0 != rlc->GetObject<LteRlcUm> ())
+  {
+    //Copy lte-rlc-um.m_txOnBuffer to X2 forwarding buffer.
+    NS_LOG_DEBUG(this << " Copying txonBuffer from RLC UM " << m_rnti);
+    m_x2forwardingBuffer = rlc->GetObject<LteRlcUm>()->GetTxBuffer();
+    m_x2forwardingBufferSize =  rlc->GetObject<LteRlcUm>()->GetTxBufferSize();
+  }
+  else if (0 != rlc->GetObject<LteRlcUmLowLat> ())
+  {
+    //Copy lte-rlc-um-low-lat.m_txOnBuffer to X2 forwarding buffer.
+    NS_LOG_DEBUG(this << " Copying txonBuffer from RLC UM " << m_rnti);
+    m_x2forwardingBuffer = rlc->GetObject<LteRlcUmLowLat>()->GetTxBuffer();
+    m_x2forwardingBufferSize =  rlc->GetObject<LteRlcUmLowLat>()->GetTxBufferSize();
+  }
+  //LteRlcAm m_txBuffer stores PDCP "PDU".
+  NS_LOG_DEBUG(this << " m_x2forw buffer size = " << m_x2forwardingBufferSize);
+    //Forwarding the packet inside m_x2forwardingBuffer to target eNB.
+
+  // Prepare the variables for the LTE to MmWave DC forward
+  Ptr<McEnbPdcp> mcPdcp;
+  if(mcLteToMmWaveForwarding)
+  {
+    mcPdcp = DynamicCast<McEnbPdcp>(pdcp);
+    NS_ASSERT_MSG(mcPdcp != 0, "Invalid option for standard PDCP");
+    NS_ASSERT_MSG(bid > 0, "Bid can't be 0");
+    NS_ASSERT_MSG(mcPdcp->GetUseMmWaveConnection(), "The McEnbPdcp is not forwarding data to the mmWave eNB, check if the switch happened!");
+  }
+
+  while (!m_x2forwardingBuffer.empty())
+  {
+    NS_LOG_DEBUG(this << " Forwarding m_x2forwardingBuffer to target eNB, gtpTeid = " << gtpTeid );
+    EpcX2Sap::UeDataParams params;
+    params.sourceCellId = m_rrc->m_cellId;
+    params.targetCellId = m_targetCellId;
+    params.gtpTeid = gtpTeid;
+    //Remove tags to get PDCP SDU from PDCP PDU.
+    //Ptr<Packet> rlcSdu =  (*(m_x2forwardingBuffer.begin()))->Copy();
+    Ptr<Packet> rlcSdu =  m_x2forwardingBuffer.at(0);
+    //Tags to be removed from rlcSdu (from outer to inner)
+    //LteRlcSduStatusTag rlcSduStatusTag;
+    //RlcTag  rlcTag; //rlc layer timestamp
+    //PdcpTag pdcpTag;  //pdcp layer timestamp
+    LtePdcpHeader pdcpHeader;
+
+
+    NS_LOG_DEBUG ("RlcSdu size = " << rlcSdu->GetSize() );
+    //rlcSdu->RemoveHeader(pdcpHeader); //remove pdcp header
+
+    //only forward data PDCP PDUs (1-DATA_PDU,0-CTR_PDU)
+    if(rlcSdu->GetSize() >= 3)
+    {
+      rlcSdu->PeekHeader(pdcpHeader);
+      if (pdcpHeader.GetDcBit() == 1 )
+      { //ignore control SDU.
+        NS_LOG_LOGIC ("SEQ = " << pdcpHeader.GetSequenceNumber());
+        NS_LOG_LOGIC ("removed pdcp header, size = " << rlcSdu->GetSize());
+
+        rlcSdu->RemoveAllPacketTags(); // this does not remove byte tags
+        NS_LOG_LOGIC ("removed tags, size = " << rlcSdu->GetSize() );
+        params.ueData = rlcSdu;
+        /*
+        rlcSdu->RemovePacketTag(rlcSduStatusTag); //remove Rlc status tag.
+        NS_LOG_DEBUG ("removed rlc status tag, size = " << rlcSdu->GetSize() );
+        rlcSdu->RemovePacketTag(rlcTag);  //remove Rlc timestamp
+        NS_LOG_DEBUG ("removed rlc timestamp, size = " << rlcSdu->GetSize() );
+        //rlcSdu->RemoveByteTag(pdcpTag); //remove pdcp timestamp
+        //NS_LOG_DEBUG ("removed pdcp timestamp, size = " << rlcSdu->GetSize());
+        */
+
+        if(!mcLteToMmWaveForwarding)
+        {
+          if(!mcMmToMmWaveForwarding)
+          {
+            rlcSdu->RemoveHeader(pdcpHeader); //remove pdcp header
+
+            NS_LOG_INFO("Forward to target cell in HO");
+            m_rrc->m_x2SapProvider->SendUeData (params);
+            NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+            NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+            NS_LOG_LOGIC ("gtpTeid = " << params.gtpTeid);
+            NS_LOG_LOGIC ("ueData = " << params.ueData);
+            NS_LOG_LOGIC ("ueData size = " << params.ueData->GetSize ());
+          }
+          else
+          {
+            NS_LOG_INFO("Forward to target cell RLC in HO");
+            m_rrc->m_x2SapProvider->ForwardRlcPdu (params);
+            NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+            NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+            NS_LOG_LOGIC ("gtpTeid = " << params.gtpTeid);
+            NS_LOG_LOGIC ("ueData = " << params.ueData);
+            NS_LOG_LOGIC ("ueData size = " << params.ueData->GetSize ());
+          }
+        }
+        else // the target eNB has no PDCP entity. Thus re-insert the packets in the
+        // LTE eNB PDCP, which will forward them to the MmWave RLC entity.
+        // Thus this method must be called after the switch to MmWave is done!
+        {
+          rlcSdu->RemoveHeader(pdcpHeader); //remove pdcp header
+          NS_LOG_INFO("Forward to mmWave cell in switch");
+          NS_ASSERT(mcPdcp != 0);
+          NS_ASSERT(mcPdcp->GetUseMmWaveConnection());
+          LtePdcpSapProvider::TransmitPdcpSduParameters pdcpParams;
+          pdcpParams.pdcpSdu = rlcSdu;
+          pdcpParams.rnti = m_rnti;
+          pdcpParams.lcid = Bid2Lcid (bid);
+          mcPdcp->GetLtePdcpSapProvider()->TransmitPdcpSdu(pdcpParams);
+        }
+      }
+    }
+    else
+    {
+      NS_LOG_UNCOND("Too small, not forwarded");
+    }
+    m_x2forwardingBufferSize -= (*(m_x2forwardingBuffer.begin()))->GetSize();
+    m_x2forwardingBuffer.erase (m_x2forwardingBuffer.begin());
+    NS_LOG_LOGIC(this << " After forwarding: buffer size = " << m_x2forwardingBufferSize );
+  }
 }
 
 
@@ -688,7 +1139,7 @@
   return BuildRadioResourceConfigDedicated ();
 }
 
-LteRrcSap::RrcConnectionReconfiguration 
+LteRrcSap::RrcConnectionReconfiguration
 UeManager::GetRrcConnectionReconfigurationForHandover ()
 {
   NS_LOG_FUNCTION (this);
@@ -709,6 +1160,7 @@
 
     case CONNECTED_NORMALLY:
     case CONNECTION_RECONFIGURATION:
+    case MC_CONNECTION_RECONFIGURATION:
     case CONNECTION_REESTABLISHMENT:
     case HANDOVER_PREPARATION:
     case HANDOVER_JOINING:
@@ -736,6 +1188,10 @@
 
     case HANDOVER_LEAVING:
       {
+        NS_LOG_LOGIC("SEQ SEQ HANDOVERLEAVING STATE LTE ENB RRC.");
+        //m_x2forwardingBuffer is empty, forward incomming pkts to target eNB.
+        if (m_x2forwardingBuffer.empty()){
+        NS_LOG_INFO ("forwarding incoming pkts to target eNB over X2-U");
         NS_LOG_LOGIC ("forwarding data to target eNB over X2-U");
         uint8_t drbid = Bid2Drbid (bid);
         EpcX2Sap::UeDataParams params;
@@ -743,8 +1199,22 @@
         params.targetCellId = m_targetCellId;
         params.gtpTeid = GetDataRadioBearerInfo (drbid)->m_gtpTeid;
         params.ueData = p;
+        NS_LOG_LOGIC("PDCP_FORWARDING_SEQ");
+        NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+        NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+        NS_LOG_LOGIC ("gtpTeid = " << params.gtpTeid);
+        NS_LOG_LOGIC ("ueData = " << params.ueData);
+        NS_LOG_LOGIC ("ueData size = " << params.ueData->GetSize ());
         m_rrc->m_x2SapProvider->SendUeData (params);
       }
+      //m_x2forwardingBuffer is not empty, append incomming pkts to m_x2forwardingBuffer.
+      //Forwarding of this m_x2forwardingBuffer is done in RecvHandoverRequestAck
+      else{
+        NS_LOG_INFO ("append incomming pkts to m_x2forwardingBuffer");
+        m_x2forwardingBuffer.push_back(p);
+        //NS_LOG_DEBUG("Forwarding but push_bach to buffer SEQ = " << pdcpHeader.GetSequenceNumber());
+      }
+    }
       break;
 
     default:
@@ -797,7 +1267,7 @@
     }
 }
 
-void 
+void
 UeManager::RecvHandoverPreparationFailure (uint16_t cellId)
 {
   NS_LOG_FUNCTION (this << cellId);
@@ -809,17 +1279,21 @@
       SwitchToState (CONNECTED_NORMALLY);
       break;
 
+    case HANDOVER_LEAVING:
+      NS_ASSERT (cellId == m_targetCellId);
+      NS_LOG_INFO ("target eNB sent HO preparation failure, aborting HO because RrcConnectionReconfigurationCompleted was not received at target");
+      break;
     default:
       NS_FATAL_ERROR ("method unexpected in state " << ToString (m_state));
       break;
     }
 }
 
-void 
+void
 UeManager::RecvSnStatusTransfer (EpcX2SapUser::SnStatusTransferParams params)
 {
   NS_LOG_FUNCTION (this);
-  for (std::vector<EpcX2Sap::ErabsSubjectToStatusTransferItem>::iterator erabIt 
+  for (std::vector<EpcX2Sap::ErabsSubjectToStatusTransferItem>::iterator erabIt
          = params.erabsSubjectToStatusTransferList.begin ();
        erabIt != params.erabsSubjectToStatusTransferList.end ();
        ++erabIt)
@@ -834,18 +1308,156 @@
     }
 }
 
-void 
+void
 UeManager::RecvUeContextRelease (EpcX2SapUser::UeContextReleaseParams params)
 {
   NS_LOG_FUNCTION (this);
   NS_ASSERT_MSG (m_state == HANDOVER_LEAVING, "method unexpected in state " << ToString (m_state));
   m_handoverLeavingTimeout.Cancel ();
+  NS_LOG_INFO("Remove UE " << m_rnti << " from eNB " << m_rrc->m_cellId);
+  if(m_rrc->m_ismmWave && m_isMc)
+  {
+    for (std::map<uint8_t, Ptr<RlcBearerInfo> >::iterator rlcIt = m_rlcMap.begin(); rlcIt != m_rlcMap.end(); ++rlcIt)
+    {
+      NS_LOG_INFO("Remove the X2 forward for TEID " << rlcIt->second->gtpTeid);
+      m_rrc->m_x2SapProvider->RemoveTeidToBeForwarded(rlcIt->second->gtpTeid);
+    }
+  }
 }
 
+void
+UeManager::RecvRlcSetupRequest (EpcX2SapUser::RlcSetupRequest params) // TODO only on MC
+{
+  if(m_isMc)
+  {
+    NS_LOG_INFO("Setup remote RLC in cell " << m_rrc->GetCellId());
+    NS_ASSERT_MSG(m_state==HANDOVER_JOINING || params.mmWaveRnti == m_rnti, "Rnti not correct " << params.mmWaveRnti << " " << m_rnti);
+    // store the params, so that on handover the eNB sends the RLC request
+    // to the othe MmWaveEnb
+    m_rlcRequestVector.push_back(params);
+
+    // setup TEIDs to receive data eventually forwarded over X2-U
+    LteEnbRrc::X2uTeidInfo x2uTeidInfo;
+    x2uTeidInfo.rnti = m_rnti;
+    x2uTeidInfo.drbid = params.drbid;
+    std::pair<std::map<uint32_t, LteEnbRrc::X2uTeidInfo>::iterator, bool> ret;
+    ret = m_rrc->m_x2uMcTeidInfoMap.insert (std::pair<uint32_t, LteEnbRrc::X2uTeidInfo> (params.gtpTeid, x2uTeidInfo));
+    // TODO overwrite may be legit, as in EpcX2::SetMcEpcX2PdcpUser
+    //NS_ASSERT_MSG (ret.second == true, "overwriting a pre-existing entry in m_x2uTeidInfoMap");
+    NS_LOG_INFO("Added entry in m_x2uMcTeidInfoMap");
+
+    // create new Rlc
+    // define a new struct similar to LteDataRadioBearerInfo with only rlc
+    Ptr<RlcBearerInfo> rlcInfo = CreateObject<RlcBearerInfo> ();
+    rlcInfo->targetCellId = params.sourceCellId; // i.e. the LTE cell
+    rlcInfo->gtpTeid = params.gtpTeid;
+    rlcInfo->mmWaveRnti = m_rnti;
+    rlcInfo->lteRnti = params.lteRnti;
+    rlcInfo->drbid = params.drbid;
+    rlcInfo->rlcConfig = params.rlcConfig;
+    rlcInfo->logicalChannelConfig = params.logicalChannelConfig;
+
+    uint8_t lcid = Drbid2Lcid(params.drbid);
+    uint8_t bid = Drbid2Bid (params.drbid);
+
+    EpsBearer bearer;
+    TypeId rlcTypeId = m_rrc->GetRlcType (bearer); // actually, this doesn't depend on bearer
+
+    ObjectFactory rlcObjectFactory;
+    rlcObjectFactory.SetTypeId (rlcTypeId);
+    Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+    NS_LOG_INFO("Created rlc " << rlc);
+    rlc->SetLteMacSapProvider (m_rrc->m_macSapProvider);
+    rlc->SetRnti (m_rnti);
+
+    rlcInfo->m_rlc = rlc;
+
+    rlc->SetLcId (lcid);
+
+    if (rlcTypeId != LteRlcSm::GetTypeId ())
+    {
+      // connect with remote PDCP
+      rlc->SetEpcX2RlcProvider (m_rrc->GetEpcX2RlcProvider());
+      EpcX2Sap::UeDataParams ueParams;
+      ueParams.sourceCellId = m_rrc->GetCellId();
+      ueParams.targetCellId = rlcInfo->targetCellId; // the LTE cell
+      ueParams.gtpTeid = rlcInfo->gtpTeid;
+      rlc->SetUeDataParams(ueParams);
+      m_rrc->m_x2SapProvider->SetEpcX2RlcUser (params.gtpTeid, rlc->GetEpcX2RlcUser());
+    }
+
+    std::vector<LteCcmRrcSapProvider::LcsConfig> lcOnCcMapping = m_rrc->m_ccmRrcSapProvider->SetupDataRadioBearer (bearer, bid, m_rnti, lcid, m_rrc->GetLogicalChannelGroup (bearer), rlc->GetLteMacSapUser ());
+    // LteEnbCmacSapProvider::LcInfo lcinfo;
+    // lcinfo.rnti = m_rnti;
+    // lcinfo.lcId = lcid;
+    // lcinfo.lcGroup = m_rrc->GetLogicalChannelGroup (params.lcinfo.isGbr);
+    // lcinfo.qci = params.lcinfo.qci;
+    // lcinfo.isGbr = params.lcinfo.isGbr;
+    // lcinfo.mbrUl = params.lcinfo.mbrUl;
+    // lcinfo.mbrDl = params.lcinfo.mbrDl;
+    // lcinfo.gbrUl = params.lcinfo.gbrUl;
+    // lcinfo.gbrDl = params.lcinfo.gbrDl;
+    std::vector<LteCcmRrcSapProvider::LcsConfig>::iterator itLcOnCcMapping = lcOnCcMapping.begin ();
+    NS_ASSERT_MSG (itLcOnCcMapping != lcOnCcMapping.end (), "Problem");
+    for (itLcOnCcMapping = lcOnCcMapping.begin (); itLcOnCcMapping != lcOnCcMapping.end (); ++itLcOnCcMapping)
+      {
+        NS_LOG_DEBUG (this << " RNTI " << itLcOnCcMapping->lc.rnti << "Lcid " << (uint16_t) itLcOnCcMapping->lc.lcId << " lcGroup " << (uint16_t) itLcOnCcMapping->lc.lcGroup << " ComponentCarrierId " << itLcOnCcMapping->componentCarrierId);
+        uint8_t index = itLcOnCcMapping->componentCarrierId;
+        LteEnbCmacSapProvider::LcInfo lcinfo = itLcOnCcMapping->lc;
+        LteMacSapUser *msu = itLcOnCcMapping->msu;
+        m_rrc->m_cmacSapProvider.at (index)->AddLc (lcinfo, msu);
+        m_rrc->m_ccmRrcSapProvider->AddLc (lcinfo, msu);
+      }
+
+    //rlcInfo->lcinfo = lcinfo;
+
+    rlcInfo->logicalChannelIdentity = lcid;
+    rlcInfo->logicalChannelConfig.priority = m_rrc->GetLogicalChannelPriority (bearer);
+    rlcInfo->logicalChannelConfig.logicalChannelGroup = m_rrc->GetLogicalChannelGroup (bearer);
+    if (bearer.IsGbr ())
+      {
+        rlcInfo->logicalChannelConfig.prioritizedBitRateKbps = params.logicalChannelConfig.prioritizedBitRateKbps;
+      }
+    else
+      {
+        rlcInfo->logicalChannelConfig.prioritizedBitRateKbps = 0;
+      }
+    rlcInfo->logicalChannelConfig.bucketSizeDurationMs = params.logicalChannelConfig.bucketSizeDurationMs;
+
+    m_rlcMap[params.drbid] = rlcInfo; //TODO add assert
+
+    // callback to notify the BearerConnector that new rlcs are available
+    m_secondaryRlcCreatedTrace(m_imsi, m_rrc->m_cellId, m_rnti);
+
+    if(m_state != HANDOVER_JOINING) // when performing a secondary cell HO do not ack the LTE eNB
+    {
+      // Ack the LTE BS, that will trigger the setup in the UE
+      EpcX2Sap::UeDataParams ackParams;
+      ackParams.sourceCellId = params.targetCellId;
+      ackParams.targetCellId = params.sourceCellId;
+      ackParams.gtpTeid = params.gtpTeid;
+      m_rrc->m_x2SapProvider->SendRlcSetupCompleted(ackParams);
+    }
+  }
+  else
+  {
+    NS_FATAL_ERROR("This is not a MC device");
+  }
+}
+
+void
+UeManager::RecvRlcSetupCompleted(uint8_t drbid)
+{
+  NS_ASSERT_MSG(m_drbMap.find(drbid) != m_drbMap.end(), "The drbid does not match");
+  NS_LOG_INFO("Setup completed for split DataRadioBearer " << (uint16_t)drbid);
+  m_drbMap.find(drbid)->second->m_isMc = true;
+  SwitchToState(PREPARE_MC_CONNECTION_RECONFIGURATION);
+  ScheduleRrcConnectionReconfiguration();
+}
 
 // methods forwarded from RRC SAP
 
-void 
+void
 UeManager::CompleteSetupUe (LteEnbRrcSapProvider::CompleteSetupUeParameters params)
 {
   NS_LOG_FUNCTION (this);
@@ -862,11 +1474,16 @@
     case INITIAL_RANDOM_ACCESS:
       {
         m_connectionRequestTimeout.Cancel ();
+        m_isMc = msg.isMc;
+
 
         if (m_rrc->m_admitRrcConnectionRequest == true)
           {
             m_imsi = msg.ueIdentity;
-            if (m_rrc->m_s1SapProvider != 0)
+            m_rrc->RegisterImsiToRnti(m_imsi, m_rnti);
+            m_rrc->m_mmWaveCellSetupCompleted[m_imsi] = false;
+            NS_LOG_DEBUG("For imsi " << m_imsi << " m_rrc->m_mmWaveCellSetupCompleted[m_imsi] " << m_rrc->m_mmWaveCellSetupCompleted[m_imsi]);
+            if (!m_isMc && m_rrc->m_s1SapProvider != 0)
               {
                 m_rrc->m_s1SapProvider->InitialUeMessage (m_imsi, m_rnti);
               }
@@ -914,6 +1531,17 @@
     {
     case CONNECTION_SETUP:
       m_connectionSetupTimeout.Cancel ();
+      //StartDataRadioBearers ();
+      NS_LOG_INFO("m_firstConnection " << m_firstConnection);
+
+      if (!m_rrc->m_ismmWave)
+      {
+        // the UE is connected to the LTE eNB, now we have to select the best
+        // mmWave eNB. We do it after the CA configuration.
+        m_pendingConnectToMmWave = true; // the UE
+        NS_LOG_INFO ("m_pendingConnectToMmWave " << m_pendingConnectToMmWave);
+      }
+
       if ( m_caSupportConfigured == false && m_rrc->m_numberOfComponentCarriers > 1)
         {
           m_pendingRrcConnectionReconfiguration = true; // Force Reconfiguration
@@ -934,12 +1562,50 @@
     }
 }
 
+bool
+UeManager::GetAllMmWaveInOutageAtInitialAccess()
+{
+  return m_allMmWaveInOutageAtInitialAccess;
+}
+
+void
+UeManager::SetAllMmWaveInOutageAtInitialAccess(bool param)
+{
+  m_allMmWaveInOutageAtInitialAccess = param;
+}
 void
 UeManager::RecvRrcConnectionReconfigurationCompleted (LteRrcSap::RrcConnectionReconfigurationCompleted msg)
 {
   NS_LOG_FUNCTION (this);
   switch (m_state)
     {
+      case MC_CONNECTION_RECONFIGURATION:
+            // cycle on the MC bearers and perform switch to MmWave connection
+        for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it =  m_drbMap.begin ();
+             it != m_drbMap.end ();
+             ++it)
+          {
+            if(it->second->m_isMc)
+            {
+              bool useMmWaveConnection = true;
+              Ptr<McEnbPdcp> pdcp = DynamicCast<McEnbPdcp>(it->second->m_pdcp);
+              if(pdcp != 0)
+              {
+                pdcp->SwitchConnection(useMmWaveConnection);
+                m_rrc->m_lastMmWaveCell[m_imsi] = m_mmWaveCellId;
+                m_rrc->m_mmWaveCellSetupCompleted[m_imsi] = true;
+                NS_LOG_INFO("Imsi " << m_imsi << " m_mmWaveCellSetupCompleted set to " << m_rrc->m_mmWaveCellSetupCompleted[m_imsi] <<
+                  " for cell " <<  m_rrc->m_lastMmWaveCell[m_imsi]);
+                m_rrc->m_imsiUsingLte[m_imsi] = false;
+                ForwardRlcBuffers(it->second->m_rlc, pdcp, it->second->m_gtpTeid, 1, 0, it->first);
+              }
+              else
+              {
+                NS_FATAL_ERROR("A device defined as MC has not a McEnbPdcp");
+              }
+            }
+          }
+      // no break so that also the CONNECTION_RECONFIGURATION code is executed
     case CONNECTION_RECONFIGURATION:
       StartDataRadioBearers ();
       if (m_needPhyMacConfiguration)
@@ -960,7 +1626,34 @@
 
           m_needPhyMacConfiguration = false;
         }
+        if(m_mmWaveCellAvailableForMcSetup)
+        {
+          NS_LOG_INFO("Notify the secondary cell that some bearers' RLC can be setup");
+          NS_ASSERT_MSG((m_mmWaveCellId!=0) && (m_mmWaveRnti!=0), "Unkonwn secondary MmWave cell");
+          RecvRrcSecondaryCellInitialAccessSuccessful(m_mmWaveRnti, m_mmWaveCellId);
+        }
+        if(m_receivedLteMmWaveHandoverCompleted)
+        {
+          NS_LOG_INFO("Notify LteEnbRrc that LTE cell received a NotifyLteMmWaveHandoverCompleted and has completed CONNECTION_RECONFIGURATION");
+          m_rrc->m_mmWaveCellSetupCompleted.find(m_imsi)->second = true;
+          m_rrc->m_imsiUsingLte.find(m_imsi)->second = true;
+        }
+
+        // for IA on LTE eNB, need to wait for CONNECTION_RECONF to be completed and a bearer to be setup
+        if(m_rrc->m_interRatHoMode && m_firstConnection && !m_rrc->m_ismmWave)
+        {
+          m_rrc->m_mmWaveCellSetupCompleted[m_imsi] = true;
+          m_rrc->m_lastMmWaveCell[m_imsi] = m_rrc->m_cellId;
+          m_rrc->m_imsiUsingLte[m_imsi] = true; // the inital connection happened on a LTE eNB
+          m_firstConnection = false;
+        }
       SwitchToState (CONNECTED_NORMALLY);
+      NS_LOG_INFO("m_queuedHandoverRequestCellId " << m_queuedHandoverRequestCellId);
+      if(m_queuedHandoverRequestCellId > 0)
+      {
+        NS_LOG_INFO("Call the postponed PrepareHandover to cell " << m_queuedHandoverRequestCellId);
+        PrepareHandover(m_queuedHandoverRequestCellId);
+      }
       m_rrc->m_connectionReconfigurationTrace (m_imsi, m_rrc->ComponentCarrierToCellId (m_componentCarrierId), m_rnti);
       break;
 
@@ -976,22 +1669,47 @@
     case HANDOVER_JOINING:
       {
         m_handoverJoiningTimeout.Cancel ();
-        NS_LOG_INFO ("Send PATH SWITCH REQUEST to the MME");
-        EpcEnbS1SapProvider::PathSwitchRequestParameters params;
-        params.rnti = m_rnti;
-        params.cellId = m_rrc->ComponentCarrierToCellId (m_componentCarrierId);
-        params.mmeUeS1Id = m_imsi;
-        SwitchToState (HANDOVER_PATH_SWITCH);
-        for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it =  m_drbMap.begin ();
-             it != m_drbMap.end ();
-             ++it)
+        if(!m_isMc)
+        {
+          NS_LOG_INFO ("Send PATH SWITCH REQUEST to the MME");
+          EpcEnbS1SapProvider::PathSwitchRequestParameters params;
+          params.rnti = m_rnti;
+          params.cellId = m_rrc->ComponentCarrierToCellId (m_componentCarrierId);
+          params.mmeUeS1Id = m_imsi;
+          SwitchToState (HANDOVER_PATH_SWITCH);
+          for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it =  m_drbMap.begin ();
+               it != m_drbMap.end ();
+               ++it)
+            {
+              EpcEnbS1SapProvider::BearerToBeSwitched b;
+              b.epsBearerId = it->second->m_epsBearerIdentity;
+              b.teid =  it->second->m_gtpTeid;
+              params.bearersToBeSwitched.push_back (b);
+            }
+
+          m_rrc->m_s1SapProvider->PathSwitchRequest (params);
+        }
+        else
+        {
+          // Send "path switch to the LTE eNB"
+          // The context release will be sent by the LTE eNB
+          NS_LOG_INFO("RRC Reconfiguration completed after secondary cell HO: send path switch to LTE coordinator");
+          EpcX2Sap::SecondaryHandoverCompletedParams params;
+          params.mmWaveRnti = m_rnti;
+          params.oldEnbUeX2apId = m_sourceX2apId;
+          params.imsi = m_imsi;
+          params.cellId = m_rrc->m_lteCellId; // just a placeholder to find the correct X2 socket in EpcX2
+          // Notify the LTE eNB
+          m_rrc->m_handoverEndOkTrace (m_imsi, m_rrc->m_cellId, m_rnti);
+          m_rrc->m_x2SapProvider->SendSecondaryCellHandoverCompleted(params);
+          SwitchToState(CONNECTED_NORMALLY);
+          NS_LOG_INFO("m_queuedHandoverRequestCellId " << m_queuedHandoverRequestCellId);
+          if(m_queuedHandoverRequestCellId > 0)
           {
-            EpcEnbS1SapProvider::BearerToBeSwitched b;
-            b.epsBearerId = it->second->m_epsBearerIdentity;
-            b.teid =  it->second->m_gtpTeid;
-            params.bearersToBeSwitched.push_back (b);
+            NS_LOG_INFO("Call the postponed PrepareHandover to cell " << m_queuedHandoverRequestCellId);
+            PrepareHandover(m_queuedHandoverRequestCellId);
           }
-        m_rrc->m_s1SapProvider->PathSwitchRequest (params);
+        }
       }
       break;
 
@@ -1001,7 +1719,7 @@
     }
 }
 
-void 
+void
 UeManager::RecvRrcConnectionReestablishmentRequest (LteRrcSap::RrcConnectionReestablishmentRequest msg)
 {
   NS_LOG_FUNCTION (this);
@@ -1026,14 +1744,14 @@
   SwitchToState (CONNECTION_REESTABLISHMENT);
 }
 
-void 
+void
 UeManager::RecvRrcConnectionReestablishmentComplete (LteRrcSap::RrcConnectionReestablishmentComplete msg)
 {
   NS_LOG_FUNCTION (this);
   SwitchToState (CONNECTED_NORMALLY);
 }
 
-void 
+void
 UeManager::RecvMeasurementReport (LteRrcSap::MeasurementReport msg)
 {
   uint8_t measId = msg.measResults.measId;
@@ -1085,6 +1803,8 @@
       // this measurement was requested by the FFR function
       m_rrc->m_ffrRrcSapProvider.at (0)->ReportUeMeas (m_rnti, msg.measResults);
     }
+
+
   if (msg.measResults.haveScellsMeas == true)
     {
       for (std::list <LteRrcSap::MeasResultScell>::iterator it = msg.measResults.measScellResultList.measResultScell.begin ();
@@ -1093,7 +1813,7 @@
         {
           m_rrc->m_ffrRrcSapProvider.at (it->servFreqId)->ReportUeMeas (m_rnti, msg.measResults);
           /// ToDo: implement on Ffr algorithm the code to properly parsing the new measResults message format
-          /// alternatevely it is needed to 'repack' properly the measResults message before sending to Ffr 
+          /// alternatevely it is needed to 'repack' properly the measResults message before sending to Ffr
         }
     }
 
@@ -1103,7 +1823,317 @@
   m_rrc->m_recvMeasurementReportTrace (m_imsi, m_rrc->ComponentCarrierToCellId (m_componentCarrierId), m_rnti, msg);
 
 } // end of UeManager::RecvMeasurementReport
+void
+UeManager::RecvRrcSecondaryCellInitialAccessSuccessful(uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+  m_mmWaveCellId = mmWaveCellId;
+  m_mmWaveRnti = mmWaveRnti;
 
+  NS_LOG_INFO("Map size " << m_drbMap.size());
+
+  // If the Map size is > 0 (Bearers already setup in the LTE cell) perform this action
+  // immediately, otherwise wait for the InitialContextSetupResponse in EpcEnbApplication
+  // that calls DataRadioBearerSetupRequest
+  if(m_drbMap.size() == 0)
+  {
+    m_mmWaveCellAvailableForMcSetup = true;
+    NS_LOG_INFO("Postpone RLC setup in the secondary cell since no bearers are yet available");
+    return;
+  }
+  else
+  {
+    for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it = m_drbMap.begin ();
+       it != m_drbMap.end ();
+       ++it)
+    {
+      if(!(it->second->m_isMc) || (it->second->m_isMc && m_rrc->m_lastMmWaveCell.find(m_imsi)->second != m_mmWaveCellId))
+      {
+        Ptr<McEnbPdcp> pdcp = DynamicCast<McEnbPdcp> (it->second->m_pdcp);
+        if (pdcp != 0)
+        {
+          // Get the EPC X2 and set it in the PDCP
+          pdcp->SetEpcX2PdcpProvider(m_rrc->GetEpcX2PdcpProvider());
+          // Set UeDataParams
+          EpcX2Sap::UeDataParams params;
+          params.sourceCellId = m_rrc->GetCellId();
+          params.targetCellId = m_mmWaveCellId;
+          params.gtpTeid = it->second->m_gtpTeid;
+          pdcp->SetUeDataParams(params);
+          pdcp->SetMmWaveRnti(mmWaveRnti);
+          // Setup TEIDs for receiving data eventually forwarded over X2-U
+          LteEnbRrc::X2uTeidInfo x2uTeidInfo;
+          x2uTeidInfo.rnti = m_rnti;
+          x2uTeidInfo.drbid = it->first;
+          std::pair<std::map<uint32_t, LteEnbRrc::X2uTeidInfo>::iterator, bool> ret;
+          ret = m_rrc->m_x2uMcTeidInfoMap.insert (std::pair<uint32_t, LteEnbRrc::X2uTeidInfo> (it->second->m_gtpTeid, x2uTeidInfo));
+          // NS_ASSERT_MSG (ret.second == true, "overwriting a pre-existing entry in m_x2uMcTeidInfoMap");
+          // Setup McEpcX2PdcpUser
+          m_rrc->m_x2SapProvider->SetEpcX2PdcpUser(it->second->m_gtpTeid, pdcp->GetEpcX2PdcpUser());
+
+          // Create a remote RLC, pass along the UeDataParams + mmWaveRnti
+          EpcX2SapProvider::RlcSetupRequest rlcParams = it->second->m_rlcSetupRequest;
+          rlcParams.targetCellId = m_mmWaveCellId;
+          rlcParams.mmWaveRnti = mmWaveRnti;
+
+          m_rrc->m_x2SapProvider->SendRlcSetupRequest(rlcParams);
+        }
+        else
+        {
+          NS_FATAL_ERROR("Trying to setup a MC device with a non MC capable PDCP");
+        }
+      }
+      else
+      {
+        NS_LOG_INFO("MC Bearer already setup"); // TODO consider bearer modifications
+      }
+    }
+  }
+}
+
+void
+UeManager::RecvSecondaryCellHandoverCompleted(EpcX2Sap::SecondaryHandoverCompletedParams params)
+{
+  uint16_t oldMmWaveCellId = m_mmWaveCellId;
+  m_mmWaveCellId = params.cellId;
+  m_mmWaveRnti = params.mmWaveRnti;
+
+  for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it = m_drbMap.begin ();
+     it != m_drbMap.end ();
+     ++it)
+  {
+    if(!(it->second->m_isMc) || (it->second->m_isMc && m_rrc->m_lastMmWaveCell.find(m_imsi)->second != m_mmWaveCellId))
+    {
+      Ptr<McEnbPdcp> pdcp = DynamicCast<McEnbPdcp> (it->second->m_pdcp);
+      if (pdcp != 0)
+      {
+        // Updated UeDataParams in the PDCP instance
+        EpcX2Sap::UeDataParams params;
+        params.sourceCellId = m_rrc->GetCellId();
+        params.targetCellId = m_mmWaveCellId;
+        params.gtpTeid = it->second->m_gtpTeid;
+        pdcp->SetUeDataParams(params);
+        pdcp->SetMmWaveRnti(m_mmWaveRnti);
+        // Update TEIDs for receiving data eventually forwarded over X2-U
+        LteEnbRrc::X2uTeidInfo x2uTeidInfo;
+        x2uTeidInfo.rnti = m_rnti;
+        x2uTeidInfo.drbid = it->first;
+        std::pair<std::map<uint32_t, LteEnbRrc::X2uTeidInfo>::iterator, bool> ret;
+        ret = m_rrc->m_x2uMcTeidInfoMap.insert (std::pair<uint32_t, LteEnbRrc::X2uTeidInfo> (it->second->m_gtpTeid, x2uTeidInfo));
+        // NS_ASSERT_MSG (ret.second == true, "overwriting a pre-existing entry in m_x2uMcTeidInfoMap");
+        // Setup McEpcX2PdcpUser
+        m_rrc->m_x2SapProvider->SetEpcX2PdcpUser(it->second->m_gtpTeid, pdcp->GetEpcX2PdcpUser());
+        // Remote RLC already setup
+
+        m_rrc->m_lastMmWaveCell[m_imsi] = m_mmWaveCellId;
+        m_rrc->m_mmWaveCellSetupCompleted[m_imsi] = true;
+        NS_LOG_INFO("Imsi " << m_imsi << " m_mmWaveCellSetupCompleted set to " << m_rrc->m_mmWaveCellSetupCompleted[m_imsi] <<
+                " for cell " <<  m_rrc->m_lastMmWaveCell[m_imsi]);
+        m_rrc->m_imsiUsingLte[m_imsi] = false;
+
+        pdcp->SwitchConnection(true); // this is needed when an handover happens after coming back from outage
+      }
+      else
+      {
+        NS_FATAL_ERROR("Trying to update a MC device with a non MC capable PDCP");
+      }
+    }
+    else
+    {
+      NS_LOG_INFO("No difference with the MC Bearer already defined"); // TODO consider bearer modifications
+    }
+  }
+
+  // send ContextRelease to the old mmWave eNB
+  NS_LOG_INFO ("Send UE CONTEXT RELEASE from target eNB to source eNB");
+  EpcX2SapProvider::UeContextReleaseParams ueCtxReleaseParams;
+  ueCtxReleaseParams.oldEnbUeX2apId = params.oldEnbUeX2apId;
+  ueCtxReleaseParams.newEnbUeX2apId = m_mmWaveRnti;
+  ueCtxReleaseParams.sourceCellId = oldMmWaveCellId;
+  m_rrc->m_x2SapProvider->SendUeContextRelease (ueCtxReleaseParams);
+}
+
+void
+UeManager::SendRrcConnectionSwitch(bool useMmWaveConnection)
+{
+  LteRrcSap::RrcConnectionSwitch msg;
+  msg.rrcTransactionIdentifier = GetNewRrcTransactionIdentifier();
+  std::vector<uint8_t> drbidVector;
+  for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it =  m_drbMap.begin ();
+     it != m_drbMap.end ();
+     ++it)
+  {
+    if(it->second->m_isMc)
+    {
+      drbidVector.push_back(it->first);
+      Ptr<McEnbPdcp> pdcp = DynamicCast<McEnbPdcp>(it->second->m_pdcp);
+      if(pdcp != 0)
+      {
+        //m_rrc->m_x2SapProvider->
+        pdcp->SwitchConnection(useMmWaveConnection);
+        // forward packets in RLC buffers!
+        // when a switch happens, the swicth target RETX and TXED buffers of RLC AM are emptied, and
+        // the different windows are resetted.
+        // then the switch message is sent and the RLC buffers are fed back to the pdpc
+        if(!m_rrc->m_ismmWave && useMmWaveConnection) //
+        {
+          NS_LOG_INFO("UeManager: forward LTE RLC buffers to mmWave");
+          ForwardRlcBuffers(it->second->m_rlc, it->second->m_pdcp, it->second->m_gtpTeid, 1, 0, it->first);
+          // create a new rlc instance!
+
+          // reset RLC and LC
+          it->second->m_rlc = 0;
+          uint8_t lcid = it->second->m_logicalChannelIdentity;
+          //TODO needs to be corrected
+          //m_rrc->m_cmacSapProvider.at(0)->ReleaseLc(m_rnti, lcid);
+          std::vector<uint8_t> ccToRelease = m_rrc->m_ccmRrcSapProvider->ReleaseDataRadioBearer (m_rnti, lcid);
+          std::vector<uint8_t>::iterator itCcToRelease = ccToRelease.begin ();
+          NS_ASSERT_MSG (itCcToRelease != ccToRelease.end (), "request to remove radio bearer with unknown drbid (ComponentCarrierManager)");
+          for (itCcToRelease = ccToRelease.begin (); itCcToRelease != ccToRelease.end (); ++itCcToRelease)
+            {
+              m_rrc->m_cmacSapProvider.at (*itCcToRelease)->ReleaseLc (m_rnti, lcid);
+            }
+
+          TypeId rlcTypeId = m_rrc->GetRlcType (it->second->m_epsBearer);
+
+          ObjectFactory rlcObjectFactory;
+          rlcObjectFactory.SetTypeId (rlcTypeId);
+          Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+          rlc->SetLteMacSapProvider (m_rrc->m_macSapProvider);
+          rlc->SetRnti (m_rnti);
+
+          it->second->m_rlc = rlc;
+
+          NS_LOG_INFO("Reset RLC in LTE eNB after switch, new rlc " << rlc);
+
+          rlc->SetLcId (lcid);
+
+          // we need PDCP only for real RLC, i.e., RLC/UM or RLC/AM
+          // if we are using RLC/SM we don't care of anything above RLC
+          if (rlcTypeId != LteRlcSm::GetTypeId ())
+          {
+            DynamicCast<McEnbPdcp>(it->second->m_pdcp)->SetLteRlcSapProvider (rlc->GetLteRlcSapProvider ());
+            rlc->SetLteRlcSapUser (DynamicCast<McEnbPdcp>(it->second->m_pdcp)->GetLteRlcSapUser ());
+          }
+
+          uint8_t drbid = it->first;
+          uint8_t bid = Drbid2Bid (drbid);
+
+          std::vector<LteCcmRrcSapProvider::LcsConfig> lcOnCcMapping = m_rrc->m_ccmRrcSapProvider->SetupDataRadioBearer (it->second->m_epsBearer, bid, m_rnti, lcid, m_rrc->GetLogicalChannelGroup (it->second->m_epsBearer), rlc->GetLteMacSapUser ());
+          //LteEnbCmacSapProvider::LcInfo lcinfo;
+          //lcinfo.rnti = m_rnti;
+          //lcinfo.lcId = lcid;
+          //lcinfo.lcGroup = m_rrc->GetLogicalChannelGroup (it->second->m_epsBearer);
+          //lcinfo.qci =   it->second->m_epsBearer.qci;
+          //lcinfo.isGbr = it->second->m_epsBearer.IsGbr ();
+          //lcinfo.mbrUl = it->second->m_epsBearer.gbrQosInfo.mbrUl;
+          //lcinfo.mbrDl = it->second->m_epsBearer.gbrQosInfo.mbrDl;
+          //lcinfo.gbrUl = it->second->m_epsBearer.gbrQosInfo.gbrUl;
+          //lcinfo.gbrDl = it->second->m_epsBearer.gbrQosInfo.gbrDl;
+          //TODO needs to be corrected
+          //m_rrc->m_cmacSapProvider.at(0)->AddLc (lcinfo, rlc->GetLteMacSapUser ());
+          std::vector<LteCcmRrcSapProvider::LcsConfig>::iterator itLcOnCcMapping = lcOnCcMapping.begin ();
+          NS_ASSERT_MSG (itLcOnCcMapping != lcOnCcMapping.end (), "Problem");
+          for (itLcOnCcMapping = lcOnCcMapping.begin (); itLcOnCcMapping != lcOnCcMapping.end (); ++itLcOnCcMapping)
+            {
+              NS_LOG_DEBUG (this << " RNTI " << itLcOnCcMapping->lc.rnti << "Lcid " << (uint16_t) itLcOnCcMapping->lc.lcId << " lcGroup " << (uint16_t) itLcOnCcMapping->lc.lcGroup << " ComponentCarrierId " << itLcOnCcMapping->componentCarrierId);
+              uint8_t index = itLcOnCcMapping->componentCarrierId;
+              LteEnbCmacSapProvider::LcInfo lcinfo = itLcOnCcMapping->lc;
+              LteMacSapUser *msu = itLcOnCcMapping->msu;
+              m_rrc->m_cmacSapProvider.at (index)->AddLc (lcinfo, msu);
+              m_rrc->m_ccmRrcSapProvider->AddLc (lcinfo, msu);
+            }
+        }
+        else if(!m_rrc->m_ismmWave && !useMmWaveConnection)
+        {
+          // switch from mmWave to LTE: it will be the mmWave cell that forwards the data back to LTE
+          EpcX2SapProvider::SwitchConnectionParams params;
+          params.mmWaveRnti = m_mmWaveRnti;
+          params.mmWaveCellId = m_mmWaveCellId;
+          params.useMmWaveConnection = useMmWaveConnection;
+          params.drbid = it->first;
+          m_rrc->m_x2SapProvider->SendSwitchConnectionToMmWave(params);
+        }
+
+      }
+      else
+      {
+        NS_FATAL_ERROR("A device defined as MC has not a McEnbPdcp");
+      }
+    }
+  }
+  msg.drbidList = drbidVector;
+  msg.useMmWaveConnection = useMmWaveConnection;
+  NS_LOG_INFO("SendRrcConnectionSwitch to " << m_rnti << " with useMmWaveConnection " << msg.useMmWaveConnection << " at time " << Simulator::Now().GetSeconds());
+  m_rrc->m_rrcSapUser->SendRrcConnectionSwitch(m_rnti, msg);
+}
+
+void
+UeManager::RecvConnectionSwitchToMmWave (bool useMmWaveConnection, uint8_t drbid)
+{
+  NS_ASSERT_MSG(m_rlcMap.find(drbid) != m_rlcMap.end(), "drbid not found in m_rlcMap");
+  NS_LOG_INFO("RecvConnectionSwitchToMmWave on cell " << m_rrc->m_cellId << " switch " << useMmWaveConnection << " for drbid " << (uint32_t)drbid);
+  if(!useMmWaveConnection)
+  {
+    //Ptr<RlcBearerInfo> rlcInfo = m_rlcMap.find(drbid)->second;
+    m_targetCellId = m_rrc->m_lteCellId;
+    ForwardRlcBuffers(m_rlcMap.find(drbid)->second->m_rlc, 0, m_rlcMap.find(drbid)->second->gtpTeid, 0, 0, 0);
+    // create a new rlc!
+
+    m_rlcMap.find(drbid)->second->m_rlc = 0;
+
+    uint8_t lcid = m_rlcMap.find(drbid)->second->logicalChannelIdentity;
+    //TODO needs to be corrected
+    //m_rrc->m_cmacSapProvider.at(0)->ReleaseLc(m_rnti, lcid);
+    std::vector<uint8_t> ccToRelease = m_rrc->m_ccmRrcSapProvider->ReleaseDataRadioBearer (m_rnti, lcid);
+    std::vector<uint8_t>::iterator itCcToRelease = ccToRelease.begin ();
+    NS_ASSERT_MSG (itCcToRelease != ccToRelease.end (), "request to remove radio bearer with unknown drbid (ComponentCarrierManager)");
+    for (itCcToRelease = ccToRelease.begin (); itCcToRelease != ccToRelease.end (); ++itCcToRelease)
+      {
+        m_rrc->m_cmacSapProvider.at (*itCcToRelease)->ReleaseLc (m_rnti, lcid);
+      }
+
+    EpsBearer bearer;
+    TypeId rlcTypeId = m_rrc->GetRlcType (bearer); // actually, this doesn't depend on bearer
+
+    ObjectFactory rlcObjectFactory;
+    rlcObjectFactory.SetTypeId (rlcTypeId);
+    Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+    NS_LOG_INFO("Reset rlc in mmWave after switch to LTE " << rlc);
+    rlc->SetLteMacSapProvider (m_rrc->m_macSapProvider);
+    rlc->SetRnti (m_rnti);
+
+    m_rlcMap.find(drbid)->second->m_rlc = rlc;
+    rlc->SetLcId (lcid);
+
+    if (rlcTypeId != LteRlcSm::GetTypeId ())
+    {
+      // connect with remote PDCP
+      rlc->SetEpcX2RlcProvider (m_rrc->GetEpcX2RlcProvider());
+      EpcX2Sap::UeDataParams ueParams;
+      ueParams.sourceCellId = m_rrc->GetCellId();
+      ueParams.targetCellId = m_rlcMap.find(drbid)->second->targetCellId; // the LTE cell
+      ueParams.gtpTeid = m_rlcMap.find(drbid)->second->gtpTeid;
+      rlc->SetUeDataParams(ueParams);
+      m_rrc->m_x2SapProvider->SetEpcX2RlcUser (m_rlcMap.find(drbid)->second->gtpTeid, rlc->GetEpcX2RlcUser());
+    }
+    //TODO needs to be corrected
+    //m_rrc->m_cmacSapProvider.at(0)->AddLc (m_rlcMap.find(drbid)->second->lcinfo, rlc->GetLteMacSapUser ());
+
+    std::vector<LteCcmRrcSapProvider::LcsConfig> lcOnCcMapping = m_rrc->m_ccmRrcSapProvider->SetupDataRadioBearer (bearer, Drbid2Bid (drbid), m_rnti, lcid, m_rrc->GetLogicalChannelGroup (bearer), rlc->GetLteMacSapUser ());
+
+    std::vector<LteCcmRrcSapProvider::LcsConfig>::iterator itLcOnCcMapping = lcOnCcMapping.begin ();
+    NS_ASSERT_MSG (itLcOnCcMapping != lcOnCcMapping.end (), "Problem");
+    for (itLcOnCcMapping = lcOnCcMapping.begin (); itLcOnCcMapping != lcOnCcMapping.end (); ++itLcOnCcMapping)
+      {
+        NS_LOG_DEBUG (this << " RNTI " << itLcOnCcMapping->lc.rnti << "Lcid " << (uint16_t) itLcOnCcMapping->lc.lcId << " lcGroup " << (uint16_t) itLcOnCcMapping->lc.lcGroup << " ComponentCarrierId " << itLcOnCcMapping->componentCarrierId);
+        uint8_t index = itLcOnCcMapping->componentCarrierId;
+        LteEnbCmacSapProvider::LcInfo lcinfo = itLcOnCcMapping->lc;
+        LteMacSapUser *msu = itLcOnCcMapping->msu;
+        m_rrc->m_cmacSapProvider.at (index)->AddLc (lcinfo, msu);
+        m_rrc->m_ccmRrcSapProvider->AddLc (lcinfo, msu);
+      }
+  }
+}
 
 // methods forwarded from CMAC SAP
 
@@ -1209,8 +2239,8 @@
 {
   NS_LOG_FUNCTION (this);
   const uint8_t MAX_DRB_ID = 32;
-  for (int drbid = (m_lastAllocatedDrbid + 1) % MAX_DRB_ID; 
-       drbid != m_lastAllocatedDrbid; 
+  for (int drbid = (m_lastAllocatedDrbid + 1) % MAX_DRB_ID;
+       drbid != m_lastAllocatedDrbid;
        drbid = (drbid + 1) % MAX_DRB_ID)
     {
       if (drbid != 0) // 0 is not allowed
@@ -1299,61 +2329,79 @@
       dtam.rlcConfig = it->second->m_rlcConfig;
       dtam.logicalChannelIdentity = it->second->m_logicalChannelIdentity;
       dtam.logicalChannelConfig = it->second->m_logicalChannelConfig;
+      dtam.is_mc = it->second->m_isMc;
       rrcd.drbToAddModList.push_back (dtam);
     }
 
+  if(m_drbMap.size() == 0 && m_isMc && m_rrc->m_ismmWave) // UeManager on a secondary cell for a MC device
+  {
+    for (std::map <uint8_t, Ptr<RlcBearerInfo> >::iterator it = m_rlcMap.begin ();
+       it != m_rlcMap.end ();
+       ++it)
+    {
+      LteRrcSap::DrbToAddMod dtam;
+      dtam.epsBearerIdentity = Drbid2Bid(it->second->drbid);
+      dtam.drbIdentity = it->second->drbid;
+      dtam.rlcConfig = it->second->rlcConfig;
+      dtam.logicalChannelIdentity = it->second->logicalChannelIdentity;
+      dtam.logicalChannelConfig = it->second->logicalChannelConfig;
+      dtam.is_mc = true;
+      rrcd.drbToAddModList.push_back (dtam);
+    }
+  }
+
   rrcd.havePhysicalConfigDedicated = true;
   rrcd.physicalConfigDedicated = m_physicalConfigDedicated;
   return rrcd;
 }
 
-uint8_t 
+uint8_t
 UeManager::GetNewRrcTransactionIdentifier ()
 {
-  ++m_lastRrcTransactionIdentifier;
+  return ++m_lastRrcTransactionIdentifier;
   m_lastRrcTransactionIdentifier %= 4;
   return m_lastRrcTransactionIdentifier;
 }
 
-uint8_t 
+uint8_t
 UeManager::Lcid2Drbid (uint8_t lcid)
 {
   NS_ASSERT (lcid > 2);
   return lcid - 2;
 }
 
-uint8_t 
+uint8_t
 UeManager::Drbid2Lcid (uint8_t drbid)
 {
   return drbid + 2;
 }
-uint8_t 
+uint8_t
 UeManager::Lcid2Bid (uint8_t lcid)
 {
   NS_ASSERT (lcid > 2);
   return lcid - 2;
 }
 
-uint8_t 
+uint8_t
 UeManager::Bid2Lcid (uint8_t bid)
 {
   return bid + 2;
 }
 
-uint8_t 
+uint8_t
 UeManager::Drbid2Bid (uint8_t drbid)
 {
   return drbid;
 }
 
-uint8_t 
+uint8_t
 UeManager::Bid2Drbid (uint8_t bid)
 {
   return bid;
 }
 
 
-void 
+void
 UeManager::SwitchToState (State newState)
 {
   NS_LOG_FUNCTION (this << ToString (newState));
@@ -1375,6 +2423,34 @@
 
     case CONNECTED_NORMALLY:
       {
+        if (m_caSupportConfigured == true && m_pendingConnectToMmWave == true)
+        {
+          // the CA setup is completed. Now we have to connect the UE to the
+          // best mmWave eNB
+
+          m_pendingConnectToMmWave = false;
+          NS_LOG_INFO("Send connect to mmwave");
+          // reply to the UE with a command to connect to the best MmWave eNB
+          if(m_rrc->m_bestMmWaveCellForImsiMap[m_imsi] != m_rrc->GetCellId() && !m_rrc->m_ismmWave)
+          {
+            uint16_t maxSinrCellId = m_rrc->m_bestMmWaveCellForImsiMap[m_imsi];
+            // get the SINR
+            double maxSinrDb = 10*std::log10(m_rrc->m_imsiCellSinrMap.find(m_imsi)->second.find(maxSinrCellId)->second);
+            if(maxSinrDb > m_rrc->m_outageThreshold)
+            {
+              // there is a MmWave cell to which the UE can connect
+              // send the connection message, then, if capable, the UE will connect
+              NS_LOG_INFO("Send connect to " << m_rrc->m_bestMmWaveCellForImsiMap.find(m_imsi)->second << " at least one mmWave eNB is not in outage");
+              m_rrc->m_rrcSapUser->SendRrcConnectToMmWave (m_rnti, m_rrc->m_bestMmWaveCellForImsiMap.find(m_imsi)->second);
+            }
+            else
+            {
+              //TODO
+              m_allMmWaveInOutageAtInitialAccess = true;
+              m_rrc->m_imsiUsingLte[m_imsi] = true;
+            }
+          }
+        }
         if (m_pendingRrcConnectionReconfiguration == true)
           {
             ScheduleRrcConnectionReconfiguration ();
@@ -1400,76 +2476,166 @@
     }
 }
 
+void
+UeManager::SetFirstConnection()
+{
+  m_firstConnection = true;
+}
+
+void
+UeManager::RecvNotifyLteMmWaveHandoverCompleted()
+{
+  NS_LOG_FUNCTION(this << m_state);
+
+  switch(m_state)
+  {
+    case CONNECTED_NORMALLY:
+      m_rrc->m_mmWaveCellSetupCompleted.find(m_imsi)->second = true;
+      NS_LOG_DEBUG("RecvNotifyLteMmWaveHandoverCompleted imsi " << m_imsi << " m_rrc->m_mmWaveCellSetupCompleted[m_imsi] " << m_rrc->m_mmWaveCellSetupCompleted[m_imsi]);
+      m_rrc->m_imsiUsingLte.find(m_imsi)->second = true;
+      break;
+    default:
+      m_receivedLteMmWaveHandoverCompleted = true;
+      break;
+  }
+}
+
 LteRrcSap::NonCriticalExtensionConfiguration
 UeManager::BuildNonCriticalExtentionConfigurationCa ()
 {
   NS_LOG_FUNCTION ( this );
   LteRrcSap::NonCriticalExtensionConfiguration ncec;
-  
+
   //  LteRrcSap::SCellToAddMod scell;
   std::list<LteRrcSap::SCellToAddMod> SccCon;
 
   // sCellToReleaseList is always empty since no Scc is released
 
-  for (auto &it: m_rrc->m_componentCarrierPhyConf)
-    {
-      uint8_t ccId = it.first;
+  if(!m_rrc->m_ismmWave)
+  {
+    for (auto &it: m_rrc->m_componentCarrierPhyConf)
+      {
+        uint8_t ccId = it.first;
+
+        if (ccId == m_componentCarrierId)
+          {
+            // Skip primary CC.
+            continue;
+          }
+        else if (ccId < m_componentCarrierId)
+          {
+            // Shift all IDs below PCC forward so PCC can use CC ID 1.
+            ccId++;
+          }
+
+        Ptr<ComponentCarrierEnb> eNbCcm = it.second;
+        LteRrcSap::SCellToAddMod component;
+        component.sCellIndex = ccId;
+        component.cellIdentification.physCellId = eNbCcm->GetCellId ();
+        component.cellIdentification.dlCarrierFreq = eNbCcm->GetDlEarfcn ();
+        component.radioResourceConfigCommonSCell.haveNonUlConfiguration = true;
+        component.radioResourceConfigCommonSCell.nonUlConfiguration.dlBandwidth = eNbCcm->GetDlBandwidth ();
+        component.radioResourceConfigCommonSCell.nonUlConfiguration.antennaInfoCommon.antennaPortsCount = 0;
+        component.radioResourceConfigCommonSCell.nonUlConfiguration.pdschConfigCommon.referenceSignalPower = m_rrc->m_cphySapProvider.at (0)->GetReferenceSignalPower ();
+        component.radioResourceConfigCommonSCell.nonUlConfiguration.pdschConfigCommon.pb = 0;
+        component.radioResourceConfigCommonSCell.haveUlConfiguration = true;
+        component.radioResourceConfigCommonSCell.ulConfiguration.ulFreqInfo.ulCarrierFreq = eNbCcm->GetUlEarfcn ();
+        component.radioResourceConfigCommonSCell.ulConfiguration.ulFreqInfo.ulBandwidth = eNbCcm->GetUlBandwidth ();
+        component.radioResourceConfigCommonSCell.ulConfiguration.ulPowerControlCommonSCell.alpha = 0;
+        //component.radioResourceConfigCommonSCell.ulConfiguration.soundingRsUlConfigCommon.type = LteRrcSap::SoundingRsUlConfigDedicated::SETUP;
+        component.radioResourceConfigCommonSCell.ulConfiguration.soundingRsUlConfigCommon.srsBandwidthConfig = 0;
+        component.radioResourceConfigCommonSCell.ulConfiguration.soundingRsUlConfigCommon.srsSubframeConfig = 0;
+        component.radioResourceConfigCommonSCell.ulConfiguration.prachConfigSCell.index = 0;
+
+        if (true)
+          {
+            component.haveRadioResourceConfigDedicatedSCell = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveNonUlConfiguration = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveAntennaInfoDedicated = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.antennaInfo.transmissionMode = m_rrc->m_defaultTransmissionMode;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.crossCarrierSchedulingConfig = false;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.havePdschConfigDedicated = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.pdschConfigDedicated.pa = LteRrcSap::PdschConfigDedicated::dB0;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveUlConfiguration = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveAntennaInfoUlDedicated = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.antennaInfoUl.transmissionMode = m_rrc->m_defaultTransmissionMode;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.pushConfigDedicatedSCell.nPuschIdentity = 0;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.ulPowerControlDedicatedSCell.pSrsOffset = 0;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveSoundingRsUlConfigDedicated = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.srsConfigIndex = GetSrsConfigurationIndex();
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.type = LteRrcSap::SoundingRsUlConfigDedicated::SETUP;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.srsBandwidth = 0;
+          }
+        else
+          {
+            component.haveRadioResourceConfigDedicatedSCell = false;
+          }
+        SccCon.push_back (component);
+      }
+  }
+  else
+  {
+    for (auto &it: m_rrc->m_mmWaveComponentCarrierPhyConf)
+      {
+        uint8_t ccId = it.first;
+
+        if (ccId == m_componentCarrierId)
+          {
+            // Skip primary CC.
+            continue;
+          }
+        else if (ccId < m_componentCarrierId)
+          {
+            // Shift all IDs below PCC forward so PCC can use CC ID 1.
+            ccId++;
+          }
+
+        LteEnbRrc::MmWaveComponentCarrierConf eNbCcm = it.second;
+        LteRrcSap::SCellToAddMod component;
+        component.sCellIndex = ccId;
+        component.cellIdentification.physCellId = eNbCcm.m_cellId;
+        //component.cellIdentification.dlCarrierFreq = eNbCcm->GetDlEarfcn ();
+        component.radioResourceConfigCommonSCell.haveNonUlConfiguration = true;
+        component.radioResourceConfigCommonSCell.nonUlConfiguration.dlBandwidth = eNbCcm.m_bandwidth;
+        component.radioResourceConfigCommonSCell.nonUlConfiguration.antennaInfoCommon.antennaPortsCount = 0;
+        component.radioResourceConfigCommonSCell.nonUlConfiguration.pdschConfigCommon.referenceSignalPower = m_rrc->m_cphySapProvider.at (0)->GetReferenceSignalPower ();
+        component.radioResourceConfigCommonSCell.nonUlConfiguration.pdschConfigCommon.pb = 0;
+        component.radioResourceConfigCommonSCell.haveUlConfiguration = true;
+        //component.radioResourceConfigCommonSCell.ulConfiguration.ulFreqInfo.ulCarrierFreq = eNbCcm->GetUlEarfcn ();
+        component.radioResourceConfigCommonSCell.ulConfiguration.ulFreqInfo.ulBandwidth = eNbCcm.m_bandwidth;
+        component.radioResourceConfigCommonSCell.ulConfiguration.ulPowerControlCommonSCell.alpha = 0;
+        //component.radioResourceConfigCommonSCell.ulConfiguration.soundingRsUlConfigCommon.type = LteRrcSap::SoundingRsUlConfigDedicated::SETUP;
+        component.radioResourceConfigCommonSCell.ulConfiguration.soundingRsUlConfigCommon.srsBandwidthConfig = 0;
+        component.radioResourceConfigCommonSCell.ulConfiguration.soundingRsUlConfigCommon.srsSubframeConfig = 0;
+        component.radioResourceConfigCommonSCell.ulConfiguration.prachConfigSCell.index = 0;
+
+        if (true)
+          {
+            component.haveRadioResourceConfigDedicatedSCell = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveNonUlConfiguration = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveAntennaInfoDedicated = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.antennaInfo.transmissionMode = m_rrc->m_defaultTransmissionMode;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.crossCarrierSchedulingConfig = false;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.havePdschConfigDedicated = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.pdschConfigDedicated.pa = LteRrcSap::PdschConfigDedicated::dB0;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveUlConfiguration = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveAntennaInfoUlDedicated = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.antennaInfoUl.transmissionMode = m_rrc->m_defaultTransmissionMode;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.pushConfigDedicatedSCell.nPuschIdentity = 0;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.ulPowerControlDedicatedSCell.pSrsOffset = 0;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveSoundingRsUlConfigDedicated = true;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.srsConfigIndex = GetSrsConfigurationIndex();
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.type = LteRrcSap::SoundingRsUlConfigDedicated::SETUP;
+            component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.srsBandwidth = 0;
+          }
+        else
+          {
+            component.haveRadioResourceConfigDedicatedSCell = false;
+          }
+        SccCon.push_back (component);
+      }
+  }
 
-      if (ccId == m_componentCarrierId)
-        {
-          // Skip primary CC.
-          continue;
-        }
-      else if (ccId < m_componentCarrierId)
-        {
-          // Shift all IDs below PCC forward so PCC can use CC ID 1.
-          ccId++;
-        }
-
-      Ptr<ComponentCarrierEnb> eNbCcm = it.second;
-      LteRrcSap::SCellToAddMod component;
-      component.sCellIndex = ccId;
-      component.cellIdentification.physCellId = eNbCcm->GetCellId ();
-      component.cellIdentification.dlCarrierFreq = eNbCcm->GetDlEarfcn ();
-      component.radioResourceConfigCommonSCell.haveNonUlConfiguration = true;
-      component.radioResourceConfigCommonSCell.nonUlConfiguration.dlBandwidth = eNbCcm->GetDlBandwidth ();
-      component.radioResourceConfigCommonSCell.nonUlConfiguration.antennaInfoCommon.antennaPortsCount = 0;
-      component.radioResourceConfigCommonSCell.nonUlConfiguration.pdschConfigCommon.referenceSignalPower = m_rrc->m_cphySapProvider.at (0)->GetReferenceSignalPower ();
-      component.radioResourceConfigCommonSCell.nonUlConfiguration.pdschConfigCommon.pb = 0;
-      component.radioResourceConfigCommonSCell.haveUlConfiguration = true;
-      component.radioResourceConfigCommonSCell.ulConfiguration.ulFreqInfo.ulCarrierFreq = eNbCcm->GetUlEarfcn ();
-      component.radioResourceConfigCommonSCell.ulConfiguration.ulFreqInfo.ulBandwidth = eNbCcm->GetUlBandwidth ();
-      component.radioResourceConfigCommonSCell.ulConfiguration.ulPowerControlCommonSCell.alpha = 0;
-      //component.radioResourceConfigCommonSCell.ulConfiguration.soundingRsUlConfigCommon.type = LteRrcSap::SoundingRsUlConfigDedicated::SETUP;
-      component.radioResourceConfigCommonSCell.ulConfiguration.soundingRsUlConfigCommon.srsBandwidthConfig = 0;
-      component.radioResourceConfigCommonSCell.ulConfiguration.soundingRsUlConfigCommon.srsSubframeConfig = 0;
-      component.radioResourceConfigCommonSCell.ulConfiguration.prachConfigSCell.index = 0;
-    
-      if (true)
-        {
-          component.haveRadioResourceConfigDedicatedSCell = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveNonUlConfiguration = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveAntennaInfoDedicated = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.antennaInfo.transmissionMode = m_rrc->m_defaultTransmissionMode;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.crossCarrierSchedulingConfig = false;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.havePdschConfigDedicated = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.pdschConfigDedicated.pa = LteRrcSap::PdschConfigDedicated::dB0;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveUlConfiguration = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveAntennaInfoUlDedicated = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.antennaInfoUl.transmissionMode = m_rrc->m_defaultTransmissionMode;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.pushConfigDedicatedSCell.nPuschIdentity = 0;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.ulPowerControlDedicatedSCell.pSrsOffset = 0;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveSoundingRsUlConfigDedicated = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.srsConfigIndex = GetSrsConfigurationIndex();
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.type = LteRrcSap::SoundingRsUlConfigDedicated::SETUP;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.srsBandwidth = 0;
-        }
-      else 
-        {
-          component.haveRadioResourceConfigDedicatedSCell = false;
-        }
-      SccCon.push_back (component);
-    }
   ncec.sCellsToAddModList = SccCon;
 
   return ncec;
@@ -1498,6 +2664,8 @@
     m_srsCurrentPeriodicityId (0),
     m_lastAllocatedConfigurationIndex (0),
     m_reconfigureUes (false),
+    m_firstSibTime (16),
+    m_numNewSinrReports (0),
     m_numberOfComponentCarriers (0),
     m_carriersConfigured (false)
 {
@@ -1510,6 +2678,12 @@
   m_x2SapUser = new EpcX2SpecificEpcX2SapUser<LteEnbRrc> (this);
   m_s1SapUser = new MemberEpcEnbS1SapUser<LteEnbRrc> (this);
   m_cphySapUser.push_back (new MemberLteEnbCphySapUser<LteEnbRrc> (this));
+
+  m_imsiCellSinrMap.clear();
+  m_x2_received_cnt = 0;
+  m_switchEnabled = true;
+  m_lteCellId = 0;
+
   m_ccmRrcSapUser = new MemberLteCcmRrcSapUser <LteEnbRrc>(this);
   m_cphySapProvider.push_back (0);
   m_cmacSapProvider.push_back (0);
@@ -1538,6 +2712,30 @@
   Object::DoInitialize ();
 }
 
+void
+LteEnbRrc::ConfigureMmWaveCarriers (std::map<uint8_t, LteEnbRrc::MmWaveComponentCarrierConf> ccPhyConf)
+{
+  NS_LOG_FUNCTION(this);
+  //TODO do we need to duplicate all the CC paramenters to support mmwave carriers?
+  NS_ASSERT_MSG (!m_carriersConfigured, "Secondary carriers can be configured only once.");
+  m_mmWaveComponentCarrierPhyConf = ccPhyConf;
+  m_numberOfComponentCarriers = ccPhyConf.size ();
+
+  NS_ASSERT (m_numberOfComponentCarriers >= MIN_NO_MMW_CC && m_numberOfComponentCarriers <= MAX_NO_MMW_CC);
+
+  for (uint8_t i = 1; i < m_numberOfComponentCarriers; i++)
+    {
+      m_cphySapUser.push_back (new MemberLteEnbCphySapUser<LteEnbRrc> (this));
+      m_cmacSapUser.push_back (new EnbRrcMemberLteEnbCmacSapUser (this, i));
+      //m_ffrRrcSapUser.push_back (new MemberLteFfrRrcSapUser<LteEnbRrc> (this));
+      m_cphySapProvider.push_back (0);
+      m_cmacSapProvider.push_back (0);
+      //m_ffrRrcSapProvider.push_back (0);
+    }
+  m_carriersConfigured = true;
+  Object::DoInitialize ();
+}
+
 LteEnbRrc::~LteEnbRrc ()
 {
   NS_LOG_FUNCTION (this);
@@ -1552,18 +2750,25 @@
     {
       delete m_cphySapUser[i];
       delete m_cmacSapUser[i];
-      delete m_ffrRrcSapUser[i];
+
+      //If this LteEnbRrc is part of a mmwave enb device, m_ffrRrcSapUser
+      //contains one (dummy) element only, the one associated to the PCC which is
+      //instantiated in the constructor.
+      if( !(m_ismmWave == true && i > 0) )
+      {
+        delete m_ffrRrcSapUser[i];
+      }
     }
-  //delete m_cphySapUser;        
+  //delete m_cphySapUser;
   m_cphySapUser.erase (m_cphySapUser.begin (),m_cphySapUser.end ());
-  m_cphySapUser.clear ();  
+  m_cphySapUser.clear ();
   //delete m_cmacSapUser;
   m_cmacSapUser.erase (m_cmacSapUser.begin (),m_cmacSapUser.end ());
-  m_cmacSapUser.clear ();  
+  m_cmacSapUser.clear ();
   //delete m_ffrRrcSapUser;
   m_ffrRrcSapUser.erase (m_ffrRrcSapUser.begin (),m_ffrRrcSapUser.end ());
   m_ffrRrcSapUser.clear ();
-  m_ueMap.clear ();  
+  m_ueMap.clear ();
   delete m_handoverManagementSapUser;
   delete m_ccmRrcSapUser;
   delete m_anrSapUser;
@@ -1590,25 +2795,26 @@
                    UintegerValue (0),  // default tx-mode
                    MakeUintegerAccessor (&LteEnbRrc::m_defaultTransmissionMode),
                    MakeUintegerChecker<uint8_t> ())
-    .AddAttribute ("EpsBearerToRlcMapping", 
+    .AddAttribute ("EpsBearerToRlcMapping",
                    "Specify which type of RLC will be used for each type of EPS bearer. ",
                    EnumValue (RLC_SM_ALWAYS),
                    MakeEnumAccessor (&LteEnbRrc::m_epsBearerToRlcMapping),
                    MakeEnumChecker (RLC_SM_ALWAYS, "RlcSmAlways",
                                     RLC_UM_ALWAYS, "RlcUmAlways",
                                     RLC_AM_ALWAYS, "RlcAmAlways",
-                                    PER_BASED,     "PacketErrorRateBased"))
+                                    PER_BASED,     "PacketErrorRateBased",
+                                    RLC_UM_LOWLAT_ALWAYS, "MmwRlcUmAlways"))
     .AddAttribute ("SystemInformationPeriodicity",
                    "The interval for sending system information (Time value)",
-                   TimeValue (MilliSeconds (80)),
+                   TimeValue (MilliSeconds (5)),
                    MakeTimeAccessor (&LteEnbRrc::m_systemInformationPeriodicity),
                    MakeTimeChecker ())
 
     // SRS related attributes
     .AddAttribute ("SrsPeriodicity",
                    "The SRS periodicity in milliseconds",
-                   UintegerValue (40),
-                   MakeUintegerAccessor (&LteEnbRrc::SetSrsPeriodicity, 
+                   UintegerValue (320),
+                   MakeUintegerAccessor (&LteEnbRrc::SetSrsPeriodicity,
                                          &LteEnbRrc::GetSrsPeriodicity),
                    MakeUintegerChecker<uint32_t> ())
 
@@ -1643,16 +2849,21 @@
                    "X2 HO REQ ACK by source eNB, transmission of the Handover "
                    "Command, non-contention-based random access and reception "
                    "of the RRC CONNECTION RECONFIGURATION COMPLETE message.",
-                   TimeValue (MilliSeconds (200)),
+                   TimeValue (Seconds (45)),
                    MakeTimeAccessor (&LteEnbRrc::m_handoverJoiningTimeoutDuration),
                    MakeTimeChecker ())
     .AddAttribute ("HandoverLeavingTimeoutDuration",
                    "After issuing a Handover Command, if neither RRC "
                    "CONNECTION RE-ESTABLISHMENT nor X2 UE Context Release has "
                    "been previously received, the UE context is destroyed.",
-                   TimeValue (MilliSeconds (500)),
+                   TimeValue (Seconds (45)),
                    MakeTimeAccessor (&LteEnbRrc::m_handoverLeavingTimeoutDuration),
                    MakeTimeChecker ())
+     .AddAttribute ("OutageThreshold",
+                    "SNR threshold for outage events [dB]",
+                    DoubleValue (-5.0),
+                    MakeDoubleAccessor (&LteEnbRrc::m_outageThreshold),
+                    MakeDoubleChecker<long double> (-10000.0, 10.0))
 
     // Cell selection related attribute
     .AddAttribute ("QRxLevMin",
@@ -1702,7 +2913,69 @@
                    UintegerValue (4),
                    MakeUintegerAccessor (&LteEnbRrc::m_rsrqFilterCoefficient),
                    MakeUintegerChecker<uint8_t> (0))
-
+   .AddAttribute ("mmWaveDevice",
+            "Indicates whether RRC is for mmWave base station",
+            BooleanValue (false),
+            MakeBooleanAccessor (&LteEnbRrc::m_ismmWave),
+            MakeBooleanChecker ())
+   .AddAttribute ("FirstSibTime",
+                  "Time in ms of initial SIB message",
+                  // i.e. the variable k in 3GPP TS 36.331 section 5.5.3.2
+                  UintegerValue (2),
+                  MakeUintegerAccessor (&LteEnbRrc::m_firstSibTime),
+                  MakeUintegerChecker<uint32_t> (0))
+   .AddAttribute ("InterRatHoMode",
+            "Indicates whether RRC is for LTE base station that coordinates InterRatHo among eNBs",
+            BooleanValue (false),
+            MakeBooleanAccessor (&LteEnbRrc::m_interRatHoMode),
+            MakeBooleanChecker ())
+   .AddAttribute ("HoSinrDifference",
+            "The value for which an handover between MmWave eNB is triggered",
+            DoubleValue (3),
+            MakeDoubleAccessor (&LteEnbRrc::m_sinrThresholdDifference),
+            MakeDoubleChecker<double> ())
+   .AddAttribute ("SecondaryCellHandoverMode",
+       "Select the secondary cell handover mode",
+        EnumValue (DYNAMIC_TTT),
+        MakeEnumAccessor (&LteEnbRrc::m_handoverMode),
+        MakeEnumChecker (FIXED_TTT, "FixedTtt",
+                 DYNAMIC_TTT, "DynamicTtt",
+                 THRESHOLD, "Threshold"))
+   .AddAttribute ("FixedTttValue",
+       "The value of TTT in case of fixed TTT handover (in ms)",
+       UintegerValue(110),
+       MakeUintegerAccessor(&LteEnbRrc::m_fixedTttValue),
+       MakeUintegerChecker<uint8_t>()) // TODO consider using a TimeValue
+   .AddAttribute ("MinDynTttValue",
+       "The minimum value of TTT in case of dynamic TTT handover (in ms)",
+       UintegerValue(25),
+       MakeUintegerAccessor(&LteEnbRrc::m_minDynTttValue),
+       MakeUintegerChecker<uint8_t>()) // TODO consider using a TimeValue
+   .AddAttribute ("MaxDynTttValue",
+       "The maximum value of TTT in case of dynamic TTT handover (in ms)",
+       UintegerValue(150),
+       MakeUintegerAccessor(&LteEnbRrc::m_maxDynTttValue),
+       MakeUintegerChecker<uint8_t>()) // TODO consider using a TimeValue
+   .AddAttribute ("MinDiffValue",
+       "The minimum value of the difference in case of dynamic TTT handover [dB]",
+       DoubleValue(3),
+       MakeDoubleAccessor(&LteEnbRrc::m_minDiffTttValue),
+       MakeDoubleChecker<double>()) // TODO set the proper value
+   .AddAttribute ("MaxDiffValue",
+       "The maximum value of the difference in case of dynamic TTT handover [dB]",
+       DoubleValue(20),
+       MakeDoubleAccessor(&LteEnbRrc::m_maxDiffTttValue),
+       MakeDoubleChecker<double>()) // TODO set the proper value
+   .AddAttribute ("CrtPeriod",
+       "The periodicity of a CRT (us)",
+       IntegerValue(1600),
+       MakeIntegerAccessor(&LteEnbRrc::m_crtPeriod),
+       MakeIntegerChecker<int>()) // TODO consider using a TimeValue
+   .AddAttribute ("ReportAllUeMeas",
+            "If true, the MmWave eNB sends to the LTE coordinator all the received UE measures (one per CC). If false, it sends only the maximum measures",
+            BooleanValue (true),
+            MakeBooleanAccessor (&LteEnbRrc::m_reportAllUeMeas),
+            MakeBooleanChecker ())
     // Trace sources
     .AddTraceSource ("NewUeContext",
                      "Fired upon creation of a new UE context.",
@@ -1728,6 +3001,10 @@
                      "trace fired when measurement report is received",
                      MakeTraceSourceAccessor (&LteEnbRrc::m_recvMeasurementReportTrace),
                      "ns3::LteEnbRrc::ReceiveReportTracedCallback")
+     .AddTraceSource ("NotifyMmWaveSinr",
+                  "trace fired when measurement report is received from mmWave cells, for each cell, for each UE",
+                  MakeTraceSourceAccessor (&LteEnbRrc::m_notifyMmWaveSinrTrace),
+                "ns3::LteEnbRrc::NotifyMmWaveSinrTracedCallback")
   ;
   return tid;
 }
@@ -1747,6 +3024,32 @@
 }
 
 void
+LteEnbRrc::SetEpcX2PdcpProvider (EpcX2PdcpProvider * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_x2PdcpProvider = s;
+}
+
+void
+LteEnbRrc::SetEpcX2RlcProvider (EpcX2RlcProvider * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_x2RlcProvider = s;
+}
+
+EpcX2PdcpProvider*
+LteEnbRrc::GetEpcX2PdcpProvider () const
+{
+  return m_x2PdcpProvider;
+}
+
+EpcX2RlcProvider*
+LteEnbRrc::GetEpcX2RlcProvider () const
+{
+  return m_x2RlcProvider;
+}
+
+void
 LteEnbRrc::SetLteEnbCmacSapProvider (LteEnbCmacSapProvider * s)
 {
   NS_LOG_FUNCTION (this << s);
@@ -1866,14 +3169,14 @@
   m_macSapProvider = s;
 }
 
-void 
+void
 LteEnbRrc::SetS1SapProvider (EpcEnbS1SapProvider * s)
 {
   m_s1SapProvider = s;
 }
 
 
-EpcEnbS1SapUser* 
+EpcEnbS1SapUser*
 LteEnbRrc::GetS1SapUser ()
 {
   return m_s1SapUser;
@@ -1925,6 +3228,60 @@
   return it->second;
 }
 
+void
+LteEnbRrc::RegisterImsiToRnti(uint64_t imsi, uint16_t rnti)
+{
+  if(m_imsiRntiMap.find(imsi) == m_imsiRntiMap.end())
+  {
+    m_imsiRntiMap.insert(std::pair<uint64_t, uint16_t> (imsi, rnti));
+    NS_LOG_INFO("New entry in m_imsiRntiMap, for rnti " << rnti << " m_interRatHoMode " << m_interRatHoMode << " m_ismmWave " << m_ismmWave);
+    if(m_interRatHoMode) // warn the UeManager that this is the first time a UE with a certain imsi
+      // connects to this MmWave eNB. This will trigger a notification to the LTE RRC once RecvRrcReconfCompleted is called
+    {
+      GetUeManager(rnti)->SetFirstConnection();
+    }
+  }
+  else
+  {
+    m_imsiRntiMap.find(imsi)->second = rnti;
+  }
+
+  if(m_rntiImsiMap.find(rnti) == m_rntiImsiMap.end())
+  {
+    m_rntiImsiMap.insert(std::pair<uint16_t, uint64_t> (rnti, imsi));
+  }
+  else
+  {
+    m_rntiImsiMap.find(rnti)->second = imsi;
+  }
+}
+
+uint16_t
+LteEnbRrc::GetRntiFromImsi(uint64_t imsi)
+{
+  if(m_imsiRntiMap.find(imsi) != m_imsiRntiMap.end())
+  {
+    return m_imsiRntiMap.find(imsi)->second;
+  }
+  else
+  {
+    return 0;
+  }
+}
+
+uint64_t
+LteEnbRrc::GetImsiFromRnti(uint16_t rnti)
+{
+  if(m_rntiImsiMap.find(rnti) != m_rntiImsiMap.end())
+  {
+    return m_rntiImsiMap.find(rnti)->second;
+  }
+  else
+  {
+    return 0;
+  }
+}
+
 uint8_t
 LteEnbRrc::AddUeMeasReportConfig (LteRrcSap::ReportConfigEutra config)
 {
@@ -2022,7 +3379,9 @@
   uint8_t dlBandwidth = it->second->GetDlBandwidth ();
   uint32_t ulEarfcn = it->second->GetUlEarfcn ();
   uint32_t dlEarfcn = it->second->GetDlEarfcn ();
-  NS_LOG_FUNCTION (this << (uint16_t) ulBandwidth << (uint16_t) dlBandwidth
+  uint16_t cellId = it->second->GetCellId ();
+  NS_LOG_FUNCTION (this << cellId
+                        << (uint16_t) ulBandwidth << (uint16_t) dlBandwidth
                         << ulEarfcn << dlEarfcn);
   NS_ASSERT (!m_configured);
 
@@ -2040,6 +3399,8 @@
   m_ulEarfcn = ulEarfcn;
   m_dlBandwidth = dlBandwidth;
   m_ulBandwidth = ulBandwidth;
+  m_cellId = cellId; // RRC cellId is equal to the cellId of the primary carrier
+
 
   /*
    * Initializing the list of UE measurement configuration (m_ueMeasConfig).
@@ -2092,11 +3453,109 @@
    * SystemInformationPeriodicity attribute to configure this).
    */
   Simulator::Schedule (MilliSeconds (16), &LteEnbRrc::SendSystemInformation, this);
+  m_imsiCellSinrMap.clear();
+  m_firstReport = true;
+  m_configured = true;
+
+}
+
+void
+LteEnbRrc::ConfigureCell (std::map<uint8_t, MmWaveComponentCarrierConf> ccPhyConf)
+{
+  NS_LOG_FUNCTION(this);
+  auto it = ccPhyConf.begin ();
+  NS_ASSERT (it != ccPhyConf.end ());
+  uint8_t bandwidth = it->second.m_bandwidth; // this information is not used
+  //uint32_t earfcn = it->second->GetEarfcn ();
+  uint16_t cellId = it->second.m_cellId;
+  //NS_LOG_FUNCTION (this << (uint16_t) bandwidth << earfcn);
+  NS_ASSERT (!m_configured);
+
+  //m_dlEarfcn = earfcn;
+  //m_ulEarfcn = earfcn;
+  //m_dlBandwidth = bandwidth;
+  //m_ulBandwidth = bandwidth;
+
+  m_dlBandwidth = 6; //this information is not used in case of mmwave dev, we set it to the default value
+  m_ulBandwidth = 6; //this information is not used in case of mmwave dev, we set it to the default value
+  m_cellId = cellId; // RRC cellId is equal to the cellId of the primary carrier
+
+  for (const auto &it: ccPhyConf)
+    {
+      bandwidth = it.second.m_bandwidth;
+      m_cphySapProvider.at (it.first)->SetBandwidth (bandwidth, bandwidth);
+      //earfcn = it.second->GetEarfcn ();
+      //m_cphySapProvider.at (it.first)->SetEarfcn (earfcn, earfcn);
+      m_cphySapProvider.at (it.first)->SetCellId (it.second.m_cellId);
+      m_cmacSapProvider.at (it.first)->ConfigureMac (bandwidth, bandwidth);
+      //m_ffrRrcSapProvider.at (it.first)->SetCellId (it.second->GetCellId ());
+      //m_ffrRrcSapProvider.at (it.first)->SetBandwidth (bandwidth, bandwidth);
+    }
+
+  /*
+   * Initializing the list of UE measurement configuration (m_ueMeasConfig).
+   * Only intra-frequency measurements are supported, so only one measurement
+   * object is created.
+   */
+
+  LteRrcSap::MeasObjectToAddMod measObject;
+  measObject.measObjectId = 1;
+  measObject.measObjectEutra.carrierFreq = m_dlEarfcn;
+  measObject.measObjectEutra.allowedMeasBandwidth = m_dlBandwidth;
+  measObject.measObjectEutra.presenceAntennaPort1 = false;
+  measObject.measObjectEutra.neighCellConfig = 0;
+  measObject.measObjectEutra.offsetFreq = 0;
+  measObject.measObjectEutra.haveCellForWhichToReportCGI = false;
+
+  m_ueMeasConfig.measObjectToAddModList.push_back (measObject);
+  m_ueMeasConfig.haveQuantityConfig = true;
+  m_ueMeasConfig.quantityConfig.filterCoefficientRSRP = m_rsrpFilterCoefficient;
+  m_ueMeasConfig.quantityConfig.filterCoefficientRSRQ = m_rsrqFilterCoefficient;
+  m_ueMeasConfig.haveMeasGapConfig = false;
+  m_ueMeasConfig.haveSmeasure = false;
+  m_ueMeasConfig.haveSpeedStatePars = false;
 
+  m_sib1.clear ();
+  m_sib1.reserve (ccPhyConf.size ());
+  for (const auto &it: ccPhyConf)
+    {
+      // Enabling MIB transmission
+      LteRrcSap::MasterInformationBlock mib;
+      mib.dlBandwidth = it.second.m_bandwidth;
+      mib.systemFrameNumber = 0;
+      m_cphySapProvider.at (it.first)->SetMasterInformationBlock (mib);
+
+      // Enabling SIB1 transmission with default values
+      LteRrcSap::SystemInformationBlockType1 sib1;
+      sib1.cellAccessRelatedInfo.cellIdentity = it.second.m_cellId;
+      sib1.cellAccessRelatedInfo.csgIndication = false;
+      sib1.cellAccessRelatedInfo.csgIdentity = 0;
+      sib1.cellAccessRelatedInfo.plmnIdentityInfo.plmnIdentity = 0; // not used
+      sib1.cellSelectionInfo.qQualMin = -34; // not used, set as minimum value
+      sib1.cellSelectionInfo.qRxLevMin = m_qRxLevMin; // set as minimum value
+      m_sib1.push_back (sib1);
+      m_cphySapProvider.at (it.first)->SetSystemInformationBlockType1 (sib1);
+    }
+  /*
+   * Enabling transmission of other SIB. The first time System Information is
+   * transmitted is arbitrarily assumed to be at +0.016s, and then it will be
+   * regularly transmitted every 80 ms by default (set the
+   * SystemInformationPeriodicity attribute to configure this).
+   */
+   // mmWave module: Changed scheduling of initial system information to +2ms
+  Simulator::Schedule (MilliSeconds (m_firstSibTime), &LteEnbRrc::SendSystemInformation, this);
+  m_imsiCellSinrMap.clear();
+  m_firstReport = true;
   m_configured = true;
 
 }
 
+void
+LteEnbRrc::SetInterRatHoMode(void)
+{
+  m_interRatHoMode = true;
+}
+
 
 void
 LteEnbRrc::SetCellId (uint16_t cellId)
@@ -2114,15 +3573,878 @@
   m_cphySapProvider.at (ccIndex)->SetSystemInformationBlockType1 (m_sib1.at (ccIndex));
 }
 
+void
+LteEnbRrc::SetClosestLteCellId (uint16_t cellId)
+{
+  m_lteCellId = cellId;
+  NS_LOG_LOGIC("Closest Lte CellId set to " << m_lteCellId);
+}
+
+uint16_t
+LteEnbRrc::GetCellId () const
+{
+  return m_cellId;
+}
+
+void
+LteEnbRrc::DoUpdateUeSinrEstimate(LteEnbCphySapUser::UeAssociatedSinrInfo info)
+{
+  NS_LOG_FUNCTION(this);
+
+  NS_LOG_INFO ("CC " << (uint16_t)info.componentCarrierId << " reports the ueImsiSinrMap");
+  m_ueImsiSinrMap[info.componentCarrierId]=info.ueImsiSinrMap; // store the received report in m_ueImsiSinrMap
+
+  // TODO report immediately or with some filtering
+  if(m_lteCellId > 0) // i.e., only if a LTE eNB was actually registered in the scenario
+                      // (this is done when an X2 interface among mmWave eNBs and LTE eNB is added)
+  {
+    // send the report to the LTE coordinator
+    EpcX2SapProvider::UeImsiSinrParams params;
+    params.targetCellId = m_lteCellId;
+    params.sourceCellId = m_cellId;
+
+    //if (m_reportAllUeMeas == true)
+    if(false)
+    {
+      params.ueImsiSinrMap = info.ueImsiSinrMap;
+      m_ueImsiSinrMap.clear(); // delete the reports
+    }
+    else
+    {
+      if (m_ueImsiSinrMap.size() == m_numberOfComponentCarriers) // if we received the ueImsiSinrMap report from all the CCs
+      {
+        // Build the ueImsiSinrMapToSend containing, for each UE, the max SINR among all the CCs
+        NS_LOG_DEBUG ("Number of ueImsiSinrMaps in m_ueImsiSinrMap " << (uint16_t)m_ueImsiSinrMap.size() );
+
+        std::map<uint64_t, double> ueImsiSinrMapToSend; // map which contains the max SINR for each UE among the CCs
+        ueImsiSinrMapToSend = m_ueImsiSinrMap.at(0); // initialization
+
+        for(uint8_t cc = 1; cc < m_numberOfComponentCarriers; cc++)
+        {
+          NS_ASSERT_MSG (m_ueImsiSinrMap.find(cc) != m_ueImsiSinrMap.end(), "CC " << (uint16_t)cc << " didn't report the ueImsiSinrMap");
+
+          for (std::map<uint64_t, double>::iterator ue = ueImsiSinrMapToSend.begin(); ue != ueImsiSinrMapToSend.end(); ue++)
+          {
+            NS_ASSERT_MSG (m_ueImsiSinrMap.at(cc).find(ue->first) != m_ueImsiSinrMap.at(cc).end(), "CC " << (uint16_t)cc << " didn't report SINR for UE "<< ue->first );
+
+            NS_LOG_DEBUG ("UE " << ue->first << " current SINR " << ue->second << " is higher than " << m_ueImsiSinrMap.at(cc).at(ue->first) << " ?");
+            if (ue->second < m_ueImsiSinrMap.at(cc).at(ue->first))
+            {
+              NS_LOG_DEBUG ("No, update SINR to " << m_ueImsiSinrMap.at(cc).at(ue->first));
+              ue->second = m_ueImsiSinrMap.at(cc).at(ue->first); // insert the max SINR for this UE among all the CCs
+            }
+          }
+        }
+        params.ueImsiSinrMap = ueImsiSinrMapToSend;
+        m_ueImsiSinrMap.clear(); // delete the reports
+      }
+    }
+
+    NS_LOG_INFO("number of SINR reported " << params.ueImsiSinrMap.size());
+    m_x2SapProvider->SendUeSinrUpdate (params);
+  }
+
+}
+
+void
+LteEnbRrc::DoRecvUeSinrUpdate(EpcX2SapUser::UeImsiSinrParams params)
+{
+  NS_LOG_FUNCTION(this);
+  NS_LOG_LOGIC("Recv Ue SINR Update from cell " << params.sourceCellId);
+  uint16_t mmWaveCellId = params.sourceCellId;
+  if(m_cellSinrMap.find(mmWaveCellId) != m_cellSinrMap.end())
+  {     // update the entry
+    m_cellSinrMap[mmWaveCellId] = params.ueImsiSinrMap;
+    m_numNewSinrReports++;
+  }
+  else  // add the entry
+  {
+    m_cellSinrMap.insert(std::pair<uint16_t, ImsiSinrMap> (mmWaveCellId, params.ueImsiSinrMap));
+    m_numNewSinrReports++;
+  }
+  // cycle on all the Imsi whose SINR is known in cell mmWaveCellId
+  for(std::map<uint64_t, double>::iterator imsiIter = params.ueImsiSinrMap.begin(); imsiIter != params.ueImsiSinrMap.end(); ++imsiIter)
+  {
+    uint64_t imsi = imsiIter->first;
+    double sinr = imsiIter->second;
+
+    m_notifyMmWaveSinrTrace(imsi, mmWaveCellId, sinr);
+
+    NS_LOG_LOGIC("Imsi " << imsi << " sinr " << sinr);
+
+    if(m_imsiCellSinrMap.find(imsi) != m_imsiCellSinrMap.end())
+    {
+      if(m_imsiCellSinrMap[imsi].find(mmWaveCellId) != m_imsiCellSinrMap[imsi].end())
+      {
+        // update the SINR measure
+        m_imsiCellSinrMap[imsi].find(mmWaveCellId)->second = sinr;
+      }
+      else // new cell for this Imsi
+      {
+        // insert a new SINR measure
+        m_imsiCellSinrMap[imsi].insert(std::pair<uint16_t, double>(mmWaveCellId, sinr));
+      }
+    }
+    else // new imsi
+    {
+      CellSinrMap map;
+      map.insert(std::pair<uint16_t, double>(mmWaveCellId, sinr));
+      m_imsiCellSinrMap.insert(std::pair<uint64_t, CellSinrMap> (imsi, map));
+    }
+  }
+
+  for(std::map<uint64_t, CellSinrMap>::iterator imsiIter = m_imsiCellSinrMap.begin(); imsiIter != m_imsiCellSinrMap.end(); ++imsiIter)
+  {
+    NS_LOG_LOGIC("Imsi " << imsiIter->first);
+    for(CellSinrMap::iterator cellIter = imsiIter->second.begin(); cellIter != imsiIter->second.end(); ++cellIter)
+    {
+      NS_LOG_LOGIC("mmWaveCell " << cellIter->first << " sinr " <<  cellIter->second);
+    }
+  }
+
+  if(!m_ismmWave && !m_interRatHoMode && m_firstReport)
+  {
+    m_firstReport = false;
+    switch(m_handoverMode)
+    {
+      case FIXED_TTT : NS_LOG_INFO("Handover Mode: Fixed TTT"); break;
+      case DYNAMIC_TTT : NS_LOG_INFO("Handover Mode: Dynamic TTT"); break;
+      case THRESHOLD : NS_LOG_INFO("Handover Mode: Threshold"); break;
+    }
+    Simulator::Schedule(MilliSeconds(0), &LteEnbRrc::TriggerUeAssociationUpdate, this);
+  }
+  else if(!m_ismmWave && m_interRatHoMode && m_firstReport)
+  {
+    m_firstReport = false;
+    Simulator::Schedule(MilliSeconds(0), &LteEnbRrc::UpdateUeHandoverAssociation, this);
+  }
+
+}
+
+void
+LteEnbRrc::TttBasedHandover(std::map<uint64_t, CellSinrMap>::iterator imsiIter, double sinrDifference, uint16_t maxSinrCellId, double maxSinrDb)
+{
+  uint64_t imsi = imsiIter->first;
+  bool alreadyAssociatedImsi = false;
+  bool onHandoverImsi = true;
+  // On RecvRrcConnectionRequest for a new RNTI, the Lte Enb RRC stores the imsi
+  // of the UE and insert a new false entry in m_mmWaveCellSetupCompleted.
+  // After the first connection to a MmWave eNB, the entry becomes true.
+  // When an handover between MmWave cells is triggered, it is set to false.
+  if(m_mmWaveCellSetupCompleted.find(imsi) != m_mmWaveCellSetupCompleted.end())
+  {
+    alreadyAssociatedImsi = true;
+    //onHandoverImsi = (!m_switchEnabled) ? true : !m_mmWaveCellSetupCompleted.find(imsi)->second;
+    onHandoverImsi = !m_mmWaveCellSetupCompleted.find(imsi)->second;
+  }
+  else
+  {
+    alreadyAssociatedImsi = false;
+    onHandoverImsi = true;
+  }
+  NS_LOG_INFO("TttBasedHandover: alreadyAssociatedImsi " << alreadyAssociatedImsi << " onHandoverImsi " << onHandoverImsi);
+
+  bool handoverNeeded = false;
+
+  double currentSinrDb = 0;
+  if(alreadyAssociatedImsi && m_lastMmWaveCell.find(imsi) != m_lastMmWaveCell.end())
+  {
+    currentSinrDb = 10*std::log10(m_imsiCellSinrMap.find(imsi)->second[m_lastMmWaveCell[imsi]]);
+    NS_LOG_DEBUG("Current SINR " << currentSinrDb);
+  }
+
+  // the UE was in outage, now a mmWave eNB is available. It may be the one to which the UE is already attached or
+  // another one
+  if(alreadyAssociatedImsi && m_imsiUsingLte[imsi])
+  {
+    if(!m_interRatHoMode)
+    {
+      if(GetUeManager(GetRntiFromImsi(imsi))->GetAllMmWaveInOutageAtInitialAccess())
+      {
+        NS_LOG_INFO("Send connect to " << maxSinrCellId << ", for the first time at least one mmWave eNB is not in outage");
+        m_rrcSapUser->SendRrcConnectToMmWave (GetRntiFromImsi(imsi), maxSinrCellId);
+        GetUeManager(GetRntiFromImsi(imsi))->SetAllMmWaveInOutageAtInitialAccess(false);
+      }
+      else if(m_lastMmWaveCell[imsi] == maxSinrCellId && !onHandoverImsi)
+      // it is on LTE, but now the last used MmWave cell is not in outage
+      {
+        // switch back to MmWave
+        NS_LOG_INFO("----- on LTE, switch to lastMmWaveCell " << m_lastMmWaveCell[imsi] << " at time " << Simulator::Now().GetSeconds());
+        Ptr<UeManager> ueMan = GetUeManager(GetRntiFromImsi(imsi));
+        bool useMmWaveConnection = true;
+        m_imsiUsingLte[imsi] = !useMmWaveConnection;
+        ueMan->SendRrcConnectionSwitch(useMmWaveConnection);
+      }
+      else if (m_lastMmWaveCell[imsi] != maxSinrCellId && !onHandoverImsi)
+      // it is on LTE, but now a MmWave cell different from the last used is not in outage, so we need to handover
+      {
+        // already using LTE connection
+        NS_LOG_INFO("----- on LTE, switch to new MmWaveCell " << maxSinrCellId << " at time " << Simulator::Now().GetSeconds());
+        // trigger ho via X2
+        EpcX2SapProvider::SecondaryHandoverParams params;
+        params.imsi = imsi;
+        params.targetCellId = maxSinrCellId;
+        params.oldCellId = m_lastMmWaveCell[imsi];
+        m_x2SapProvider->SendMcHandoverRequest(params);
+
+        m_mmWaveCellSetupCompleted[imsi] = false;
+      }
+    }
+    else
+    {
+      if(!onHandoverImsi)
+      {
+        // trigger an handover to mmWave
+        m_mmWaveCellSetupCompleted[imsi] = false;
+        m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+        NS_LOG_INFO("---- on LTE, handover to MmWave " << maxSinrCellId << " at time " << Simulator::Now().GetSeconds());
+        SendHandoverRequest(GetRntiFromImsi(imsi), maxSinrCellId);
+      }
+    }
+
+  }
+  else if(alreadyAssociatedImsi && !onHandoverImsi)
+  {
+    // the UE is connected to a mmWave eNB which was not in outage
+    // check if there are HO events pending
+    HandoverEventMap::iterator handoverEvent = m_imsiHandoverEventsMap.find(imsi);
+    if(handoverEvent != m_imsiHandoverEventsMap.end())
+    {
+      // an handover event is already scheduled
+      // check if the cell to which the handover should happen is maxSinrCellId
+      if(handoverEvent->second.targetCellId == maxSinrCellId)
+      {
+        if(currentSinrDb < m_outageThreshold) // we need to handover right now!
+        {
+          handoverEvent->second.scheduledHandoverEvent.Cancel();
+          handoverNeeded = true;
+          NS_LOG_INFO("------ Handover was already scheduled, but the current cell is in outage, thus HO to " << maxSinrCellId);
+        }
+        else
+        {
+          // TODO consider if TTT must be updated or if it can remain as computed before
+          // we should compute the new TTT: if Now() + TTT < scheduledTime then update!
+          uint8_t newTtt = ComputeTtt(sinrDifference);
+          uint64_t handoverHappensAtTime = handoverEvent->second.scheduledHandoverEvent.GetTs(); // in nanoseconds
+          NS_LOG_INFO("Scheduled for " << handoverHappensAtTime << " while now the scheduler would give " << Simulator::Now().GetMilliSeconds() + newTtt);
+          if(Simulator::Now().GetMilliSeconds() + newTtt < (double)handoverHappensAtTime/1e6)
+          {
+            handoverEvent->second.scheduledHandoverEvent.Cancel();
+            NS_LOG_INFO("------ Handover remains scheduled for " << maxSinrCellId << " but a new shorter TTT is computed");
+            handoverNeeded = true;
+          }
+        }
+      }
+      else
+      {
+        uint16_t targetCellId = handoverEvent->second.targetCellId;
+        NS_LOG_INFO("------ Handover was scheduled for " << handoverEvent->second.targetCellId << " but now maxSinrCellId is " << maxSinrCellId);
+        //  get the SINR for the scheduled targetCellId: if the diff is smaller than 3 dB handover anyway
+        double originalTargetSinrDb = 10*std::log10(m_imsiCellSinrMap.find(imsi)->second[targetCellId]);
+        if(maxSinrDb - originalTargetSinrDb > m_sinrThresholdDifference) // this parameter is the same as the one for ThresholdBasedSecondaryCellHandover
+        {
+          // delete this event
+          handoverEvent->second.scheduledHandoverEvent.Cancel();
+          // we need to re-compute the TTT and schedule a new event
+          if(maxSinrCellId != m_lastMmWaveCell[imsi])
+          {
+            handoverNeeded = true;
+          }
+          else
+          {
+            m_imsiHandoverEventsMap.erase(handoverEvent);
+          }
+        }
+        else
+        {
+          if(maxSinrCellId == m_lastMmWaveCell[imsi])
+          {
+            // delete this event
+            NS_LOG_INFO("-------------- The difference between the two mmWave SINR is smaller than "
+                  << m_sinrThresholdDifference << " dB, but the new max is the current cell, thus cancel the handover");
+            handoverEvent->second.scheduledHandoverEvent.Cancel();
+            m_imsiHandoverEventsMap.erase(handoverEvent);
+          }
+          else
+          {
+            NS_LOG_INFO("-------------- The difference between the two mmWave SINR is smaller than "
+                  << m_sinrThresholdDifference << " dB, do not cancel the handover");
+          }
+        }
+      }
+    }
+    else
+    {
+      // check if the maxSinrCellId is different from the current cell
+      if(maxSinrCellId != m_lastMmWaveCell[imsi])
+      {
+        NS_LOG_INFO("----- Handover needed from cell " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId);
+        handoverNeeded = true;
+      }
+    }
+  }
+
+  if(handoverNeeded)
+  {
+    NS_LOG_DEBUG("handoverNeeded");
+    // compute the TTT
+    uint8_t millisecondsToHandover = ComputeTtt(sinrDifference);
+    NS_LOG_INFO("The sinrDifference is " << sinrDifference << " and the TTT computed is " << (uint32_t)millisecondsToHandover
+      << " ms, thus the event will happen at time " << Simulator::Now().GetMilliSeconds() + millisecondsToHandover);
+    if(currentSinrDb < m_outageThreshold)
+    {
+      millisecondsToHandover = 0;
+      NS_LOG_INFO("Current Cell is in outage, handover immediately");
+    }
+    // schedule the event
+    EventId scheduledHandoverEvent = Simulator::Schedule(MilliSeconds(millisecondsToHandover), &LteEnbRrc::PerformHandover, this, imsi);
+    LteEnbRrc::HandoverEventInfo handoverInfo;
+    handoverInfo.sourceCellId = m_lastMmWaveCell[imsi];
+    handoverInfo.targetCellId = maxSinrCellId;
+    handoverInfo.scheduledHandoverEvent = scheduledHandoverEvent;
+    HandoverEventMap::iterator handoverEvent = m_imsiHandoverEventsMap.find(imsi);
+    if(handoverEvent != m_imsiHandoverEventsMap.end()) // another event was scheduled, but it was already deleted. Replace the entry
+    {
+      handoverEvent->second = handoverInfo;
+    }
+    else
+    {
+      m_imsiHandoverEventsMap.insert(std::pair<uint64_t, HandoverEventInfo> (imsi, handoverInfo));
+    }
+    // when the handover event happens, we need to check that no other procedures are ongoing and in case
+    // postpone it!
+  }
+}
+
+uint8_t
+LteEnbRrc::ComputeTtt(double sinrDifference)
+{
+  if(m_handoverMode == FIXED_TTT)
+  {
+    return m_fixedTttValue;
+  }
+  else if(m_handoverMode == DYNAMIC_TTT)
+  {
+    if(sinrDifference < m_minDiffTttValue)
+    {
+      return m_maxDynTttValue;
+    }
+    else if(sinrDifference > m_maxDiffTttValue)
+    {
+      return m_minDynTttValue;
+    }
+    else // in between
+    {
+      double ttt = m_maxDynTttValue - (m_maxDynTttValue - m_minDynTttValue)*(sinrDifference - m_minDiffTttValue)/(m_maxDiffTttValue - m_minDiffTttValue);
+      NS_ASSERT_MSG(ttt >= 0, "Negative TTT!");
+      uint8_t truncated_ttt = ttt;
+      return truncated_ttt;
+    }
+  }
+  else
+  {
+    NS_FATAL_ERROR("Unsupported HO mode");
+  }
+}
+
+void
+LteEnbRrc::PerformHandover(uint64_t imsi)
+{
+  NS_ASSERT_MSG(m_imsiHandoverEventsMap.find(imsi) != m_imsiHandoverEventsMap.end(), "No handover event for this imsi!");
+  LteEnbRrc::HandoverEventInfo handoverInfo = m_imsiHandoverEventsMap.find(imsi)->second;
+  NS_ASSERT_MSG(handoverInfo.sourceCellId == m_lastMmWaveCell[imsi], "The secondary cell to which the UE is attached has changed handoverInfo.sourceCellId "
+    << handoverInfo.sourceCellId << " m_lastMmWaveCell[imsi] " << m_lastMmWaveCell[imsi] << " imsi " << imsi);
+  bool alreadyAssociatedImsi = false;
+  bool onHandoverImsi = true;
+  // On RecvRrcConnectionRequest for a new RNTI, the Lte Enb RRC stores the imsi
+  // of the UE and insert a new false entry in m_mmWaveCellSetupCompleted.
+  // After the first connection to a MmWave eNB, the entry becomes true.
+  // When an handover between MmWave cells is triggered, it is set to false.
+  if(m_mmWaveCellSetupCompleted.find(imsi) != m_mmWaveCellSetupCompleted.end())
+  {
+    alreadyAssociatedImsi = true;
+    //onHandoverImsi = (!m_switchEnabled) ? true : !m_mmWaveCellSetupCompleted.find(imsi)->second;
+    onHandoverImsi = !m_mmWaveCellSetupCompleted.find(imsi)->second;
+  }
+  else
+  {
+    alreadyAssociatedImsi = false;
+    onHandoverImsi = true;
+  }
+  NS_LOG_INFO("PerformHandover: alreadyAssociatedImsi " << alreadyAssociatedImsi << " onHandoverImsi " << onHandoverImsi);
+
+  if(alreadyAssociatedImsi)
+  {
+    if(!onHandoverImsi)
+    {
+      // The new secondary cell HO procedure does not require to switch to LTE
+      NS_LOG_INFO("PerformHandover ----- handover from " << m_lastMmWaveCell[imsi] << " to " << handoverInfo.targetCellId << " at time " << Simulator::Now().GetSeconds());
+
+      // trigger ho via X2
+      EpcX2SapProvider::SecondaryHandoverParams params;
+      params.imsi = imsi;
+      params.targetCellId = handoverInfo.targetCellId;
+      params.oldCellId = m_lastMmWaveCell[imsi];
+      m_x2SapProvider->SendMcHandoverRequest(params);
+
+      m_mmWaveCellSetupCompleted[imsi] = false;
+    }
+    else
+    {
+      //TODO Do nothing or what?
+      NS_LOG_UNCOND("## Warn: handover not triggered because the UE is already performing HO!");
+    }
+  }
+  else
+  {
+    NS_LOG_UNCOND("## Warn: handover not triggered because the UE is not associated yet!");
+  }
+
+  // remove the HandoverEvent from the map
+  m_imsiHandoverEventsMap.erase(m_imsiHandoverEventsMap.find(imsi));
+}
+
+void
+LteEnbRrc::ThresholdBasedSecondaryCellHandover(std::map<uint64_t, CellSinrMap>::iterator imsiIter, double sinrDifference, uint16_t maxSinrCellId, double maxSinrDb)
+{
+  uint64_t imsi = imsiIter->first;
+  bool alreadyAssociatedImsi = false;
+  bool onHandoverImsi = true;
+  // On RecvRrcConnectionRequest for a new RNTI, the Lte Enb RRC stores the imsi
+  // of the UE and insert a new false entry in m_mmWaveCellSetupCompleted.
+  // After the first connection to a MmWave eNB, the entry becomes true.
+  // When an handover between MmWave cells is triggered, it is set to false.
+  if(m_mmWaveCellSetupCompleted.find(imsi) != m_mmWaveCellSetupCompleted.end())
+  {
+    alreadyAssociatedImsi = true;
+    //onHandoverImsi = (!m_switchEnabled) ? true : !m_mmWaveCellSetupCompleted.find(imsi)->second;
+    onHandoverImsi = !m_mmWaveCellSetupCompleted.find(imsi)->second;
+  }
+  else
+  {
+    alreadyAssociatedImsi = false;
+    onHandoverImsi = true;
+  }
+  NS_LOG_INFO("ThresholdBasedSecondaryCellHandover: alreadyAssociatedImsi " << alreadyAssociatedImsi << " onHandoverImsi " << onHandoverImsi);
+
+  if(maxSinrCellId == m_bestMmWaveCellForImsiMap[imsi] && !m_imsiUsingLte[imsi])
+  {
+    if (alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference > m_sinrThresholdDifference) // not on LTE, handover between MmWave cells
+    // this may happen when channel changes while there is an handover
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " channel changed previously at time " << Simulator::Now().GetSeconds());
+
+      // The new secondary cell HO procedure does not require to switch to LTE
+      //Ptr<UeManager> ueMan = GetUeManager(GetRntiFromImsi(imsi));
+      //bool useMmWaveConnection = false;
+      //m_imsiUsingLte[imsi] = !useMmWaveConnection;
+      //ueMan->SendRrcConnectionSwitch(useMmWaveConnection);
+
+      // trigger ho via X2
+      EpcX2SapProvider::SecondaryHandoverParams params;
+      params.imsi = imsi;
+      params.targetCellId = maxSinrCellId;
+      params.oldCellId = m_lastMmWaveCell[imsi];
+      m_x2SapProvider->SendMcHandoverRequest(params);
+
+      m_mmWaveCellSetupCompleted[imsi] = false; // TODO check this bool
+      m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+      NS_LOG_INFO("For imsi " << imsi << " the best cell is " << m_bestMmWaveCellForImsiMap[imsi] << " with SINR " << maxSinrDb);
+    }
+    else if(alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference < m_sinrThresholdDifference)
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " not triggered due to small diff " << sinrDifference << " at time " << Simulator::Now().GetSeconds());
+    }
+  }
+  else
+  {
+    if(alreadyAssociatedImsi && !onHandoverImsi && m_imsiUsingLte[imsi] && GetUeManager(GetRntiFromImsi(imsi))->GetAllMmWaveInOutageAtInitialAccess())
+    {
+      // perform initial access to mmWave eNB, since for the first time one mmWave eNB is not in outage!
+      NS_LOG_INFO("Send connect to " << maxSinrCellId << ", for the first time at least one mmWave eNB is not in outage");
+      m_rrcSapUser->SendRrcConnectToMmWave (GetRntiFromImsi(imsi), maxSinrCellId);
+    }
+    else if(alreadyAssociatedImsi && !onHandoverImsi && m_imsiUsingLte[imsi] && m_lastMmWaveCell[imsi] == maxSinrCellId)
+    // it is on LTE, but now the last used MmWave cell is not in outage
+    {
+      // switch back to MmWave
+      NS_LOG_INFO("----- on LTE, switch to lastMmWaveCell " << m_lastMmWaveCell[imsi] << " at time " << Simulator::Now().GetSeconds());
+      Ptr<UeManager> ueMan = GetUeManager(GetRntiFromImsi(imsi));
+      bool useMmWaveConnection = true;
+      m_imsiUsingLte[imsi] = !useMmWaveConnection;
+      ueMan->SendRrcConnectionSwitch(useMmWaveConnection);
+    }
+    else if (alreadyAssociatedImsi && !onHandoverImsi && m_imsiUsingLte[imsi] && m_lastMmWaveCell[imsi] != maxSinrCellId)
+    // it is on LTE, but now a MmWave cell different from the last used is not in outage, so we need to handover
+    {
+      // already using LTE connection
+      NS_LOG_INFO("----- on LTE, switch to new MmWaveCell " << maxSinrCellId << " at time " << Simulator::Now().GetSeconds());
+      // trigger ho via X2
+      EpcX2SapProvider::SecondaryHandoverParams params;
+      params.imsi = imsi;
+      params.targetCellId = maxSinrCellId;
+      params.oldCellId = m_lastMmWaveCell[imsi];
+      m_x2SapProvider->SendMcHandoverRequest(params);
+
+      m_mmWaveCellSetupCompleted[imsi] = false;
+    }
+    else if (alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference > m_sinrThresholdDifference)
+    // not on LTE, handover between MmWave cells
+    {
+      // The new secondary cell HO procedure does not require to switch to LTE
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " at time " << Simulator::Now().GetSeconds());
+      //Ptr<UeManager> ueMan = GetUeManager(GetRntiFromImsi(imsi));
+      //bool useMmWaveConnection = false;
+      //m_imsiUsingLte[imsi] = !useMmWaveConnection;
+      //ueMan->SendRrcConnectionSwitch(useMmWaveConnection);
+
+      // trigger ho via X2
+      EpcX2SapProvider::SecondaryHandoverParams params;
+      params.imsi = imsi;
+      params.targetCellId = maxSinrCellId;
+      params.oldCellId = m_lastMmWaveCell[imsi];
+      m_x2SapProvider->SendMcHandoverRequest(params);
+
+      m_mmWaveCellSetupCompleted[imsi] = false;
+    }
+    else if(alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference < m_sinrThresholdDifference)
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " not triggered due to small diff " << sinrDifference << " at time " << Simulator::Now().GetSeconds());
+    }
+    m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+    NS_LOG_INFO("For imsi " << imsi << " the best cell is " << m_bestMmWaveCellForImsiMap[imsi] << " with SINR " << maxSinrDb);
+  }
+}
+
+void
+LteEnbRrc::TriggerUeAssociationUpdate()
+{
+  if(m_imsiCellSinrMap.size() > 0) // there are some entries
+  {
+    for(std::map<uint64_t, CellSinrMap>::iterator imsiIter = m_imsiCellSinrMap.begin(); imsiIter != m_imsiCellSinrMap.end(); ++imsiIter)
+    {
+      uint64_t imsi = imsiIter->first;
+      long double maxSinr = 0;
+      long double currentSinr = 0;
+      uint16_t maxSinrCellId = 0;
+      bool alreadyAssociatedImsi = false;
+      bool onHandoverImsi = true;
+      Ptr<UeManager> ueMan;
+      // On RecvRrcConnectionRequest for a new RNTI, the Lte Enb RRC stores the imsi
+      // of the UE and insert a new false entry in m_mmWaveCellSetupCompleted.
+      // After the first connection to a MmWave eNB, the entry becomes true.
+      // When an handover between MmWave cells is triggered, it is set to false.
+      if(m_mmWaveCellSetupCompleted.find(imsi) != m_mmWaveCellSetupCompleted.end())
+      {
+        alreadyAssociatedImsi = true;
+        //onHandoverImsi = (!m_switchEnabled) ? true : !m_mmWaveCellSetupCompleted.find(imsi)->second;
+        onHandoverImsi = !m_mmWaveCellSetupCompleted.find(imsi)->second;
+
+      }
+      else
+      {
+        alreadyAssociatedImsi = false;
+        onHandoverImsi = true;
+      }
+      NS_LOG_INFO("alreadyAssociatedImsi " << alreadyAssociatedImsi << " onHandoverImsi " << onHandoverImsi);
+
+      for(CellSinrMap::iterator cellIter = imsiIter->second.begin(); cellIter != imsiIter->second.end(); ++cellIter)
+      {
+        NS_LOG_INFO("Cell " << cellIter->first << " reports " << 10*std::log10(cellIter->second));
+        if(cellIter->second > maxSinr)
+        {
+          maxSinr = cellIter->second;
+          maxSinrCellId = cellIter->first;
+        }
+        if(m_lastMmWaveCell[imsi] == cellIter->first)
+        {
+          currentSinr = cellIter->second;
+        }
+      }
+      long double sinrDifference = std::abs(10*(std::log10((long double)maxSinr) - std::log10((long double)currentSinr)));
+      long double maxSinrDb = 10*std::log10((long double)maxSinr);
+      long double currentSinrDb = 10*std::log10((long double)currentSinr);
+      NS_LOG_INFO("MaxSinr " << maxSinrDb << " in cell " << maxSinrCellId <<
+          " current cell " << m_lastMmWaveCell[imsi] << " currentSinr " << currentSinrDb << " sinrDifference " << sinrDifference);
+      if ((maxSinrDb < m_outageThreshold || (m_imsiUsingLte[imsi] && maxSinrDb < m_outageThreshold + 2)) && alreadyAssociatedImsi) // no MmWaveCell can serve this UE
+      {
+        // outage, perform fast switching if MC device or hard handover
+        NS_LOG_INFO("----- Warn: outage detected ------ at time " << Simulator::Now().GetSeconds());
+        if(m_imsiUsingLte[imsi] == false)
+        {
+          ueMan = GetUeManager(GetRntiFromImsi(imsi));
+          NS_LOG_INFO("Switch to LTE stack");
+          bool useMmWaveConnection = false;
+          m_imsiUsingLte[imsi] = !useMmWaveConnection;
+          ueMan->SendRrcConnectionSwitch(useMmWaveConnection);
+          //m_switchEnabled = false;
+          //Simulator::Schedule(MilliSeconds(50), &LteEnbRrc::EnableSwitching, this, imsi);
+
+          // delete the handover event which was scheduled for this UE (if any)
+          HandoverEventMap::iterator handoverEvent = m_imsiHandoverEventsMap.find(imsi);
+          if(handoverEvent != m_imsiHandoverEventsMap.end())
+          {
+            handoverEvent->second.scheduledHandoverEvent.Cancel();
+            m_imsiHandoverEventsMap.erase(handoverEvent);
+          }
+        }
+        else
+        {
+          NS_LOG_INFO("Already on LTE");
+          ueMan = GetUeManager(GetRntiFromImsi(imsi));
+          if(ueMan->GetAllMmWaveInOutageAtInitialAccess())
+          {
+            NS_LOG_INFO("The UE never connected to a mmWave eNB");
+          }
+        }
+      }
+      else
+      {
+        if(m_handoverMode == THRESHOLD)
+        {
+          ThresholdBasedSecondaryCellHandover(imsiIter, sinrDifference, maxSinrCellId, maxSinrDb);
+        }
+        else if(m_handoverMode == FIXED_TTT || m_handoverMode == DYNAMIC_TTT)
+        {
+          m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+          TttBasedHandover(imsiIter, sinrDifference, maxSinrCellId, maxSinrDb);
+        }
+        else
+        {
+          NS_FATAL_ERROR("Unsupported HO mode");
+        }
+      }
+    }
+  }
+
+  Simulator::Schedule(MicroSeconds(m_crtPeriod), &LteEnbRrc::TriggerUeAssociationUpdate, this);
+}
+
+void
+LteEnbRrc::ThresholdBasedInterRatHandover(std::map<uint64_t, CellSinrMap>::iterator imsiIter, double sinrDifference, uint16_t maxSinrCellId, double maxSinrDb)
+{
+  uint64_t imsi = imsiIter->first;
+  bool alreadyAssociatedImsi = false;
+  bool onHandoverImsi = true;
+  // On RecvRrcConnectionRequest for a new RNTI, the Lte Enb RRC stores the imsi
+  // of the UE and insert a new false entry in m_mmWaveCellSetupCompleted.
+  // After the first connection to a MmWave eNB, the entry becomes true.
+  // When an handover between MmWave cells is triggered, it is set to false.
+  if(m_mmWaveCellSetupCompleted.find(imsi) != m_mmWaveCellSetupCompleted.end())
+  {
+    alreadyAssociatedImsi = true;
+    //onHandoverImsi = (!m_switchEnabled) ? true : !m_mmWaveCellSetupCompleted.find(imsi)->second;
+    onHandoverImsi = !m_mmWaveCellSetupCompleted.find(imsi)->second;
+  }
+  else
+  {
+    alreadyAssociatedImsi = false;
+    onHandoverImsi = true;
+  }
+  NS_LOG_INFO("ThresholdBasedSecondaryCellHandover: alreadyAssociatedImsi " << alreadyAssociatedImsi << " onHandoverImsi " << onHandoverImsi);
+
+  if(maxSinrCellId == m_bestMmWaveCellForImsiMap[imsi] && !m_imsiUsingLte[imsi])
+  {
+    if (alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference > m_sinrThresholdDifference) // not on LTE, handover between MmWave cells
+    // this may happen when channel changes while there is an handover
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " channel changed previously");
+      // trigger ho via X2
+      EpcX2SapProvider::SecondaryHandoverParams params;
+      params.imsi = imsi;
+      params.targetCellId = maxSinrCellId;
+      params.oldCellId = m_lastMmWaveCell[imsi];
+      m_x2SapProvider->SendMcHandoverRequest(params);
+
+      m_mmWaveCellSetupCompleted[imsi] = false;
+      m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+      NS_LOG_INFO("For imsi " << imsi << " the best cell is " << m_bestMmWaveCellForImsiMap[imsi] << " with SINR " << maxSinrDb);
+    }
+    else if(alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference < m_sinrThresholdDifference)
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " not triggered due to small diff " << sinrDifference);
+    }
+  }
+  else
+  {
+    if(m_imsiUsingLte[imsi] && alreadyAssociatedImsi && !onHandoverImsi)
+    // it is on LTE, but now the a MmWave cell is not in outage
+    {
+      // switch back to MmWave
+      m_mmWaveCellSetupCompleted[imsi] = false;
+      m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+      NS_LOG_INFO("Handover to MmWave " << m_bestMmWaveCellForImsiMap[imsi]);
+      SendHandoverRequest(GetRntiFromImsi(imsi), m_bestMmWaveCellForImsiMap[imsi]);
+    }
+    else if (!m_imsiUsingLte[imsi] && alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference > m_sinrThresholdDifference) // not on LTE, handover between MmWave cells
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId);
+                  // trigger ho via X2
+      EpcX2SapProvider::SecondaryHandoverParams params;
+      params.imsi = imsi;
+      params.targetCellId = maxSinrCellId;
+      params.oldCellId = m_lastMmWaveCell[imsi];
+      m_x2SapProvider->SendMcHandoverRequest(params);
+
+      m_mmWaveCellSetupCompleted[imsi] = false;
+    }
+    else if(alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference < m_sinrThresholdDifference)
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " not triggered due to small diff " << sinrDifference);
+    }
+    m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+    NS_LOG_INFO("For imsi " << imsi << " the best cell is " << m_bestMmWaveCellForImsiMap[imsi] << " with SINR " << maxSinrDb);
+  }
+}
+
+void
+LteEnbRrc::EnableSwitching(uint64_t imsi)
+{
+  m_switchEnabled = true;
+}
+
+void
+LteEnbRrc::UpdateUeHandoverAssociation()
+{
+  // TODO rules for possible ho of each UE
+  if(m_imsiCellSinrMap.size() > 0) // there are some entries
+  {
+    for(std::map<uint64_t, CellSinrMap>::iterator imsiIter = m_imsiCellSinrMap.begin(); imsiIter != m_imsiCellSinrMap.end(); ++imsiIter)
+    {
+      uint64_t imsi = imsiIter->first;
+      long double maxSinr = 0;
+      long double currentSinr = 0;
+      uint16_t maxSinrCellId = 0;
+      bool alreadyAssociatedImsi = false;
+      bool onHandoverImsi = true;
+
+      // If the LteEnbRrc is InterRatHo mode, the MmWave eNB notifies the
+      // LTE eNB of the first access of a certain imsi. This is stored in a map
+      // and m_mmWaveCellSetupCompleted for that imsi is set to true.
+      // When an handover between MmWave cells is triggered, it is set to false.
+      if(m_mmWaveCellSetupCompleted.find(imsi) != m_mmWaveCellSetupCompleted.end())
+      {
+        alreadyAssociatedImsi = true;
+        onHandoverImsi = !m_mmWaveCellSetupCompleted.find(imsi)->second;
+      }
+      else
+      {
+        alreadyAssociatedImsi = false;
+        onHandoverImsi = true;
+      }
+      NS_LOG_INFO("alreadyAssociatedImsi " << alreadyAssociatedImsi << " onHandoverImsi " << onHandoverImsi);
+
+      for(CellSinrMap::iterator cellIter = imsiIter->second.begin(); cellIter != imsiIter->second.end(); ++cellIter)
+      {
+        NS_LOG_INFO("Cell " << cellIter->first << " reports " << 10*std::log10(cellIter->second));
+        if(cellIter->second > maxSinr)
+        {
+          maxSinr = cellIter->second;
+          maxSinrCellId = cellIter->first;
+        }
+        if(m_lastMmWaveCell[imsi] == cellIter->first)
+        {
+          currentSinr = cellIter->second;
+        }
+      }
+
+      long double sinrDifference = std::abs(10*(std::log10((long double)maxSinr) - std::log10((long double)currentSinr)));
+      long double maxSinrDb = 10*std::log10((long double)maxSinr);
+      long double currentSinrDb = 10*std::log10((long double)currentSinr);
+      NS_LOG_INFO("MaxSinr " << maxSinrDb << " in cell " << maxSinrCellId <<
+          " current cell " << m_lastMmWaveCell[imsi] << " currentSinr " << currentSinrDb << " sinrDifference " << sinrDifference);
+      // check if MmWave cells are in outage. In this case the UE should handover to LTE cell
+      if (maxSinrDb < m_outageThreshold || (m_imsiUsingLte[imsi] && maxSinrDb < m_outageThreshold + 2)) // no MmWaveCell can serve this UE
+      {
+        // outage, perform handover to LTE
+        NS_LOG_INFO("----- Warn: outage detected ------");
+        if(m_imsiUsingLte[imsi] == false)
+        {
+          NS_LOG_INFO("Handover to LTE");
+          if(!onHandoverImsi)
+          {
+            bool useMmWaveConnection = false;
+            m_imsiUsingLte[imsi] = !useMmWaveConnection;
+            // trigger ho via X2
+            EpcX2SapProvider::SecondaryHandoverParams params;
+            params.imsi = imsi;
+            params.targetCellId = m_cellId;
+            params.oldCellId = m_lastMmWaveCell[imsi];
+            m_mmWaveCellSetupCompleted.find(imsi)->second = false;
+            m_x2SapProvider->SendMcHandoverRequest(params);
+          }
+          else
+          {
+            NS_LOG_INFO("Already performing another HO");
+          }
+
+          // delete the handover event which was scheduled for this UE (if any)
+          HandoverEventMap::iterator handoverEvent = m_imsiHandoverEventsMap.find(imsi);
+          if(handoverEvent != m_imsiHandoverEventsMap.end())
+          {
+            handoverEvent->second.scheduledHandoverEvent.Cancel();
+            m_imsiHandoverEventsMap.erase(handoverEvent);
+          }
+
+        }
+        else
+        {
+          NS_LOG_INFO("Already on LTE");
+        }
+      }
+      else // there is at least a MmWave eNB that can serve this UE
+      {
+        if(m_handoverMode == THRESHOLD)
+        {
+          ThresholdBasedInterRatHandover(imsiIter, sinrDifference, maxSinrCellId, maxSinrDb);
+        }
+        else if(m_handoverMode == FIXED_TTT || m_handoverMode == DYNAMIC_TTT)
+        {
+          m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+          TttBasedHandover(imsiIter, sinrDifference, maxSinrCellId, maxSinrDb);
+        }
+        else
+        {
+          NS_FATAL_ERROR("Unsupported HO mode");
+        }
+      }
+    }
+  }
+  Simulator::Schedule(MicroSeconds(m_crtPeriod), &LteEnbRrc::UpdateUeHandoverAssociation, this);
+}
+
+void
+LteEnbRrc::DoRecvMcHandoverRequest(EpcX2SapUser::SecondaryHandoverParams params)
+{
+  NS_ASSERT_MSG(m_ismmWave == true, "Trying to perform HO for a secondary cell on a non secondary cell");
+  // retrieve RNTI
+  uint16_t rnti = GetRntiFromImsi(params.imsi);
+  NS_LOG_LOGIC("Rnti " << rnti);
+  SendHandoverRequest(rnti, params.targetCellId);
+}
+
 uint8_t
 LteEnbRrc::CellToComponentCarrierId (uint16_t cellId)
 {
   NS_LOG_FUNCTION (this << cellId);
-  for (auto &it: m_componentCarrierPhyConf)
+  if(!m_ismmWave)
+  {
+    for (auto &it: m_componentCarrierPhyConf)
+      {
+        if (it.second->GetCellId () == cellId)
+          {
+            return it.first;
+          }
+      }
+    }
+    else
     {
-      if (it.second->GetCellId () == cellId)
+      for (auto &it: m_mmWaveComponentCarrierPhyConf)
         {
-          return it.first;
+          if (it.second.m_cellId == cellId)
+            {
+              return it.first;
+            }
         }
     }
   NS_FATAL_ERROR ("Cell " << cellId << " not found in CC map");
@@ -2131,8 +4453,17 @@
 uint16_t
 LteEnbRrc::ComponentCarrierToCellId (uint8_t componentCarrierId)
 {
-  NS_LOG_FUNCTION (this << +componentCarrierId);
-  return m_componentCarrierPhyConf.at (componentCarrierId)->GetCellId ();
+  NS_LOG_FUNCTION (this << (uint32_t)componentCarrierId);
+  uint16_t cellId;
+  if(!m_ismmWave)
+  {
+    cellId = m_componentCarrierPhyConf.at (componentCarrierId)->GetCellId ();
+  }
+  else
+  {
+    cellId = m_mmWaveComponentCarrierPhyConf.at (componentCarrierId).m_cellId;
+  }
+  return cellId;
 }
 
 bool
@@ -2149,7 +4480,7 @@
   return true;
 }
 
-void 
+void
 LteEnbRrc::SetForwardUpCallback (Callback <void, Ptr<Packet> > cb)
 {
   m_forwardUpCallback = cb;
@@ -2186,9 +4517,25 @@
 LteEnbRrc::HandoverJoiningTimeout (uint16_t rnti)
 {
   NS_LOG_FUNCTION (this << rnti);
+  NS_LOG_INFO("Handover joining Timeout on cell " << m_cellId);
   NS_ASSERT_MSG (GetUeManager (rnti)->GetState () == UeManager::HANDOVER_JOINING,
                  "HandoverJoiningTimeout in unexpected state " << ToString (GetUeManager (rnti)->GetState ()));
-  RemoveUe (rnti);
+
+   // notify the LTE eNB (coordinator) of the failure
+   if(m_ismmWave)
+   {
+     uint16_t sourceCellId = (GetUeManager (rnti)->GetSource()).first;
+
+     NS_LOG_INFO ("rejecting handover request from cellId " << sourceCellId);
+     EpcX2SapProvider::HandoverFailedParams res;
+     res.sourceCellId = sourceCellId;
+     res.targetCellId = m_cellId;
+     res.coordinatorId = m_lteCellId;
+     res.imsi = GetImsiFromRnti(rnti);
+     m_x2SapProvider->NotifyCoordinatorHandoverFailed(res);
+   }
+   // schedule the removal of the UE
+   Simulator::Schedule(MilliSeconds(300), &LteEnbRrc::RemoveUe, this, rnti);
 }
 
 void
@@ -2207,12 +4554,14 @@
   NS_LOG_LOGIC ("Request to send HANDOVER REQUEST");
   NS_ASSERT (m_configured);
 
+  NS_LOG_INFO("LteEnbRrc on cell " << m_cellId << " for rnti " << rnti << " SendHandoverRequest at time " << Simulator::Now().GetSeconds() << " to cellId " << cellId);
+
   Ptr<UeManager> ueManager = GetUeManager (rnti);
   ueManager->PrepareHandover (cellId);
- 
+
 }
 
-void 
+void
 LteEnbRrc::DoCompleteSetupUe (uint16_t rnti, LteEnbRrcSapProvider::CompleteSetupUeParameters params)
 {
   NS_LOG_FUNCTION (this << rnti);
@@ -2237,38 +4586,46 @@
 LteEnbRrc::DoRecvRrcConnectionReconfigurationCompleted (uint16_t rnti, LteRrcSap::RrcConnectionReconfigurationCompleted msg)
 {
   NS_LOG_FUNCTION (this << rnti);
+  NS_LOG_INFO("Received RRC connection reconf completed on cell " << m_cellId);
   GetUeManager (rnti)->RecvRrcConnectionReconfigurationCompleted (msg);
 }
 
-void 
+void
 LteEnbRrc::DoRecvRrcConnectionReestablishmentRequest (uint16_t rnti, LteRrcSap::RrcConnectionReestablishmentRequest msg)
 {
   NS_LOG_FUNCTION (this << rnti);
   GetUeManager (rnti)->RecvRrcConnectionReestablishmentRequest (msg);
 }
 
-void 
+void
 LteEnbRrc::DoRecvRrcConnectionReestablishmentComplete (uint16_t rnti, LteRrcSap::RrcConnectionReestablishmentComplete msg)
 {
   NS_LOG_FUNCTION (this << rnti);
   GetUeManager (rnti)->RecvRrcConnectionReestablishmentComplete (msg);
 }
 
-void 
+void
 LteEnbRrc::DoRecvMeasurementReport (uint16_t rnti, LteRrcSap::MeasurementReport msg)
 {
   NS_LOG_FUNCTION (this << rnti);
   GetUeManager (rnti)->RecvMeasurementReport (msg);
 }
 
-void 
+void
+LteEnbRrc::DoRecvRrcSecondaryCellInitialAccessSuccessful (uint16_t rnti, uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+  NS_LOG_FUNCTION (this << rnti);
+  GetUeManager (rnti)->RecvRrcSecondaryCellInitialAccessSuccessful (mmWaveRnti, mmWaveCellId);
+}
+
+void
 LteEnbRrc::DoDataRadioBearerSetupRequest (EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters request)
 {
   Ptr<UeManager> ueManager = GetUeManager (request.rnti);
   ueManager->SetupDataRadioBearer (request.bearer, request.bearerId, request.gtpTeid, request.transportLayerAddress);
 }
 
-void 
+void
 LteEnbRrc::DoPathSwitchRequestAcknowledge (EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters params)
 {
   Ptr<UeManager> ueManager = GetUeManager (params.rnti);
@@ -2286,6 +4643,7 @@
   NS_LOG_LOGIC ("sourceCellId = " << req.sourceCellId);
   NS_LOG_LOGIC ("targetCellId = " << req.targetCellId);
   NS_LOG_LOGIC ("mmeUeS1apId = " << req.mmeUeS1apId);
+  NS_LOG_INFO ("isMc = " << req.isMc);
 
   if (m_admitHandoverRequest == false)
     {
@@ -2313,6 +4671,8 @@
   Ptr<UeManager> ueManager = GetUeManager (rnti);
   ueManager->SetSource (req.sourceCellId, req.oldEnbUeX2apId);
   ueManager->SetImsi (req.mmeUeS1apId);
+  ueManager->SetIsMc (req.isMc);
+  RegisterImsiToRnti(req.mmeUeS1apId, rnti);
 
   EpcX2SapProvider::HandoverRequestAckParams ackParams;
   ackParams.oldEnbUeX2apId = req.oldEnbUeX2apId;
@@ -2330,6 +4690,14 @@
       ackParams.admittedBearers.push_back (i);
     }
 
+    // For secondary cell HO for MC devices, setup RLC instances
+    for (std::vector <EpcX2Sap::RlcSetupRequest>::iterator it = req.rlcRequests.begin();
+       it != req.rlcRequests.end ();
+         ++it)
+    {
+      ueManager->RecvRlcSetupRequest(*it);
+    }
+
   LteRrcSap::RrcConnectionReconfiguration handoverCommand = ueManager->GetRrcConnectionReconfigurationForHandover ();
   handoverCommand.haveMobilityControlInfo = true;
   handoverCommand.mobilityControlInfo.targetPhysCellId = req.targetCellId;
@@ -2348,7 +4716,7 @@
   handoverCommand.mobilityControlInfo.radioResourceConfigCommon.rachConfigCommon.preambleInfo.numberOfRaPreambles = rc.numberOfRaPreambles;
   handoverCommand.mobilityControlInfo.radioResourceConfigCommon.rachConfigCommon.raSupervisionInfo.preambleTransMax = rc.preambleTransMax;
   handoverCommand.mobilityControlInfo.radioResourceConfigCommon.rachConfigCommon.raSupervisionInfo.raResponseWindowSize = rc.raResponseWindowSize;
-  handoverCommand.haveNonCriticalExtension = false;
+  //handoverCommand.haveNonCriticalExtension = false; // this is correctly set in BuildRrcConnectionReconfiguration
 
   Ptr<Packet> encodedHandoverCommand = m_rrcSapUser->EncodeHandoverCommand (handoverCommand);
 
@@ -2382,6 +4750,19 @@
 }
 
 void
+LteEnbRrc::DoRecvSecondaryCellHandoverCompleted (EpcX2SapUser::SecondaryHandoverCompletedParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_ASSERT_MSG(!m_ismmWave, "Only the LTE cell (coordinator) can receive a SecondaryCellHandoverCompleted message");
+  NS_LOG_LOGIC ("Recv X2 message: SECONDARY CELL HANDOVER COMPLETED");
+
+  // get the RNTI from IMSI
+  Ptr<UeManager> ueMan = GetUeManager(GetRntiFromImsi(params.imsi));
+  ueMan->RecvSecondaryCellHandoverCompleted(params);
+}
+
+void
 LteEnbRrc::DoRecvHandoverPreparationFailure (EpcX2SapUser::HandoverPreparationFailureParams params)
 {
   NS_LOG_FUNCTION (this);
@@ -2426,11 +4807,68 @@
   NS_LOG_LOGIC ("newEnbUeX2apId = " << params.newEnbUeX2apId);
 
   uint16_t rnti = params.oldEnbUeX2apId;
+
+  if(m_interRatHoMode && m_ismmWave)
+  {
+    NS_LOG_INFO("Notify LTE eNB that the handover is completed from cell " << m_cellId << " to " << params.sourceCellId);
+    EpcX2Sap::SecondaryHandoverParams sendParams;
+    sendParams.imsi = GetImsiFromRnti(rnti);
+    sendParams.oldCellId = m_lteCellId;
+    sendParams.targetCellId = params.sourceCellId;
+    m_x2SapProvider->NotifyLteMmWaveHandoverCompleted(sendParams);
+  }
+  else if(m_interRatHoMode && !m_ismmWave)
+  {
+    NS_LOG_INFO("LTE eNB received UE context release from cell " << params.sourceCellId);
+    m_lastMmWaveCell[GetImsiFromRnti(rnti)] = params.sourceCellId;
+    m_mmWaveCellSetupCompleted[GetImsiFromRnti(rnti)] = true;
+    m_imsiUsingLte[GetImsiFromRnti(rnti)] = false;
+  }
+
   GetUeManager (rnti)->RecvUeContextRelease (params);
   RemoveUe (rnti);
 }
 
 void
+LteEnbRrc::DoRecvLteMmWaveHandoverCompleted (EpcX2SapUser::SecondaryHandoverParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_INFO ("Recv X2 message: NOTIFY MMWAVE HANDOVER COMPLETED " << m_interRatHoMode << " m_ismmWave " << m_ismmWave);
+
+  if(m_interRatHoMode && !m_ismmWave)
+  {
+    uint64_t imsi = params.imsi;
+    NS_LOG_INFO("LTE eNB received notification that MmWave handover is completed to cell " << params.targetCellId);
+    m_lastMmWaveCell[imsi] = params.targetCellId;
+    if(params.targetCellId != m_cellId)
+    {
+      m_imsiUsingLte[imsi] = false;
+      m_mmWaveCellSetupCompleted[imsi] = true;
+    }
+    else
+    {
+      // m_imsiUsingLte[imsi] = true;
+      // if the LTE cell is the target of the Handover, it may still
+      // be in the RRC RECONFIGURATION phase
+      GetUeManager(GetRntiFromImsi(imsi))->RecvNotifyLteMmWaveHandoverCompleted();
+      // m_mmWaveCellSetupCompleted[imsi] = true;
+    }
+  }
+}
+
+void
+LteEnbRrc::DoRecvConnectionSwitchToMmWave (EpcX2SapUser::SwitchConnectionParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("Recv X2 message: SWITCH CONNECTION");
+
+  GetUeManager(params.mmWaveRnti)->RecvConnectionSwitchToMmWave(params.useMmWaveConnection, params.drbid);
+}
+
+
+void
 LteEnbRrc::DoRecvLoadInformation (EpcX2SapUser::LoadInformationParams params)
 {
   NS_LOG_FUNCTION (this);
@@ -2455,6 +4893,35 @@
 }
 
 void
+LteEnbRrc::DoRecvRlcSetupRequest (EpcX2SapUser::RlcSetupRequest params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("Recv X2 message: RLC SETUP REQUEST");
+
+  GetUeManager(params.mmWaveRnti)->RecvRlcSetupRequest(params);
+}
+
+void
+LteEnbRrc::DoRecvRlcSetupCompleted (EpcX2SapUser::UeDataParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("Recv X2 message: RLC SETUP COMPLETED");
+
+  std::map<uint32_t, X2uTeidInfo>::iterator
+    teidInfoIt = m_x2uMcTeidInfoMap.find (params.gtpTeid);
+  if (teidInfoIt != m_x2uMcTeidInfoMap.end ())
+    {
+      GetUeManager (teidInfoIt->second.rnti)->RecvRlcSetupCompleted (teidInfoIt->second.drbid);
+    }
+  else
+    {
+      NS_FATAL_ERROR ("No X2uMcTeidInfo found");
+    }
+}
+
+void
 LteEnbRrc::DoRecvUeData (EpcX2SapUser::UeDataParams params)
 {
   NS_LOG_FUNCTION (this);
@@ -2466,7 +4933,7 @@
   NS_LOG_LOGIC ("ueData = " << params.ueData);
   NS_LOG_LOGIC ("ueData size = " << params.ueData->GetSize ());
 
-  std::map<uint32_t, X2uTeidInfo>::iterator 
+  std::map<uint32_t, X2uTeidInfo>::iterator
     teidInfoIt = m_x2uTeidInfoMap.find (params.gtpTeid);
   if (teidInfoIt != m_x2uTeidInfoMap.end ())
     {
@@ -2474,12 +4941,19 @@
     }
   else
     {
-      NS_FATAL_ERROR ("X2-U data received but no X2uTeidInfo found");
+      teidInfoIt = m_x2uMcTeidInfoMap.find(params.gtpTeid);
+      if(teidInfoIt != m_x2uMcTeidInfoMap.end ())
+      {
+        GetUeManager (teidInfoIt->second.rnti)->SendData (teidInfoIt->second.drbid, params.ueData);
+      }
+      else
+      {
+        NS_FATAL_ERROR ("X2-U data received but no X2uTeidInfo found");
+      }
     }
 }
 
-
-uint16_t 
+uint16_t
 LteEnbRrc::DoAllocateTemporaryCellRnti (uint8_t componentCarrierId)
 {
   NS_LOG_FUNCTION (this << +componentCarrierId);
@@ -2601,7 +5075,7 @@
   NS_LOG_FUNCTION (this);
   bool found = false;
   uint16_t rnti;
-  for (rnti = m_lastAllocatedRnti + 1; 
+  for (rnti = m_lastAllocatedRnti + 1;
        (rnti != m_lastAllocatedRnti - 1) && (!found);
        ++rnti)
     {
@@ -2631,19 +5105,21 @@
   std::map <uint16_t, Ptr<UeManager> >::iterator it = m_ueMap.find (rnti);
   NS_ASSERT_MSG (it != m_ueMap.end (), "request to remove UE info with unknown rnti " << rnti);
   uint16_t srsCi = (*it).second->GetSrsConfigurationIndex ();
+  bool isMc = it->second->GetIsMc();
+
   m_ueMap.erase (it);
   for (uint8_t i = 0; i < m_numberOfComponentCarriers; i++)
     {
       m_cmacSapProvider.at (i)->RemoveUe (rnti);
       m_cphySapProvider.at (i)->RemoveUe (rnti);
     }
-  if (m_s1SapProvider != 0)
+  if (m_s1SapProvider != 0 && !isMc)
     {
       m_s1SapProvider->UeContextRelease (rnti);
     }
   m_ccmRrcSapProvider-> RemoveUe (rnti);
   // need to do this after UeManager has been deleted
-  RemoveSrsConfigurationIndex (srsCi); 
+  RemoveSrsConfigurationIndex (srsCi);
 }
 
 TypeId
@@ -2674,6 +5150,10 @@
         }
       break;
 
+    case RLC_UM_LOWLAT_ALWAYS:
+      return LteRlcUmLowLat::GetTypeId ();
+      break;
+
     default:
       return LteRlcSm::GetTypeId ();
       break;
@@ -2730,7 +5210,7 @@
  */
 static const uint16_t g_srsCiHigh[SRS_ENTRIES] =      {0, 1, 6, 16, 36, 76, 156, 316, 636};
 
-void 
+void
 LteEnbRrc::SetSrsPeriodicity (uint32_t p)
 {
   NS_LOG_FUNCTION (this << p);
@@ -2751,7 +5231,7 @@
   NS_FATAL_ERROR ("illecit SRS periodicity value " << p << ". Allowed values: " << allowedValues.str ());
 }
 
-uint32_t 
+uint32_t
 LteEnbRrc::GetSrsPeriodicity () const
 {
   NS_LOG_FUNCTION (this);
@@ -2771,7 +5251,7 @@
   NS_LOG_DEBUG (this << " SRS p " << g_srsPeriodicity[m_srsCurrentPeriodicityId] << " set " << m_ueSrsConfigurationIndexSet.size ());
   if (m_ueSrsConfigurationIndexSet.size () >= g_srsPeriodicity[m_srsCurrentPeriodicityId])
     {
-      NS_FATAL_ERROR ("too many UEs (" << m_ueSrsConfigurationIndexSet.size () + 1 
+      NS_FATAL_ERROR ("too many UEs (" << m_ueSrsConfigurationIndexSet.size () + 1
                                        << ") for current SRS periodicity "
                                        <<  g_srsPeriodicity[m_srsCurrentPeriodicityId]
                                        << ", consider increasing the value of ns3::LteEnbRrc::SrsPeriodicity");
@@ -2798,7 +5278,7 @@
       else
         {
           // look for released ones
-          for (uint16_t srcCi = g_srsCiLow[m_srsCurrentPeriodicityId]; srcCi < g_srsCiHigh[m_srsCurrentPeriodicityId]; srcCi++) 
+          for (uint16_t srcCi = g_srsCiLow[m_srsCurrentPeriodicityId]; srcCi < g_srsCiHigh[m_srsCurrentPeriodicityId]; srcCi++)
             {
               std::set<uint16_t>::iterator it = m_ueSrsConfigurationIndexSet.find (srcCi);
               if (it == m_ueSrsConfigurationIndexSet.end ())
@@ -2808,7 +5288,7 @@
                   break;
                 }
             }
-        } 
+        }
     }
   return m_lastAllocatedConfigurationIndex;
 
@@ -2824,7 +5304,7 @@
   m_ueSrsConfigurationIndexSet.erase (it);
 }
 
-uint8_t 
+uint8_t
 LteEnbRrc::GetLogicalChannelGroup (EpsBearer bearer)
 {
   if (bearer.IsGbr ())
@@ -2837,7 +5317,20 @@
     }
 }
 
-uint8_t 
+uint8_t
+LteEnbRrc::GetLogicalChannelGroup (bool isGbr)
+{
+  if (isGbr)
+    {
+      return 1;
+    }
+  else
+    {
+      return 2;
+    }
+}
+
+uint8_t
 LteEnbRrc::GetLogicalChannelPriority (EpsBearer bearer)
 {
   return bearer.qci;
@@ -2846,28 +5339,54 @@
 void
 LteEnbRrc::SendSystemInformation ()
 {
-  // NS_LOG_FUNCTION (this);
+  NS_LOG_FUNCTION (this);
 
-  for (auto &it: m_componentCarrierPhyConf)
-    {
-      uint8_t ccId = it.first;
+  if(!m_ismmWave)
+  {
+    for (auto &it: m_componentCarrierPhyConf)
+      {
+        uint8_t ccId = it.first;
 
-      LteRrcSap::SystemInformation si;
-      si.haveSib2 = true;
-      si.sib2.freqInfo.ulCarrierFreq = it.second->GetUlEarfcn ();
-      si.sib2.freqInfo.ulBandwidth = it.second->GetUlBandwidth ();
-      si.sib2.radioResourceConfigCommon.pdschConfigCommon.referenceSignalPower = m_cphySapProvider.at (ccId)->GetReferenceSignalPower ();
-      si.sib2.radioResourceConfigCommon.pdschConfigCommon.pb = 0;
-
-      LteEnbCmacSapProvider::RachConfig rc = m_cmacSapProvider.at (ccId)->GetRachConfig ();
-      LteRrcSap::RachConfigCommon rachConfigCommon;
-      rachConfigCommon.preambleInfo.numberOfRaPreambles = rc.numberOfRaPreambles;
-      rachConfigCommon.raSupervisionInfo.preambleTransMax = rc.preambleTransMax;
-      rachConfigCommon.raSupervisionInfo.raResponseWindowSize = rc.raResponseWindowSize;
-      si.sib2.radioResourceConfigCommon.rachConfigCommon = rachConfigCommon;
+        LteRrcSap::SystemInformation si;
+        si.haveSib2 = true;
+        si.sib2.freqInfo.ulCarrierFreq = it.second->GetUlEarfcn ();
+        si.sib2.freqInfo.ulBandwidth = it.second->GetUlBandwidth ();
+        si.sib2.radioResourceConfigCommon.pdschConfigCommon.referenceSignalPower = m_cphySapProvider.at (ccId)->GetReferenceSignalPower ();
+        si.sib2.radioResourceConfigCommon.pdschConfigCommon.pb = 0;
+
+        LteEnbCmacSapProvider::RachConfig rc = m_cmacSapProvider.at (ccId)->GetRachConfig ();
+        LteRrcSap::RachConfigCommon rachConfigCommon;
+        rachConfigCommon.preambleInfo.numberOfRaPreambles = rc.numberOfRaPreambles;
+        rachConfigCommon.raSupervisionInfo.preambleTransMax = rc.preambleTransMax;
+        rachConfigCommon.raSupervisionInfo.raResponseWindowSize = rc.raResponseWindowSize;
+        si.sib2.radioResourceConfigCommon.rachConfigCommon = rachConfigCommon;
 
-      m_rrcSapUser->SendSystemInformation (it.second->GetCellId (), si);
-    }
+        m_rrcSapUser->SendSystemInformation (it.second->GetCellId (), si);
+      }
+  }
+  else
+  {
+    for (auto &it: m_mmWaveComponentCarrierPhyConf)
+      {
+        uint8_t ccId = it.first;
+
+        LteRrcSap::SystemInformation si;
+        si.haveSib2 = true;
+        //si.sib2.freqInfo.ulCarrierFreq = it.second->GetUlEarfcn ();
+        si.sib2.freqInfo.ulBandwidth = it.second.m_bandwidth;
+        si.sib2.radioResourceConfigCommon.pdschConfigCommon.referenceSignalPower = m_cphySapProvider.at (ccId)->GetReferenceSignalPower ();
+        si.sib2.radioResourceConfigCommon.pdschConfigCommon.pb = 0;
+
+        LteEnbCmacSapProvider::RachConfig rc = m_cmacSapProvider.at (ccId)->GetRachConfig ();
+        LteRrcSap::RachConfigCommon rachConfigCommon;
+        rachConfigCommon.preambleInfo.numberOfRaPreambles = rc.numberOfRaPreambles;
+        rachConfigCommon.raSupervisionInfo.preambleTransMax = rc.preambleTransMax;
+        rachConfigCommon.raSupervisionInfo.raResponseWindowSize = rc.raResponseWindowSize;
+        si.sib2.radioResourceConfigCommon.rachConfigCommon = rachConfigCommon;
+
+        m_rrcSapUser->SendSystemInformation (it.second.m_cellId, si);
+      }
+  }
 
   /*
    * For simplicity, we use the same periodicity for all SIBs. Note that in real
@@ -2878,4 +5397,3 @@
 
 
 } // namespace ns3
-
diff -Naru a/model/lte-enb-rrc.h b/model/lte-enb-rrc.h
--- a/model/lte-enb-rrc.h	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-enb-rrc.h	2018-08-03 16:39:02.891957671 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011, 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, 2018, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,10 +18,16 @@
  *
  * Authors: Nicola Baldo <nbaldo@cttc.es>
  *          Marco Miozzo <mmiozzo@cttc.es>
- *          Manuel Requena <manuel.requena@cttc.es> 
+ *          Manuel Requena <manuel.requena@cttc.es>
  * Modified by:
  *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
  *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
+ *
+ * Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+ *						  Integration of Carrier Aggregation for the mmWave module
  */
 
 #ifndef LTE_ENB_RRC_H
@@ -45,6 +52,8 @@
 #include <ns3/lte-anr-sap.h>
 #include <ns3/lte-ffr-rrc-sap.h>
 #include <ns3/lte-rlc.h>
+#include <ns3/lte-pdcp.h>
+#include <ns3/lte-rlc-am.h>
 
 #include <map>
 #include <set>
@@ -53,16 +62,20 @@
 
 #define MIN_NO_CC 1
 #define MAX_NO_CC 5 // this is the maximum number of carrier components allowed by 3GPP up to R13
+#define MIN_NO_MMW_CC 1
+#define MAX_NO_MMW_CC 16 // from TR 38.802
 
 namespace ns3 {
 
 class LteRadioBearerInfo;
 class LteSignalingRadioBearerInfo;
 class LteDataRadioBearerInfo;
+class RlcBearerInfo;
 class LteEnbRrc;
 class Packet;
 
-
+typedef std::map<uint64_t, double> ImsiSinrMap;
+typedef std::map<uint16_t, double> CellSinrMap;
 
 /**
  * \ingroup lte
@@ -79,7 +92,7 @@
 
   /**
    * The state of the UeManager at the eNB RRC
-   * 
+   *
    */
   enum State
   {
@@ -93,20 +106,22 @@
     HANDOVER_JOINING,
     HANDOVER_PATH_SWITCH,
     HANDOVER_LEAVING,
+    PREPARE_MC_CONNECTION_RECONFIGURATION,
+    MC_CONNECTION_RECONFIGURATION,
     NUM_STATES
   };
 
   UeManager ();
- 
-  /** 
+
+  /**
    * UeManager constructor
-   * 
+   *
    * \param rrc pointer to the LteEnbRrc holding this UeManager
    * \param rnti RNTI of the UE
    * \param s initial state of the UeManager
    * \param componentCarrierId primary component carrier ID
-   * 
-   * \return 
+   *
+   * \return
    */
   UeManager (Ptr<LteEnbRrc> rrc, uint16_t rnti, State s, uint8_t componentCarrierId);
 
@@ -116,52 +131,59 @@
 protected:
   virtual void DoInitialize ();
   virtual void DoDispose ();
-public: 
+public:
   /**
    * \brief Get the type ID.
    * \return the object TypeId
    */
   static TypeId GetTypeId (void);
 
-  /** 
+  /**
    * Set the identifiers of the source eNB for the case where a UE
-   * joins the current eNB as part of a handover procedure 
-   * 
-   * \param sourceCellId 
-   * \param sourceX2apId 
+   * joins the current eNB as part of a handover procedure
+   *
+   * \param sourceCellId
+   * \param sourceX2apId
    */
   void SetSource (uint16_t sourceCellId, uint16_t sourceX2apId);
 
-  /** 
+  std::pair<uint16_t, uint16_t> GetSource (void);//mc
+
+
+  /**
    * Set the IMSI
-   * 
+   *
    * \param imsi the IMSI
    */
   void SetImsi (uint64_t imsi);
 
-  /** 
+  // set if this is a MC device
+  void SetIsMc (bool isMc);
+  // know if this is a MC device
+  bool GetIsMc (void) const;
+  /**
    * Setup a new data radio bearer, including both the configuration
    * within the eNB and the necessary RRC signaling with the UE
-   * 
+   *
    * \param bearer the QoS characteristics of the bearer
    * \param bearerId the EPS bearer identifier
    * \param gtpTeid S1-bearer GTP tunnel endpoint identifier, see 36.423 9.2.1
    * \param transportLayerAddress  IP Address of the SGW, see 36.423 9.2.1
-   * 
+   *
    */
   void SetupDataRadioBearer (EpsBearer bearer, uint8_t bearerId, uint32_t gtpTeid, Ipv4Address transportLayerAddress);
 
-  /** 
+  /**
    * Start all configured data radio bearers. It is safe to call this
    * method if any bearer had been already started previously.
-   * 
+   *
    */
   void RecordDataRadioBearersToBeStarted ();
 
-  /** 
+  /**
    * Start the data radio bearers that have been previously recorded
-   * to be started using RecordDataRadioBearersToBeStarted() 
-   * 
+   * to be started using RecordDataRadioBearersToBeStarted()
+   *
    */
   void StartDataRadioBearers ();
 
@@ -173,85 +195,98 @@
    */
   void ReleaseDataRadioBearer (uint8_t drbid);
 
-  /** 
+  /**
    * schedule an RRC Connection Reconfiguration procedure with the UE
-   * 
+   *
    */
   void ScheduleRrcConnectionReconfiguration ();
 
-  /** 
+  /**
    * Start the handover preparation and send the handover request
-   * 
+   *
    * \param cellId id of the target cell
    */
   void PrepareHandover (uint16_t cellId);
 
-  /** 
+  /**
    * take the necessary actions in response to the reception of an X2 HANDOVER REQUEST ACK message
-   * 
-   * \param params 
+   *
+   * \param params
    */
   void RecvHandoverRequestAck (EpcX2SapUser::HandoverRequestAckParams params);
 
-  /** 
-   * 
+  /**
+   *
    * \return the HandoverPreparationInfo sent by the source eNB to the
    * target eNB in the X2-based handover procedure
    */
   LteRrcSap::RadioResourceConfigDedicated GetRadioResourceConfigForHandoverPreparationInfo ();
 
-  /** 
-   * 
+  /**
+   *
    * \return retrieve the data that the target eNB needs to send to the source
    * eNB as the Handover Command in the X2-based handover
    * procedure.
    *
    * \note mobility control info is not expected to be filled in
-   * (shall be filled in by the caller). 
+   * (shall be filled in by the caller).
    */
   LteRrcSap::RrcConnectionReconfiguration GetRrcConnectionReconfigurationForHandover ();
 
-  /** 
+  /**
    * Send a data packet over the appropriate Data Radio Bearer
-   * 
+   *
    * \param bid the corresponding EPS Bearer ID
    * \param p the packet
    */
   void SendData (uint8_t bid, Ptr<Packet> p);
 
-  /** 
-   * 
+  /**
+   *
    * \return a list of ERAB-to-be-setup items to be put in a X2 HO REQ message
    */
   std::vector<EpcX2Sap::ErabToBeSetupItem> GetErabList ();
 
-  /** 
+  /**
    * send the UE CONTEXT RELEASE X2 message to the source eNB, thus
-   * successfully terminating an X2 handover procedure 
-   * 
+   * successfully terminating an X2 handover procedure
+   *
    */
   void SendUeContextRelease ();
 
-  /** 
+  void SendRrcConnectionSwitch(bool useMmWaveConnection);
+
+  /**
    * Take the necessary actions in response to the reception of an X2 HO preparation failure message
-   * 
+   *
    * \param cellId id of the target cell
    */
   void RecvHandoverPreparationFailure (uint16_t cellId);
 
-  /** 
+  /**
    * Take the necessary actions in response to the reception of an X2 SN STATUS TRANSFER message
-   * 
+   *
    * \param params the SN STATUS
    */
   void RecvSnStatusTransfer (EpcX2SapUser::SnStatusTransferParams params);
- 
-  /** 
+
+  /**
    * Take the necessary actions in response to the reception of an X2 UE CONTEXT RELEASE message
-   * 
+   *
    * \param params the SN STATUS
    */
-  void RecvUeContextRelease (EpcX2SapUser::UeContextReleaseParams params); 
+  void RecvUeContextRelease (EpcX2SapUser::UeContextReleaseParams params);
+
+  /**
+   * Setup a new RLC entity and the X2 related connection
+   */
+  void RecvRlcSetupRequest (EpcX2SapUser::RlcSetupRequest params);
+
+  /**
+   * Ack the setup of the RLC remote entity, start the re-configuration on the UE
+   */
+  void RecvRlcSetupCompleted (uint8_t drbid);
+
 
 
   // METHODS FORWARDED FROM ENB RRC SAP ///////////////////////////////////////
@@ -291,7 +326,7 @@
    * \param msg the measrurement report
    */
   void RecvMeasurementReport (LteRrcSap::MeasurementReport msg);
-
+  void RecvRrcSecondaryCellInitialAccessSuccessful(uint16_t mmWaveRnti, uint16_t mmWaveCellId);
 
   // METHODS FORWARDED FROM ENB CMAC SAP //////////////////////////////////////
 
@@ -309,14 +344,14 @@
    */
   void DoReceivePdcpSdu (LtePdcpSapUser::ReceivePdcpSduParameters params);
 
-  /** 
-   * 
+  /**
+   *
    * \return the RNTI, i.e., an UE identifier that is unique within
    * the cell
    */
   uint16_t GetRnti (void) const;
 
-  /** 
+  /**
    *
    * \return the IMSI, i.e., a globally unique UE identifier
    */
@@ -328,21 +363,21 @@
    */
   uint8_t GetComponentCarrierId () const;
 
-  /** 
-   * 
+  /**
+   *
    * \return the SRS Configuration Index
    */
   uint16_t GetSrsConfigurationIndex (void) const;
 
-  /** 
+  /**
    * Set the SRS configuration index and do the necessary reconfiguration
-   * 
-   * \param srsConfIndex 
+   *
+   * \param srsConfIndex
    */
   void SetSrsConfigurationIndex (uint16_t srsConfIndex);
 
-  /** 
-   * 
+  /**
+   *
    * \return the current state
    */
   State GetState () const;
@@ -368,103 +403,164 @@
     (const uint64_t imsi, const uint16_t cellId, const uint16_t rnti,
     const State oldState, const State newState);
 
-private:
+    /**
+     * TracedCallback signature for imsi, cellId and rnti events.
+     *
+     * \param [in] imsi
+     * \param [in] cellId
+     * \param [in] rnti
+     */
+    typedef void (* ImsiCidRntiTracedCallback)
+      (uint64_t imsi, uint16_t cellId, uint16_t rnti);
+
+    // for interRatHandover mode
+    void SetFirstConnection();
+
+    // for mc devices, get the m_allMmWaveInOutageAtInitialAccess variable
+    bool GetAllMmWaveInOutageAtInitialAccess();
+    void SetAllMmWaveInOutageAtInitialAccess(bool param);
+
+    /**
+     * This method is called by the eNB RRC to notify the
+     * UeManager that the handover from a MmWave cell to LTE
+     * was completed. Then, according to the state of
+     * the UeManager, it will modify the m_mmWaveCellSetupCompleted map
+     * of RRC.
+     * Used only with InterRat HO mode
+     */
+    void RecvNotifyLteMmWaveHandoverCompleted();
+
+    /**
+     * Notify a mmWave remote UeManager that a switch is expected.
+     * If the switch is to LTE, forward RLC buffers to LTE eNB
+     */
+    void RecvConnectionSwitchToMmWave (bool useMmWaveConnection, uint8_t drbid);
+
+    /**
+     * A SecondaryCellHandoverCompleted is received by the LTE eNB when the
+     * handover between 2 mmWave eNBs is completed. The LTE eNB has to update
+     * the information on the secondary cell and send the connection release to the
+     * source mmWave eNB.
+     */
+    void RecvSecondaryCellHandoverCompleted (EpcX2SapUser::SecondaryHandoverCompletedParams params);
 
-  /** 
+private:
+  //Lossless HO: merge 2 buffers into 1 with increment order.
+  std::vector < LteRlcAm::RetxPdu > MergeBuffers(std::vector < LteRlcAm::RetxPdu > first, std::vector < LteRlcAm::RetxPdu > second);
+  /**
+   * Forward the content of RLC buffers. For RLC UM and UM LowLat, forward txBuffer.
+   * For RLC AM, forward the merge of retx and txed buffers, and txBuffer
+   * @param the RLC entity
+   * @param the PDCP entity, if the mcLteToMmWaveForwarding is false it can be 0
+   * @param the gtpTeid that identifies the X2 connection to be used
+   * @param a bool that specifies if this operation involves a classic forwarding (to PDCP of the target eNB)
+   * or a LTE to MmWave Dual Connectivity forwarding, which needs the packets to be inserted back in the LTE PDCP
+   * (there is no PDCP in the MmWave eNB in DC setup)
+   * @param a bool that specifies if this operation involves the forwarding of packets from a secondary mmWave cell
+   * to another secondary mmWave cell during a secondary cell HO
+   * @param the bearer id, used only if mcLteToMmWaveForwarding is true
+   */
+  void ForwardRlcBuffers(Ptr<LteRlc> rlc, Ptr<LtePdcp> pdcp, uint32_t gtpTeid, bool mcLteToMmWaveForwarding, bool mcMmToMmWaveForwarding, uint8_t bid);
+
+
+  bool m_firstConnection;
+  bool m_receivedLteMmWaveHandoverCompleted;
+  uint16_t m_queuedHandoverRequestCellId;
+  /**
    * Add a new LteDataRadioBearerInfo structure to the UeManager
-   * 
-   * \param radioBearerInfo 
-   * 
+   *
+   * \param radioBearerInfo
+   *
    * \return the id of the newly added data radio bearer structure
    */
   uint8_t AddDataRadioBearerInfo (Ptr<LteDataRadioBearerInfo> radioBearerInfo);
 
-  /** 
+  /**
    * \param drbid the Data Radio Bearer id
-   * 
+   *
    * \return the corresponding LteDataRadioBearerInfo
    */
   Ptr<LteDataRadioBearerInfo> GetDataRadioBearerInfo (uint8_t drbid);
 
-  /** 
+  /**
    * remove the LteDataRadioBearerInfo corresponding to a bearer being released
    *
    * \param drbid the Data Radio Bearer id
    */
   void RemoveDataRadioBearerInfo (uint8_t drbid);
 
-  /** 
-   * 
+  /**
+   *
    * \return an RrcConnectionReconfiguration struct built based on the
    * current configuration
    */
   LteRrcSap::RrcConnectionReconfiguration BuildRrcConnectionReconfiguration ();
 
-  /** 
-   * 
+  /**
+   *
    * \return an NonCriticalExtensionConfiguration struct built based on the
    * current configuration
    */
   LteRrcSap::NonCriticalExtensionConfiguration BuildNonCriticalExtentionConfigurationCa ();
 
-  /** 
-   * 
+  /**
+   *
    * \return a RadioResourceConfigDedicated struct built based on the
    * current configuration
    */
   LteRrcSap::RadioResourceConfigDedicated BuildRadioResourceConfigDedicated ();
 
-  /** 
-   * 
+  /**
+   *
    * \return a newly allocated identifier for a new RRC transaction
    */
   uint8_t GetNewRrcTransactionIdentifier ();
 
-  /** 
+  /**
    * \param lcid a Logical Channel Identifier
-   * 
+   *
    * \return the corresponding Data Radio Bearer Id
    */
   uint8_t Lcid2Drbid (uint8_t lcid);
 
-  /** 
+  /**
    * \param drbid a Data Radio Bearer Id
-   * 
+   *
    * \return the corresponding  Logical Channel Identifier
    */
   uint8_t Drbid2Lcid (uint8_t drbid);
 
-  /** 
+  /**
    * \param lcid a  Logical Channel Identifier
-   * 
+   *
    * \return the corresponding EPS Bearer Identifier
    */
   uint8_t Lcid2Bid (uint8_t lcid);
 
-  /** 
+  /**
    * \param bid  an EPS Bearer Identifier
-   * 
+   *
    * \return the corresponding Logical Channel Identifier
    */
   uint8_t Bid2Lcid (uint8_t bid);
 
-  /** 
+  /**
    * \param drbid Data Radio Bearer Id
-   * 
+   *
    * \return the corresponding EPS Bearer Identifier
    */
   uint8_t Drbid2Bid (uint8_t drbid);
 
-  /** 
+  /**
    * \param bid an EPS Bearer Identifier
-   * 
+   *
    * \return the corresponding Data Radio Bearer Id
    */
   uint8_t Bid2Drbid (uint8_t bid);
 
-  /** 
+  /**
    * Switch the UeManager to the given state
-   * 
+   *
    * \param s the given state
    */
   void SwitchToState (State s);
@@ -478,6 +574,15 @@
   std::map <uint8_t, Ptr<LteDataRadioBearerInfo> > m_drbMap;
 
   /**
+   * Map the drb into a RLC (used for remote independent RLC in an MC setup)
+   */
+  std::map <uint8_t, Ptr<RlcBearerInfo> > m_rlcMap;
+  /**
+   * Map the drb into a RLCSetupRequest (used to handover remote independent RLC in an MC setup)
+   */
+  std::vector <EpcX2SapUser::RlcSetupRequest> m_rlcRequestVector;
+
+  /**
    * The `Srb0` attribute. SignalingRadioBearerInfo for SRB0.
    */
   Ptr<LteSignalingRadioBearerInfo> m_srb0;
@@ -499,7 +604,7 @@
    * ID of the primary CC for this UE
    */
   uint8_t m_componentCarrierId;
-  
+
   uint8_t m_lastRrcTransactionIdentifier; ///< last RRC transaction identifier
 
   LteRrcSap::PhysicalConfigDedicated m_physicalConfigDedicated; ///< physical config dedicated
@@ -507,11 +612,17 @@
   Ptr<LteEnbRrc> m_rrc;
   /// The current UeManager state.
   State m_state;
-  
+  ///
+
   LtePdcpSapUser* m_drbPdcpSapUser; ///< DRB PDCP SAP user
 
   bool m_pendingRrcConnectionReconfiguration; ///< pending RRC connection reconfiguration
 
+  bool m_pendingConnectToMmWave; ///< this attribute is set to true when RecvRrcConnectionSetupCompleted
+                                   // is executed. At the end of the CA configuration procedure, the
+                                   // LTE eNB will select the best mmWaveCell and will send the
+                                   // ConnectToMmWave command to the UE
+
   /**
    * The `StateTransition` trace source. Fired upon every UE state transition
    * seen by the UeManager at the eNB RRC. Exporting IMSI, cell ID, RNTI, old
@@ -519,11 +630,23 @@
    */
   TracedCallback<uint64_t, uint16_t, uint16_t, State, State> m_stateTransitionTrace;
 
-  uint16_t m_sourceX2apId; ///< source X2 ap ID
-  uint16_t m_sourceCellId; ///< source cell ID
-  uint16_t m_targetCellId; ///< target cell ID
-  std::list<uint8_t> m_drbsToBeStarted; ///< DRBS to be started
-  bool m_needPhyMacConfiguration; ///< need Phy MAC configuration
+  /**
+   * The `SwitchToMmWaveEnb` trace source. Fired upon receiving an ACK to a command to
+   * switch to MmWave RAT. Exporting IMSI, cellId, RNTI.
+   */
+  TracedCallback<uint64_t, uint16_t, uint16_t> m_secondaryRlcCreatedTrace;
+
+  uint16_t m_sourceX2apId;
+  uint16_t m_sourceCellId;
+  uint16_t m_targetCellId;
+  std::list<uint8_t> m_drbsToBeStarted;
+  bool m_needPhyMacConfiguration;
+
+  uint16_t m_mmWaveCellId;
+  uint16_t m_mmWaveRnti;
+  bool m_mmWaveCellAvailableForMcSetup;
+  bool m_isMc;
+  //bool m_isInterRatHoCapable;
 
   /**
    * Time limit before a _connection request timeout_ occurs. Set after a new
@@ -559,6 +682,13 @@
    */
   EventId m_handoverLeavingTimeout;
 
+  std::vector < Ptr<Packet> > m_x2forwardingBuffer;
+  uint32_t m_x2forwardingBufferSize;
+  uint32_t m_maxx2forwardingBufferSize;
+
+  // this variable is set to true if on initial access, for mc devices, all the mmWave eNBs are in outage
+  bool m_allMmWaveInOutageAtInitialAccess;
+
   /// Define if the Carrier Aggregation was already configure for the current UE on not
   bool m_caSupportConfigured;
 
@@ -571,7 +701,7 @@
 
 /**
  * \ingroup lte
- * 
+ *
  * The LTE Radio Resource Control entity at the eNB
  */
 class LteEnbRrc : public Object
@@ -593,6 +723,8 @@
   friend class EpcX2SpecificEpcX2SapUser<LteEnbRrc>;
   /// allow UeManager class friend access
   friend class UeManager;
+  friend class MemberLteEnbCphySapUser<LteEnbRrc>;
+
   /// allow  MemberLteCcmRrcSapUser<LteEnbRrc> class friend access
   friend class MemberLteCcmRrcSapUser<LteEnbRrc>;
 
@@ -608,6 +740,19 @@
    */
   virtual ~LteEnbRrc ();
 
+  /**
+   * Each instance of this struct is associated to a mmWave CC and contains the
+   * parameters needed by the RRC.
+   * When LteEnbRrc::ConfigureMmWaveCarriers () is called, a map of
+   * MmWaveComponentCarrierConf objects is stored in the
+   * m_mmWaveComponentCarrierPhyConf variable.
+   */
+  struct MmWaveComponentCarrierConf
+  {
+    uint8_t m_ccId;       ///< mmWave component carrier ID
+    uint16_t m_cellId;    ///< cell ID
+    uint32_t m_bandwidth; ///< bandwidth
+  };
 
   // inherited from Object
 protected:
@@ -619,18 +764,32 @@
    */
   static TypeId GetTypeId (void);
 
+
   /**
    * Set the X2 SAP this RRC should interact with
    * \param s the X2 SAP Provider to be used by this RRC entity
    */
   void SetEpcX2SapProvider (EpcX2SapProvider* s);
 
-  /** 
+  /**
    * Get the X2 SAP offered by this RRC
    * \return s the X2 SAP User interface offered to the X2 entity by this RRC entity
    */
   EpcX2SapUser* GetEpcX2SapUser ();
 
+  /**
+   * Set the X2 PDCP Provider this RRC should pass to PDCP layers
+   * \param s the X2 PDCP Provider to be stored in this RRC entity
+   */
+  void SetEpcX2PdcpProvider (EpcX2PdcpProvider* s);
+  EpcX2PdcpProvider* GetEpcX2PdcpProvider () const;
+
+  /**
+   * Set the X2 RLC Provider this RRC should pass to RLC layers
+   * \param s the X2 RLC Provider to be stored in this RRC entity
+   */
+  void SetEpcX2RlcProvider (EpcX2RlcProvider* s);
+  EpcX2RlcProvider* GetEpcX2RlcProvider() const;
 
   /**
    * set the CMAC SAP this RRC should interact with
@@ -647,13 +806,13 @@
    */
   void SetLteEnbCmacSapProvider (LteEnbCmacSapProvider * s, uint8_t pos);
 
-  /** 
+  /**
    * Get the CMAC SAP offered by this RRC
    * \returns the CMAC SAP User interface offered to the MAC by this RRC
    */
   LteEnbCmacSapUser* GetLteEnbCmacSapUser ();
 
-  /** 
+  /**
    * Get the CMAC SAP offered by this RRC
    * \param pos the position
    * \returns the CMAC SAP User interface offered to the MAC by this RRC
@@ -758,15 +917,15 @@
   void SetLteMacSapProvider (LteMacSapProvider* s);
 
 
-  /** 
+  /**
    * Set the S1 SAP Provider
-   * 
+   *
    * \param s the S1 SAP Provider
    */
   void SetS1SapProvider (EpcEnbS1SapProvider * s);
 
-  /** 
-   * 
+  /**
+   *
    * \return the S1 SAP user
    */
   EpcEnbS1SapUser* GetS1SapUser ();
@@ -802,11 +961,11 @@
    */
   LteEnbCphySapUser* GetLteEnbCphySapUser (uint8_t pos);
 
-  /** 
-   * 
-   * 
+  /**
+   *
+   *
    * \param rnti the identifier of an UE
-   * 
+   *
    * \return true if the corresponding UeManager instance exists
    */
   bool HasUeManager (uint16_t rnti) const;
@@ -860,23 +1019,69 @@
   void ConfigureCell (std::map<uint8_t, Ptr<ComponentCarrierEnb>> ccPhyConf);
 
   /**
-   * \brief Configure carriers.
+   * \brief Configure cell-specific parameters.
+   * \param cellId the ID of the cell
+   *
+   * Configure cell-specific parameters and propagate them to lower layers.
+   * The parameters include bandwidth, EARFCN (E-UTRA Absolute Radio Frequency
+   * Channel Number), and cell ID.
+   *
+   * In addition to parameter configuration, this function also performs several
+   * other tasks:
+   *  - Initializing UE measurement (i.e. measurement object and quantity
+   *    configuration), which is expected to be further configured through
+   *    `LteEnbRrc::AddUeMeasReportConfig`;
+   *  - Enabling MIB (Master Information Block) broadcast transmission
+   *  - Enabling SIB (System Information Block) broadcast transmission
+   *
+   * Typically runs when the eNodeB NetDevice is installed, for instance by
+   * `LteHelper::InstallEnbDevice` (i.e. before the simulation starts).
+   *
+   * \warning Raises an error when executed more than once.
+   *
+   * \param ccPhyConf the component carrier configuration map
+   */
+  void ConfigureCell (std::map<uint8_t, MmWaveComponentCarrierConf> ccPhyConf);
+
+  /**
+   * \brief Configure LTE carriers.
    * \param ccPhyConf the component carrier configuration
    */
   void ConfigureCarriers (std::map<uint8_t, Ptr<ComponentCarrierEnb>> ccPhyConf);
 
-  /** 
+  /**
+   * \brief Configure mmWave carriers.
+   * \param ccPhyConf the component carrier configuration
+   */
+  void ConfigureMmWaveCarriers (std::map<uint8_t, MmWaveComponentCarrierConf> ccPhyConf);
+
+  /**
    * set the cell id of this eNB
-   * 
-   * \param m_cellId 
+   *
+   * \param m_cellId
    */
   void SetCellId (uint16_t m_cellId);
 
-  /** 
+  /**
+   * If this is a MmWave eNB RRC, set the cell id of the closest LTE cell
+   *
+   * \param cellId
+   */
+  void SetClosestLteCellId (uint16_t cellId);
+
+  /**
+   * get the cell id of this eNB
+   *
+   * \param m_cellId
+   */
+  uint16_t GetCellId () const;
+
+
+  /**
    * set the cell id of this eNB
-   * 
-   * \param m_cellId 
-   * \param ccIndex 
+   *
+   * \param m_cellId
+   * \param ccIndex
    */
   void SetCellId (uint16_t m_cellId, uint8_t ccIndex);
 
@@ -898,33 +1103,33 @@
    */
   uint16_t ComponentCarrierToCellId (uint8_t componentCarrierId);
 
-  /** 
+  /**
    * Enqueue an IP data packet on the proper bearer for downlink
    * transmission. Normally expected to be called by the NetDevice
-   * forwarding a packet coming from the EpcEnbApplication 
-   * 
+   * forwarding a packet coming from the EpcEnbApplication
+   *
    * \param p the packet
-   * 
+   *
    * \return true if successful, false if an error occurred
    */
   bool SendData (Ptr<Packet> p);
 
-  /** 
+  /**
    * set the callback used to forward data packets up the stack
-   * 
-   * \param cb 
+   *
+   * \param cb
    */
   void SetForwardUpCallback (Callback <void, Ptr<Packet> > cb);
 
-  /** 
+  /**
    * Method triggered when a UE is expected to request for connection but does
    * not do so in a reasonable time. The method will remove the UE context.
-   * 
+   *
    * \param rnti the T-C-RNTI whose timeout expired
    */
   void ConnectionRequestTimeout (uint16_t rnti);
 
-  /** 
+  /**
    * Method triggered when a UE is expected to complete a connection setup
    * procedure but does not do so in a reasonable time. The method will remove
    * the UE context.
@@ -936,30 +1141,30 @@
   /**
    * Method triggered a while after sending RRC Connection Rejected. The method
    * will remove the UE context.
-   * 
+   *
    * \param rnti the T-C-RNTI whose timeout expired
    */
   void ConnectionRejectedTimeout (uint16_t rnti);
 
-  /** 
-   * Method triggered when a UE is expected to join the cell for a handover 
+  /**
+   * Method triggered when a UE is expected to join the cell for a handover
    * but does not do so in a reasonable time. The method will remove the UE
    * context.
-   * 
+   *
    * \param rnti the C-RNTI whose timeout expired
    */
   void HandoverJoiningTimeout (uint16_t rnti);
 
-  /** 
+  /**
    * Method triggered when a UE is expected to leave a cell for a handover
    * but no feedback is received in a reasonable time. The method will remove
    * the UE context.
-   * 
+   *
    * \param rnti the C-RNTI whose timeout expired
    */
   void HandoverLeavingTimeout (uint16_t rnti);
 
-  /** 
+  /**
    * Send a HandoverRequest through the X2 SAP interface. This method will
    * trigger a handover which is started by the RRC by sending a handover
    * request to the target eNB over the X2 interface
@@ -979,12 +1184,13 @@
 
   /**
    * Identifies how EPS Bearer parameters are mapped to different RLC types
-   * 
+   *
    */
   enum LteEpsBearerToRlcMapping_t {RLC_SM_ALWAYS = 1,
                                    RLC_UM_ALWAYS = 2,
                                    RLC_AM_ALWAYS = 3,
-                                   PER_BASED = 4};
+                                   PER_BASED = 4,
+                                   RLC_UM_LOWLAT_ALWAYS = 5};
 
   /**
    * TracedCallback signature for new Ue Context events.
@@ -1031,6 +1237,43 @@
     (const uint64_t imsi, const uint16_t cellId, const uint16_t rnti,
      const LteRrcSap::MeasurementReport report);
 
+   typedef void (* NotifyMmWaveSinrTracedCallback)
+     (uint64_t imsi, uint16_t cellId, long double sinr);
+
+   /**
+    * Different secondary cell handover modes
+    */
+   enum HandoverMode
+   {
+     FIXED_TTT = 1,
+     DYNAMIC_TTT = 2,
+     THRESHOLD = 3
+   };
+
+   struct HandoverEventInfo
+   {
+     uint16_t sourceCellId;
+     uint16_t targetCellId;
+     EventId scheduledHandoverEvent;
+   };
+
+   /**
+    * Map with info on handover events, per imsi
+    */
+   typedef std::map<uint64_t, HandoverEventInfo> HandoverEventMap;
+
+   /**
+    * This method maps Imsi to Rnti, so that the UeManager of a certain UE
+    * can be retrieved also with the Imsi
+    */
+   void RegisterImsiToRnti(uint64_t imsi, uint16_t rnti);
+
+   uint16_t GetRntiFromImsi(uint64_t imsi);
+
+   uint64_t GetImsiFromRnti(uint16_t rnti);
+
+   void SetInterRatHoMode ();
+
 private:
 
 
@@ -1085,6 +1328,7 @@
    */
   void DoRecvMeasurementReport (uint16_t rnti, LteRrcSap::MeasurementReport msg);
 
+  void DoRecvRrcSecondaryCellInitialAccessSuccessful (uint16_t rnti, uint16_t mmWaveRnti, uint16_t mmWaveCellId);
   // S1 SAP methods
 
   /**
@@ -1144,12 +1388,20 @@
    * \param params EpcX2SapUser::ResourceStatusUpdateParams
    */
   void DoRecvResourceStatusUpdate (EpcX2SapUser::ResourceStatusUpdateParams params);
+  void DoRecvRlcSetupRequest (EpcX2SapUser::RlcSetupRequest params);
+  void DoRecvRlcSetupCompleted (EpcX2SapUser::UeDataParams params);
   /**
    * Receive UE data function
    *
    * \param params EpcX2SapUser::UeDataParams
    */
   void DoRecvUeData (EpcX2SapUser::UeDataParams params);
+  void DoRecvUeSinrUpdate(EpcX2SapUser::UeImsiSinrParams params);
+  void DoRecvMcHandoverRequest(EpcX2SapUser::SecondaryHandoverParams params);
+  void DoRecvLteMmWaveHandoverCompleted (EpcX2SapUser::SecondaryHandoverParams params);
+  void DoRecvConnectionSwitchToMmWave (EpcX2SapUser::SwitchConnectionParams params);
+  void DoRecvSecondaryCellHandoverCompleted (EpcX2SapUser::SecondaryHandoverCompletedParams params);
+
 
   // CMAC SAP methods
 
@@ -1232,8 +1484,14 @@
    */
   void DoSendLoadInformation (EpcX2Sap::LoadInformationParams params);
 
+  // CPHY SAP methods
+  void DoUpdateUeSinrEstimate(LteEnbCphySapUser::UeAssociatedSinrInfo info);
+
   // Internal methods
 
+  void EnableSwitching(uint64_t imsi);
+  bool m_switchEnabled;
+
   /**
    * Allocate a new RNTI for a new UE. This is done in the following cases:
    *   * T-C-RNTI allocation upon contention-based MAC Random Access procedure
@@ -1254,10 +1512,10 @@
   void RemoveUe (uint16_t rnti);
 
 
-  /** 
-   * 
+  /**
+   *
    * \param bearer the specification of an EPS bearer
-   * 
+   *
    * \return the type of RLC that is to be created for the given EPS bearer
    */
   TypeId GetRlcType (EpsBearer bearer);
@@ -1266,20 +1524,20 @@
 
 public:
 
-  /** 
+  /**
    * Add a neighbour with an X2 interface
    *
    * \param cellId neighbouring cell id
    */
   void AddX2Neighbour (uint16_t cellId);
 
-  /** 
-   * 
+  /**
+   *
    * \param p the SRS periodicity in num TTIs
    */
   void SetSrsPeriodicity (uint32_t p);
 
-  /** 
+  /**
    *
    * \return the current SRS periodicity
    */
@@ -1314,41 +1572,42 @@
 
 private:
 
-  /** 
-   * Allocate a new SRS configuration index for a new UE. 
+  /**
+   * Allocate a new SRS configuration index for a new UE.
    *
    * \note this method can have the side effect of updating the SRS
    * configuration index of all UEs
-   * 
+   *
    * \return the newly allocated SRS configuration index
    */
   uint16_t GetNewSrsConfigurationIndex (void);
 
-  /** 
+  /**
    * remove a previously allocated SRS configuration index
    *
    * \note this method can have the side effect of updating the SRS
    * configuration index of all UEs
-   * 
+   *
    * \param srcCi the indext to be removed
    */
   void RemoveSrsConfigurationIndex (uint16_t srcCi);
 
- 
 
-  /** 
-   * 
+
+  /**
+   *
    * \param bearer the characteristics of the bearer
-   * 
+   *
    * \return the Logical Channel Group in a bearer with these
-   * characteristics is put. Used for MAC Buffer Status Reporting purposes. 
+   * characteristics is put. Used for MAC Buffer Status Reporting purposes.
    */
   uint8_t GetLogicalChannelGroup (EpsBearer bearer);
+  uint8_t GetLogicalChannelGroup (bool isGbr);
 
-  /** 
-   * 
+  /**
+   *
    * \param bearer the characteristics of the bearer
-   * 
+   *
    * \return the priority level of a bearer with these
    * characteristics is put. Used for the part of UL MAC Scheduling
    * carried out by the UE
@@ -1356,18 +1615,72 @@
   uint8_t GetLogicalChannelPriority (EpsBearer bearer);
 
 
-  /** 
+  /**
    * method used to periodically send System Information
-   * 
+   *
    */
   void SendSystemInformation ();
 
+  /**
+   * method used to periodically check if switching of MC devices or handover of MmWave dev is needed
+   *
+   */
+  void TriggerUeAssociationUpdate();
+
+  /**
+   * Trigger an handover according to certain conditions on the SINR
+   * @params the iterator on m_imsiCellSinrMap
+   * @params the sinrDifference between the current and the maxSinr cell
+   * @params the CellId of the maximum SINR cell
+   * @params the value of the SINR for this cell
+   */
+  void ThresholdBasedSecondaryCellHandover(std::map<uint64_t, CellSinrMap>::iterator imsiIter, double sinrDifference, uint16_t maxSinrCellId, double maxSinrDb);
+
+    /**
+   * Trigger an handover according to certain conditions on the SINR and the TTT
+   * @params the iterator on m_imsiCellSinrMap
+   * @params the sinrDifference between the current and the maxSinr cell
+   * @params the CellId of the maximum SINR cell
+   * @params the value of the SINR for this cell
+   */
+  void TttBasedHandover(std::map<uint64_t, CellSinrMap>::iterator imsiIter, double sinrDifference, uint16_t maxSinrCellId, double maxSinrDb);
+
+  /**
+   * Compute the TTT according to the sinrDifference and the dynamic handover algorithm
+   */
+  uint8_t ComputeTtt(double sinrDifference);
+
+  /**
+   * Method that can be scheduled to perform an handover
+   * @params imsi
+   */
+  void PerformHandover(uint64_t imsi);
+
+  /**
+   * method used to periodically check if HO between MmWave and LTE is needed
+   *
+   */
+  void UpdateUeHandoverAssociation();
+
+  /**
+   * Trigger an handover according to certain conditions on the SINR (for single-connectivity devices)
+   * @params the iterator on m_imsiCellSinrMap
+   * @params the sinrDifference between the current and the maxSinr cell
+   * @params the CellId of the maximum SINR cell
+   * @params the value of the SINR for this cell
+   */
+  void ThresholdBasedInterRatHandover(std::map<uint64_t, CellSinrMap>::iterator imsiIter, double sinrDifference, uint16_t maxSinrCellId, double maxSinrDb);
+
   Callback <void, Ptr<Packet> > m_forwardUpCallback;  ///< forward up callback function
 
   /// Interface to receive messages from neighbour eNodeB over the X2 interface.
   EpcX2SapUser* m_x2SapUser;
   /// Interface to send messages to neighbour eNodeB over the X2 interface.
   EpcX2SapProvider* m_x2SapProvider;
+  /// Interface to be provided to PDCP
+  EpcX2PdcpProvider* m_x2PdcpProvider;
+  /// Interface to be provided to RLC
+  EpcX2RlcProvider* m_x2RlcProvider;
 
   /// Receive API calls from the eNodeB MAC instance.
   std::vector<LteEnbCmacSapUser*> m_cmacSapUser;
@@ -1414,6 +1727,10 @@
 
   /// True if ConfigureCell() has been completed.
   bool m_configured;
+  /// Cell identifier. Must be unique across the simulation.
+  uint16_t m_cellId;
+  /// Closest LTE Cell identifier (for MmWave cells only).
+  uint16_t m_lteCellId;
   /// Downlink E-UTRA Absolute Radio Frequency Channel Number.
   uint32_t m_dlEarfcn;
   /// Uplink E-UTRA Absolute Radio Frequency Channel Number.
@@ -1457,6 +1774,7 @@
 
   /// TEID, RNTI, DRBID
   std::map<uint32_t, X2uTeidInfo> m_x2uTeidInfoMap;
+  std::map<uint32_t, X2uTeidInfo> m_x2uMcTeidInfoMap; // for the MC devices
 
   /**
    * The `DefaultTransmissionMode` attribute. The default UEs' transmission
@@ -1575,12 +1893,58 @@
    */
   TracedCallback<uint64_t, uint16_t, uint16_t, LteRrcSap::MeasurementReport> m_recvMeasurementReportTrace;
 
+  TracedCallback<uint64_t, uint16_t, long double> m_notifyMmWaveSinrTrace;
+
+  //mc
+  bool m_ismmWave;
+  bool m_interRatHoMode;
+  bool m_firstReport;
+
+  uint32_t m_firstSibTime;		// time in ms of initial SIB
+
+  // for MmWave eNBs
+  std::map<uint8_t, ImsiSinrMap> m_ueImsiSinrMap; // this map contains the ueImsiSinrMap reports sent by the CCs
+  bool m_reportAllUeMeas; // if true, the MmWave eNB reports to the coordinator all the received UE measures, i.e. one per CC
+
+  // for LTE eNBs
+  std::map<uint16_t, ImsiSinrMap> m_cellSinrMap;
+  uint16_t m_numNewSinrReports;
+  std::map<uint64_t, uint16_t> m_bestMmWaveCellForImsiMap;
+  std::map<uint64_t, uint16_t> m_lastMmWaveCell;
+  std::map<uint64_t, bool> m_mmWaveCellSetupCompleted;
+  std::map<uint64_t, bool> m_imsiUsingLte;
+  std::map<uint64_t, CellSinrMap> m_imsiCellSinrMap;
+  std::map<uint64_t, uint16_t> m_imsiRntiMap;
+  std::map<uint16_t, uint64_t> m_rntiImsiMap;
+
+  HandoverMode m_handoverMode;
+
+  // TTT based handover management
+  HandoverEventMap m_imsiHandoverEventsMap;
+
+  long double m_sinrThresholdDifference;
+
+  long double m_outageThreshold;
+
+  uint8_t m_fixedTttValue;
+  uint8_t m_minDynTttValue;
+  uint8_t m_maxDynTttValue;
+  double m_minDiffTttValue;
+  double m_maxDiffTttValue;
+
+  int m_crtPeriod;
+
+  uint32_t m_x2_received_cnt;
+
+  //Carrier aggregation
   uint16_t m_numberOfComponentCarriers; ///< number of component carriers
 
   bool m_carriersConfigured; ///< are carriers configured
 
   std::map<uint8_t, Ptr<ComponentCarrierEnb>> m_componentCarrierPhyConf; ///< component carrier phy configuration
 
+  std::map<uint8_t, MmWaveComponentCarrierConf> m_mmWaveComponentCarrierPhyConf; ///< mmWave component carrier phy configuration
+
 }; // end of `class LteEnbRrc`
 
 
diff -Naru a/model/lte-harq-phy.cc b/model/lte-harq-phy.cc
--- a/model/lte-harq-phy.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-harq-phy.cc	2018-08-03 16:39:02.891957671 +0200
@@ -176,13 +176,13 @@
     }
   else
     {
-      if ((*it).second.at (0).size () == 3) // MAX HARQ RETX
+      if ((*it).second.at (7).size () == 3) // MAX HARQ RETX
         {
           // HARQ should be disabled -> discard info
           return;
         }
-      
-//       move current status back at the end to maintain full history
+
+      //move current status back at the end to maintain full history
       HarqProcessInfoList_t list = (*it).second.at (0);
       for (uint8_t i = 0; i < list.size (); i++)
         {
diff -Naru a/model/lte-mac-sap.cc b/model/lte-mac-sap.cc
--- a/model/lte-mac-sap.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-mac-sap.cc	2018-08-03 16:39:02.891957671 +0200
@@ -33,7 +33,15 @@
 {
 }
 
+void
+LteMacSapUser::NotifyDlHarqDeliveryFailure (uint8_t harqId)
+{
+}
 
+void
+LteMacSapUser::NotifyUlHarqDeliveryFailure (uint8_t harqId)
+{
+}
 
 
 } // namespace ns3
diff -Naru a/model/lte-mac-sap.h b/model/lte-mac-sap.h
--- a/model/lte-mac-sap.h	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-mac-sap.h	2018-08-03 16:39:02.891957671 +0200
@@ -73,6 +73,13 @@
     uint32_t retxQueueSize;  /**<  the current size of the RLC retransmission queue in bytes */
     uint16_t retxQueueHolDelay;  /**<  the Head Of Line delay of the retransmission queue */
     uint16_t statusPduSize;  /**< the current size of the pending STATUS RLC  PDU message in bytes */
+
+    // RDF: Added for MmWave low-latency schedulers
+    std::list<uint32_t>	txPacketSizes;
+    std::list<uint32_t>	retxPacketSizes;
+    std::list<double>	txPacketDelays;
+    std::list<double>	retxPacketDelays;
+    double arrivalRate;		// average bits per s
   };
 
   /**
@@ -117,6 +124,9 @@
    */
   virtual void NotifyHarqDeliveryFailure () = 0;
 
+  virtual void NotifyDlHarqDeliveryFailure (uint8_t harqId);
+
+  virtual void NotifyUlHarqDeliveryFailure (uint8_t harqId);
 
   /**
    * Called by the MAC to notify the RLC of the reception of a new PDU
diff -Naru a/model/lte-mi-error-model.cc b/model/lte-mi-error-model.cc
--- a/model/lte-mi-error-model.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-mi-error-model.cc	2018-08-03 16:39:02.891957671 +0200
@@ -27,7 +27,7 @@
 *
 * Subsequent integration in LENA and extension done by:
 *      Marco Miozzo <marco.miozzo@cttc.es>
-*/ 
+*/
 
 #include <list>
 #include <vector>
@@ -59,7 +59,7 @@
   static const uint8_t McsEcrBlerTableMapping[29] = {
     3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
     16, 17, 18, 19, 20, 21, 22,
-    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37    
+    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37
   };
 
   /// Table of ECR of the standard MCSs
@@ -71,39 +71,39 @@
   static const double HarqRetxEcr[9] = {0.00064, 0.000512, 0.000041, 0.09, 0.027, 0.0081, 0.185, 0.079, 0.034
   };
 #endif
- 
+
   /** PCFICH-PDCCH Error model based on 3GPP R4-081920 "LTE PDCCH/PCFICH
-   *  Demodulation Performance Results with Implementation Margin" 
+   *  Demodulation Performance Results with Implementation Margin"
    *  X axis */
   static const double PdcchPcfichBlerCurveXaxis[PDCCH_PCFICH_CURVE_SIZE] = {
       -10,-9.8,-9.6, -9.4, -9.2, -9.0, -8.8, -8.6, -8.4, -8.2, -8.0,
-      -7.8, -7.6, -7.4, -7.2, -7.0, -6.8, -6.6, -6.4,   -6.2, -6.0, 
-      -5.8, -5.6, -5.4, -5.2, -5.0, -4.8, -4.6, -4.4, -4.2, -4.0, 
-      -3.8, -3.6, -3.4, -3.2, -3.0, -2.8, -2.6, -2.4, -2.2, -2.0, 
+      -7.8, -7.6, -7.4, -7.2, -7.0, -6.8, -6.6, -6.4,   -6.2, -6.0,
+      -5.8, -5.6, -5.4, -5.2, -5.0, -4.8, -4.6, -4.4, -4.2, -4.0,
+      -3.8, -3.6, -3.4, -3.2, -3.0, -2.8, -2.6, -2.4, -2.2, -2.0,
       -1.8, -1.6, -1.4, -1.2, -1.0
   };
-  
+
   /** PCFICH-PDCCH Error model based on 3GPP R4-081920 "LTE PDCCH/PCFICH
-   *  Demodulation Performance Results with Implementation Margin" 
+   *  Demodulation Performance Results with Implementation Margin"
    *  Y axis */
   static const double PdcchPcfichBlerCurveYaxis[PDCCH_PCFICH_CURVE_SIZE] = {
     0.922602, 0.871559, 0.82334, 0.777789, 0.734758, 0.694107, 0.655706,
     0.619429, 0.585159, 0.552785, 0.520927, 0.479229, 0.440869, 0.405579,
     0.373114, 0.343104, 0.309947,0.279994, 0.252936, 0.228492, 0.206048,
     0.181449, 0.159787, 0.140711, 0.123912, 0.109119, 0.0916184, 0.0769244,
-    0.0645871, 0.0542285, 0.0454971, 0.037584, 0.0310472, 0.0256473, 
+    0.0645871, 0.0542285, 0.0454971, 0.037584, 0.0310472, 0.0256473,
     0.0211866, 0.0175023, 0.0144636, 0.0119524, 0.00987724, 0.00816236,
     0.00673821, 0.00532283, 0.00420476, 0.00332154, 0.00262385, 0.0020727
-  
+
   };
-  
+
 #if 0 // currently unused
   static const int TbsIndex[32] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 10, 11, 12, 13, 14, 15, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, -1, -1, -1};
 #endif
-  
+
   /// as K column of table 5.1.3-3 of TS 36,212
   static const uint16_t cbSizeTable[188] = {
-    
+
     40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128, 136, 144, 152,
     160, 168, 176, 184, 192, 200, 208, 216, 224, 232, 240, 248, 256, 264,
     272, 280, 288, 296, 304, 312, 320, 328, 336, 344, 352, 360, 368, 376,
@@ -121,7 +121,7 @@
     5824, 5888, 5952, 6016, 6080, 6144
   };
 
-/// MI size table  
+/// MI size table
 static const uint16_t cbMiSizeTable [9] = {40, 104, 160, 256, 512, 1024, 2560, 4032, 6144};
 
 
@@ -168,7 +168,7 @@
     -1.000, -1.000, -1.000, -1.000, -1.000, -1.000, -1.000, // 16QAM
     -1.000, -1.000, -1.000, // 64QAM retx
     -1.000, -1.000, -1.000, -1.000, -1.000, -1.000, -1.000, -1.000, -1.000, -1.000, -1.000, -1.000 // 64QAM
-  },  
+  },
   // CB of 104 bits
   {
     0.01940, 0.05020, 0.07592, // QPSK retx
@@ -242,9 +242,9 @@
     0.49780, 0.51606, 0.5600, 0.6027, 0.6494, 0.6948, 0.7407, 0.7842, 0.8284, 0.8692, 0.9058, 0.9325  // 64QAM
   },
 };
-  
 
-/// CECR table  
+
+/// CECR table
 static const double cEcrTable [9][38] = {
   // CB of 40 bits
   {
@@ -327,19 +327,19 @@
     0.00303, 0.00377, 0.00507, // 64QAM retx
     0.0060, 0.00609, 0.0061, 0.0066, 0.0069, 0.0080, 0.0081, 0.0080, 0.0077, 0.0068, 0.0066, 0.0058 // 64QAM
   }
-    
+
 };
 
 
-double 
+double
 LteMiErrorModel::Mib (const SpectrumValue& sinr, const std::vector<int>& map, uint8_t mcs)
 {
   NS_LOG_FUNCTION (sinr << &map << (uint32_t) mcs);
-  
+
   double MI;
   double MIsum = 0.0;
   SpectrumValue sinrCopy = sinr;
-  
+
   for (uint32_t i = 0; i < map.size (); i++)
     {
       double sinrLin = sinrCopy[map.at (i)];
@@ -350,13 +350,13 @@
             {
               MI = 1;
             }
-          else 
-            { 
+          else
+            {
               // since the values in MI_map_qpsk_axis are uniformly spaced, we have
               // index = ((sinrLin - value[0]) / (value[SIZE-1] - value[0])) * (SIZE-1)
               // the scaling coefficient is always the same, so we use a static const
               // to speed up the calculation
-              static const double scalingCoeffQpsk = 
+              static const double scalingCoeffQpsk =
                 (MI_MAP_QPSK_SIZE - 1) / (MI_map_qpsk_axis[MI_MAP_QPSK_SIZE-1] - MI_map_qpsk_axis[0]);
               double sinrIndexDouble = (sinrLin -  MI_map_qpsk_axis[0]) * scalingCoeffQpsk + 1;
               uint32_t sinrIndex = std::max(0.0, std::floor (sinrIndexDouble));
@@ -372,13 +372,13 @@
                 {
                   MI = 1;
                 }
-              else 
+              else
                 {
                   // since the values in MI_map_16QAM_axis are uniformly spaced, we have
                   // index = ((sinrLin - value[0]) / (value[SIZE-1] - value[0])) * (SIZE-1)
                   // the scaling coefficient is always the same, so we use a static const
                   // to speed up the calculation
-                  static const double scalingCoeff16qam = 
+                  static const double scalingCoeff16qam =
                     (MI_MAP_16QAM_SIZE - 1) / (MI_map_16qam_axis[MI_MAP_16QAM_SIZE-1] - MI_map_16qam_axis[0]);
                   double sinrIndexDouble = (sinrLin -  MI_map_16qam_axis[0]) * scalingCoeff16qam + 1;
                   uint32_t sinrIndex = std::max(0.0, std::floor (sinrIndexDouble));
@@ -398,7 +398,7 @@
                   // index = ((sinrLin - value[0]) / (value[SIZE-1] - value[0])) * (SIZE-1)
                   // the scaling coefficient is always the same, so we use a static const
                   // to speed up the calculation
-                  static const double scalingCoeff64qam = 
+                  static const double scalingCoeff64qam =
                     (MI_MAP_64QAM_SIZE - 1) / (MI_map_64qam_axis[MI_MAP_64QAM_SIZE-1] - MI_map_64qam_axis[0]);
                   double sinrIndexDouble = (sinrLin -  MI_map_64qam_axis[0]) * scalingCoeff64qam + 1;
                   uint32_t sinrIndex = std::max(0.0, std::floor (sinrIndexDouble));
@@ -416,7 +416,7 @@
 }
 
 
-double 
+double
 LteMiErrorModel::MappingMiBler (double mib, uint8_t ecrId, uint16_t cbSize)
 {
   NS_LOG_FUNCTION (mib << (uint32_t) ecrId << (uint32_t) cbSize);
@@ -479,13 +479,13 @@
         {
           MI = 1;
         }
-      else 
-        { 
+      else
+        {
           // since the values in MI_map_qpsk_axis are uniformly spaced, we have
           // index = ((sinrLin - value[0]) / (value[SIZE-1] - value[0])) * (SIZE-1)
               // the scaling coefficient is always the same, so we use a static const
               // to speed up the calculation
-          static const double scalingCoeffQpsk = 
+          static const double scalingCoeffQpsk =
             (MI_MAP_QPSK_SIZE - 1) / (MI_map_qpsk_axis[MI_MAP_QPSK_SIZE-1] - MI_map_qpsk_axis[0]);
           double sinrIndexDouble = (sinrLin -  MI_map_qpsk_axis[0]) * scalingCoeffQpsk + 1;
           uint32_t sinrIndex = std::max(0.0, std::floor (sinrIndexDouble));
@@ -508,10 +508,10 @@
     {
       esinr = MI_map_qpsk_axis[MI_MAP_QPSK_SIZE-1];
     }
-  else 
+  else
     {
       NS_ASSERT_MSG (j<MI_MAP_QPSK_SIZE, "MI map out of data");
-      // take the closest value (when possible)  
+      // take the closest value (when possible)
       if (j>0)
         {
           if ((MI_map_qpsk[j]-MI)<(MI-MI_map_qpsk[j-1]))
@@ -529,7 +529,7 @@
         }
     }
 
-  double esirnDb = 10*log10 (esinr); 
+  double esirnDb = 10*log10 (esinr);
 //   NS_LOG_DEBUG ("Effective SINR " << esirnDb << " max " << 10*log10 (MI_map_qpsk [MI_MAP_QPSK_SIZE-1]));
   uint16_t i = 0;
   double errorRate = 0.0;
@@ -541,12 +541,12 @@
     {
       errorRate = 0.0;
     }
-  else 
+  else
     {
       NS_ASSERT_MSG (i<PDCCH_PCFICH_CURVE_SIZE, "PDCCH-PCFICH map out of data");
       errorRate = PdcchPcfichBlerCurveYaxis[i];
-    }  
-  
+    }
+
   return (errorRate);
 }
 
@@ -576,7 +576,7 @@
       codeBitsSum += (((double)size*8.0) / McsEcrTable [mcs]);
       miSum += (tbMi*(((double)size*8.0) / McsEcrTable [mcs]));
       Reff = miHistory.at (0).m_infoBits / (double)codeBitsSum; // information bits are the size of the first TB
-      MI = miSum / (double)codeBitsSum;      
+      MI = miSum / (double)codeBitsSum;
     }
   else
     {
@@ -740,7 +740,6 @@
 }
 
 
-  
 
-} // namespace ns3
 
+} // namespace ns3
diff -Naru a/model/lte-net-device.cc b/model/lte-net-device.cc
--- a/model/lte-net-device.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-net-device.cc	2018-08-03 16:39:02.891957671 +0200
@@ -291,7 +291,7 @@
   ipType = (ipType>>4) & 0x0f;
 
   if (ipType == 0x04)
-    m_rxCallback (this, p, Ipv4L3Protocol::PROT_NUMBER, Address ());
+  m_rxCallback (this, p, Ipv4L3Protocol::PROT_NUMBER, Address ());
   else if (ipType == 0x06)
     m_rxCallback (this, p, Ipv6L3Protocol::PROT_NUMBER, Address ());
   else
diff -Naru a/model/lte-net-device.h b/model/lte-net-device.h
--- a/model/lte-net-device.h	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-net-device.h	2018-08-03 16:39:02.891957671 +0200
@@ -80,21 +80,21 @@
   virtual void SetReceiveCallback (NetDevice::ReceiveCallback cb);
   virtual Address GetMulticast (Ipv4Address addr) const;
   virtual Address GetMulticast (Ipv6Address addr) const;
-  virtual void SetPromiscReceiveCallback (PromiscReceiveCallback cb); 
+  virtual void SetPromiscReceiveCallback (PromiscReceiveCallback cb);
   virtual bool SendFrom (Ptr<Packet> packet, const Address& source, const Address& dest, uint16_t protocolNumber);
   virtual bool SupportsSendFrom (void) const;
 
-  /** 
+  /**
    * receive a packet from the lower layers in order to forward it to the upper layers
-   * 
+   *
    * \param p the packet
    */
   void Receive (Ptr<Packet> p);
-  
+
 protected:
-  
+
   NetDevice::ReceiveCallback m_rxCallback; ///< receive callback
-  
+
 private:
   /// type conversion operator
   LteNetDevice (const LteNetDevice &);
diff -Naru a/model/lte-pdcp.cc b/model/lte-pdcp.cc
--- a/model/lte-pdcp.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-pdcp.cc	2018-08-03 16:39:02.891957671 +0200
@@ -155,7 +155,7 @@
   return m_rlcSapUser;
 }
 
-LtePdcp::Status 
+LtePdcp::Status
 LtePdcp::GetStatus ()
 {
   Status s;
@@ -164,7 +164,7 @@
   return s;
 }
 
-void 
+void
 LtePdcp::SetStatus (Status s)
 {
   m_txSequenceNumber = s.txSn;
@@ -194,7 +194,7 @@
 
   // Sender timestamp
   PdcpTag pdcpTag (Simulator::Now ());
-  p->AddPacketTag (pdcpTag);
+  p->AddByteTag (pdcpTag);
   m_txPdu (m_rnti, m_lcid, p->GetSize ());
 
   LteRlcSapProvider::TransmitPdcpPduParameters params;
@@ -213,9 +213,10 @@
   // Receiver timestamp
   PdcpTag pdcpTag;
   Time delay;
-  NS_ASSERT_MSG (p->PeekPacketTag (pdcpTag), "PdcpTag is missing");
-  p->RemovePacketTag (pdcpTag);
-  delay = Simulator::Now() - pdcpTag.GetSenderTimestamp ();
+  if (p->FindFirstMatchingByteTag (pdcpTag))
+    {
+      delay = Simulator::Now() - pdcpTag.GetSenderTimestamp ();
+    }
   m_rxPdu(m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
 
   LtePdcpHeader pdcpHeader;
diff -Naru a/model/lte-pdcp-header.cc b/model/lte-pdcp-header.cc
--- a/model/lte-pdcp-header.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-pdcp-header.cc	2018-08-03 16:39:02.891957671 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/log.h"
@@ -98,7 +102,7 @@
   Buffer::Iterator i = start;
 
   i.WriteU8 ( (m_dcBit << 7) | (m_sequenceNumber & 0x0F00) >> 8 );
-  i.WriteU8 ( (m_sequenceNumber & 0x00FF) );
+  i.WriteU8 ( (uint8_t)(m_sequenceNumber & 0x00FF) );
 }
 
 uint32_t LtePdcpHeader::Deserialize (Buffer::Iterator start)
@@ -110,8 +114,10 @@
   byte_1 = i.ReadU8 ();
   byte_2 = i.ReadU8 ();
   m_dcBit = (byte_1 & 0x80) > 7;
-  // For now, we just support DATA PDUs
-  NS_ASSERT (m_dcBit == DATA_PDU);
+  
+  // HACKED. ENABLE THIS TO DISTINGUISH DATA_PDU and CONTROL_PDU in lte-enb-rrc.cc, lossless HO func
+  //NS_ASSERT (m_dcBit == DATA_PDU);
+
   m_sequenceNumber = ((byte_1 & 0x0F) << 8) | byte_2;
 
   return GetSerializedSize ();
diff -Naru a/model/lte-phy.cc b/model/lte-phy.cc
--- a/model/lte-phy.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-phy.cc	2018-08-03 16:39:02.891957671 +0200
@@ -1,7 +1,8 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2010 TELEMATICS LAB, DEE - Politecnico di Bari
- *
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation;
@@ -17,6 +18,9 @@
  *
  * Author: Giuseppe Piro  <g.piro@poliba.it>
  *         Marco Miozzo <mmiozzo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/waveform-generator.h>
@@ -87,27 +91,27 @@
 }
 
 void
-LtePhy::SetDevice (Ptr<LteNetDevice> d)
+LtePhy::SetDevice (Ptr<NetDevice> d)
 {
   NS_LOG_FUNCTION (this << d);
   m_netDevice = d;
 }
 
 
-Ptr<LteNetDevice>
+Ptr<NetDevice>
 LtePhy::GetDevice () const
 {
   NS_LOG_FUNCTION (this);
   return m_netDevice;
 }
 
-Ptr<LteSpectrumPhy> 
+Ptr<LteSpectrumPhy>
 LtePhy::GetDownlinkSpectrumPhy ()
 {
   return m_downlinkSpectrumPhy;
 }
 
-Ptr<LteSpectrumPhy> 
+Ptr<LteSpectrumPhy>
 LtePhy::GetUplinkSpectrumPhy ()
 {
   return m_uplinkSpectrumPhy;
diff -Naru a/model/lte-phy.h b/model/lte-phy.h
--- a/model/lte-phy.h	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-phy.h	2018-08-03 16:39:02.891957671 +0200
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2010 TELEMATICS LAB, DEE - Politecnico di Bari
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Giuseppe Piro  <g.piro@poliba.it>
  *         Marco Miozzo <mmiozzo@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_PHY_H
@@ -53,13 +57,13 @@
 {
 
 public:
-  /** 
+  /**
    * @warning the default constructor should not be used
    */
   LtePhy ();
 
-  /** 
-   * 
+  /**
+   *
    * \param dlPhy the downlink LteSpectrumPhy instance
    * \param ulPhy the uplink LteSpectrumPhy instance
    */
@@ -77,22 +81,22 @@
    * \brief Set the device where the phy layer is attached
    * \param d the device
    */
-  void SetDevice (Ptr<LteNetDevice> d);
+  void SetDevice (Ptr<NetDevice> d);
   /**
    * \brief Get the device where the phy layer is attached
    * \return the pointer to the device
    */
-  Ptr<LteNetDevice> GetDevice () const;
+  Ptr<NetDevice> GetDevice () const;
 
-  /** 
-   * 
+  /**
+   *
    * \return a pointer to the LteSpectrumPhy instance that manages the downlink
    */
   Ptr<LteSpectrumPhy> GetDownlinkSpectrumPhy ();
 
 
-  /** 
-   * 
+  /**
+   *
    * \return a pointer to the LteSpectrumPhy instance that manages the uplink
    */
   Ptr<LteSpectrumPhy> GetUplinkSpectrumPhy ();
@@ -133,8 +137,8 @@
    */
   double GetTti (void) const;
 
-  /** 
-   * 
+  /**
+   *
    * \param cellId the Cell Identifier
    */
   void DoSetCellId (uint16_t cellId);
@@ -144,14 +148,14 @@
   * \returns the RB group size according to the bandwidth
   */
   uint8_t GetRbgSize (void) const;
-  
-  
+
+
   /**
   * \returns the SRS periodicity (see Table 8.2-1 of 36.213)
   * \param srcCi the SRS Configuration Index
   */
   uint16_t GetSrsPeriodicity (uint16_t srcCi) const;
-  
+
   /**
   * \returns the SRS Subframe offset (see Table 8.2-1 of 36.213)
   * \param srcCi the SRS Configuration Index
@@ -180,17 +184,17 @@
   std::list<Ptr<LteControlMessage> > GetControlMessages (void);
 
 
-  /** 
+  /**
    * generate a CQI report based on the given SINR of Ctrl frame
-   * 
+   *
    * \param sinr the SINR vs frequency measured by the device
    */
   virtual void GenerateCtrlCqiReport (const SpectrumValue& sinr) = 0;
-  
-  /** 
+
+  /**
   * generate a CQI report based on the given SINR of Data frame
   * (used for PUSCH CQIs)
-  * 
+  *
   * \param sinr the SINR vs frequency measured by the device
   */
   virtual void GenerateDataCqiReport (const SpectrumValue& sinr) = 0;
@@ -198,14 +202,14 @@
   /**
   * generate a report based on the linear interference and noise power
   * perceived during DATA frame
-  * NOTE: used only by eNB 
+  * NOTE: used only by eNB
   *
   * \param interf the interference + noise power measured by the device
   */
   virtual void ReportInterference (const SpectrumValue& interf) = 0;
 
   /**
-  * generate a report based on the linear RS power perceived during CTRL 
+  * generate a report based on the linear RS power perceived during CTRL
   * frame
   * NOTE: used only by UE for evaluating RSRP
   *
@@ -214,14 +218,14 @@
   virtual void ReportRsReceivedPower (const SpectrumValue& power) = 0;
 
   /**
-  * Set the component carrier ID 
+  * Set the component carrier ID
   *
   * \param index the component carrier ID index
   */
   void SetComponentCarrierId (uint8_t index);
 
   /**
-  * Get the component carrier ID 
+  * Get the component carrier ID
   *
   * \returns the component carrier ID index
   */
@@ -229,7 +233,7 @@
 
 protected:
   /// Pointer to the NetDevice where this PHY layer is attached.
-  Ptr<LteNetDevice> m_netDevice;
+  Ptr<NetDevice> m_netDevice;
 
   /**
    * The downlink LteSpectrumPhy associated to this LtePhy. Also available as
diff -Naru a/model/lte-radio-bearer-info.cc b/model/lte-radio-bearer-info.cc
--- a/model/lte-radio-bearer-info.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-radio-bearer-info.cc	2018-08-03 16:39:02.891957671 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "lte-radio-bearer-info.h"
@@ -113,6 +117,31 @@
   return tid;
 }
 
+RlcBearerInfo::RlcBearerInfo (void)
+{
+}
+
+RlcBearerInfo::~RlcBearerInfo (void)
+{
+}
+  
+TypeId 
+RlcBearerInfo::GetTypeId (void)
+{
+  static TypeId
+    tid =
+    TypeId ("ns3::RlcBearerInfo")
+    .SetParent<Object> ()
+    .AddConstructor<RlcBearerInfo> ()
+    .AddAttribute ("LteRlc", "RLC instance of the secondary connection.",
+                   PointerValue (),
+                   MakePointerAccessor (&RlcBearerInfo::m_rlc),
+                   MakePointerChecker<LteRlc> ())
+    ;
+  return tid;
+}
+
+
 
 
 } // namespace ns3
diff -Naru a/model/lte-radio-bearer-info.h b/model/lte-radio-bearer-info.h
--- a/model/lte-radio-bearer-info.h	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-radio-bearer-info.h	2018-08-03 16:39:02.891957671 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_RADIO_BEARER_INFO_H
@@ -26,6 +30,7 @@
 #include <ns3/eps-bearer.h>
 #include <ns3/lte-rrc-sap.h>
 #include <ns3/ipv4-address.h>
+#include <ns3/epc-x2-sap.h>
 
 namespace ns3 {
 
@@ -34,7 +39,7 @@
 
 /**
  * store information on active radio bearer instance
- * 
+ *
  */
 class LteRadioBearerInfo : public Object
 {
@@ -55,7 +60,7 @@
 
 /**
  * store information on active signaling radio bearer instance
- * 
+ *
  */
 class LteSignalingRadioBearerInfo : public LteRadioBearerInfo
 {
@@ -68,13 +73,13 @@
   static TypeId GetTypeId (void);
 
   uint8_t m_srbIdentity; ///< SRB indentity
-  LteRrcSap::LogicalChannelConfig m_logicalChannelConfig; ///< logical channel config  
+  LteRrcSap::LogicalChannelConfig m_logicalChannelConfig; ///< logical channel config
 };
 
 
 /**
  * store information on active data radio bearer instance
- * 
+ *
  */
 class LteDataRadioBearerInfo : public LteRadioBearerInfo
 {
@@ -94,8 +99,29 @@
   LteRrcSap::LogicalChannelConfig m_logicalChannelConfig; ///< logical channel config
   uint32_t m_gtpTeid; /**< S1-bearer GTP tunnel endpoint identifier, see 36.423 9.2.1 */
   Ipv4Address m_transportLayerAddress; /**< IP Address of the SGW, see 36.423 9.2.1 */
+  EpcX2Sap::RlcSetupRequest m_rlcSetupRequest; // complete bearer with related info, for MC functionalities
+  bool m_isMc; // true if a bearer is split
 };
 
+class RlcBearerInfo : public Object
+{
+public:
+  RlcBearerInfo (void);
+  virtual ~RlcBearerInfo (void);
+  static TypeId GetTypeId (void);
+
+    uint16_t    sourceCellId;
+    uint16_t    targetCellId;
+    uint32_t    gtpTeid;
+    uint16_t    mmWaveRnti;
+    uint16_t    lteRnti;
+    uint8_t     drbid;
+    uint8_t     logicalChannelIdentity;
+    LteRrcSap::RlcConfig rlcConfig;
+    LteRrcSap::LogicalChannelConfig logicalChannelConfig;
+    LteEnbCmacSapProvider::LcInfo lcinfo;
+    Ptr<LteRlc> m_rlc;
+};
 
 
 
diff -Naru a/model/lte-rlc-am.cc b/model/lte-rlc-am.cc
--- a/model/lte-rlc-am.cc	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rlc-am.cc	2018-08-03 16:39:02.891957671 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, 2018, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,16 +18,24 @@
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
+ *
+ * Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+ *								 Integration of Carrier Aggregation for the mmWave module
  */
 
 #include "ns3/simulator.h"
 #include "ns3/log.h"
+#include "ns3/string.h"
 
 #include "ns3/lte-rlc-am-header.h"
 #include "ns3/lte-rlc-am.h"
 #include "ns3/lte-rlc-sdu-status-tag.h"
 #include "ns3/lte-rlc-tag.h"
-
+#include "ns3/ipv4-queue-disc-item.h"
+#include "ns3/ipv4-packet-filter.h"
 
 namespace ns3 {
 
@@ -41,11 +50,19 @@
 
   // Buffers
   m_txonBufferSize = 0;
+  m_retxSegBuffer.resize (1024);
   m_retxBuffer.resize (1024);
   m_retxBufferSize = 0;
   m_txedBuffer.resize (1024);
   m_txedBufferSize = 0;
 
+  // LL HO
+  m_transmittingRlcSduBufferSize = 0;
+  m_txedRlcSduBuffer.resize (0);
+  m_txedRlcSduBufferSize = 0;
+  is_fragmented = 0;
+  //
+
   m_statusPduRequested = false;
   m_statusPduBufferSize = 0;
 
@@ -70,13 +87,52 @@
   // Configurable parameters
   m_maxRetxThreshold = 5;
   m_pollPdu = 1;
-  m_pollByte = 50;
+  m_pollByte = 50; // 1500000
 
   // SDU reassembling process
   m_reassemblingState = WAITING_S0_FULL;
   m_expectedSeqNumber = 0;
 
+  //LL HO: Reassemble
+  m_reassembleExpectedSeqNumber = 0;
+  m_assemblingState = WAITING_SI_SF;
+
   m_pollRetransmitTimerJustExpired = false;
+
+  m_epcX2RlcUser = new EpcX2RlcSpecificUser<LteRlcAm> (this);
+  m_epcX2RlcProvider = 0;
+
+  m_txonQueue = CreateObject<CoDelQueueDisc> ();
+  m_txonQueue->Initialize ();
+
+  m_traceBufferSizeEvent = Simulator::Schedule(MilliSeconds(2), &LteRlcAm::BufferSizeTrace, this);
+}
+
+void
+LteRlcAm::BufferSizeTrace()
+{
+  NS_LOG_LOGIC("BufferSizeTrace " << Simulator::Now().GetSeconds() << " " << m_rnti << " " << m_lcid << " " << m_txonBufferSize);
+  // write to file
+  /*if(!m_bufferSizeFile.is_open())
+  {
+    m_bufferSizeFile.open(GetBufferSizeFilename().c_str(), std::ofstream::app);
+    NS_LOG_LOGIC("File opened");
+  }
+  m_bufferSizeFile << Simulator::Now().GetSeconds() << " " << m_rnti << " " << (uint16_t) m_lcid << " " << m_txonBufferSize << std::endl;
+  */
+  m_traceBufferSizeEvent = Simulator::Schedule(MilliSeconds(10), &LteRlcAm::BufferSizeTrace, this);
+}
+
+std::string
+LteRlcAm::GetBufferSizeFilename()
+{
+  return m_bufferSizeFilename;
+}
+
+void
+LteRlcAm::SetBufferSizeFilename(std::string filename)
+{
+  m_bufferSizeFilename = filename;
 }
 
 LteRlcAm::~LteRlcAm ()
@@ -108,7 +164,7 @@
                    MakeTimeChecker ())
     .AddAttribute ("ReportBufferStatusTimer",
                    "How much to wait to issue a new Report Buffer Status since the last time "
-                   "a new SDU was received",     
+                   "a new SDU was received",
                    TimeValue (MilliSeconds (20)),
                    MakeTimeAccessor (&LteRlcAm::m_rbsTimerValue),
                    MakeTimeChecker ())
@@ -119,7 +175,21 @@
                    BooleanValue (false),
                    MakeBooleanAccessor (&LteRlcAm::m_txOpportunityForRetxAlwaysBigEnough),
                    MakeBooleanChecker ())
-
+   .AddAttribute ("MaxTxBufferSize",
+                  "Maximum Size of the Transmission Buffer (in Bytes)",
+                  UintegerValue (1024 * 1024),
+                  MakeUintegerAccessor (&LteRlcAm::m_maxTxBufferSize),
+                  MakeUintegerChecker<uint32_t> ())
+    .AddAttribute ("EnableAQM",
+                  "Enable active queue management (CoDel)",
+                   BooleanValue (false),
+                   MakeBooleanAccessor (&LteRlcAm::m_enableAqm),
+                   MakeBooleanChecker ())
+   .AddAttribute ("BufferSizeFilename",
+                   "Name of the file where the buffer size will be periodically written.",
+                   StringValue ("RlcAmBufferSize.txt"),
+                   MakeStringAccessor (&LteRlcAm::SetBufferSizeFilename),
+                   MakeStringChecker ())
     ;
   return tid;
 }
@@ -142,8 +212,22 @@
   m_rxonBuffer.clear ();
   m_sdusBuffer.clear ();
   m_keepS0 = 0;
+  m_keepS0Reassemble = 0;
   m_controlPduBuffer = 0;
 
+  // LL HO
+  m_sdusAssembleBuffer.clear ();
+  m_reassembleExpectedSeqNumber = 0;
+  m_expectedSeqNumber = 0;
+  m_transmittingRlcSduBufferSize = 0;
+  m_transmittingRlcSduBuffer.clear();
+  is_fragmented = 0;
+  m_txedRlcSduBuffer.clear ();
+  m_txedRlcSduBufferSize = 0;
+
+  m_traceBufferSizeEvent.Cancel();
+  m_bufferSizeFile.close();
+
   LteRlc::DoDispose ();
 }
 
@@ -157,22 +241,57 @@
 {
   NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
 
-  /** Store arrival time */
-  Time now = Simulator::Now ();
-  RlcTag timeTag (now);
-  p->AddPacketTag (timeTag);
-
-  /** Store PDCP PDU */
-
-  LteRlcSduStatusTag tag;
-  tag.SetStatus (LteRlcSduStatusTag::FULL_SDU);
-  p->AddPacketTag (tag);
+  if(m_enableAqm == false)
+  {
+    if (m_txonBufferSize + p->GetSize () <= m_maxTxBufferSize)
+    {
+      /** Store arrival time */
+      Time now = Simulator::Now ();
+      RlcTag timeTag (now);
+      p->AddPacketTag (timeTag);
+
+      /** Store PDCP PDU */
+
+      LteRlcSduStatusTag tag;
+      tag.SetStatus (LteRlcSduStatusTag::FULL_SDU);
+      p->AddPacketTag (tag);
+
+      NS_LOG_INFO ("Txon Buffer: New packet added");
+      m_txonBuffer.push_back (p);
+      m_txonBufferSize += p->GetSize ();
+      NS_LOG_LOGIC ("NumOfBuffers = " << m_txonBuffer.size() );
+      NS_LOG_LOGIC ("txonBufferSize = " << m_txonBufferSize);
+    }
+    else
+    {
+      // Discard full RLC SDU
+      NS_LOG_LOGIC ("TxBuffer is full. RLC SDU discarded");
+      NS_LOG_LOGIC ("MaxTxBufferSize = " << m_maxTxBufferSize);
+      NS_LOG_LOGIC ("txonBufferSize    = " << m_txonBufferSize);
+      NS_LOG_LOGIC ("packet size     = " << p->GetSize ());
+    }
+  }
+  else // Use CoDel queue
+  {
+    //Store arrival time
+    Time now = Simulator::Now ();
+    RlcTag timeTag (now);
+    p->AddPacketTag (timeTag);
+
+    //Store PDCP PDU
+
+    LteRlcSduStatusTag tag;
+    tag.SetStatus (LteRlcSduStatusTag::FULL_SDU);
+    p->AddPacketTag (tag);
+
+    NS_LOG_LOGIC ("Txon Buffer: New packet added");
+    Ptr<Ipv4QueueDiscItem> item;
+    Ipv4Header ipv4Header;
+    Address dest;
+    item = Create<Ipv4QueueDiscItem> (p, dest, 0, ipv4Header);
+    m_txonQueue->Enqueue (item);
+  }
 
-  NS_LOG_LOGIC ("Txon Buffer: New packet added");
-  m_txonBuffer.push_back (p);
-  m_txonBufferSize += p->GetSize ();
-  NS_LOG_LOGIC ("NumOfBuffers = " << m_txonBuffer.size() );
-  NS_LOG_LOGIC ("txonBufferSize = " << m_txonBufferSize);
 
   /** Report Buffer Status */
   DoReportBufferStatus ();
@@ -180,6 +299,14 @@
   m_rbsTimer = Simulator::Schedule (m_rbsTimerValue, &LteRlcAm::ExpireRbsTimer, this);
 }
 
+void
+LteRlcAm::DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION(this);
+  NS_LOG_INFO("Send MC PDU received from " << params.sourceCellId << " in cell " << params.targetCellId);
+  DoTransmitPdcpPdu(params.ueData);
+}
+
 
 /**
  * MAC SAP
@@ -200,7 +327,7 @@
       return;
     }
 
-  if ( m_statusPduRequested && ! m_statusProhibitTimer.IsRunning () )
+  if ( m_statusPduRequested && ! m_statusProhibitTimer.IsRunning () && componentCarrierId == 0) // only the PCC can send STATUS PDUs
     {
       if (bytes < m_statusPduBufferSize)
         {
@@ -216,42 +343,49 @@
       Ptr<Packet> packet = Create<Packet> ();
       LteRlcAmHeader rlcAmHeader;
       rlcAmHeader.SetControlPdu (LteRlcAmHeader::STATUS_PDU);
-     
+
       NS_LOG_LOGIC ("Check for SNs to NACK from " << m_vrR.GetValue() << " to " << m_vrMs.GetValue());
       SequenceNumber10 sn;
       sn.SetModulusBase (m_vrR);
       std::map<uint16_t, PduBuffer>::iterator pduIt;
-      for (sn = m_vrR; sn < m_vrMs; sn++) 
+      for (sn = m_vrR; sn < m_vrMs; sn++)
         {
-          NS_LOG_LOGIC ("SN = " << sn);          
+          NS_LOG_LOGIC ("SN = " << sn);
           if (!rlcAmHeader.OneMoreNackWouldFitIn (bytes))
             {
               NS_LOG_LOGIC ("Can't fit more NACKs in STATUS PDU");
               break;
-            }          
+            }
           pduIt = m_rxonBuffer.find (sn.GetValue ());
           if (pduIt == m_rxonBuffer.end () || (!(pduIt->second.m_pduComplete)))
             {
               NS_LOG_LOGIC ("adding NACK_SN " << sn.GetValue ());
-              rlcAmHeader.PushNack (sn.GetValue ());              
-            }          
+              rlcAmHeader.PushNack (sn.GetValue ());
+            }
         }
       NS_LOG_LOGIC ("SN at end of NACK loop = " << sn);
       // 3GPP TS 36.322 section 6.2.2.1.4 ACK SN
-      // find the  SN of the next not received RLC Data PDU 
-      // which is not reported as missing in the STATUS PDU. 
+      // find the  SN of the next not received RLC Data PDU
+      // which is not reported as missing in the STATUS PDU.
       pduIt = m_rxonBuffer.find (sn.GetValue ());
-      while ((sn < m_vrMs) && (pduIt != m_rxonBuffer.end ()) && (pduIt->second.m_pduComplete))            
+      while ((sn < m_vrMs) && (pduIt != m_rxonBuffer.end ()) && (pduIt->second.m_pduComplete))
         {
           NS_LOG_LOGIC ("SN = " << sn << " < " << m_vrMs << " = " << (sn < m_vrMs));
           sn++;
           NS_LOG_LOGIC ("SN = " << sn);
           pduIt = m_rxonBuffer.find (sn.GetValue ());
         }
-      
-      NS_ASSERT_MSG (sn <= m_vrMs, "first SN not reported as missing = " << sn << ", VR(MS) = " << m_vrMs);      
-      rlcAmHeader.SetAckSn (sn); 
 
+      NS_ASSERT_MSG (sn <= m_vrMs, "first SN not reported as missing = " << sn << ", VR(MS) = " << m_vrMs);
+      rlcAmHeader.SetAckSn (sn);
+
+      // map SN to HARQ ID
+      std::map <uint8_t, uint16_t>::iterator itHarqIdMap = m_harqIdToSnMap.find (harqId);
+      if (itHarqIdMap != m_harqIdToSnMap.end ())
+      {
+        m_harqIdToSnMap.erase (itHarqIdMap);
+      }
+      m_harqIdToSnMap.insert (std::pair <uint8_t, uint16_t> (harqId, sn.GetValue ()));
 
       NS_LOG_LOGIC ("RLC header: " << rlcAmHeader);
       packet->AddHeader (rlcAmHeader);
@@ -281,21 +415,37 @@
     }
   else if ( m_retxBufferSize > 0 )
     {
-      NS_LOG_LOGIC ("retxBufferSize = " << m_retxBufferSize);      
+      NS_LOG_LOGIC ("retxBufferSize = " << m_retxBufferSize);
       NS_LOG_LOGIC ("Sending data from Retransmission Buffer");
       NS_ASSERT (m_vtA < m_vtS);
       SequenceNumber10 sn;
       sn.SetModulusBase (m_vtA);
-      for (sn = m_vtA; sn < m_vtS; sn++) 
+      bool found = false;
+      for (sn = m_vtA; sn < m_vtS; sn++)
         {
           uint16_t seqNumberValue = sn.GetValue ();
           NS_LOG_LOGIC ("SN = " << seqNumberValue << " m_pdu " << m_retxBuffer.at (seqNumberValue).m_pdu);
 
-          if (m_retxBuffer.at (seqNumberValue).m_pdu != 0)
-            {            
-
-              Ptr<Packet> packet = m_retxBuffer.at (seqNumberValue).m_pdu->Copy ();
-              
+          if (m_retxSegBuffer.at (seqNumberValue).m_lastSegSent)
+          {
+            return; // all segments sent, need to wait for ACK or reorder timer to expire
+          }
+
+          Ptr<Packet> packet;
+          bool segment = false;
+          if (m_retxSegBuffer.at (seqNumberValue).m_pdu != 0)
+          {
+            packet = m_retxSegBuffer.at (seqNumberValue).m_pdu->Copy ();
+            found = true;
+            segment = true;
+          }
+          else if (m_retxBuffer.at (seqNumberValue).m_pdu != 0)
+          {
+            packet = m_retxBuffer.at (seqNumberValue).m_pdu->Copy ();
+            found = true;
+          }
+          if (found == true)
+          {
               if (( packet->GetSize () <= bytes )
                   || m_txOpportunityForRetxAlwaysBigEnough)
                 {
@@ -304,13 +454,23 @@
                   packet->RemoveHeader (rlcAmHeader);
                   NS_LOG_LOGIC ("old AM RLC header: " << rlcAmHeader);
 
+                  if (segment)
+                  {
+                    NS_LOG_INFO ("Sending last RLC PDU segment, sn= " << seqNumberValue << " offset= " << rlcAmHeader.GetSegmentOffset()
+                                                     << " size= " << rlcAmHeader.GetLastOffset()-rlcAmHeader.GetSegmentOffset());
+                    // opportunity is large enough to transmit remaining segment, so clear segment buffer
+                    m_retxSegBuffer.at(seqNumberValue).m_pdu = 0;
+                    m_retxSegBuffer.at(seqNumberValue).m_lastSegSent = true;
+                    rlcAmHeader.SetLastSegmentFlag (LteRlcAmHeader::LAST_PDU_SEGMENT);
+                  }
+
                   // Calculate the Polling Bit (5.2.2.1)
                   rlcAmHeader.SetPollingBit (LteRlcAmHeader::STATUS_REPORT_NOT_REQUESTED);
 
-                  NS_LOG_LOGIC ("polling conditions: m_txonBuffer.empty=" << m_txonBuffer.empty () 
+                  NS_LOG_LOGIC ("polling conditions: m_txonBuffer.empty=" << m_txonBuffer.empty ()
                                 << " retxBufferSize="  << m_retxBufferSize
                                 << " packet->GetSize ()=" << packet->GetSize ());
-                  if (((m_txonBuffer.empty ()) && (m_retxBufferSize == packet->GetSize () + rlcAmHeader.GetSerializedSize ())) 
+                  if (((m_txonBuffer.empty ()) && (m_txonQueue->GetNPackets ()==0) && (m_retxBufferSize == packet->GetSize () + rlcAmHeader.GetSerializedSize ()))
                       || (m_vtS >= m_vtMs)
                       || m_pollRetransmitTimerJustExpired)
                     {
@@ -339,15 +499,10 @@
                         }
                     }
 
+
                   packet->AddHeader (rlcAmHeader);
                   NS_LOG_LOGIC ("new AM RLC header: " << rlcAmHeader);
 
-                  // Sender timestamp
-                  RlcTag rlcTag (Simulator::Now ());
-                  NS_ASSERT_MSG (packet->PeekPacketTag (rlcTag), "RlcTag is missing");
-                  packet->ReplacePacketTag (rlcTag);
-                  m_txPdu (m_rnti, m_lcid, packet->GetSize ());
-
                   // Send RLC PDU to MAC layer
                   LteMacSapProvider::TransmitPduParameters params;
                   params.pdu = packet;
@@ -356,7 +511,7 @@
                   params.layer = layer;
                   params.harqProcessId = harqId;
                   params.componentCarrierId = componentCarrierId;
-                  
+
                   m_macSapProvider->TransmitPdu (params);
 
                   m_retxBuffer.at (seqNumberValue).m_retxCount++;
@@ -369,27 +524,157 @@
                   NS_LOG_INFO ("Move SN = " << seqNumberValue << " back to txedBuffer");
                   m_txedBuffer.at (seqNumberValue).m_pdu = m_retxBuffer.at (seqNumberValue).m_pdu->Copy ();
                   m_txedBuffer.at (seqNumberValue).m_retxCount = m_retxBuffer.at (seqNumberValue).m_retxCount;
+                  NS_ASSERT_MSG(m_txedBuffer.at (seqNumberValue).m_pdu != 0, "Just inserted an invalid pointer");
                   m_txedBufferSize += m_txedBuffer.at (seqNumberValue).m_pdu->GetSize ();
 
                   m_retxBufferSize -= m_retxBuffer.at (seqNumberValue).m_pdu->GetSize ();
                   m_retxBuffer.at (seqNumberValue).m_pdu = 0;
                   m_retxBuffer.at (seqNumberValue).m_retxCount = 0;
-                  
+
+                  // reset segment buffer
+                  m_retxSegBuffer.at (seqNumberValue).m_pdu = 0;
+                  m_retxSegBuffer.at (seqNumberValue).m_retxCount = 0;
+                  m_retxSegBuffer.at (seqNumberValue).m_lastSegSent = 0;
+
                   NS_LOG_LOGIC ("retxBufferSize = " << m_retxBufferSize);
 
                   return;
                 }
               else
                 {
-                  NS_LOG_LOGIC ("TxOpportunity (size = " << bytes << ") too small for retransmission of the packet (size = " << packet->GetSize () << ")");
-                  NS_LOG_LOGIC ("Waiting for bigger TxOpportunity");
+//                  NS_LOG_LOGIC ("TxOpportunity (size = " << bytes << ") too small for retransmission of the packet (size = " << packet->GetSize () << ")");
+//                  NS_LOG_LOGIC ("Waiting for bigger TxOpportunity");
+//                  return;
+                  // According to 5.2.1, the data field is left as is, but we rebuild the header
+                  LteRlcAmHeader firstSegHdr;
+
+                  // if(bytes < firstSegHdr.GetSerializedSize() )
+                  // {
+                  //   return;
+                  // }
+
+                  packet->RemoveHeader (firstSegHdr);
+                  NS_LOG_LOGIC ("old AM RLC header: " << firstSegHdr);
+
+                  // Calculate the Polling Bit (5.2.2.1)
+                  firstSegHdr.SetPollingBit (LteRlcAmHeader::STATUS_REPORT_NOT_REQUESTED);
+
+                  NS_LOG_LOGIC ("polling conditions: m_txonBuffer.empty=" << m_txonBuffer.empty ()
+                                << " retxBufferSize="  << m_retxBufferSize
+                                << " packet->GetSize ()=" << packet->GetSize ());
+                  if (((m_txonBuffer.empty ()) && (m_txonQueue->GetNPackets () == 0) && (m_retxBufferSize == packet->GetSize () + firstSegHdr.GetSerializedSize ()))
+                      || (m_vtS >= m_vtMs)
+                      || m_pollRetransmitTimerJustExpired)
+                  {
+                    m_pollRetransmitTimerJustExpired = false;
+                    firstSegHdr.SetPollingBit (LteRlcAmHeader::STATUS_REPORT_IS_REQUESTED);
+                    m_pduWithoutPoll = 0;
+                    m_byteWithoutPoll = 0;
+
+                    m_pollSn = m_vtS - 1;
+                    NS_LOG_LOGIC ("New POLL_SN = " << m_pollSn);
+
+                    if (! m_pollRetransmitTimer.IsRunning () )
+                    {
+                      NS_LOG_LOGIC ("Start PollRetransmit timer");
+
+                      m_pollRetransmitTimer = Simulator::Schedule (m_pollRetransmitTimerValue,
+                                                                   &LteRlcAm::ExpirePollRetransmitTimer, this);
+                    }
+                    else
+                    {
+                      NS_LOG_LOGIC ("Restart PollRetransmit timer");
+
+                      m_pollRetransmitTimer.Cancel ();
+                      m_pollRetransmitTimer = Simulator::Schedule (m_pollRetransmitTimerValue,
+                                                                   &LteRlcAm::ExpirePollRetransmitTimer, this);
+                    }
+                  }
+
+                  // set flags
+                  firstSegHdr.SetResegmentationFlag (LteRlcAmHeader::SEGMENT);
+                  firstSegHdr.SetLastSegmentFlag (LteRlcAmHeader::NO_LAST_PDU_SEGMENT);
+                  //firstSegHdr.PushLengthIndicator (firstPduSegSize);
+
+                  // build header for second segment
+                  LteRlcAmHeader nextSegHdr = firstSegHdr;
+                  //nextSegHdr.PushLengthIndicator (nextPduSegSize);
+                  // get size of last segment
+                  //unsigned segSize = rlcAmHeader.PopLengthIndicator ();
+                  // set offset to last offset + last size
+
+                  if (!segment)
+                  {
+                    firstSegHdr.SetSegmentOffset (0);
+                  }
+
+                  if (bytes < firstSegHdr.GetSerializedSize ())
+                  {
+                    return;
+                  }
+
+                   // segment packet
+                  uint16_t firstPduSegSize = bytes - firstSegHdr.GetSerializedSize ();
+                  uint16_t nextPduSegSize = packet->GetSize ()-firstPduSegSize;
+                  Ptr<Packet> firstSeg = packet->CreateFragment (0, firstPduSegSize);
+                  Ptr<Packet> nextSeg = packet->CreateFragment (firstPduSegSize, nextPduSegSize);
+
+                  nextSegHdr.SetSegmentOffset (firstSegHdr.GetSegmentOffset () + firstPduSegSize);
+
+                  firstSeg->AddHeader (firstSegHdr);
+                  nextSeg->AddHeader (nextSegHdr);
+
+                  // add next segment to reTX segment buffer
+                  m_retxSegBuffer.at (seqNumberValue).m_pdu = nextSeg;
+
+                  NS_LOG_LOGIC ("new AM RLC header: " << firstSegHdr);
+
+                  // Send RLC PDU to MAC layer
+                  LteMacSapProvider::TransmitPduParameters params;
+                  params.pdu = firstSeg;
+                  params.rnti = m_rnti;
+                  params.lcid = m_lcid;
+                  params.layer = layer;
+                  params.harqProcessId = harqId;
+                  params.componentCarrierId =  componentCarrierId;
+
+                  NS_LOG_INFO ("Sending RLC PDU segment, sn= " << seqNumberValue << " offset= " << firstSegHdr.GetSegmentOffset()
+                                                   << " size= " << firstPduSegSize);
+
+                  if (firstSeg->GetSize () > bytes)
+                  {
+                    NS_FATAL_ERROR ("PDU header too large " << firstSegHdr);
+                  }
+
+                  m_macSapProvider->TransmitPdu (params);
+
+                  //m_retxSegBuffer.at (seqNumberValue).m_pdu
+
+//                  m_retxBuffer.at (seqNumberValue).m_retxCount++;
+//                  NS_LOG_INFO ("Incr RETX_COUNT for SN = " << seqNumberValue);
+//                  if (m_retxBuffer.at (seqNumberValue).m_retxCount >= m_maxRetxThreshold)
+//                  {
+//                    NS_LOG_INFO ("Max RETX_COUNT for SN = " << seqNumberValue);
+//                  }
+//
+//                  NS_LOG_INFO ("Move SN = " << seqNumberValue << " back to txedBuffer");
+//                  m_txedBuffer.at (seqNumberValue).m_pdu = m_retxBuffer.at (seqNumberValue).m_pdu->Copy ();
+//                  m_txedBuffer.at (seqNumberValue).m_retxCount = m_retxBuffer.at (seqNumberValue).m_retxCount;
+//                  m_txedBufferSize += m_txedBuffer.at (seqNumberValue).m_pdu->GetSize ();
+//
+//                  m_retxBufferSize -= m_retxBuffer.at (seqNumberValue).m_pdu->GetSize ();
+//                  m_retxBuffer.at (seqNumberValue).m_pdu = 0;
+//                  m_retxBuffer.at (seqNumberValue).m_retxCount = 0;
+
+                  NS_LOG_LOGIC ("retxBufferSize = " << m_retxBufferSize);
+
                   return;
                 }
             }
         }
-      NS_ASSERT_MSG (false, "m_retxBufferSize > 0, but no PDU considered for retx found");
+      NS_ASSERT_MSG (found, "m_retxBufferSize > 0, but no PDU considered for retx found");
     }
-  else if ( m_txonBufferSize > 0 )
+  else if ( m_txonBufferSize + m_txonQueue->GetNBytes() > 0 )
     {
       if (bytes < 7)
       {
@@ -421,6 +706,16 @@
   //
   //
 
+  // LL HO
+  // if m_vtS is not inside the transmitting window: simply return
+  //      otherwise continue constructing sending RLC PDU with m_vtS is
+  //      the sequence number and deliver it to the lower layer.
+  if (!IsInsideTransmittingWindow()){
+    NS_LOG_LOGIC ("SEQ = " << m_vtS << " is NOT inside transmitting window [ " << m_vtA << " , " << m_vtMs << " ). Discard TxOppotunity");
+    return;
+  }
+
+
   Ptr<Packet> packet = Create<Packet> ();
   LteRlcAmHeader rlcAmHeader;
   rlcAmHeader.SetDataPdu ();
@@ -434,7 +729,7 @@
 
   // Remove the first packet from the transmission buffer.
   // If only a segment of the packet is taken, then the remaining is given back later
-  if ( m_txonBuffer.size () == 0 )
+  if ( m_txonBuffer.size () + m_txonQueue->GetNBytes() == 0 )
     {
       NS_LOG_LOGIC ("No data pending");
       return;
@@ -445,7 +740,27 @@
   NS_LOG_LOGIC ("First SDU size    = " << (*(m_txonBuffer.begin()))->GetSize ());
   NS_LOG_LOGIC ("Next segment size = " << nextSegmentSize);
   NS_LOG_LOGIC ("Remove SDU from TxBuffer");
+
+  if (m_txonBuffer.empty())
+  {
+    Ptr<Packet> tempP = m_txonQueue->Dequeue()->GetPacket();
+    m_txonBuffer.push_back (tempP);
+    m_txonBufferSize += tempP->GetSize ();
+  }
+
   Ptr<Packet> firstSegment = (*(m_txonBuffer.begin ()))->Copy ();
+
+  // LL HO
+  // tricky: store the incomplete Rlc SDU for forwarding to
+  // target eNB in lossless HO. This will reduce the work of
+  // reassemling the incomplete SDU later.
+  Ptr<Packet> entireSdu ;
+  // store complete the last complete SDU of the txonBuffer.
+  if (!is_fragmented){
+    NS_LOG_DEBUG ("Last complete SDU in txonBuffer size = " << firstSegment->GetSize() << " SEQ = " << m_vtS );
+    entireSdu = (*(m_txonBuffer.begin ()))->Copy ();
+  }
+
   m_txonBufferSize -= (*(m_txonBuffer.begin()))->GetSize ();
   NS_LOG_LOGIC ("txBufferSize      = " << m_txonBufferSize );
   m_txonBuffer.erase (m_txonBuffer.begin ());
@@ -470,6 +785,9 @@
           // Segment txBuffer.FirstBuffer and
           // Give back the remaining segment to the transmission buffer
           Ptr<Packet> newSegment = firstSegment->CreateFragment (0, currSegmentSize);
+          // LL HO: This firstSegment is fragmented. Update the status variable.
+          is_fragmented = 1;
+
           NS_LOG_LOGIC ("    newSegment size   = " << newSegment->GetSize ());
 
           // Status tag of the new and remaining segments
@@ -496,7 +814,20 @@
             {
               firstSegment->AddPacketTag (oldTag);
 
-              m_txonBuffer.insert (m_txonBuffer.begin (), firstSegment);
+              //LL HO Mark the first SDU is txonBuffer is fragmented. This maybe not needed.
+              is_fragmented = 1;
+
+              // m_txonBuffer.insert (m_txonBuffer.begin (), firstSegment);
+
+              if(m_txonBuffer.empty())
+              {
+                m_txonBuffer.push_back(firstSegment);
+              }
+              else
+              {
+                m_txonBuffer.insert (m_txonBuffer.begin (), firstSegment);
+              }
+
               m_txonBufferSize += (*(m_txonBuffer.begin()))->GetSize ();
 
               NS_LOG_LOGIC ("    Txon buffer: Give back the remaining segment");
@@ -542,7 +873,8 @@
           // (NO more segments) ? exit
           // break;
         }
-      else if ( (nextSegmentSize - firstSegment->GetSize () <= 2) || (m_txonBuffer.size () == 0) )
+      else if ( (nextSegmentSize - firstSegment->GetSize () <= 2)
+        || (m_txonBuffer.size () + m_txonQueue->GetNPackets() == 0) )
         {
           NS_LOG_LOGIC ("    IF nextSegmentSize - firstSegment->GetSize () <= 2 || txonBuffer.size == 0");
 
@@ -561,7 +893,7 @@
           nextSegmentId++;
 
           NS_LOG_LOGIC ("        SDUs in TxBuffer  = " << m_txonBuffer.size ());
-          if (m_txonBuffer.size () > 0)
+          if (m_txonBuffer.size () + m_txonQueue->GetNPackets() > 0)
             {
               NS_LOG_LOGIC ("        First SDU buffer  = " << *(m_txonBuffer.begin()));
               NS_LOG_LOGIC ("        First SDU size    = " << (*(m_txonBuffer.begin()))->GetSize ());
@@ -591,7 +923,7 @@
           nextSegmentId++;
 
           NS_LOG_LOGIC ("        SDUs in TxBuffer  = " << m_txonBuffer.size ());
-          if (m_txonBuffer.size () > 0)
+          if (m_txonBuffer.size () + m_txonQueue->GetNPackets() > 0)
             {
               NS_LOG_LOGIC ("        First SDU buffer  = " << *(m_txonBuffer.begin()));
               NS_LOG_LOGIC ("        First SDU size    = " << (*(m_txonBuffer.begin()))->GetSize ());
@@ -600,14 +932,45 @@
           NS_LOG_LOGIC ("        Remove SDU from TxBuffer");
 
           // (more segments)
+
+          if(m_txonBuffer.empty())
+          {
+            Ptr<Packet> tempP = m_txonQueue->Dequeue()->GetPacket();
+            m_txonBuffer.push_back (tempP);
+            m_txonBufferSize += tempP->GetSize ();
+          }
+
           firstSegment = (*(m_txonBuffer.begin ()))->Copy ();
+
+          // LL HO
+          // New complete SDU is taken from txonBuffer so reset the
+          // status is_fragmented.
+          is_fragmented = 0;
+          m_txedRlcSduBuffer.push_back((*(m_txonBuffer.begin()))->Copy());
+          NS_LOG_DEBUG ("m_txedRlcSduBuffer.size() = " << m_txedRlcSduBuffer.size());
+          if (m_txedRlcSduBuffer.size() > 1024){
+            NS_LOG_DEBUG ("m_txedRlcSduBuffer.size() = " << m_txedRlcSduBuffer.size() << " clear and resize");
+            m_txedRlcSduBuffer.clear();
+            m_txedRlcSduBuffer.resize(0);
+            NS_LOG_DEBUG ("m_txedRlcSduBuffer.size() = " << m_txedRlcSduBuffer.size() << " after clear and resize");
+          }
+          // Store the last complete SDU before segmentation in txonBuffer.
+          entireSdu = (*(m_txonBuffer.begin ()))->Copy ();
+
           m_txonBufferSize -= (*(m_txonBuffer.begin()))->GetSize ();
           m_txonBuffer.erase (m_txonBuffer.begin ());
           NS_LOG_LOGIC ("        txBufferSize = " << m_txonBufferSize );
         }
-
     }
 
+  // LL HO tricky: store the complete version of the LAST incomplete Rlc SDU for forwarding to
+  // target eNB in lossless HO. This will reduce the work of
+  // reassemling the incomplete SDU later.
+  if (entireSdu != NULL){
+    m_segmented_rlcsdu = entireSdu;
+    NS_LOG_DEBUG ("entireSdu = " << m_segmented_rlcsdu->GetSize() << " SEQ = " << m_vtS );
+  }
+
   //
   // Build RLC header
   //
@@ -617,6 +980,8 @@
   rlcAmHeader.SetLastSegmentFlag (LteRlcAmHeader::LAST_PDU_SEGMENT);
   rlcAmHeader.SetSegmentOffset (0);
 
+  NS_LOG_INFO("Send m_vtS " << m_vtS << " m_vtMs " << m_vtMs << " m_vtA " << m_vtA << " time " << Simulator::Now().GetSeconds());
+
   NS_ASSERT_MSG(rlcAmHeader.GetSequenceNumber () < m_vtMs, "SN above TX window");
   NS_ASSERT_MSG(rlcAmHeader.GetSequenceNumber () >= m_vtA, "SN below TX window");
 
@@ -627,8 +992,7 @@
 
   // FIRST SEGMENT
   LteRlcSduStatusTag tag;
-  NS_ASSERT_MSG ((*it)->PeekPacketTag (tag), "LteRlcSduStatusTag is missing");
-  (*it)->PeekPacketTag (tag);
+  (*it)->RemovePacketTag (tag);
   if ( (tag.GetStatus () == LteRlcSduStatusTag::FULL_SDU) ||
        (tag.GetStatus () == LteRlcSduStatusTag::FIRST_SEGMENT)
      )
@@ -639,27 +1003,20 @@
     {
       framingInfo |= LteRlcAmHeader::NO_FIRST_BYTE;
     }
+  (*it)->AddPacketTag (tag);
 
   // Add all SDUs (in DataField) to the Packet
   while (it < dataField.end ())
     {
       NS_LOG_LOGIC ("Adding SDU/segment to packet, length = " << (*it)->GetSize ());
 
-      NS_ASSERT_MSG ((*it)->PeekPacketTag (tag), "LteRlcSduStatusTag is missing");
-      (*it)->RemovePacketTag (tag);
-      if (packet->GetSize () > 0)
-        {
-          packet->AddAtEnd (*it);
-        }
-      else
-        {
-          packet = (*it);
-        }
+      packet->AddAtEnd (*it);
       it++;
     }
 
   // LAST SEGMENT (Note: There could be only one and be the first one)
   it--;
+  (*it)->RemovePacketTag (tag);
   if ( (tag.GetStatus () == LteRlcSduStatusTag::FULL_SDU) ||
         (tag.GetStatus () == LteRlcSduStatusTag::LAST_SEGMENT) )
     {
@@ -669,6 +1026,7 @@
     {
       framingInfo |= LteRlcAmHeader::NO_LAST_BYTE;
     }
+  (*it)->AddPacketTag (tag);
 
   // Set the FramingInfo flag after the calculation
   rlcAmHeader.SetFramingInfo (framingInfo);
@@ -682,8 +1040,13 @@
   m_byteWithoutPoll += packet->GetSize ();
   NS_LOG_LOGIC ("BYTE_WITHOUT_POLL = " << m_byteWithoutPoll);
 
+  // if ( (m_pduWithoutPoll >= m_pollPdu) || (m_byteWithoutPoll >= m_pollByte) ||
+  //      ( (m_txonBuffer.empty ()) && (m_retxBufferSize == 0) ) ||
+  //      (m_vtS >= m_vtMs)
+  //      || m_pollRetransmitTimerJustExpired
+  //    )
   if ( (m_pduWithoutPoll >= m_pollPdu) || (m_byteWithoutPoll >= m_pollByte) ||
-       ( (m_txonBuffer.empty ()) && (m_retxBufferSize == 0) ) ||
+       ( (m_txonBuffer.empty ()) && (m_txonQueue->GetNPackets () == 0) && (m_retxBufferSize == 0) ) ||
        (m_vtS >= m_vtMs)
        || m_pollRetransmitTimerJustExpired
      )
@@ -723,10 +1086,11 @@
   m_txedBufferSize += packet->GetSize ();
   m_txedBuffer.at ( rlcAmHeader.GetSequenceNumber ().GetValue () ).m_pdu = packet->Copy ();
   m_txedBuffer.at ( rlcAmHeader.GetSequenceNumber ().GetValue () ).m_retxCount = 0;
+  NS_ASSERT_MSG(m_txedBuffer.at (rlcAmHeader.GetSequenceNumber ().GetValue ()).m_pdu != 0, "Just inserted an invalid pointer");
 
   // Sender timestamp
   RlcTag rlcTag (Simulator::Now ());
-  packet->ReplacePacketTag (rlcTag);
+  packet->AddByteTag (rlcTag);
   m_txPdu (m_rnti, m_lcid, packet->GetSize ());
 
   // Send RLC PDU to MAC layer
@@ -738,15 +1102,681 @@
   params.harqProcessId = harqId;
   params.componentCarrierId = componentCarrierId;
 
+
   m_macSapProvider->TransmitPdu (params);
 }
 
+std::vector < Ptr<Packet> >
+LteRlcAm::GetTxBuffer()
+{
+  std::vector < Ptr<Packet> > toBeReturned;
+  if(!m_enableAqm)
+  {
+    toBeReturned.insert(toBeReturned.begin(), m_txonBuffer.begin(), m_txonBuffer.end());
+    m_txonBuffer.clear();
+    m_txonBufferSize = 0;
+  }
+  else
+  {
+    while(m_txonQueue->GetNBytes() > 0)
+    {
+      toBeReturned.push_back(m_txonQueue->Dequeue()->GetPacket());
+    }
+  }
+  return toBeReturned;
+}
+uint32_t LteRlcAm::GetTxBufferSize()
+{
+  return m_txonBufferSize + m_txonQueue->GetNBytes();
+}
+
+std::vector < LteRlcAm::RetxPdu >
+LteRlcAm::GetTxedBuffer()
+{
+  //std::vector < LteRlcAm::RetxPdu > toBeReturned;
+  //toBeReturned.insert(toBeReturned.begin(), m_txedBuffer.begin(), m_txedBuffer.end());
+  return m_txedBuffer;
+}
+uint32_t
+LteRlcAm::GetTxedBufferSize()
+{
+  return m_txedBufferSize;
+}
+
+std::vector < LteRlcAm::RetxPdu >
+LteRlcAm::GetRetxBuffer()
+{
+  std::vector < LteRlcAm::RetxPdu > toBeReturned;
+  toBeReturned.insert(toBeReturned.begin(), m_retxBuffer.begin(), m_retxBuffer.end());
+  return toBeReturned;
+}
+
+uint32_t
+LteRlcAm::GetRetxBufferSize()
+{
+  return m_retxBufferSize;
+}
+
+std::map < uint32_t, Ptr<Packet> >
+LteRlcAm::GetTransmittingRlcSduBuffer()
+{
+  return m_transmittingRlcSduBuffer;
+  // TODO check if it must be emptied
+}
+uint32_t
+LteRlcAm::GetTransmittingRlcSduBufferSize()
+{
+  return m_transmittingRlcSduBufferSize;
+}
+
+Ptr<Packet>
+LteRlcAm::GetSegmentedRlcsdu()
+{
+  return m_segmented_rlcsdu;
+}
+
+/* LL HO
+ * Check if the current m_vtS (sending SEQ) is
+ * inside the transmitting window.
+ */
+bool
+LteRlcAm::IsInsideTransmittingWindow(){
+  //36.322 Section 5.1.3.1.1: window is m_vtA <= SN < m_vtMs, here: m_vtA <= SN <= m_vtMs.
+  if (m_vtS < m_vtMs && m_vtS >= m_vtA){
+    return true;
+  }
+  else
+    return false;
+}
+
 void
 LteRlcAm::DoNotifyHarqDeliveryFailure ()
 {
   NS_LOG_FUNCTION (this);
 }
 
+void
+LteRlcAm::DoNotifyDlHarqDeliveryFailure (uint8_t harqId)
+{
+  NS_LOG_FUNCTION (this);
+
+/*
+  std::map <uint8_t, uint16_t>::const_iterator it = m_harqIdToSnMap.find (harqId);
+  NS_ASSERT (it != m_harqIdToSnMap.end ());
+
+  uint16_t seqNumberValue = it->second;
+  if (m_txedBuffer.at (seqNumberValue).m_pdu != 0)
+  {
+    NS_LOG_INFO ("Move SN = " << seqNumberValue << " to retxBuffer");
+    m_retxBuffer.at (seqNumberValue).m_pdu = m_txedBuffer.at (seqNumberValue).m_pdu->Copy ();
+    m_retxBuffer.at (seqNumberValue).m_retxCount = m_txedBuffer.at (seqNumberValue).m_retxCount;
+    m_retxBufferSize += m_retxBuffer.at (seqNumberValue).m_pdu->GetSize ();
+
+    m_txedBufferSize -= m_txedBuffer.at (seqNumberValue).m_pdu->GetSize ();
+    m_txedBuffer.at (seqNumberValue).m_pdu = 0;
+    m_txedBuffer.at (seqNumberValue).m_retxCount = 0;
+  }
+  NS_ASSERT (m_retxBuffer.at (seqNumberValue).m_pdu != 0);
+*/
+}
+
+void
+LteRlcAm::DoNotifyUlHarqDeliveryFailure (uint8_t harqId)
+{
+  // send NACK
+}
+
+// LL HO
+// Packet: RlcPdu
+// Assemble RlcPdus in txed/retxBuffer to RlcSdu.
+// Note: if handover happens when RlcPdu is smaller than RlcSdu,
+// the switch condition often ends up with: NO LOSS S1 11 case
+// and multiple RlcPdus is combined to create a RlcSdu (1500B).
+void
+LteRlcAm::Reassemble (Ptr<Packet> packet)
+{
+  LteRlcAmHeader rlcAmHeader;
+  packet->RemoveHeader (rlcAmHeader);
+  uint8_t framingInfo = rlcAmHeader.GetFramingInfo ();
+  SequenceNumber10 currSeqNumber = rlcAmHeader.GetSequenceNumber ();
+  bool expectedSnLost;
+  NS_LOG_DEBUG("currSeqNumber = " << currSeqNumber << "expected = " << m_reassembleExpectedSeqNumber);
+  //Starting state: WITH LOSS.
+  if ( currSeqNumber != m_reassembleExpectedSeqNumber )
+    {
+      expectedSnLost = true;
+      NS_LOG_LOGIC ("There are losses. Expected SN = " << m_reassembleExpectedSeqNumber  << ". Current SN = " << currSeqNumber);
+      m_reassembleExpectedSeqNumber = currSeqNumber + 1;
+    }
+  else
+    {
+      expectedSnLost = false;
+      NS_LOG_LOGIC ("No losses. Expected SN = " << m_reassembleExpectedSeqNumber  << ". Current SN = " << currSeqNumber);
+      m_reassembleExpectedSeqNumber = m_reassembleExpectedSeqNumber + 1;
+    }
+
+  // Build list of SDUs
+  uint8_t extensionBit;
+  uint16_t lengthIndicator;
+  do
+    {
+      extensionBit = rlcAmHeader.PopExtensionBit ();
+      NS_LOG_DEBUG ("E = " << (uint16_t)extensionBit);
+
+      if ( extensionBit == 0 )
+        {
+          m_sdusAssembleBuffer.push_back (packet);
+        }
+      else // extensionBit == 1
+        {
+          lengthIndicator = rlcAmHeader.PopLengthIndicator ();
+          NS_LOG_DEBUG ("LI = " << lengthIndicator);
+
+          // Check if there is enough data in the packet
+          if ( lengthIndicator >= packet->GetSize () )
+            {
+              NS_LOG_DEBUG ("INTERNAL ERROR: Not enough data in the packet (" << packet->GetSize () << "). Needed LI=" << lengthIndicator);
+              /// \todo What to do in this case? Discard packet and continue? Or Assert?
+            }
+
+          // Split packet in two fragments
+          Ptr<Packet> data_field = packet->CreateFragment (0, lengthIndicator);
+          packet->RemoveAtStart (lengthIndicator);
+
+          m_sdusAssembleBuffer.push_back (data_field);
+        }
+    }
+  while ( extensionBit == 1 );
+
+  std::list < Ptr<Packet> >::iterator it;
+
+  //m_assemblingState = WAITING_SI_SF;
+  // Current reassembling state
+  if      (m_assemblingState == WAITING_S0_FULL)  NS_LOG_DEBUG ("Reassembling State = 'WAITING_S0_FULL'");
+  else if (m_assemblingState == WAITING_SI_SF)    NS_LOG_DEBUG ("Reassembling State = 'WAITING_SI_SF'");
+  else                                              NS_LOG_DEBUG ("Reassembling State = Unknown state");
+
+  // Received framing Info
+  NS_LOG_DEBUG ("Framing Info = " << (uint16_t)framingInfo);
+  NS_LOG_DEBUG ("m_sdusAssembleBuffer = " << m_sdusAssembleBuffer.size ());
+ // Reassemble the list of SDUs (when there is no losses)
+  if (!expectedSnLost)
+    {
+      NS_LOG_DEBUG ("Reassembling NO LOSS ");
+      switch (m_assemblingState)
+        {
+          case WAITING_S0_FULL: //Not waiting to complete a SDU.
+                  switch (framingInfo)
+                    {
+                      //RlcPdu = RlcSdu, without loss -> m_sdusAssembleBuffer contains all RLC SDUs.
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                              m_assemblingState = WAITING_S0_FULL;
+
+                              NS_LOG_DEBUG (" S0 00 ");
+                              /**
+                              * Deliver one or multiple PDUs
+                              */
+                              for ( it = m_sdusAssembleBuffer.begin () ; it != m_sdusAssembleBuffer.end () ; it++ )
+                                {
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << (*it)->GetSize());
+                                  m_transmittingRlcSdus.push_back (*it);
+                                  m_transmittingRlcSduBufferSize += (*it)->GetSize ();
+                                }
+                              m_sdusAssembleBuffer.clear ();
+                      break;
+
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                              //Received a PDU with the last part is a portion of a SDU.
+                              //Switch to waiting for complete SDU state.
+                              m_assemblingState = WAITING_SI_SF;
+                              NS_LOG_DEBUG (" S0 01 ");
+
+                              /**
+                              * Deliver full PDUs
+                              */
+                              //Previous recorded SDUs must be complete SDUs. The last PDU could
+                              //be: (1) a part of the SDU, (2) several SDUs and a part of the last SDU.
+                              while ( m_sdusAssembleBuffer.size () > 1 )
+                                {
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+
+                              /**
+                              * Keep S0. Keep the last incomplete SDU in the sduBuffer
+                              * to wait for its ending portion.
+                              */
+                              m_keepS0Reassemble = m_sdusAssembleBuffer.front ();
+
+                              m_sdusAssembleBuffer.pop_front ();
+                      break;
+                      //This could not happen because in this state, PDU should presents complete
+                      //SDU or the last part of PDU is a portion of RLC.
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                      default:
+                              /**
+                              * ERROR: Transition not possible
+                              */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                              NS_LOG_DEBUG ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          case WAITING_SI_SF:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::LAST_BYTE): //finish the previous S0.
+                              m_assemblingState = WAITING_S0_FULL;  //switch state to not waiting for S0 full.
+
+                              NS_LOG_DEBUG (" SI 10 ");
+                              /**
+                              * Deliver (Kept)S0 + SN
+                              */
+                              //Received an ending flag, if the state is waiting for the ending,
+                              //then switch to complete (S0_full)
+                              m_keepS0Reassemble->AddAtEnd (m_sdusAssembleBuffer.front ());
+                              m_sdusAssembleBuffer.pop_front ();
+                              NS_LOG_DEBUG ("Received Pdu Size = " << m_keepS0Reassemble->GetSize ());
+                              m_transmittingRlcSdus.push_back (m_keepS0Reassemble);
+                              m_transmittingRlcSduBufferSize += m_keepS0Reassemble->GetSize ();
+
+                              /**
+                                * Deliver zero, one or multiple PDUs
+                                */
+                              //Deliver the complete SDUs after the first portion of SDU that completes
+                              //the above S0.
+                              while ( ! m_sdusAssembleBuffer.empty () )
+                                {
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                              m_assemblingState = WAITING_SI_SF;
+                              NS_LOG_DEBUG (" SI 11 ");
+
+                              /**
+                              * Keep SI
+                              */
+                              if ( m_sdusAssembleBuffer.size () == 1 )
+                                {
+                                  m_keepS0Reassemble->AddAtEnd (m_sdusAssembleBuffer.front ());
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                              else // m_sdusAssembleBuffer.size () > 1
+                                {
+                                  /**
+                                  * Deliver (Kept)S0 + SN
+                                  */
+                                  m_keepS0Reassemble->AddAtEnd (m_sdusAssembleBuffer.front ());
+                                  m_sdusAssembleBuffer.pop_front ();
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_keepS0Reassemble->GetSize ());
+                                  m_transmittingRlcSdus.push_back (m_keepS0Reassemble);
+                                  m_transmittingRlcSduBufferSize += m_keepS0Reassemble->GetSize ();
+
+                                  /**
+                                  * Deliver zero, one or multiple PDUs
+                                  */
+                                  while ( m_sdusAssembleBuffer.size () > 1 )
+                                    {
+                                      NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                      m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                      m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                      m_sdusAssembleBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                  * Keep S0
+                                  */
+                                  m_keepS0Reassemble = m_sdusAssembleBuffer.front ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                      default:
+                              /**
+                                * ERROR: Transition not possible
+                                */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                              NS_LOG_DEBUG ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          default:
+                NS_LOG_LOGIC ("INTERNAL ERROR: Wrong reassembling state = " << (uint32_t) m_assemblingState);
+          break;
+        }
+    }
+  else // Reassemble the list of SDUs (when there are losses, i.e. the received SN is not the expected one)
+    {
+    NS_LOG_DEBUG ("Reassembling WITH LOSS");
+    switch (m_assemblingState)
+        {
+          case WAITING_S0_FULL:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                              m_assemblingState = WAITING_S0_FULL;
+                              NS_LOG_DEBUG (" S0 00");
+                              /**
+                               * Deliver one or multiple PDUs
+                               */
+                              for ( it = m_sdusAssembleBuffer.begin () ; it != m_sdusAssembleBuffer.end () ; it++ )
+                                {
+                                  m_transmittingRlcSdus.push_back (*it);
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << (*it)->GetSize ());
+                                  m_transmittingRlcSduBufferSize += (*it)->GetSize ();
+                                }
+                              m_sdusAssembleBuffer.clear ();
+                      break;
+
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                              m_assemblingState = WAITING_SI_SF;
+
+                              NS_LOG_DEBUG (" S0 01 ");
+                              /**
+                               * Deliver full PDUs
+                               */
+                              while ( m_sdusAssembleBuffer.size () > 1 )
+                                {
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+
+                              /**
+                               * Keep S0
+                               */
+                              m_keepS0Reassemble = m_sdusAssembleBuffer.front ();
+                              m_sdusAssembleBuffer.pop_front ();
+                      break;
+
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                              m_assemblingState = WAITING_S0_FULL;
+                              NS_LOG_DEBUG (" S0 10");
+                              /**
+                               * Discard the first junk portion of SDU.
+                               */
+                              m_sdusAssembleBuffer.pop_front ();
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( ! m_sdusAssembleBuffer.empty () )
+                                {
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                              NS_LOG_DEBUG(" S0 11");
+
+                              if ( m_sdusAssembleBuffer.size () == 1 )
+                                {
+                                  m_assemblingState = WAITING_S0_FULL;
+                                }
+                              else
+                                {
+                                  m_assemblingState = WAITING_SI_SF;
+                                }
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusAssembleBuffer.pop_front ();
+
+                              if ( m_sdusAssembleBuffer.size () > 0 )
+                                {
+                                  /**
+                                  * Deliver zero, one or multiple PDUs
+                                  */
+                                  while ( m_sdusAssembleBuffer.size () > 1 )
+                                    {
+                                      NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                      m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                      m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                      m_sdusAssembleBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                  * Keep S0
+                                  */
+                                  m_keepS0Reassemble = m_sdusAssembleBuffer.front ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      default:
+                              /**
+                               * ERROR: Transition not possible
+                               */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                              NS_LOG_DEBUG ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          case WAITING_SI_SF:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                              m_assemblingState = WAITING_S0_FULL;
+
+                              NS_LOG_DEBUG (" SI 00");
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0Reassemble = 0;
+
+                              /**
+                               * Deliver one or multiple PDUs
+                               */
+                              while ( ! m_sdusAssembleBuffer.empty () )
+                                {
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                              m_assemblingState = WAITING_SI_SF;
+
+                              NS_LOG_DEBUG (" SI 01");
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0Reassemble = 0;
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( m_sdusAssembleBuffer.size () > 1 )
+                                {
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+
+                              /**
+                               * Keep S0
+                               */
+                              m_keepS0Reassemble = m_sdusAssembleBuffer.front ();
+                              m_sdusAssembleBuffer.pop_front ();
+
+                      break;
+
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                              NS_LOG_DEBUG (" SI 10");
+                              m_assemblingState = WAITING_S0_FULL;
+
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0Reassemble = 0;
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusAssembleBuffer.pop_front ();
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( ! m_sdusAssembleBuffer.empty () )
+                                {
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+
+                              NS_LOG_DEBUG(" SI 11");
+                              if ( m_sdusAssembleBuffer.size () == 1 )
+                                {
+                                  m_assemblingState = WAITING_SI_SF;
+                                  m_reassembleExpectedSeqNumber = currSeqNumber - 1; //With loss + SI_SF: Jump here until sdusBuffer is larger than 1, meaning a new SDU begins.
+                                }
+                              else
+                                {
+                                  m_assemblingState = WAITING_SI_SF;
+                                }
+
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0Reassemble = 0;
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusAssembleBuffer.pop_front ();
+
+                              if ( m_sdusAssembleBuffer.size () > 0 )
+                                {
+                                  /**
+                                   * Deliver zero, one or multiple PDUs
+                                   */
+                                  while ( m_sdusAssembleBuffer.size () > 1 )
+                                    {
+                                      NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                      m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                      m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                      m_sdusAssembleBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                   * Keep S0
+                                   */
+                                  m_keepS0Reassemble = m_sdusAssembleBuffer.front ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      default:
+                              /**
+                                * ERROR: Transition not possible
+                                */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                              NS_LOG_DEBUG ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          default:
+                NS_LOG_LOGIC ("INTERNAL ERROR: Wrong reassembling state = " << (uint32_t) m_assemblingState);
+                NS_LOG_DEBUG ("INTERNAL ERROR: Wrong reassembling state = " << (uint32_t) m_assemblingState);
+          break;
+        }
+  }
+  NS_LOG_DEBUG ("End RlcPdutoRlcSdu... transmittingRlcSduBufferSize= " << m_transmittingRlcSdus.size() << " Bytes= " << m_transmittingRlcSduBufferSize);
+}
+
+// LL HO
+void
+LteRlcAm::CreateRlcSduBuffer(){
+  NS_LOG_DEBUG (this);
+  LtePdcpHeader pdcpHeader;
+  for (std::vector < Ptr<Packet> >::iterator it = m_transmittingRlcSdus.begin(); it != m_transmittingRlcSdus.end(); ++it){
+    (*it)->PeekHeader(pdcpHeader);
+    NS_LOG_DEBUG ("RLCSDU_SEQ = " << pdcpHeader.GetSequenceNumber());
+    m_transmittingRlcSduBuffer[pdcpHeader.GetSequenceNumber()] = (*it)->Copy();
+  }
+}
+
+// LL HO
+void
+LteRlcAm::RlcPdusToRlcSdus (std::vector < LteRlcAm::RetxPdu > RlcPdus){
+
+  NS_LOG_DEBUG (this << "in RlcPdusTo..." );
+  uint16_t isGotExpectedSeqNumber = 0;
+  for ( std::vector <LteRlcAm::RetxPdu>::iterator it = RlcPdus.begin(); it != RlcPdus.end (); it++)
+        {
+          if (it->m_pdu == 0){
+            continue;
+          }
+          NS_LOG_DEBUG (this << "Pdu = " << it->m_pdu );
+          Ptr<Packet> p = it->m_pdu->Copy();
+
+          // Get RLC header parameters
+          LteRlcAmHeader rlcAmHeader;
+          p->PeekHeader (rlcAmHeader);
+          NS_LOG_DEBUG("RLC header: " << rlcAmHeader);
+
+          //Always enter the Reassemble function with LOSS mode.
+          if (isGotExpectedSeqNumber  == 0){
+              isGotExpectedSeqNumber = 1;
+              m_reassembleExpectedSeqNumber = rlcAmHeader.GetSequenceNumber()+1; //To make the condition WITH LOSS true.
+          }
+          if ( rlcAmHeader.IsDataPdu () )
+            {
+              SequenceNumber10 seqNumber = rlcAmHeader.GetSequenceNumber ();
+
+              if ( rlcAmHeader.GetResegmentationFlag () == LteRlcAmHeader::SEGMENT )
+                {
+                  NS_LOG_DEBUG ("PDU segment in Txed/Retx buffer ( *absolute* SN = " << seqNumber << " )");
+                }
+              else if ( rlcAmHeader.GetResegmentationFlag () == LteRlcAmHeader::PDU )
+                {
+                  NS_LOG_DEBUG ("PDU in Txed/Retx buffer ( *absolute* SN = " << seqNumber << " )");
+                }
+              else
+                {
+                  NS_ASSERT_MSG (false, "Neither a PDU segment nor a PDU Txed/Retx buffer");
+                  return ;
+                }
+              Reassemble(p);
+            }
+          else if ( rlcAmHeader.IsControlPdu () )
+            {
+              NS_LOG_DEBUG ("Control AM RLC PDU in Txed/Retx buffer. Discard");
+            }
+          else
+            {
+              NS_LOG_DEBUG ("Wrong AM RLC PDU type in Txed/Retx buffer");
+              return;
+            }
+    }
+    CreateRlcSduBuffer();
+}
 
 void
 LteRlcAm::DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
@@ -756,9 +1786,10 @@
   // Receiver timestamp
   RlcTag rlcTag;
   Time delay;
-  NS_ASSERT_MSG (p->PeekPacketTag (rlcTag), "RlcTag is missing");
-  p->RemovePacketTag (rlcTag);
-  delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+  if (p->FindFirstMatchingByteTag (rlcTag))
+    {
+      delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+    }
   m_rxPdu (m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
 
   // Get RLC header parameters
@@ -768,6 +1799,7 @@
 
   if ( rlcAmHeader.IsDataPdu () )
     {
+      NS_LOG_INFO (this << " RLC DoReceivePdu " << m_rnti << (uint32_t) m_lcid << p->GetSize () << " time " << Simulator::Now().GetSeconds());
 
       // 5.1.3.1   Transmit operations
 
@@ -877,23 +1909,85 @@
         {
           // - if some byte segments of the AMD PDU contained in the RLC data PDU have been received before:
           //         - discard the duplicate byte segments.
-          // note: re-segmentation of AMD PDU is currently not supported, 
+          // note: re-segmentation of AMD PDU is currently not supported,
           // so we just check that the segment was not received before
           std::map <uint16_t, PduBuffer>::iterator it = m_rxonBuffer.find (seqNumber.GetValue ());
           if (it != m_rxonBuffer.end () )
             {
               NS_ASSERT (it->second.m_byteSegments.size () > 0);
-              NS_ASSERT_MSG (it->second.m_byteSegments.size () == 1, "re-segmentation not supported");
-              NS_LOG_LOGIC ("PDU segment already received, discarded");
+              //NS_ASSERT_MSG (it->second.m_byteSegments.size () == 1, "re-segmentation not supported");
+              NS_LOG_LOGIC ("Received duplicate SN");
+
+              if (rlcAmHeader.GetResegmentationFlag () == LteRlcAmHeader::SEGMENT)
+              {
+                NS_LOG_LOGIC ("Received PDU segment");
+                //unsigned totalBytes = 0;
+                std::list < Ptr<Packet> >::iterator itSeg;
+//                for (itSeg = it->second.m_byteSegments.begin ();
+//                    itSeg != it->second.m_byteSegments.end (); itSeg++)
+//                {
+//                  totalBytes += (*itSeg)->GetSize ();
+//                }
+                // get header of last segment received
+                NS_LOG_INFO ("RLC AM PDU segment received, offset= " << rlcAmHeader.GetSegmentOffset() <<
+                               " size= " << rlcAmHeader.GetLastOffset()-rlcAmHeader.GetSegmentOffset());
+                LteRlcAmHeader lastSegHdr;
+                it->second.m_byteSegments.back ()->PeekHeader (lastSegHdr);
+                if(rlcAmHeader.GetSegmentOffset() == lastSegHdr.GetLastOffset () || rlcAmHeader.GetSegmentOffset() + 32768 == lastSegHdr.GetLastOffset ())
+                {
+                  // segment is next in sequence
+                  it->second.m_byteSegments.push_back (p);
+                  if (rlcAmHeader.GetLastSegmentFlag () == LteRlcAmHeader::LAST_PDU_SEGMENT)
+                  {
+                    // got last segment, reassemble segments
+                    it->second.m_pduComplete = true;
+                    NS_ASSERT (it->second.m_byteSegments.size () > 1);
+                    itSeg = it->second.m_byteSegments.begin ();
+                    itSeg++;
+                    for (; itSeg != it->second.m_byteSegments.end (); itSeg++)
+                    {
+                      LteRlcAmHeader segHdr;
+                      (*itSeg)->RemoveHeader (segHdr);
+                      //totalBytes = segHdr.PopLengthIndicator ();
+                      it->second.m_byteSegments.front ()->AddAtEnd (*itSeg);
+                    }
+                    // now delete all fragments after the first whole data field
+                    itSeg = it->second.m_byteSegments.begin ();
+                    itSeg++;
+                    it->second.m_byteSegments.erase (itSeg, it->second.m_byteSegments.end ());
+                  }
+                }
+                else
+                {
+                  // out of order segment, discard both received packet and buffered
+                  //it->second.m_byteSegments.clear ();
+                  if(it->second.m_pduComplete == false)
+                  {
+                      m_rxonBuffer.erase (it);
+                      NS_LOG_LOGIC ("PDU segment received out of order, discarding");
+                  }
+                }
+              }
             }
           else
             {
-              NS_LOG_LOGIC ("Place PDU in the reception buffer ( SN = " << seqNumber << " )");
-              m_rxonBuffer[ seqNumber.GetValue () ].m_byteSegments.push_back (p);
-              m_rxonBuffer[ seqNumber.GetValue () ].m_pduComplete = true;
+              if(rlcAmHeader.GetSegmentOffset() == 0)
+              {
+                NS_LOG_LOGIC ("Place PDU in the reception buffer ( SN = " << seqNumber << " )");
+                m_rxonBuffer[ seqNumber.GetValue () ].m_byteSegments.push_back (p);
+                if(rlcAmHeader.GetResegmentationFlag () == LteRlcAmHeader::SEGMENT)
+                {
+                  NS_LOG_INFO ("RLC AM PDU segment received, offset= " << rlcAmHeader.GetSegmentOffset() <<
+                                                 " size= " << rlcAmHeader.GetLastOffset()-rlcAmHeader.GetSegmentOffset());
+                  // received segment
+                  m_rxonBuffer[ seqNumber.GetValue () ].m_pduComplete = false;
+                }
+                else
+                {
+                  m_rxonBuffer[ seqNumber.GetValue () ].m_pduComplete = true;
+                }
+              }
             }
-
-
         }
 
       // 5.1.3.2.3 Actions when a RLC data PDU is placed in the reception buffer
@@ -949,7 +2043,7 @@
                 {
                   NS_LOG_LOGIC ("Reassemble and Deliver ( SN = " << m_vrR << " )");
                   NS_ASSERT_MSG (it->second.m_byteSegments.size () == 1,
-                                "Too many segments. PDU Reassembly process didn't work");
+                                 "Too many segments. PDU Reassembly process didn't work");
                   ReassembleAndDeliver (it->second.m_byteSegments.front ());
                   m_rxonBuffer.erase (m_vrR.GetValue ());
 
@@ -1025,7 +2119,7 @@
       ackSn.SetModulusBase (m_vtA);
       sn.SetModulusBase (m_vtA);
 
-      bool incrementVtA = true; 
+      bool incrementVtA = true;
 
       for (sn = m_vtA; sn < ackSn && sn < m_vtS; sn++)
         {
@@ -1033,7 +2127,7 @@
 
           uint16_t seqNumberValue = sn.GetValue ();
 
-          if (m_pollRetransmitTimer.IsRunning () 
+          if (m_pollRetransmitTimer.IsRunning ()
               && (seqNumberValue == m_pollSn.GetValue ()))
             {
               m_pollRetransmitTimer.Cancel ();
@@ -1058,7 +2152,7 @@
                 }
 
               NS_ASSERT (m_retxBuffer.at (seqNumberValue).m_pdu != 0);
-              
+
             }
           else
             {
@@ -1068,6 +2162,9 @@
                 {
                   NS_LOG_INFO ("ACKed SN = " << seqNumberValue << " from txedBuffer");
                   //               NS_LOG_INFO ("m_txedBuffer( " << m_vtA << " )->GetSize = " << m_txedBuffer.at (m_vtA.GetValue ())->GetSize ());
+                  NS_LOG_LOGIC("m_txCompletedCallback " << m_rnti);
+                  m_txCompletedCallback(m_rnti, m_lcid, m_txedBuffer.at (seqNumberValue).m_pdu->GetSize (), 0); // 0 retransmissions at the RLC layer
+
                   m_txedBufferSize -= m_txedBuffer.at (seqNumberValue).m_pdu->GetSize ();
                   m_txedBuffer.at (seqNumberValue).m_pdu = 0;
                   NS_ASSERT (m_retxBuffer.at (seqNumberValue).m_pdu == 0);
@@ -1077,14 +2174,22 @@
                 {
                   NS_LOG_INFO ("ACKed SN = " << seqNumberValue << " from retxBuffer");
                   m_retxBufferSize -= m_retxBuffer.at (seqNumberValue).m_pdu->GetSize ();
+                  NS_LOG_LOGIC("m_txCompletedCallback " << m_rnti);
+
+                  m_txCompletedCallback(m_rnti, m_lcid, m_retxBuffer.at (seqNumberValue).m_pdu->GetSize (), m_retxBuffer.at (seqNumberValue).m_retxCount);
+
                   m_retxBuffer.at (seqNumberValue).m_pdu = 0;
                   m_retxBuffer.at (seqNumberValue).m_retxCount = 0;
+                  // reset segment buffer
+                  m_retxSegBuffer.at (seqNumberValue).m_pdu = 0;
+                  m_retxSegBuffer.at (seqNumberValue).m_retxCount = 0;
+                  m_retxSegBuffer.at (seqNumberValue).m_lastSegSent = 0;
                 }
 
             }
 
           NS_LOG_LOGIC ("retxBufferSize = " << m_retxBufferSize);
-          NS_LOG_LOGIC ("txedBufferSize = " << m_txedBufferSize);      
+          NS_LOG_LOGIC ("txedBufferSize = " << m_txedBufferSize);
 
           if (incrementVtA)
             {
@@ -1097,9 +2202,9 @@
               ackSn.SetModulusBase (m_vtA);
               sn.SetModulusBase (m_vtA);
             }
-          
+
         } // loop over SN : VT(A) <= SN < ACK SN
-      
+
       return;
 
     }
@@ -1111,7 +2216,6 @@
 
 }
 
-
 bool
 LteRlcAm::IsInsideReceivingWindow (SequenceNumber10 seqNumber)
 {
@@ -1194,10 +2298,9 @@
   std::list < Ptr<Packet> >::iterator it;
 
   // Current reassembling state
-  if (m_reassemblingState == WAITING_S0_FULL)       NS_LOG_LOGIC ("Reassembling State = 'WAITING_S0_FULL'");
+  if      (m_reassemblingState == WAITING_S0_FULL)  NS_LOG_LOGIC ("Reassembling State = 'WAITING_S0_FULL'");
   else if (m_reassemblingState == WAITING_SI_SF)    NS_LOG_LOGIC ("Reassembling State = 'WAITING_SI_SF'");
- else                                               NS_LOG_LOGIC ("Reassembling State = Unknown state");
-
+  else                                              NS_LOG_LOGIC ("Reassembling State = Unknown state");
 
   // Received framing Info
   NS_LOG_LOGIC ("Framing Info = " << (uint16_t)framingInfo);
@@ -1219,7 +2322,7 @@
                               */
                               for ( it = m_sdusBuffer.begin () ; it != m_sdusBuffer.end () ; it++ )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (*it);
+                                  TriggerReceivePdcpPdu (*it);
                                 }
                               m_sdusBuffer.clear ();
                       break;
@@ -1232,7 +2335,7 @@
                               */
                               while ( m_sdusBuffer.size () > 1 )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
 
@@ -1265,14 +2368,14 @@
                               */
                               m_keepS0->AddAtEnd (m_sdusBuffer.front ());
                               m_sdusBuffer.pop_front ();
-                              m_rlcSapUser->ReceivePdcpPdu (m_keepS0);
+                              TriggerReceivePdcpPdu (m_keepS0);
 
                               /**
                                 * Deliver zero, one or multiple PDUs
                                 */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -1295,14 +2398,14 @@
                                   */
                                   m_keepS0->AddAtEnd (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
-                                  m_rlcSapUser->ReceivePdcpPdu (m_keepS0);
+                                  TriggerReceivePdcpPdu (m_keepS0);
 
                                   /**
                                   * Deliver zero, one or multiple PDUs
                                   */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -1345,7 +2448,7 @@
                                */
                               for ( it = m_sdusBuffer.begin () ; it != m_sdusBuffer.end () ; it++ )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (*it);
+                                  TriggerReceivePdcpPdu (*it);
                                 }
                               m_sdusBuffer.clear ();
                       break;
@@ -1358,7 +2461,7 @@
                                */
                               while ( m_sdusBuffer.size () > 1 )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
 
@@ -1382,7 +2485,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -1409,7 +2512,7 @@
                                   */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -1446,7 +2549,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -1464,7 +2567,7 @@
                                */
                               while ( m_sdusBuffer.size () > 1 )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
 
@@ -1494,7 +2597,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -1526,7 +2629,7 @@
                                    */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -1556,6 +2659,21 @@
 }
 
 void
+LteRlcAm::TriggerReceivePdcpPdu(Ptr<Packet> p)
+{
+  if(!isMc)
+  {
+    m_rlcSapUser->ReceivePdcpPdu(p);
+  }
+  else
+  {
+    m_ueDataParams.ueData = p;
+    m_epcX2RlcProvider->ReceiveMcPdcpSdu(m_ueDataParams);
+  }
+}
+
+
+void
 LteRlcAm::DoReportBufferStatus (void)
 {
   NS_LOG_FUNCTION (this);
@@ -1589,22 +2707,36 @@
       else
         {
           m_txedBuffer.at (m_vtA.GetValue ()).m_pdu->PeekPacketTag (retxQueueHolTimeTag);
-        }      
+        }
       retxQueueHolDelay = now - retxQueueHolTimeTag.GetSenderTimestamp ();
     }
-  else 
-    {      
+  else
+    {
       retxQueueHolDelay = Seconds (0);
     }
 
   LteMacSapProvider::ReportBufferStatusParameters r;
   r.rnti = m_rnti;
   r.lcid = m_lcid;
-  r.txQueueSize = m_txonBufferSize;
+  r.txQueueSize = m_txonBufferSize + m_txonQueue->GetNBytes();
   r.txQueueHolDelay = txonQueueHolDelay.GetMilliSeconds ();
-  r.retxQueueSize = m_retxBufferSize + m_txedBufferSize;
+  r.retxQueueSize = m_retxBufferSize;// + m_txedBufferSize;
   r.retxQueueHolDelay = retxQueueHolDelay.GetMilliSeconds ();
 
+  // from UM low lat TODO check
+  for (unsigned i = 0; i < m_txonBuffer.size(); i++)
+  {
+    if (i == 20)  // only include up to the first 20 packets
+    {
+      break;
+    }
+    r.txPacketSizes.push_back (m_txonBuffer[i]->GetSize ());
+    RlcTag holTimeTag;
+    m_txonBuffer[i]->PeekPacketTag (holTimeTag);
+    Time holDelay = Simulator::Now () - holTimeTag.GetSenderTimestamp ();
+    r.txPacketDelays.push_back (holDelay.GetMicroSeconds ());
+  }
+
   if ( m_statusPduRequested && ! m_statusProhibitTimer.IsRunning () )
     {
       r.statusPduSize = m_statusPduBufferSize;
@@ -1616,9 +2748,9 @@
 
   if ( r.txQueueSize != 0 || r.retxQueueSize != 0 || r.statusPduSize != 0 )
     {
-      NS_LOG_INFO ("Send ReportBufferStatus: " << r.txQueueSize << ", " << r.txQueueHolDelay << ", " 
-                                               << r.retxQueueSize << ", " << r.retxQueueHolDelay << ", " 
-                                               << r.statusPduSize);
+      NS_LOG_INFO ("Send ReportBufferStatus: " << r.txQueueSize << ", " << r.txQueueHolDelay << ", "
+                                               << r.retxQueueSize << ", " << r.retxQueueHolDelay << ", "
+                                               << r.statusPduSize << ", " << r.txPacketSizes.size());
       m_macSapProvider->ReportBufferStatus (r);
     }
   else
@@ -1634,6 +2766,13 @@
   NS_LOG_FUNCTION (this);
   NS_LOG_LOGIC ("Reordering Timer has expired");
 
+  // clear the RLC segment buffer
+  // for (unsigned i = 0; i < m_retxSegBuffer.size(); i++)
+  // {
+  //  m_retxSegBuffer.at (i).m_pdu = 0;
+  //  m_retxSegBuffer.at (i).m_lastSegSent = false;
+  // }
+
   // 5.1.3.2.4 Actions when t-Reordering expires
   // When t-Reordering expires, the receiving side of an AM RLC entity shall:
   // - update VR(MS) to the SN of the first AMD PDU with SN >= VR(X) for which not all byte segments
@@ -1666,7 +2805,7 @@
 
     // Section 5.2.3 Status Reporting:
     //   - The receiving side of an AM RLC entity shall trigger a
-    //     STATUS report when T_reordering expires. 
+    //     STATUS report when T_reordering expires.
   m_statusPduRequested = true;
 }
 
@@ -1686,26 +2825,68 @@
   // see section 5.2.2.3
   // note the difference between Rel 8 and Rel 11 specs; we follow Rel 11 here
   NS_ASSERT (m_vtS <= m_vtMs);
-  if ((m_txonBufferSize == 0 && m_retxBufferSize == 0)
+  //if ((m_txonBufferSize == 0 && m_retxBufferSize == 0)
+  if ((m_txonBufferSize + m_txonQueue->GetNBytes() == 0 && m_retxBufferSize == 0)
       || (m_vtS == m_vtMs))
     {
       NS_LOG_INFO ("txonBuffer and retxBuffer empty. Move PDUs up to = " << m_vtS.GetValue () - 1 << " to retxBuffer");
-      for (SequenceNumber10 sn = m_vtA; sn < m_vtS; sn++)
+      uint16_t sn = 0;
+      uint16_t acked =  m_vtA.GetValue();
+      uint16_t sent = m_vtS.GetValue ();
+      if(acked <= sent) //If no overflow, no change.
         {
-          bool pduAvailable = m_txedBuffer.at (sn.GetValue ()).m_pdu != 0;
+      for ( sn = m_vtA.GetValue(); sn < m_vtS.GetValue (); sn++ )
+      {
+        bool pduAvailable = m_txedBuffer.at (sn).m_pdu != 0;
+
+         if ( pduAvailable )
+         {
+           NS_LOG_INFO ("Move PDU " << sn << " from txedBuffer to retxBuffer");
+           m_retxBuffer.at (sn).m_pdu = m_txedBuffer.at (sn).m_pdu->Copy ();
+           m_retxBuffer.at (sn).m_retxCount = m_txedBuffer.at (sn).m_retxCount;
+           m_retxBufferSize += m_retxBuffer.at (sn).m_pdu->GetSize ();
+
+           m_txedBufferSize -= m_txedBuffer.at (sn).m_pdu->GetSize ();
+           m_txedBuffer.at (sn).m_pdu = 0;
+           m_txedBuffer.at (sn).m_retxCount = 0;
+         }
+       }
+         }
+       else//If overflow happened, we retransmit from acked sequence to 1023, then from 0 to sent sequence.
+         {
+       for ( sn = m_vtA.GetValue(); sn < 1024; sn++ )
+         {
+         bool pduAvailable = m_txedBuffer.at (sn).m_pdu != 0;
+
+         if ( pduAvailable )
+         {
+           NS_LOG_INFO ("Move PDU " << sn << " from txedBuffer to retxBuffer");
+           m_retxBuffer.at (sn).m_pdu = m_txedBuffer.at (sn).m_pdu->Copy ();
+           m_retxBuffer.at (sn).m_retxCount = m_txedBuffer.at (sn).m_retxCount;
+           m_retxBufferSize += m_retxBuffer.at (sn).m_pdu->GetSize ();
+
+           m_txedBufferSize -= m_txedBuffer.at (sn).m_pdu->GetSize ();
+           m_txedBuffer.at (sn).m_pdu = 0;
+           m_txedBuffer.at (sn).m_retxCount = 0;
+         }
+      }
 
-           if ( pduAvailable )
-             {
-               uint16_t snValue = sn.GetValue ();
-               NS_LOG_INFO ("Move PDU " << sn << " from txedBuffer to retxBuffer");
-               m_retxBuffer.at (snValue).m_pdu = m_txedBuffer.at (snValue).m_pdu->Copy ();
-               m_retxBuffer.at (snValue).m_retxCount = m_txedBuffer.at (snValue).m_retxCount;
-               m_retxBufferSize += m_retxBuffer.at (snValue).m_pdu->GetSize ();
-
-               m_txedBufferSize -= m_txedBuffer.at (snValue).m_pdu->GetSize ();
-               m_txedBuffer.at (snValue).m_pdu = 0;
-               m_txedBuffer.at (snValue).m_retxCount = 0;
-             }
+      for ( sn = 0; sn < m_vtS.GetValue (); sn++ )
+      {
+        bool pduAvailable = m_txedBuffer.at (sn).m_pdu != 0;
+
+         if ( pduAvailable )
+         {
+           NS_LOG_INFO ("Move PDU " << sn << " from txedBuffer to retxBuffer");
+           m_retxBuffer.at (sn).m_pdu = m_txedBuffer.at (sn).m_pdu->Copy ();
+           m_retxBuffer.at (sn).m_retxCount = m_txedBuffer.at (sn).m_retxCount;
+           m_retxBufferSize += m_retxBuffer.at (sn).m_pdu->GetSize ();
+
+           m_txedBufferSize -= m_txedBuffer.at (sn).m_pdu->GetSize ();
+           m_txedBuffer.at (sn).m_pdu = 0;
+           m_txedBuffer.at (sn).m_retxCount = 0;
+         }
+      }
         }
     }
 
@@ -1713,7 +2894,7 @@
 }
 
 
-void 
+void
 LteRlcAm::ExpireStatusProhibitTimer (void)
 {
   NS_LOG_FUNCTION (this);
@@ -1724,7 +2905,7 @@
 {
   NS_LOG_LOGIC ("RBS Timer expires");
 
-  if (m_txonBufferSize + m_txedBufferSize + m_retxBufferSize > 0)
+  if (m_txonBufferSize + m_txonQueue->GetNBytes() + m_txedBufferSize + m_retxBufferSize > 0)
     {
       DoReportBufferStatus ();
       m_rbsTimer = Simulator::Schedule (m_rbsTimerValue, &LteRlcAm::ExpireRbsTimer, this);
diff -Naru a/model/lte-rlc-am.h b/model/lte-rlc-am.h
--- a/model/lte-rlc-am.h	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rlc-am.h	2018-08-03 16:39:02.891957671 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, 2018, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,11 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by Michele Polese <michele.polese@gmail.com> to add DC functionalities
+ *
+ * Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+ *							Integration of Carrier Aggregation for the mmWave module
  */
 
 #ifndef LTE_RLC_AM_H
@@ -24,10 +30,15 @@
 #include <ns3/event-id.h>
 #include <ns3/lte-rlc-sequence-number.h>
 #include <ns3/lte-rlc.h>
+#include <ns3/epc-x2-sap.h>
+#include <ns3/lte-pdcp-header.h>
 
 #include <vector>
 #include <map>
+#include <fstream>
+#include <string>
 
+#include "ns3/codel-queue-disc.h"
 namespace ns3 {
 
 /**
@@ -45,6 +56,12 @@
   static TypeId GetTypeId (void);
   virtual void DoDispose ();
 
+  struct RetxPdu
+  {
+    Ptr<Packet> m_pdu;
+    uint16_t    m_retxCount;
+  };
+
   /**
    * RLC SAP
    *
@@ -53,10 +70,46 @@
   virtual void DoTransmitPdcpPdu (Ptr<Packet> p);
 
   /**
+   * RLC EPC X2 SAP
+   */
+  virtual void DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params);
+
+  // LL HO
+  std::vector < Ptr<Packet> > GetTxBuffer();
+  uint32_t GetTxBufferSize();
+
+  std::vector < RetxPdu > GetTxedBuffer();
+  uint32_t GetTxedBufferSize();
+
+  std::vector < RetxPdu > GetRetxBuffer();
+  uint32_t GetRetxBufferSize();
+
+  std::map < uint32_t, Ptr<Packet> > GetTransmittingRlcSduBuffer();
+  uint32_t GetTransmittingRlcSduBufferSize();
+
+  Ptr<Packet> GetSegmentedRlcsdu();
+  ///< translate a vector of Rlc PDUs to Rlc SDUs
+  ///< and put the Rlc SDUs into m_transmittingRlcSdus.
+  void  RlcPdusToRlcSdus (std::vector < RetxPdu >  Pdus);
+
+  std::vector < Ptr<Packet> > GetTxedRlcSduBuffer (){
+    return m_txedRlcSduBuffer;
+  }
+
+private:
+  //whether the last SDU in the txonBuffer is a complete SDU.
+  bool is_fragmented;
+
+  //
+  std::vector < Ptr <Packet> > m_txedRlcSduBuffer;
+  uint32_t m_txedRlcSduBufferSize;
+
+public:
+  /**
    * MAC SAP
    *
    * \param bytes number of bytes
-   * \param layer 
+   * \param layer
    * \param harqId HARQ ID
    * \param componentCarrierId component carrier ID
    * \param rnti the RNTI
@@ -67,6 +120,8 @@
    * Notify HARQ delivery failure
    */
   virtual void DoNotifyHarqDeliveryFailure ();
+  virtual void DoNotifyDlHarqDeliveryFailure (uint8_t harqId);
+  virtual void DoNotifyUlHarqDeliveryFailure (uint8_t harqId);
   virtual void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
 
 private:
@@ -76,59 +131,88 @@
    * in which case this method does nothing.
    */
   void ExpireReorderingTimer (void);
-  /// Expire poll retransmitter 
+  /// Expire poll retransmitter
   void ExpirePollRetransmitTimer (void);
   /// Expire RBS timer
   void ExpireRbsTimer (void);
 
-  /** 
+  /**
    * method called when the T_status_prohibit timer expires
-   * 
+   *
    */
   void ExpireStatusProhibitTimer (void);
 
-  /** 
+  /**
    * method called when the T_status_prohibit timer expires
-   * 
+   *
    * \param seqNumber SequenceNumber10
    * \returns true is inside receivign window
    */
   bool IsInsideReceivingWindow (SequenceNumber10 seqNumber);
-// 
+
+  // LL HO
+  bool IsInsideTransmittingWindow ();
+  //Create RlcSduBuffer <seqNumber, RlcSDU> based on m_transmittingRlcSdus.
+  //The buffer is ascending ordered on sequence number.
+  void CreateRlcSduBuffer ();
+
+//
 //   void ReassembleOutsideWindow (void);
 //   void ReassembleSnLessThan (uint16_t seqNumber);
-// 
+//
 
-  /** 
+  /**
    * Reassemble and deliver
-   * 
+   *
    * \param packet the packet
    */
   void ReassembleAndDeliver (Ptr<Packet> packet);
+  void TriggerReceivePdcpPdu(Ptr<Packet> p);
+
+  void Reassemble (Ptr<Packet> Packet);
 
-  /** 
+  /**
    * Report buffer status
    */
   void DoReportBufferStatus ();
 
+  std::string GetBufferSizeFilename();
+  void SetBufferSizeFilename(std::string filename);
+  void BufferSizeTrace();
+
 private:
     std::vector < Ptr<Packet> > m_txonBuffer; ///< Transmission buffer
 
-    /// RetxPdu structure
-    struct RetxPdu
+    struct RetxSegPdu
     {
       Ptr<Packet> m_pdu; ///< PDU
       uint16_t    m_retxCount; ///< retransmit count
+      bool      m_lastSegSent;    // all segments sent, waiting for ACK
     };
 
-  std::vector <RetxPdu> m_txedBuffer;  ///< Buffer for transmitted and retransmitted PDUs 
-                                       ///< that have not been acked but are not considered 
-                                       ///< for retransmission 
+  // LL HO: store a complete version of the incomplete RLC SDU at the
+  // edge of the m_txonBuffer during the segmentation process.
+  // This SDU will be forwarded to target eNB in lossless HO
+  // to assure no packet is lost.
+  Ptr<Packet> m_segmented_rlcsdu;
+
+  std::vector <RetxPdu> m_txedBuffer;  ///< Buffer for transmitted and retransmitted PDUs
+                                       ///< that have not been acked but are not considered
+                                       ///< for retransmission
   std::vector <RetxPdu> m_retxBuffer;  ///< Buffer for PDUs considered for retransmission
+  std::vector <RetxSegPdu> m_retxSegBuffer;  // buffer for AM PDU segments
 
-    uint32_t m_txonBufferSize; ///< transmit on buffer size
-    uint32_t m_retxBufferSize; ///< retransmit buffer size
-    uint32_t m_txedBufferSize; ///< transmit ed buffer size
+  Ptr<CoDelQueueDisc> m_txonQueue;
+
+  ///< LL HO: stores RLC SDUs that is not acked
+  ///< and forwarded to target eNB during lossless handover.
+  std::vector < Ptr<Packet> > m_transmittingRlcSdus;
+  uint32_t m_transmittingRlcSduBufferSize;
+  std::map <uint32_t, Ptr <Packet> > m_transmittingRlcSduBuffer;
+
+    uint32_t m_txonBufferSize;  ///< transmit on buffer size
+    uint32_t m_retxBufferSize;  ///< transmit on buffer size
+    uint32_t m_txedBufferSize;  ///< transmit ed buffer size
 
     bool     m_statusPduRequested; ///< status PDU requested
     uint32_t m_statusPduBufferSize; ///< status PDU buffer size
@@ -140,6 +224,8 @@
       std::list < Ptr<Packet> >  m_byteSegments; ///< byte segments
 
       bool      m_pduComplete; ///< PDU complete?
+      uint16_t  m_totalSize;
+      uint16_t  m_currSize;
     };
 
     std::map <uint16_t, PduBuffer > m_rxonBuffer; ///< Reception buffer
@@ -148,8 +234,9 @@
 
     // SDU reassembly
 //   std::vector < Ptr<Packet> > m_reasBuffer;     // Reassembling buffer
-// 
+//
     std::list < Ptr<Packet> > m_sdusBuffer;       ///< List of SDUs in a packet (PDU)
+    std::list < Ptr<Packet> > m_sdusAssembleBuffer;
 
   /**
    * State variables. See section 7.1 in TS 36.322
@@ -196,8 +283,8 @@
   uint16_t m_maxRetxThreshold;  ///< \todo How these parameters are configured???
   uint16_t m_pollPdu; ///< poll PDU
   uint16_t m_pollByte; ///< poll byte
-  
-  bool m_txOpportunityForRetxAlwaysBigEnough; ///< transmit opportunity for retransmit? 
+
+  bool m_txOpportunityForRetxAlwaysBigEnough; ///< transmit opportunity for retransmit?
   bool m_pollRetransmitTimerJustExpired; ///< poll retransmit timer just expired?
 
   /**
@@ -207,15 +294,28 @@
                  WAITING_S0_FULL = 1,
                  WAITING_SI_SF   = 2 } ReassemblingState_t;
   ReassemblingState_t m_reassemblingState; ///< reassembling state
+  ReassemblingState_t m_assemblingState; //state of the RlcPduToRlcSdu assembling used for handover.
   Ptr<Packet> m_keepS0; ///< keep S0
+  Ptr<Packet> m_keepS0Reassemble;
 
   /**
    * Expected Sequence Number
    */
   SequenceNumber10 m_expectedSeqNumber;
 
-};
+  SequenceNumber10 m_reassembleExpectedSeqNumber;
+
+  std::map <uint8_t, uint16_t> m_harqIdToSnMap;
 
+  uint32_t m_maxTxBufferSize;
+
+  std::string m_bufferSizeFilename;
+  std::ofstream m_bufferSizeFile;
+  EventId m_traceBufferSizeEvent;
+
+  bool m_enableAqm;
+
+};
 
 } // namespace ns3
 
diff -Naru a/model/lte-rlc-am-header.cc b/model/lte-rlc-am-header.cc
--- a/model/lte-rlc-am-header.cc	2018-08-03 16:38:46.667806936 +0200
+++ b/model/lte-rlc-am-header.cc	2018-08-03 16:39:02.891957671 +0200
@@ -261,7 +261,7 @@
           return true;
         }
     }
-  return false;  
+  return false;
 }
 
 int
@@ -357,7 +357,7 @@
           it3++;
         }
 
- 
+
     }
 }
 
@@ -428,7 +428,7 @@
       // note: second part of ackSn will be written later
 
       // serialize the NACKs
-      if ( it3 == m_nackSnList.end () ) 
+      if ( it3 == m_nackSnList.end () )
         {
           NS_LOG_LOGIC (this << " no NACKs");
            // If there are no NACKs then this line adds the rest of the ACK
@@ -525,11 +525,17 @@
       m_sequenceNumber     = ((byte_1 & 0x03) << 8) | byte_2;
 
       m_lastSegmentFlag    = (byte_3 & 0x80) >> 7;
-      m_segmentOffset      = (byte_3 & 0x7F) | byte_4;
+      m_segmentOffset      = (byte_3 & 0x7F) << 8 | byte_4;
 
       extensionBit = (byte_1 & 0x04) >> 2;
       m_extensionBits.push_back (extensionBit);
 
+      if (m_resegmentationFlag == SEGMENT)
+        {
+          // initialize m_lastOffset
+          m_lastOffset = m_segmentOffset + start.GetSize () - m_headerLength;
+        }
+
       if (extensionBit == DATA_FIELD_FOLLOWS)
         {
           return GetSerializedSize ();
@@ -569,7 +575,8 @@
 
       if (m_resegmentationFlag == SEGMENT)
         {
-          m_lastOffset = m_segmentOffset + start.GetSize () - m_headerLength; 
+          // update m_lastOffset
+          m_lastOffset = m_segmentOffset + start.GetSize () - m_headerLength;
         }
     }
   else // if ( m_dataControlBit == CONTROL_PDU )
diff -Naru a/model/lte-rlc.cc b/model/lte-rlc.cc
--- a/model/lte-rlc.cc	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rlc.cc	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -24,7 +28,7 @@
 
 #include "ns3/lte-rlc.h"
 #include "ns3/lte-rlc-tag.h"
-// #include "lte-mac-sap.h"
+//#include "lte-mac-sap.h"
 #include "ns3/lte-rlc-sap.h"
 // #include "ff-mac-sched-sap.h"
 
@@ -32,16 +36,19 @@
 
 NS_LOG_COMPONENT_DEFINE ("LteRlc");
 
-
+///////////////////////////////////////
 /// LteRlcSpecificLteMacSapUser class
+/*
 class LteRlcSpecificLteMacSapUser : public LteMacSapUser
 {
 public:
+*/
   /**
    * Constructor
    *
    * \param rlc the RLC
    */
+   /*
   LteRlcSpecificLteMacSapUser (LteRlc* rlc);
 
   // Interface implemented from LteMacSapUser
@@ -53,6 +60,7 @@
   LteRlcSpecificLteMacSapUser ();
   LteRlc* m_rlc; ///< the RLC
 };
+*/
 
 LteRlcSpecificLteMacSapUser::LteRlcSpecificLteMacSapUser (LteRlc* rlc)
   : m_rlc (rlc)
@@ -76,12 +84,17 @@
 }
 
 void
+LteRlcSpecificLteMacSapUser::NotifyHarqDeliveryFailure (uint8_t harqId)
+{
+  m_rlc->DoNotifyHarqDeliveryFailure (harqId);
+}
+
+void
 LteRlcSpecificLteMacSapUser::ReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
 {
   m_rlc->DoReceivePdu (p, rnti, lcid);
 }
 
-
 ///////////////////////////////////////
 
 NS_OBJECT_ENSURE_REGISTERED (LteRlc);
@@ -90,10 +103,12 @@
   : m_rlcSapUser (0),
     m_macSapProvider (0),
     m_rnti (0),
-    m_lcid (0)
+    m_lcid (0),
+    isMc(false) // TODO refactor this!!
 {
   NS_LOG_FUNCTION (this);
   m_rlcSapProvider = new LteRlcSpecificLteRlcSapProvider<LteRlc> (this);
+  m_epcX2RlcUser = new EpcX2RlcSpecificUser<LteRlc> (this);
   m_macSapUser = new LteRlcSpecificLteMacSapUser (this);
 }
 
@@ -115,6 +130,10 @@
                      "PDU received.",
                      MakeTraceSourceAccessor (&LteRlc::m_rxPdu),
                      "ns3::LteRlc::ReceiveTracedCallback")
+   .AddTraceSource ("TxCompletedCallback",
+                     "PDU acked.",
+                     MakeTraceSourceAccessor (&LteRlc::m_txCompletedCallback),
+                     "ns3::LteRlc::RetransmissionCountCallback")
     ;
   return tid;
 }
@@ -169,7 +188,30 @@
   return m_macSapUser;
 }
 
+void
+LteRlc::DoNotifyHarqDeliveryFailure (uint8_t harqId)
+{
+	NS_LOG_FUNCTION (this);
+}
+
+void
+LteRlc::SetUeDataParams(EpcX2Sap::UeDataParams params)
+{
+  isMc = true;
+  m_ueDataParams = params;
+}
 
+void
+LteRlc::SetEpcX2RlcProvider (EpcX2RlcProvider * s)
+{
+  m_epcX2RlcProvider = s;
+}
+
+EpcX2RlcUser*
+LteRlc::GetEpcX2RlcUser ()
+{
+  return m_epcX2RlcUser;
+}
 
 ////////////////////////////////////////
 
@@ -223,12 +265,13 @@
   // RLC Performance evaluation
   RlcTag rlcTag;
   Time delay;
-  NS_ASSERT_MSG (p->PeekPacketTag (rlcTag), "RlcTag is missing");
-  p->RemovePacketTag (rlcTag);
-  delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
-  NS_LOG_LOGIC (" RNTI=" << m_rnti 
-                << " LCID=" << (uint32_t) m_lcid 
-                << " size=" << p->GetSize () 
+  if (p->FindFirstMatchingByteTag(rlcTag))
+    {
+      delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+    }
+  NS_LOG_LOGIC (" RNTI=" << m_rnti
+                << " LCID=" << (uint32_t) m_lcid
+                << " size=" << p->GetSize ()
                 << " delay=" << delay.GetNanoSeconds ());
   m_rxPdu(m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds () );
 }
@@ -247,9 +290,9 @@
 
   // RLC Performance evaluation
   RlcTag tag (Simulator::Now());
-  params.pdu->AddPacketTag (tag);
-  NS_LOG_LOGIC (" RNTI=" << m_rnti 
-                << " LCID=" << (uint32_t) m_lcid 
+  params.pdu->AddByteTag (tag);
+  NS_LOG_LOGIC (" RNTI=" << m_rnti
+                << " LCID=" << (uint32_t) m_lcid
                 << " size=" << bytes);
   m_txPdu(m_rnti, m_lcid, bytes);
 
@@ -270,7 +313,7 @@
   LteMacSapProvider::ReportBufferStatusParameters p;
   p.rnti = m_rnti;
   p.lcid = m_lcid;
-  p.txQueueSize = 80000;
+  p.txQueueSize = 1000000;  // mmWave module: Arbitrarily changed full-buffer BSR to report 1MB available each subframe
   p.txQueueHolDelay = 10;
   p.retxQueueSize = 0;
   p.retxQueueHolDelay = 0;
@@ -278,6 +321,13 @@
   m_macSapProvider->ReportBufferStatus (p);
 }
 
+void
+LteRlcSm::DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION(this);
+  NS_FATAL_ERROR("Not supported");
+}
+
 
 
 
diff -Naru a/model/lte-rlc.h b/model/lte-rlc.h
--- a/model/lte-rlc.h	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rlc.h	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_RLC_H
@@ -27,6 +31,7 @@
 #include "ns3/traced-value.h"
 #include "ns3/trace-source-accessor.h"
 #include "ns3/nstime.h"
+#include <ns3/epc-x2-sap.h>
 
 #include "ns3/object.h"
 
@@ -38,20 +43,40 @@
 
 // class LteRlcSapProvider;
 // class LteRlcSapUser;
-// 
+//
 // class LteMacSapProvider;
 // class LteMacSapUser;
 
+
+class LteRlc;
+
+class LteRlcSpecificLteMacSapUser : public LteMacSapUser
+{
+
+public:
+  LteRlcSpecificLteMacSapUser (LteRlc* rlc);
+
+  // Interface implemented from LteMacSapUser
+  virtual void NotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid);
+  virtual void NotifyHarqDeliveryFailure ();
+  virtual void NotifyHarqDeliveryFailure (uint8_t harqId);
+  virtual void ReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
+
+private:
+  LteRlcSpecificLteMacSapUser ();
+  LteRlc* m_rlc;
+};
+
+
 /**
  * This abstract base class defines the API to interact with the Radio Link Control
  * (LTE_RLC) in LTE, see 3GPP TS 36.322
  *
  */
-class LteRlc : public Object // SimpleRefCount<LteRlc>
+class LteRlc : public Object
 {
-  /// allow LteRlcSpecificLteMacSapUser class friend access
   friend class LteRlcSpecificLteMacSapUser;
-  /// allow LteRlcSpecificLteRlcSapProvider<LteRlc> class friend access
+  friend class EpcX2RlcSpecificUser<LteRlc>;
   friend class LteRlcSpecificLteRlcSapProvider<LteRlc>;
 public:
   LteRlc ();
@@ -92,6 +117,22 @@
   LteRlcSapProvider* GetLteRlcSapProvider ();
 
   /**
+   * Set the param needed for X2 tunneling
+   * \param the UeDataParams defined in RRC
+   */
+  void SetUeDataParams(EpcX2Sap::UeDataParams params);
+
+  /**
+   * \param s the EpcX2Rlc Provider to the Epc X2 interface
+   */
+  void SetEpcX2RlcProvider (EpcX2RlcProvider * s);
+
+  /**
+   * \return the EpcX2Rlc User, given to X2 to access Rlc SendMcPdcpPdu method
+   */
+  EpcX2RlcUser* GetEpcX2RlcUser ();
+
+  /**
    *
    *
    * \param s the MAC SAP Provider to be used by this LTE_RLC
@@ -129,14 +170,26 @@
   typedef void (* ReceiveTracedCallback)
     (uint16_t rnti, uint8_t lcid, uint32_t bytes, uint64_t delay);
 
+  /**
+   * TracedCallback signature for
+   *
+   * \param [in] rnti C-RNTI scheduled.
+   * \param [in] lcid The logical channel id corresponding to
+   *             the sending RLC instance.
+   * \param [in] bytes The packet size.
+   * \param [in] the number of RLC AM retransmissions for that packet
+   */
+  typedef void (* RetransmissionCountCallback)
+    (uint16_t rnti, uint8_t lcid, uint32_t bytes, uint32_t numRetx);
+
   /// \todo MRE What is the sense to duplicate all the interfaces here???
   // NB to avoid the use of multiple inheritance
-  
+
 protected:
   // Interface forwarded by LteRlcSapProvider
   /**
    * Transmit PDCP PDU
-   * 
+   *
    * \param p packet
    */
   virtual void DoTransmitPdcpPdu (Ptr<Packet> p) = 0;
@@ -154,21 +207,24 @@
    * \param componentCarrierId component carrier ID
    * \param rnti the RNTI
    * \param lcid the LCID
-   */ 
+   */
   virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) = 0;
   /**
    * Notify HARQ delivery failure
-   */ 
+   */
   virtual void DoNotifyHarqDeliveryFailure () = 0;
+  virtual void DoNotifyHarqDeliveryFailure (uint8_t harqId);
   /**
    * Receive PDU function
    *
    * \param p the packet
    * \param rnti the RNTI
    * \param lcid the LCID
-   */ 
+   */
   virtual void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid) = 0;
 
+  virtual void DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params) = 0;
+
   LteMacSapUser* m_macSapUser; ///< MAC SAP user
   LteMacSapProvider* m_macSapProvider; ///< MAC SAP provider
 
@@ -184,6 +240,15 @@
    */
   TracedCallback<uint16_t, uint8_t, uint32_t, uint64_t> m_rxPdu;
 
+  TracedCallback<uint16_t, uint8_t, uint32_t, uint32_t> m_txCompletedCallback; // callback used to broadcast the number of retx for each RLC packet
+
+  // MC functionalities
+  // UeDataParams needed to forward data to MmWave
+  EpcX2Sap::UeDataParams m_ueDataParams;
+  bool isMc;
+  EpcX2RlcProvider* m_epcX2RlcProvider;
+  EpcX2RlcUser* m_epcX2RlcUser;
+
 };
 
 
@@ -213,11 +278,11 @@
   virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid);
   virtual void DoNotifyHarqDeliveryFailure ();
   virtual void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
+  virtual void DoSendMcPdcpSdu (EpcX2Sap::UeDataParams params);
 
 
 
 private:
-  /// Report buffer status
   void ReportBufferStatus ();
 
 };
diff -Naru a/model/lte-rlc-sequence-number.h b/model/lte-rlc-sequence-number.h
--- a/model/lte-rlc-sequence-number.h	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rlc-sequence-number.h	2018-08-03 16:39:02.895957709 +0200
@@ -156,9 +156,9 @@
   bool operator > (const SequenceNumber10 &other) const
   {
     NS_ASSERT (m_modulusBase == other.m_modulusBase);
-    uint16_t v1 = (m_value - m_modulusBase) % 1024;
-    uint16_t v2 = (other.m_value - other.m_modulusBase) % 1024;
-    return v1 > v2;
+    SequenceNumber10 v1 ((m_value - m_modulusBase) % 1024);
+    SequenceNumber10 v2 ((other.m_value - other.m_modulusBase) % 1024);
+    return ( v1.GetValue () > v2.GetValue () );
   }
 
   /**
diff -Naru a/model/lte-rlc-tm.cc b/model/lte-rlc-tm.cc
--- a/model/lte-rlc-tm.cc	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rlc-tm.cc	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011,2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/simulator.h"
@@ -105,6 +109,12 @@
   m_rbsTimer.Cancel ();
 }
 
+void
+LteRlcTm::DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION(this);
+  DoTransmitPdcpPdu(params.ueData);
+}
 
 /**
  * MAC SAP
@@ -115,7 +125,7 @@
 {
   NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << bytes  << (uint32_t) layer << (uint32_t) harqId);
 
-  // 5.1.1.1 Transmit operations 
+  // 5.1.1.1 Transmit operations
   // 5.1.1.1.1 General
   // When submitting a new TMD PDU to lower layer, the transmitting TM RLC entity shall:
   // - submit a RLC SDU without any modification to lower layer.
@@ -137,10 +147,10 @@
 
   m_txBufferSize -= (*(m_txBuffer.begin()))->GetSize ();
   m_txBuffer.erase (m_txBuffer.begin ());
- 
+
   // Sender timestamp
   RlcTag rlcTag (Simulator::Now ());
-  packet->ReplacePacketTag (rlcTag);
+  packet->AddByteTag (rlcTag);
   m_txPdu (m_rnti, m_lcid, packet->GetSize ());
 
   // Send RLC PDU to MAC layer
@@ -175,12 +185,13 @@
   // Receiver timestamp
   RlcTag rlcTag;
   Time delay;
-  NS_ASSERT_MSG (p->PeekPacketTag (rlcTag), "RlcTag is missing");
-  p->RemovePacketTag (rlcTag);
-  delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+  if (p->FindFirstMatchingByteTag (rlcTag))
+    {
+      delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+    }
   m_rxPdu (m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
 
-  // 5.1.1.2 Receive operations 
+  // 5.1.1.2 Receive operations
   // 5.1.1.2.1  General
   // When receiving a new TMD PDU from lower layer, the receiving TM RLC entity shall:
   // - deliver the TMD PDU without any modification to upper layer.
@@ -198,7 +209,6 @@
   if (! m_txBuffer.empty ())
     {
       RlcTag holTimeTag;
-      NS_ASSERT_MSG (m_txBuffer.front ()->PeekPacketTag (holTimeTag), "RlcTag is missing");
       m_txBuffer.front ()->PeekPacketTag (holTimeTag);
       holDelay = Simulator::Now () - holTimeTag.GetSenderTimestamp ();
 
@@ -214,6 +224,20 @@
   r.retxQueueHolDelay = 0;
   r.statusPduSize = 0;
 
+  // from UM low lat
+  for (unsigned i = 0; i < m_txBuffer.size(); i++)
+  {
+    if (i == 20)  // only include up to the first 20 packets
+    {
+      break;
+    }
+    r.txPacketSizes.push_back (m_txBuffer[i]->GetSize ());
+    RlcTag holTimeTag;
+    m_txBuffer[i]->PeekPacketTag (holTimeTag);
+    holDelay = Simulator::Now () - holTimeTag.GetSenderTimestamp ();
+    r.txPacketDelays.push_back (holDelay.GetMicroSeconds ());
+  }
+
   NS_LOG_LOGIC ("Send ReportBufferStatus = " << r.txQueueSize << ", " << r.txQueueHolDelay );
   m_macSapProvider->ReportBufferStatus (r);
 }
diff -Naru a/model/lte-rlc-tm.h b/model/lte-rlc-tm.h
--- a/model/lte-rlc-tm.h	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rlc-tm.h	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011,2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,8 +16,11 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Manuel Requena <manuel.requena@cttc.es> 
+ * Author: Manuel Requena <manuel.requena@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_RLC_TM_H
@@ -53,7 +57,7 @@
 
   /**
    * MAC SAP
-   * 
+   *
    * \param bytes number of bytes
    * \param layer the layer
    * \param harqId HARQ ID
@@ -68,6 +72,8 @@
   virtual void DoNotifyHarqDeliveryFailure ();
   virtual void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
 
+  virtual void DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params);
+
 private:
   /// Expire RBS timer function
   void ExpireRbsTimer (void);
diff -Naru a/model/lte-rlc-um.cc b/model/lte-rlc-um.cc
--- a/model/lte-rlc-um.cc	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rlc-um.cc	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/simulator.h"
@@ -44,6 +48,8 @@
 {
   NS_LOG_FUNCTION (this);
   m_reassemblingState = WAITING_S0_FULL;
+  m_epcX2RlcUser = new EpcX2RlcSpecificUser<LteRlcUm> (this);
+  m_epcX2RlcProvider = 0;
 }
 
 LteRlcUm::~LteRlcUm ()
@@ -63,6 +69,17 @@
                    UintegerValue (10 * 1024),
                    MakeUintegerAccessor (&LteRlcUm::m_maxTxBufferSize),
                    MakeUintegerChecker<uint32_t> ())
+    .AddAttribute ("ReportBufferStatusTimer",
+                   "How much to wait to issue a new Report Buffer Status since the last time "
+                   "a new SDU was received",
+                   TimeValue (MilliSeconds (10)),
+                   MakeTimeAccessor (&LteRlcUm::m_rbsTimerValue),
+                   MakeTimeChecker ())
+    .AddAttribute ("ReorderingTimer",
+                   "Value of the t-Reordering timer (See section 7.3 of 3GPP TS 36.322)",
+                   TimeValue (MilliSeconds (10)),
+                   MakeTimeAccessor (&LteRlcUm::m_reorderingTimerValue),
+                   MakeTimeChecker ())
     ;
   return tid;
 }
@@ -77,6 +94,12 @@
   LteRlc::DoDispose ();
 }
 
+uint32_t
+LteRlcUm::GetMaxBuff()
+{
+  return m_maxTxBufferSize;
+}
+
 /**
  * RLC SAP
  */
@@ -107,10 +130,10 @@
   else
     {
       // Discard full RLC SDU
-      NS_LOG_LOGIC ("TxBuffer is full. RLC SDU discarded");
-      NS_LOG_LOGIC ("MaxTxBufferSize = " << m_maxTxBufferSize);
-      NS_LOG_LOGIC ("txBufferSize    = " << m_txBufferSize);
-      NS_LOG_LOGIC ("packet size     = " << p->GetSize ());
+      NS_LOG_WARN ("TxBuffer is full. RLC SDU discarded");
+      NS_LOG_WARN ("MaxTxBufferSize = " << m_maxTxBufferSize);
+      NS_LOG_WARN ("txBufferSize    = " << m_txBufferSize);
+      NS_LOG_WARN ("packet size     = " << p->GetSize ());
     }
 
   /** Report Buffer Status */
@@ -118,6 +141,12 @@
   m_rbsTimer.Cancel ();
 }
 
+void
+LteRlcUm::DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION(this);
+  DoTransmitPdcpPdu(params.ueData);
+}
 
 /**
  * MAC SAP
@@ -396,7 +425,7 @@
   if (! m_txBuffer.empty ())
     {
       m_rbsTimer.Cancel ();
-      m_rbsTimer = Simulator::Schedule (MilliSeconds (10), &LteRlcUm::ExpireRbsTimer, this);
+      m_rbsTimer = Simulator::Schedule (m_rbsTimerValue, &LteRlcUm::ExpireRbsTimer, this);
     }
 }
 
@@ -406,6 +435,12 @@
   NS_LOG_FUNCTION (this);
 }
 
+std::vector < Ptr<Packet> >
+LteRlcUm::GetTxBuffer()
+{
+  return m_txBuffer;
+}
+
 void
 LteRlcUm::DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
 {
@@ -414,7 +449,10 @@
   // Receiver timestamp
   RlcTag rlcTag;
   Time delay;
-  NS_ASSERT_MSG (p->PeekPacketTag (rlcTag), "RlcTag is missing");
+  if (p->FindFirstMatchingByteTag (rlcTag))
+  {
+    delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+  }
   p->RemovePacketTag (rlcTag);
   delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
   m_rxPdu (m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
@@ -558,7 +596,7 @@
         {
           NS_LOG_LOGIC ("VR(UH) > VR(UR)");
           NS_LOG_LOGIC ("Start reordering timer");
-          m_reorderingTimer = Simulator::Schedule (Time ("0.1s"),
+          m_reorderingTimer = Simulator::Schedule (m_reorderingTimerValue,
                                                    &LteRlcUm::ExpireReorderingTimer ,this);
           m_vrUx = m_vrUh;
           NS_LOG_LOGIC ("New VR(UX) = " << m_vrUx);
@@ -648,7 +686,7 @@
   std::list < Ptr<Packet> >::iterator it;
 
   // Current reassembling state
-  if (m_reassemblingState == WAITING_S0_FULL)       NS_LOG_LOGIC ("Reassembling State = 'WAITING_S0_FULL'");
+  if      (m_reassemblingState == WAITING_S0_FULL)  NS_LOG_LOGIC ("Reassembling State = 'WAITING_S0_FULL'");
   else if (m_reassemblingState == WAITING_SI_SF)    NS_LOG_LOGIC ("Reassembling State = 'WAITING_SI_SF'");
   else                                              NS_LOG_LOGIC ("Reassembling State = Unknown state");
 
@@ -671,7 +709,7 @@
                               */
                               for ( it = m_sdusBuffer.begin () ; it != m_sdusBuffer.end () ; it++ )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (*it);
+                                  TriggerReceivePdcpPdu (*it);
                                 }
                               m_sdusBuffer.clear ();
                       break;
@@ -684,7 +722,7 @@
                               */
                               while ( m_sdusBuffer.size () > 1 )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
 
@@ -708,7 +746,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -735,7 +773,7 @@
                                    */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -767,14 +805,14 @@
                               */
                               m_keepS0->AddAtEnd (m_sdusBuffer.front ());
                               m_sdusBuffer.pop_front ();
-                              m_rlcSapUser->ReceivePdcpPdu (m_keepS0);
+                              TriggerReceivePdcpPdu (m_keepS0);
 
                               /**
                                 * Deliver zero, one or multiple PDUs
                                 */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -797,14 +835,14 @@
                                   */
                                   m_keepS0->AddAtEnd (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
-                                  m_rlcSapUser->ReceivePdcpPdu (m_keepS0);
+                                  TriggerReceivePdcpPdu (m_keepS0);
 
                                   /**
                                   * Deliver zero, one or multiple PDUs
                                   */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -847,7 +885,7 @@
                                */
                               for ( it = m_sdusBuffer.begin () ; it != m_sdusBuffer.end () ; it++ )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (*it);
+                                  TriggerReceivePdcpPdu (*it);
                                 }
                               m_sdusBuffer.clear ();
                       break;
@@ -860,7 +898,7 @@
                                */
                               while ( m_sdusBuffer.size () > 1 )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
 
@@ -884,7 +922,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -911,7 +949,7 @@
                                   */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -948,7 +986,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -966,7 +1004,7 @@
                                */
                               while ( m_sdusBuffer.size () > 1 )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
 
@@ -996,7 +1034,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -1028,7 +1066,7 @@
                                    */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -1057,6 +1095,22 @@
 
 }
 
+void
+LteRlcUm::TriggerReceivePdcpPdu(Ptr<Packet> p)
+{
+  if(!isMc)
+  {
+    NS_LOG_INFO(this << " RlcUm forwards packet to PDCP (either from MmWave or LTE stack)");
+    m_rlcSapUser->ReceivePdcpPdu(p);
+  }
+  else
+  {
+    NS_LOG_INFO(this << " MmWave Rlc Um forwards packet to remote PDCP");
+    m_ueDataParams.ueData = p;
+    m_epcX2RlcProvider->ReceiveMcPdcpSdu(m_ueDataParams);
+  }
+}
+
 
 void
 LteRlcUm::ReassembleOutsideWindow (void)
@@ -1109,7 +1163,7 @@
 
           m_rxBuffer.erase (it);
         }
-        
+
       reassembleSn++;
     }
 }
@@ -1124,7 +1178,6 @@
   if (! m_txBuffer.empty ())
     {
       RlcTag holTimeTag;
-      NS_ASSERT_MSG (m_txBuffer.front ()->PeekPacketTag (holTimeTag), "RlcTag is missing");
       m_txBuffer.front ()->PeekPacketTag (holTimeTag);
       holDelay = Simulator::Now () - holTimeTag.GetSenderTimestamp ();
 
@@ -1176,7 +1229,7 @@
   if ( m_vrUh > m_vrUr)
     {
       NS_LOG_LOGIC ("Start reordering timer");
-      m_reorderingTimer = Simulator::Schedule (Time ("0.1s"),
+      m_reorderingTimer = Simulator::Schedule (m_reorderingTimerValue,
                                                &LteRlcUm::ExpireReorderingTimer, this);
       m_vrUx = m_vrUh;
       NS_LOG_LOGIC ("New VR(UX) = " << m_vrUx);
@@ -1192,7 +1245,7 @@
   if (! m_txBuffer.empty ())
     {
       DoReportBufferStatus ();
-      m_rbsTimer = Simulator::Schedule (MilliSeconds (10), &LteRlcUm::ExpireRbsTimer, this);
+      m_rbsTimer = Simulator::Schedule (m_rbsTimerValue, &LteRlcUm::ExpireRbsTimer, this);
     }
 }
 
diff -Naru a/model/lte-rlc-um.h b/model/lte-rlc-um.h
--- a/model/lte-rlc-um.h	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rlc-um.h	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_RLC_UM_H
@@ -23,6 +27,7 @@
 
 #include "ns3/lte-rlc-sequence-number.h"
 #include "ns3/lte-rlc.h"
+#include <ns3/epc-x2-sap.h>
 
 #include <ns3/event-id.h>
 #include <map>
@@ -44,6 +49,8 @@
   static TypeId GetTypeId (void);
   virtual void DoDispose ();
 
+  uint32_t GetMaxBuff();
+
   /**
    * RLC SAP
    *
@@ -52,6 +59,11 @@
   virtual void DoTransmitPdcpPdu (Ptr<Packet> p);
 
   /**
+   * RLC EPC X2 SAP
+   */
+  virtual void DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params);
+
+  /**
    * MAC SAP
    *
    * \param bytes the number of bytes
@@ -65,6 +77,12 @@
   virtual void DoNotifyHarqDeliveryFailure ();
   virtual void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
 
+  std::vector < Ptr<Packet> > GetTxBuffer();
+  uint32_t GetTxBufferSize()
+  {
+    return m_txBufferSize;
+  }
+
 private:
   /// Expire reordering timer
   void ExpireReorderingTimer (void);
@@ -95,6 +113,7 @@
    * \param packet the packet
    */
   void ReassembleAndDeliver (Ptr<Packet> packet);
+  void TriggerReceivePdcpPdu(Ptr<Packet> p);
 
   /// Report buffer status
   void DoReportBufferStatus ();
@@ -142,6 +161,8 @@
    */
   SequenceNumber10 m_expectedSeqNumber;
 
+  Time m_rbsTimerValue;
+  Time m_reorderingTimerValue;
 };
 
 
diff -Naru a/model/lte-rlc-um-lowlat.cc b/model/lte-rlc-um-lowlat.cc
--- a/model/lte-rlc-um-lowlat.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/lte-rlc-um-lowlat.cc	2018-08-03 16:39:02.895957709 +0200
@@ -0,0 +1,1303 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2017, NYU WIRELESS, Tandon School of Engineering, New York University
+ * Copyright (c) 2017, 2018, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by:  Russell Ford
+ *                  Low lat
+ *               Michele Polese <michele.polese@gmail.com>
+ *                  Dual Connectivity functionalities
+ *
+ * Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+ *								 Integration of Carrier Aggregation for the mmWave module
+ */
+
+#include "lte-rlc-um-lowlat.h"
+
+#include "ns3/simulator.h"
+#include "ns3/log.h"
+
+#include "ns3/lte-rlc-header.h"
+#include "ns3/lte-rlc-sdu-status-tag.h"
+#include "ns3/lte-rlc-tag.h"
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("LteRlcUmLowLat");
+
+NS_OBJECT_ENSURE_REGISTERED (LteRlcUmLowLat);
+
+uint32_t LteRlcUmLowLat::m_numArrivalsToAvg = 20;
+
+LteRlcUmLowLat::LteRlcUmLowLat ()
+  : m_maxTxBufferSize (10 * 1024),
+    m_txBufferSize (0),
+    m_sequenceNumber (0),
+    m_vrUr (0),
+    m_vrUx (0),
+    m_vrUh (0),
+    m_windowSize (512),
+    m_expectedSeqNumber (0),
+		m_currTotalPacketSize (0),
+		//m_lastArrivalTime (0),
+		m_arrivalRate (0.0),
+    m_bsrReported(false)
+		//m_forgetFactor (0.1)
+{
+  NS_LOG_FUNCTION (this);
+  m_reassemblingState = WAITING_S0_FULL;
+  m_epcX2RlcUser = new EpcX2RlcSpecificUser<LteRlcUmLowLat> (this);
+  m_epcX2RlcProvider = 0;
+
+}
+
+LteRlcUmLowLat::~LteRlcUmLowLat ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+TypeId
+LteRlcUmLowLat::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::LteRlcUmLowLat")
+    .SetParent<LteRlc> ()
+    .SetGroupName("Lte")
+    .AddConstructor<LteRlcUmLowLat> ()
+    .AddAttribute ("MaxTxBufferSize",
+                   "Maximum Size of the Transmission Buffer (in Bytes)",
+                   UintegerValue (10 * 1024),
+                   MakeUintegerAccessor (&LteRlcUmLowLat::m_maxTxBufferSize),
+                   MakeUintegerChecker<uint32_t> ())
+	 .AddAttribute ("ReportBufferStatusTimer",
+									"How much to wait to issue a new Report Buffer Status since the last time "
+									"a new SDU was received",
+									TimeValue (MilliSeconds (20)),
+									MakeTimeAccessor (&LteRlcUmLowLat::m_rbsTimerValue),
+									MakeTimeChecker ())
+	 .AddAttribute ("ReorderingTimeExpires",
+									"Time to wait for out of order PDUs"
+									"a new SDU was received",
+									TimeValue (MilliSeconds (100.0)),
+									MakeTimeAccessor (&LteRlcUmLowLat::m_reorderingTimeExpires),
+									MakeTimeChecker ())
+    .AddAttribute ("SendBsrWhenPacketTx",
+ 									"Call DoReportBufferStatus at the end of DoNotifyTxOpportunity",
+                  BooleanValue (false),
+        					MakeBooleanAccessor (&LteRlcUmLowLat::m_sendBsrWhenPacketTx),
+        					MakeBooleanChecker ())
+    ;
+  return tid;
+}
+
+void
+LteRlcUmLowLat::DoDispose ()
+{
+  NS_LOG_FUNCTION (this);
+  m_reorderingTimer.Cancel ();
+  m_rbsTimer.Cancel ();
+
+  LteRlc::DoDispose ();
+}
+
+/**
+ * RLC SAP
+ */
+
+void
+LteRlcUmLowLat::DoTransmitPdcpPdu (Ptr<Packet> p)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
+
+  if (m_txBufferSize + p->GetSize () <= m_maxTxBufferSize)
+    {
+      /** Store arrival time */
+      RlcTag timeTag (Simulator::Now ());
+      p->AddPacketTag (timeTag);
+
+      /** Store PDCP PDU */
+
+      LteRlcSduStatusTag tag;
+      tag.SetStatus (LteRlcSduStatusTag::FULL_SDU);
+      p->AddPacketTag (tag);
+
+      NS_LOG_LOGIC ("Tx Buffer: New packet added");
+      m_txBuffer.push_back (p);
+      m_txBufferSize += p->GetSize ();
+      NS_LOG_LOGIC ("NumOfBuffers = " << m_txBuffer.size() );
+      NS_LOG_LOGIC ("txBufferSize = " << m_txBufferSize);
+
+      if (m_recentArrivalTimes.size () == m_numArrivalsToAvg)
+      {
+      	m_recentArrivalTimes.pop_front ();
+      	m_currTotalPacketSize -= m_recentPacketSizes.front ();
+      	m_recentPacketSizes.pop_front ();
+      }
+      m_recentArrivalTimes.push_back ((uint32_t)timeTag.GetSenderTimestamp ().GetMicroSeconds ());
+      m_recentPacketSizes.push_back (p->GetSize ());
+      m_currTotalPacketSize += p->GetSize ();
+      double timeDiff = (m_recentArrivalTimes.back () - m_recentArrivalTimes.front ()) * 1e-6;
+      //m_arrivalRate = (1 - m_forgetFactor) * (p->GetSize () / timeDiff) + m_forgetFactor * m_arrivalRate;
+      m_arrivalRate = m_currTotalPacketSize / timeDiff;
+    }
+  else
+    {
+      // Discard full RLC SDU
+      NS_LOG_LOGIC ("TxBuffer is full. RLC SDU discarded");
+      NS_LOG_LOGIC ("MaxTxBufferSize = " << m_maxTxBufferSize);
+      NS_LOG_LOGIC ("txBufferSize    = " << m_txBufferSize);
+      NS_LOG_LOGIC ("packet size     = " << p->GetSize ());
+    }
+
+  /** Report Buffer Status */
+  DoReportBufferStatus ();
+  m_bsrReported = true;
+  m_rbsTimer.Cancel ();
+  m_rbsTimer = Simulator::Schedule (m_rbsTimerValue, &LteRlcUmLowLat::ExpireRbsTimer, this);
+}
+
+void
+LteRlcUmLowLat::DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION(this);
+  DoTransmitPdcpPdu(params.ueData);
+}
+
+/**
+ * MAC SAP
+ */
+
+void
+LteRlcUmLowLat::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << bytes << (uint32_t)componentCarrierId);
+
+  if (bytes <= 2)
+    {
+      // Stingy MAC: Header fix part is 2 bytes, we need more bytes for the data
+      NS_LOG_LOGIC ("TX opportunity too small = " << bytes);
+      return;
+    }
+
+  if (bytes > m_txBufferSize)
+   {
+     NS_LOG_DEBUG("LteRlcUmLowLat rnti " << m_rnti << " lcid " << m_lcid << " allocated " << bytes << " bufsize " << m_txBufferSize);
+   }
+
+  Ptr<Packet> packet = Create<Packet> ();
+  LteRlcHeader rlcHeader;
+
+  // Build Data field
+  uint32_t nextSegmentSize = bytes - 2;
+  uint32_t nextSegmentId = 1;
+  uint32_t dataFieldTotalSize = 0;
+  uint32_t dataFieldAddedSize = 0;
+  std::vector < Ptr<Packet> > dataField;
+
+  // Remove the first packet from the transmission buffer.
+  // If only a segment of the packet is taken, then the remaining is given back later
+  if ( m_txBuffer.size () == 0 )
+    {
+      NS_LOG_LOGIC ("No data pending");
+      return;
+    }
+
+  NS_LOG_LOGIC ("SDUs in TxBuffer  = " << m_txBuffer.size ());
+  NS_LOG_LOGIC ("First SDU buffer  = " << *(m_txBuffer.begin()));
+  NS_LOG_LOGIC ("First SDU size    = " << (*(m_txBuffer.begin()))->GetSize ());
+  NS_LOG_LOGIC ("Next segment size = " << nextSegmentSize);
+  NS_LOG_LOGIC ("Remove SDU from TxBuffer");
+  Ptr<Packet> firstSegment = (*(m_txBuffer.begin ()))->Copy ();
+  m_txBufferSize -= (*(m_txBuffer.begin()))->GetSize ();
+  NS_LOG_LOGIC ("txBufferSize      = " << m_txBufferSize );
+  m_txBuffer.erase (m_txBuffer.begin ());
+
+  while ( firstSegment && (firstSegment->GetSize () > 0) && (nextSegmentSize > 0) )
+    {
+      NS_LOG_LOGIC ("WHILE ( firstSegment && firstSegment->GetSize > 0 && nextSegmentSize > 0 )");
+      NS_LOG_LOGIC ("    firstSegment size = " << firstSegment->GetSize ());
+      NS_LOG_LOGIC ("    nextSegmentSize   = " << nextSegmentSize);
+      if ( (firstSegment->GetSize () > nextSegmentSize) ||
+           // Segment larger than 2047 octets can only be mapped to the end of the Data field
+           (firstSegment->GetSize () > 2047)
+         )
+        {
+          // Take the minimum size, due to the 2047-bytes 3GPP exception
+          // This exception is due to the length of the LI field (just 11 bits)
+          uint32_t currSegmentSize = std::min (firstSegment->GetSize (), nextSegmentSize);
+
+          NS_LOG_LOGIC ("    IF ( firstSegment > nextSegmentSize ||");
+          NS_LOG_LOGIC ("         firstSegment > 2047 )");
+
+          // Segment txBuffer.FirstBuffer and
+          // Give back the remaining segment to the transmission buffer
+          Ptr<Packet> newSegment = firstSegment->CreateFragment (0, currSegmentSize);
+          NS_LOG_LOGIC ("    newSegment size   = " << newSegment->GetSize ());
+
+          // Status tag of the new and remaining segments
+          // Note: This is the only place where a PDU is segmented and
+          // therefore its status can change
+          LteRlcSduStatusTag oldTag, newTag;
+          firstSegment->RemovePacketTag (oldTag);
+          newSegment->RemovePacketTag (newTag);
+          if (oldTag.GetStatus () == LteRlcSduStatusTag::FULL_SDU)
+            {
+              newTag.SetStatus (LteRlcSduStatusTag::FIRST_SEGMENT);
+              oldTag.SetStatus (LteRlcSduStatusTag::LAST_SEGMENT);
+            }
+          else if (oldTag.GetStatus () == LteRlcSduStatusTag::LAST_SEGMENT)
+            {
+              newTag.SetStatus (LteRlcSduStatusTag::MIDDLE_SEGMENT);
+              //oldTag.SetStatus (LteRlcSduStatusTag::LAST_SEGMENT);
+            }
+
+          // Give back the remaining segment to the transmission buffer
+          firstSegment->RemoveAtStart (currSegmentSize);
+          NS_LOG_LOGIC ("    firstSegment size (after RemoveAtStart) = " << firstSegment->GetSize ());
+          if (firstSegment->GetSize () > 0)
+            {
+              firstSegment->AddPacketTag (oldTag);
+
+              m_txBuffer.insert (m_txBuffer.begin (), firstSegment);
+              m_txBufferSize += (*(m_txBuffer.begin()))->GetSize ();
+
+              NS_LOG_LOGIC ("    TX buffer: Give back the remaining segment");
+              NS_LOG_LOGIC ("    TX buffers = " << m_txBuffer.size ());
+              NS_LOG_LOGIC ("    Front buffer size = " << (*(m_txBuffer.begin()))->GetSize ());
+              NS_LOG_LOGIC ("    txBufferSize = " << m_txBufferSize );
+            }
+          else
+            {
+              // Whole segment was taken, so adjust tag
+              if (newTag.GetStatus () == LteRlcSduStatusTag::FIRST_SEGMENT)
+                {
+                  newTag.SetStatus (LteRlcSduStatusTag::FULL_SDU);
+                }
+              else if (newTag.GetStatus () == LteRlcSduStatusTag::MIDDLE_SEGMENT)
+                {
+                  newTag.SetStatus (LteRlcSduStatusTag::LAST_SEGMENT);
+                }
+            }
+          // Segment is completely taken or
+          // the remaining segment is given back to the transmission buffer
+          firstSegment = 0;
+
+          // Put status tag once it has been adjusted
+          newSegment->AddPacketTag (newTag);
+
+          // Add Segment to Data field
+          dataFieldAddedSize = newSegment->GetSize ();
+          dataFieldTotalSize += dataFieldAddedSize;
+          dataField.push_back (newSegment);
+          newSegment = 0;
+
+          // ExtensionBit (Next_Segment - 1) = 0
+          rlcHeader.PushExtensionBit (LteRlcHeader::DATA_FIELD_FOLLOWS);
+
+          // no LengthIndicator for the last one
+
+          nextSegmentSize -= dataFieldAddedSize;
+          nextSegmentId++;
+
+          // nextSegmentSize MUST be zero (only if segment is smaller or equal to 2047)
+
+          // (NO more segments)  exit
+          // break;
+        }
+      else if ( (nextSegmentSize - firstSegment->GetSize () <= 2) || (m_txBuffer.size () == 0) )
+        {
+          NS_LOG_LOGIC ("    IF nextSegmentSize - firstSegment->GetSize () <= 2 || txBuffer.size == 0");
+          // Add txBuffer.FirstBuffer to DataField
+          dataFieldAddedSize = firstSegment->GetSize ();
+          dataFieldTotalSize += dataFieldAddedSize;
+          dataField.push_back (firstSegment);
+          firstSegment = 0;
+
+          // ExtensionBit (Next_Segment - 1) = 0
+          rlcHeader.PushExtensionBit (LteRlcHeader::DATA_FIELD_FOLLOWS);
+
+          // no LengthIndicator for the last one
+
+          nextSegmentSize -= dataFieldAddedSize;
+          nextSegmentId++;
+
+          NS_LOG_LOGIC ("        SDUs in TxBuffer  = " << m_txBuffer.size ());
+          if (m_txBuffer.size () > 0)
+            {
+              NS_LOG_LOGIC ("        First SDU buffer  = " << *(m_txBuffer.begin()));
+              NS_LOG_LOGIC ("        First SDU size    = " << (*(m_txBuffer.begin()))->GetSize ());
+            }
+          NS_LOG_LOGIC ("        Next segment size = " << nextSegmentSize);
+
+          // nextSegmentSize <= 2 (only if txBuffer is not empty)
+
+          // (NO more segments)  exit
+          // break;
+        }
+      else // (firstSegment->GetSize () < m_nextSegmentSize) && (m_txBuffer.size () > 0)
+        {
+          NS_LOG_LOGIC ("    IF firstSegment < NextSegmentSize && txBuffer.size > 0");
+          // Add txBuffer.FirstBuffer to DataField
+          dataFieldAddedSize = firstSegment->GetSize ();
+          dataFieldTotalSize += dataFieldAddedSize;
+          dataField.push_back (firstSegment);
+
+          // ExtensionBit (Next_Segment - 1) = 1
+          rlcHeader.PushExtensionBit (LteRlcHeader::E_LI_FIELDS_FOLLOWS);
+
+          // LengthIndicator (Next_Segment)  = txBuffer.FirstBuffer.length()
+          rlcHeader.PushLengthIndicator (firstSegment->GetSize ());
+
+          nextSegmentSize -= ((nextSegmentId % 2) ? (2) : (1)) + dataFieldAddedSize;
+          nextSegmentId++;
+
+          NS_LOG_LOGIC ("        SDUs in TxBuffer  = " << m_txBuffer.size ());
+          if (m_txBuffer.size () > 0)
+            {
+              NS_LOG_LOGIC ("        First SDU buffer  = " << *(m_txBuffer.begin()));
+              NS_LOG_LOGIC ("        First SDU size    = " << (*(m_txBuffer.begin()))->GetSize ());
+            }
+          NS_LOG_LOGIC ("        Next segment size = " << nextSegmentSize);
+          NS_LOG_LOGIC ("        Remove SDU from TxBuffer");
+
+          // (more segments)
+          firstSegment = (*(m_txBuffer.begin ()))->Copy ();
+          m_txBufferSize -= (*(m_txBuffer.begin()))->GetSize ();
+          m_txBuffer.erase (m_txBuffer.begin ());
+          NS_LOG_LOGIC ("        txBufferSize = " << m_txBufferSize );
+        }
+
+    }
+
+  // Build RLC header
+  rlcHeader.SetSequenceNumber (m_sequenceNumber++);
+
+  // Build RLC PDU with DataField and Header
+  std::vector< Ptr<Packet> >::iterator it;
+  it = dataField.begin ();
+
+  uint8_t framingInfo = 0;
+
+  // FIRST SEGMENT
+  LteRlcSduStatusTag tag;
+  (*it)->RemovePacketTag (tag);
+  if ( (tag.GetStatus () == LteRlcSduStatusTag::FULL_SDU) ||
+        (tag.GetStatus () == LteRlcSduStatusTag::FIRST_SEGMENT) )
+    {
+      framingInfo |= LteRlcHeader::FIRST_BYTE;
+    }
+  else
+    {
+      framingInfo |= LteRlcHeader::NO_FIRST_BYTE;
+    }
+  (*it)->AddPacketTag (tag);
+
+  while (it < dataField.end ())
+    {
+      NS_LOG_LOGIC ("Adding SDU/segment to packet, length = " << (*it)->GetSize ());
+
+      packet->AddAtEnd (*it);
+      it++;
+    }
+
+  // LAST SEGMENT (Note: There could be only one and be the first one)
+  it--;
+  (*it)->RemovePacketTag (tag);
+  if ( (tag.GetStatus () == LteRlcSduStatusTag::FULL_SDU) ||
+        (tag.GetStatus () == LteRlcSduStatusTag::LAST_SEGMENT) )
+    {
+      framingInfo |= LteRlcHeader::LAST_BYTE;
+    }
+  else
+    {
+      framingInfo |= LteRlcHeader::NO_LAST_BYTE;
+    }
+  (*it)->AddPacketTag (tag);
+
+  rlcHeader.SetFramingInfo (framingInfo);
+
+  NS_LOG_LOGIC ("RLC header: " << rlcHeader);
+  packet->AddHeader (rlcHeader);
+
+  // Sender timestamp
+  RlcTag rlcTag (Simulator::Now ());
+  packet->AddByteTag (rlcTag);
+  m_txPdu (m_rnti, m_lcid, packet->GetSize ());
+
+  // Send RLC PDU to MAC layer
+  LteMacSapProvider::TransmitPduParameters params;
+  params.pdu = packet;
+  params.rnti = m_rnti;
+  params.lcid = m_lcid;
+  params.layer = layer;
+  params.harqProcessId = harqId;
+  params.componentCarrierId = componentCarrierId;
+
+  m_macSapProvider->TransmitPdu (params);
+
+  if (! m_txBuffer.empty ())
+    {
+      m_rbsTimer.Cancel ();
+      m_rbsTimer = Simulator::Schedule (m_rbsTimerValue, &LteRlcUmLowLat::ExpireRbsTimer, this);
+    }
+
+  m_bsrReported = false; // buffer size has changed
+  if (m_sendBsrWhenPacketTx)
+  {
+    DoReportBufferStatus ();
+  }
+}
+
+void
+LteRlcUmLowLat::DoNotifyHarqDeliveryFailure ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+std::vector < Ptr<Packet> >
+LteRlcUmLowLat::GetTxBuffer()
+{
+  return m_txBuffer;
+}
+
+void
+LteRlcUmLowLat::DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
+
+  // Receiver timestamp
+  RlcTag rlcTag;
+  Time delay;
+  if (p->FindFirstMatchingByteTag (rlcTag))
+    {
+      delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+    }
+  m_rxPdu (m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
+
+  // 5.1.2.2 Receive operations
+
+  // Get RLC header parameters
+  LteRlcHeader rlcHeader;
+  p->PeekHeader (rlcHeader);
+  NS_LOG_LOGIC ("RLC header: " << rlcHeader);
+  SequenceNumber10 seqNumber = rlcHeader.GetSequenceNumber ();
+
+  // 5.1.2.2.1 General
+  // The receiving UM RLC entity shall maintain a reordering window according to state variable VR(UH) as follows:
+  // - a SN falls within the reordering window if (VR(UH) - UM_Window_Size) <= SN < VR(UH);
+  // - a SN falls outside of the reordering window otherwise.
+  // When receiving an UMD PDU from lower layer, the receiving UM RLC entity shall:
+  // - either discard the received UMD PDU or place it in the reception buffer (see sub clause 5.1.2.2.2);
+  // - if the received UMD PDU was placed in the reception buffer:
+  // - update state variables, reassemble and deliver RLC SDUs to upper layer and start/stop t-Reordering as needed (see sub clause 5.1.2.2.3);
+  // When t-Reordering expires, the receiving UM RLC entity shall:
+  // - update state variables, reassemble and deliver RLC SDUs to upper layer and start t-Reordering as needed (see sub clause 5.1.2.2.4).
+
+  // 5.1.2.2.2 Actions when an UMD PDU is received from lower layer
+  // When an UMD PDU with SN = x is received from lower layer, the receiving UM RLC entity shall:
+  // - if VR(UR) < x < VR(UH) and the UMD PDU with SN = x has been received before; or
+  // - if (VR(UH) - UM_Window_Size) <= x < VR(UR):
+  //    - discard the received UMD PDU;
+  // - else:
+  //    - place the received UMD PDU in the reception buffer.
+
+  NS_LOG_LOGIC ("VR(UR) = " << m_vrUr);
+  NS_LOG_LOGIC ("VR(UX) = " << m_vrUx);
+  NS_LOG_LOGIC ("VR(UH) = " << m_vrUh);
+  NS_LOG_LOGIC ("SN = " << seqNumber);
+
+  m_vrUr.SetModulusBase (m_vrUh - m_windowSize);
+  m_vrUh.SetModulusBase (m_vrUh - m_windowSize);
+  seqNumber.SetModulusBase (m_vrUh - m_windowSize);
+
+  if ( ( (m_vrUr < seqNumber) && (seqNumber < m_vrUh) && (m_rxBuffer.count (seqNumber.GetValue ()) > 0) ) ||
+       ( ((m_vrUh - m_windowSize) <= seqNumber) && (seqNumber < m_vrUr) )
+     )
+    {
+      NS_LOG_LOGIC ("PDU discarded");
+      p = 0;
+      return;
+    }
+  else
+    {
+      NS_LOG_LOGIC ("Place PDU in the reception buffer");
+      m_rxBuffer[seqNumber.GetValue ()] = p;
+    }
+
+
+  // 5.1.2.2.3 Actions when an UMD PDU is placed in the reception buffer
+  // When an UMD PDU with SN = x is placed in the reception buffer, the receiving UM RLC entity shall:
+
+  // - if x falls outside of the reordering window:
+  //    - update VR(UH) to x + 1;
+  //    - reassemble RLC SDUs from any UMD PDUs with SN that falls outside of the reordering window, remove
+  //      RLC headers when doing so and deliver the reassembled RLC SDUs to upper layer in ascending order of the
+  //      RLC SN if not delivered before;
+  //    - if VR(UR) falls outside of the reordering window:
+  //        - set VR(UR) to (VR(UH) - UM_Window_Size);
+
+  if ( ! IsInsideReorderingWindow (seqNumber))
+    {
+      NS_LOG_LOGIC ("SN is outside the reordering window");
+
+      m_vrUh = seqNumber + 1;
+      NS_LOG_LOGIC ("New VR(UH) = " << m_vrUh);
+
+      ReassembleOutsideWindow ();
+
+      if ( ! IsInsideReorderingWindow (m_vrUr) )
+        {
+          m_vrUr = m_vrUh - m_windowSize;
+          NS_LOG_LOGIC ("VR(UR) is outside the reordering window");
+          NS_LOG_LOGIC ("New VR(UR) = " << m_vrUr);
+        }
+    }
+
+  // - if the reception buffer contains an UMD PDU with SN = VR(UR):
+  //    - update VR(UR) to the SN of the first UMD PDU with SN > current VR(UR) that has not been received;
+  //    - reassemble RLC SDUs from any UMD PDUs with SN < updated VR(UR), remove RLC headers when doing
+  //      so and deliver the reassembled RLC SDUs to upper layer in ascending order of the RLC SN if not delivered
+  //      before;
+
+  if ( m_rxBuffer.count (m_vrUr.GetValue ()) > 0 )
+    {
+      NS_LOG_LOGIC ("Reception buffer contains SN = " << m_vrUr);
+
+      std::map <uint16_t, Ptr<Packet> >::iterator it;
+      uint16_t newVrUr;
+      SequenceNumber10 oldVrUr = m_vrUr;
+
+      it = m_rxBuffer.find (m_vrUr.GetValue ());
+      newVrUr = (it->first) + 1;
+      while ( m_rxBuffer.count (newVrUr) > 0 )
+        {
+          newVrUr++;
+        }
+      m_vrUr = newVrUr;
+      NS_LOG_LOGIC ("New VR(UR) = " << m_vrUr);
+
+      ReassembleSnInterval (oldVrUr, m_vrUr);
+    }
+
+  // m_vrUh can change previously, set new modulus base
+  // for the t-Reordering timer-related comparisons
+  m_vrUr.SetModulusBase (m_vrUh - m_windowSize);
+  m_vrUx.SetModulusBase (m_vrUh - m_windowSize);
+  m_vrUh.SetModulusBase (m_vrUh - m_windowSize);
+
+  // - if t-Reordering is running:
+  //    - if VR(UX) <= VR(UR); or
+  //    - if VR(UX) falls outside of the reordering window and VR(UX) is not equal to VR(UH)::
+  //        - stop and reset t-Reordering;
+  if ( m_reorderingTimer.IsRunning () )
+    {
+      NS_LOG_LOGIC ("Reordering timer is running");
+
+      if ( (m_vrUx <= m_vrUr) ||
+           ((! IsInsideReorderingWindow (m_vrUx)) && (m_vrUx != m_vrUh)) )
+        {
+          NS_LOG_LOGIC ("Stop reordering timer");
+          m_reorderingTimer.Cancel ();
+        }
+    }
+
+  // - if t-Reordering is not running (includes the case when t-Reordering is stopped due to actions above):
+  //    - if VR(UH) > VR(UR):
+  //        - start t-Reordering;
+  //        - set VR(UX) to VR(UH).
+  if ( ! m_reorderingTimer.IsRunning () )
+    {
+      NS_LOG_LOGIC ("Reordering timer is not running");
+
+      if ( m_vrUh > m_vrUr )
+        {
+          NS_LOG_LOGIC ("VR(UH) > VR(UR)");
+          NS_LOG_LOGIC ("Start reordering timer");
+          m_reorderingTimer = Simulator::Schedule (m_reorderingTimeExpires,
+                                                   &LteRlcUmLowLat::ExpireReorderingTimer ,this);
+          m_vrUx = m_vrUh;
+          NS_LOG_LOGIC ("New VR(UX) = " << m_vrUx);
+        }
+    }
+
+}
+
+
+bool
+LteRlcUmLowLat::IsInsideReorderingWindow (SequenceNumber10 seqNumber)
+{
+  NS_LOG_FUNCTION (this << seqNumber);
+  NS_LOG_LOGIC ("Reordering Window: " <<
+                m_vrUh << " - " << m_windowSize << " <= " << seqNumber << " < " << m_vrUh);
+
+  m_vrUh.SetModulusBase (m_vrUh - m_windowSize);
+  seqNumber.SetModulusBase (m_vrUh - m_windowSize);
+
+  if ( ((m_vrUh - m_windowSize) <= seqNumber) && (seqNumber < m_vrUh))
+    {
+      NS_LOG_LOGIC (seqNumber << " is INSIDE the reordering window");
+      return true;
+    }
+  else
+    {
+      NS_LOG_LOGIC (seqNumber << " is OUTSIDE the reordering window");
+      return false;
+    }
+}
+
+
+void
+LteRlcUmLowLat::ReassembleAndDeliver (Ptr<Packet> packet)
+{
+  LteRlcHeader rlcHeader;
+  packet->RemoveHeader (rlcHeader);
+  uint8_t framingInfo = rlcHeader.GetFramingInfo ();
+  SequenceNumber10 currSeqNumber = rlcHeader.GetSequenceNumber ();
+  bool expectedSnLost;
+
+  if ( currSeqNumber != m_expectedSeqNumber )
+    {
+      expectedSnLost = true;
+      NS_LOG_LOGIC ("There are losses. Expected SN = " << m_expectedSeqNumber << ". Current SN = " << currSeqNumber);
+      m_expectedSeqNumber = currSeqNumber + 1;
+    }
+  else
+    {
+      expectedSnLost = false;
+      NS_LOG_LOGIC ("No losses. Expected SN = " << m_expectedSeqNumber << ". Current SN = " << currSeqNumber);
+      m_expectedSeqNumber++;
+    }
+
+  // Build list of SDUs
+  uint8_t extensionBit;
+  uint16_t lengthIndicator;
+  do
+    {
+      extensionBit = rlcHeader.PopExtensionBit ();
+      NS_LOG_LOGIC ("E = " << (uint16_t)extensionBit);
+
+      if ( extensionBit == 0 )
+        {
+          m_sdusBuffer.push_back (packet);
+        }
+      else // extensionBit == 1
+        {
+          lengthIndicator = rlcHeader.PopLengthIndicator ();
+          NS_LOG_LOGIC ("LI = " << lengthIndicator);
+
+          // Check if there is enough data in the packet
+          if ( lengthIndicator >= packet->GetSize () )
+            {
+              NS_LOG_LOGIC ("INTERNAL ERROR: Not enough data in the packet (" << packet->GetSize () << "). Needed LI=" << lengthIndicator);
+            }
+
+          // Split packet in two fragments
+          Ptr<Packet> data_field = packet->CreateFragment (0, lengthIndicator);
+          packet->RemoveAtStart (lengthIndicator);
+
+          m_sdusBuffer.push_back (data_field);
+        }
+    }
+  while ( extensionBit == 1 );
+
+  std::list < Ptr<Packet> >::iterator it;
+
+  // Current reassembling state
+  if      (m_reassemblingState == WAITING_S0_FULL)  NS_LOG_LOGIC ("Reassembling State = 'WAITING_S0_FULL'");
+  else if (m_reassemblingState == WAITING_SI_SF)    NS_LOG_LOGIC ("Reassembling State = 'WAITING_SI_SF'");
+  else                                              NS_LOG_LOGIC ("Reassembling State = Unknown state");
+
+  // Received framing Info
+  NS_LOG_LOGIC ("Framing Info = " << (uint16_t)framingInfo);
+
+  // Reassemble the list of SDUs (when there is no losses)
+  if (!expectedSnLost)
+    {
+      switch (m_reassemblingState)
+        {
+          case WAITING_S0_FULL:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                              * Deliver one or multiple PDUs
+                              */
+                              for ( it = m_sdusBuffer.begin () ; it != m_sdusBuffer.end () ; it++ )
+                                {
+                                  TriggerReceivePdcpPdu (*it);
+                                }
+                              m_sdusBuffer.clear ();
+                      break;
+
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              m_reassemblingState = WAITING_SI_SF;
+
+                              /**
+                              * Deliver full PDUs
+                              */
+                              while ( m_sdusBuffer.size () > 1 )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+
+                              /**
+                              * Keep S0
+                              */
+                              m_keepS0 = m_sdusBuffer.front ();
+                              m_sdusBuffer.pop_front ();
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusBuffer.pop_front ();
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( ! m_sdusBuffer.empty () )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              if ( m_sdusBuffer.size () == 1 )
+                                {
+                                  m_reassemblingState = WAITING_S0_FULL;
+                                }
+                              else
+                                {
+                                  m_reassemblingState = WAITING_SI_SF;
+                                }
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusBuffer.pop_front ();
+
+                              if ( m_sdusBuffer.size () > 0 )
+                                {
+                                  /**
+                                   * Deliver zero, one or multiple PDUs
+                                   */
+                                  while ( m_sdusBuffer.size () > 1 )
+                                    {
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                      m_sdusBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                   * Keep S0
+                                   */
+                                  m_keepS0 = m_sdusBuffer.front ();
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      default:
+                              /**
+                              * ERROR: Transition not possible
+                              */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          case WAITING_SI_SF:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                              * Deliver (Kept)S0 + SN
+                              */
+                              m_keepS0->AddAtEnd (m_sdusBuffer.front ());
+                              m_sdusBuffer.pop_front ();
+                              TriggerReceivePdcpPdu (m_keepS0);
+
+                              /**
+                                * Deliver zero, one or multiple PDUs
+                                */
+                              while ( ! m_sdusBuffer.empty () )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              m_reassemblingState = WAITING_SI_SF;
+
+                              /**
+                              * Keep SI
+                              */
+                              if ( m_sdusBuffer.size () == 1 )
+                                {
+                                  m_keepS0->AddAtEnd (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+                              else // m_sdusBuffer.size () > 1
+                                {
+                                  /**
+                                  * Deliver (Kept)S0 + SN
+                                  */
+                                  m_keepS0->AddAtEnd (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                  TriggerReceivePdcpPdu (m_keepS0);
+
+                                  /**
+                                  * Deliver zero, one or multiple PDUs
+                                  */
+                                  while ( m_sdusBuffer.size () > 1 )
+                                    {
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                      m_sdusBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                  * Keep S0
+                                  */
+                                  m_keepS0 = m_sdusBuffer.front ();
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                      default:
+                              /**
+                                * ERROR: Transition not possible
+                                */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          default:
+                NS_LOG_LOGIC ("INTERNAL ERROR: Wrong reassembling state = " << (uint32_t) m_reassemblingState);
+          break;
+        }
+    }
+  else // Reassemble the list of SDUs (when there are losses, i.e. the received SN is not the expected one)
+    {
+      switch (m_reassemblingState)
+        {
+          case WAITING_S0_FULL:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                               * Deliver one or multiple PDUs
+                               */
+                              for ( it = m_sdusBuffer.begin () ; it != m_sdusBuffer.end () ; it++ )
+                                {
+                                  TriggerReceivePdcpPdu (*it);
+                                }
+                              m_sdusBuffer.clear ();
+                      break;
+
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              m_reassemblingState = WAITING_SI_SF;
+
+                              /**
+                               * Deliver full PDUs
+                               */
+                              while ( m_sdusBuffer.size () > 1 )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+
+                              /**
+                               * Keep S0
+                               */
+                              m_keepS0 = m_sdusBuffer.front ();
+                              m_sdusBuffer.pop_front ();
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                               * Discard SN
+                               */
+                              m_sdusBuffer.pop_front ();
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( ! m_sdusBuffer.empty () )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              if ( m_sdusBuffer.size () == 1 )
+                                {
+                                  m_reassemblingState = WAITING_S0_FULL;
+                                }
+                              else
+                                {
+                                  m_reassemblingState = WAITING_SI_SF;
+                                }
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusBuffer.pop_front ();
+
+                              if ( m_sdusBuffer.size () > 0 )
+                                {
+                                  /**
+                                  * Deliver zero, one or multiple PDUs
+                                  */
+                                  while ( m_sdusBuffer.size () > 1 )
+                                    {
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                      m_sdusBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                  * Keep S0
+                                  */
+                                  m_keepS0 = m_sdusBuffer.front ();
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      default:
+                              /**
+                               * ERROR: Transition not possible
+                               */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          case WAITING_SI_SF:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0 = 0;
+
+                              /**
+                               * Deliver one or multiple PDUs
+                               */
+                              while ( ! m_sdusBuffer.empty () )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              m_reassemblingState = WAITING_SI_SF;
+
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0 = 0;
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( m_sdusBuffer.size () > 1 )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+
+                              /**
+                               * Keep S0
+                               */
+                              m_keepS0 = m_sdusBuffer.front ();
+                              m_sdusBuffer.pop_front ();
+
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0 = 0;
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusBuffer.pop_front ();
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( ! m_sdusBuffer.empty () )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              if ( m_sdusBuffer.size () == 1 )
+                                {
+                                  m_reassemblingState = WAITING_S0_FULL;
+                                }
+                              else
+                                {
+                                  m_reassemblingState = WAITING_SI_SF;
+                                }
+
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0 = 0;
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusBuffer.pop_front ();
+
+                              if ( m_sdusBuffer.size () > 0 )
+                                {
+                                  /**
+                                   * Deliver zero, one or multiple PDUs
+                                   */
+                                  while ( m_sdusBuffer.size () > 1 )
+                                    {
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                      m_sdusBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                   * Keep S0
+                                   */
+                                  m_keepS0 = m_sdusBuffer.front ();
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      default:
+                              /**
+                                * ERROR: Transition not possible
+                                */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          default:
+                NS_LOG_LOGIC ("INTERNAL ERROR: Wrong reassembling state = " << (uint32_t) m_reassemblingState);
+          break;
+        }
+    }
+
+}
+
+
+void
+LteRlcUmLowLat::ReassembleOutsideWindow (void)
+{
+  NS_LOG_LOGIC ("Reassemble Outside Window");
+
+  std::map <uint16_t, Ptr<Packet> >::iterator it;
+  it = m_rxBuffer.begin ();
+
+  while ( (it != m_rxBuffer.end ()) && ! IsInsideReorderingWindow (SequenceNumber10 (it->first)) )
+    {
+      NS_LOG_LOGIC ("SN = " << it->first);
+
+      // Reassemble RLC SDUs and deliver the PDCP PDU to upper layer
+      ReassembleAndDeliver (it->second);
+
+      std::map <uint16_t, Ptr<Packet> >::iterator it_tmp = it;
+      ++it;
+      m_rxBuffer.erase (it_tmp);
+    }
+
+  if (it != m_rxBuffer.end ())
+    {
+      NS_LOG_LOGIC ("(SN = " << it->first << ") is inside the reordering window");
+    }
+}
+
+void
+LteRlcUmLowLat::ReassembleSnInterval (SequenceNumber10 lowSeqNumber, SequenceNumber10 highSeqNumber)
+{
+  NS_LOG_LOGIC ("Reassemble SN between " << lowSeqNumber << " and " << highSeqNumber);
+
+  std::map <uint16_t, Ptr<Packet> >::iterator it;
+
+  SequenceNumber10 reassembleSn = lowSeqNumber;
+  NS_LOG_LOGIC ("reassembleSN = " << reassembleSn);
+  NS_LOG_LOGIC ("highSeqNumber = " << highSeqNumber);
+  while (reassembleSn < highSeqNumber)
+    {
+      NS_LOG_LOGIC ("reassembleSn < highSeqNumber");
+      it = m_rxBuffer.find (reassembleSn.GetValue ());
+      NS_LOG_LOGIC ("it->first  = " << it->first);
+      NS_LOG_LOGIC ("it->second = " << it->second);
+      if (it != m_rxBuffer.end () )
+        {
+          NS_LOG_LOGIC ("SN = " << it->first);
+
+          // Reassemble RLC SDUs and deliver the PDCP PDU to upper layer
+          ReassembleAndDeliver (it->second);
+
+          m_rxBuffer.erase (it);
+        }
+
+      reassembleSn++;
+    }
+}
+
+
+void
+LteRlcUmLowLat::DoReportBufferStatus (void)
+{
+  if(!m_bsrReported)
+  {
+    Time holDelay (0);
+    uint32_t queueSize = 0;
+
+    if (! m_txBuffer.empty ())
+      {
+        RlcTag holTimeTag;
+        m_txBuffer.front ()->PeekPacketTag (holTimeTag);
+        holDelay = Simulator::Now () - holTimeTag.GetSenderTimestamp ();
+
+        queueSize = m_txBufferSize + 2 * m_txBuffer.size (); // Data in tx queue + estimated headers size
+      }
+
+    LteMacSapProvider::ReportBufferStatusParameters r;
+    r.rnti = m_rnti;
+    r.lcid = m_lcid;
+    r.txQueueSize = queueSize;
+    r.txQueueHolDelay = holDelay.GetMicroSeconds () ;
+    r.retxQueueSize = 0;
+    r.retxQueueHolDelay = 0;
+    r.statusPduSize = 0;
+
+    for (unsigned i = 0; i < m_txBuffer.size(); i++)
+    {
+      if (i == 20)  // only include up to the first 20 packets
+      {
+        break;
+      }
+      r.txPacketSizes.push_back (m_txBuffer[i]->GetSize ());
+      RlcTag holTimeTag;
+      m_txBuffer[i]->PeekPacketTag (holTimeTag);
+      holDelay = Simulator::Now () - holTimeTag.GetSenderTimestamp ();
+      r.txPacketDelays.push_back (holDelay.GetMicroSeconds ());
+    }
+
+    r.arrivalRate = m_arrivalRate;
+
+    NS_LOG_INFO ("Send ReportBufferStatus = " << r.txQueueSize << ", " << r.txQueueHolDelay << ", " << r.txPacketSizes.size());
+    m_macSapProvider->ReportBufferStatus (r);
+  }
+}
+
+
+void
+LteRlcUmLowLat::ExpireReorderingTimer (void)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid);
+  NS_LOG_LOGIC ("Reordering timer has expired");
+
+  // 5.1.2.2.4 Actions when t-Reordering expires
+  // When t-Reordering expires, the receiving UM RLC entity shall:
+  // - update VR(UR) to the SN of the first UMD PDU with SN >= VR(UX) that has not been received;
+  // - reassemble RLC SDUs from any UMD PDUs with SN < updated VR(UR), remove RLC headers when doing so
+  //   and deliver the reassembled RLC SDUs to upper layer in ascending order of the RLC SN if not delivered before;
+  // - if VR(UH) > VR(UR):
+  //    - start t-Reordering;
+  //    - set VR(UX) to VR(UH).
+
+  std::map <uint16_t, Ptr<Packet> >::iterator it;
+  SequenceNumber10 newVrUr = m_vrUx;
+
+  while ( (it = m_rxBuffer.find (newVrUr.GetValue ())) != m_rxBuffer.end () )
+    {
+      newVrUr++;
+    }
+  SequenceNumber10 oldVrUr = m_vrUr;
+  m_vrUr = newVrUr;
+  NS_LOG_LOGIC ("New VR(UR) = " << m_vrUr);
+
+  ReassembleSnInterval (oldVrUr, m_vrUr);
+
+  if ( m_vrUh > m_vrUr)
+    {
+      NS_LOG_LOGIC ("Start reordering timer");
+      m_reorderingTimer = Simulator::Schedule (m_reorderingTimeExpires,
+                                               &LteRlcUmLowLat::ExpireReorderingTimer, this);
+      m_vrUx = m_vrUh;
+      NS_LOG_LOGIC ("New VR(UX) = " << m_vrUx);
+    }
+}
+
+
+void
+LteRlcUmLowLat::ExpireRbsTimer (void)
+{
+  NS_LOG_LOGIC ("RBS Timer expires");
+
+  if (! m_txBuffer.empty ())
+    {
+      DoReportBufferStatus ();
+      m_rbsTimer = Simulator::Schedule (MilliSeconds (10), &LteRlcUmLowLat::ExpireRbsTimer, this);
+    }
+}
+
+
+void
+LteRlcUmLowLat::TriggerReceivePdcpPdu(Ptr<Packet> p)
+{
+  if(!isMc)
+  {
+    NS_LOG_INFO(this << " RlcUmLowLat forwards packet to PDCP (either from MmWave or LTE stack)");
+    m_rlcSapUser->ReceivePdcpPdu(p);
+  }
+  else
+  {
+    NS_LOG_INFO(this << " MmWave Rlc Um LowLat forwards packet to remote PDCP");
+    m_ueDataParams.ueData = p;
+    m_epcX2RlcProvider->ReceiveMcPdcpSdu(m_ueDataParams);
+  }
+}
+
+} // namespace ns3
diff -Naru a/model/lte-rlc-um-lowlat.h b/model/lte-rlc-um-lowlat.h
--- a/model/lte-rlc-um-lowlat.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/lte-rlc-um-lowlat.h	2018-08-03 16:39:02.895957709 +0200
@@ -0,0 +1,150 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2017, NYU WIRELESS, Tandon School of Engineering, New York University
+ * Copyright (c) 2017, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by:  Russell Ford
+ *                  Low lat
+ *               Michele Polese <michele.polese@gmail.com>
+ *                  Dual Connectivity functionalities
+ */
+
+#ifndef LTE_RLC_UM_LOWLAT_H
+#define LTE_RLC_UM_LOWLAT_H
+
+#include "ns3/lte-rlc-sequence-number.h"
+#include "ns3/lte-rlc.h"
+#include <ns3/epc-x2-sap.h>
+
+#include <ns3/event-id.h>
+#include <map>
+#include <deque>
+
+namespace ns3 {
+
+/**
+ * LTE RLC Unacknowledged Mode (UM), see 3GPP TS 36.322
+ */
+class LteRlcUmLowLat : public LteRlc
+{
+public:
+  LteRlcUmLowLat ();
+  virtual ~LteRlcUmLowLat ();
+  static TypeId GetTypeId (void);
+  virtual void DoDispose ();
+
+  /**
+   * RLC SAP
+   */
+  virtual void DoTransmitPdcpPdu (Ptr<Packet> p);
+
+  /**
+   * RLC EPC X2 SAP
+   */
+  virtual void DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params);
+
+  /**
+   * MAC SAP
+   */
+  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid);
+  virtual void DoNotifyHarqDeliveryFailure ();
+  virtual void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
+
+  std::vector < Ptr<Packet> > GetTxBuffer();
+  uint32_t GetTxBufferSize()
+  {
+    return m_txBufferSize;
+  }
+
+private:
+  void ExpireReorderingTimer (void);
+  void ExpireRbsTimer (void);
+
+  bool IsInsideReorderingWindow (SequenceNumber10 seqNumber);
+
+  void ReassembleOutsideWindow (void);
+  void ReassembleSnInterval (SequenceNumber10 lowSeqNumber, SequenceNumber10 highSeqNumber);
+
+  void ReassembleAndDeliver (Ptr<Packet> packet);
+  void TriggerReceivePdcpPdu(Ptr<Packet> p);
+
+  void DoReportBufferStatus ();
+
+private:
+  uint32_t m_maxTxBufferSize;
+  uint32_t m_txBufferSize;
+  std::vector < Ptr<Packet> > m_txBuffer;       // Transmission buffer
+  std::map <uint16_t, Ptr<Packet> > m_rxBuffer; // Reception buffer
+  std::vector < Ptr<Packet> > m_reasBuffer;     // Reassembling buffer
+
+  std::list < Ptr<Packet> > m_sdusBuffer;       // List of SDUs in a packet
+
+  /**
+   * State variables. See section 7.1 in TS 36.322
+   */
+  SequenceNumber10 m_sequenceNumber; // VT(US)
+
+  SequenceNumber10 m_vrUr;           // VR(UR)
+  SequenceNumber10 m_vrUx;           // VR(UX)
+  SequenceNumber10 m_vrUh;           // VR(UH)
+
+  /**
+   * Constants. See section 7.2 in TS 36.322
+   */
+  uint16_t m_windowSize;
+
+  /**
+   * Timers. See section 7.3 in TS 36.322
+   */
+  EventId m_reorderingTimer;
+  EventId m_rbsTimer;
+  Time    m_rbsTimerValue;
+
+  /**
+   * Reassembling state
+   */
+  typedef enum { NONE            = 0,
+                 WAITING_S0_FULL = 1,
+                 WAITING_SI_SF   = 2 } ReassemblingState_t;
+  ReassemblingState_t m_reassemblingState;
+  Ptr<Packet> m_keepS0;
+
+  /**
+   * Expected Sequence Number
+   */
+  SequenceNumber10 m_expectedSeqNumber;
+
+  std::deque <uint32_t> m_recentArrivalTimes;
+  std::deque <uint32_t> m_recentPacketSizes;
+  uint32_t	m_currTotalPacketSize;
+  //uint64_t m_lastArrivalTime;
+  double m_arrivalRate;
+  static uint32_t m_numArrivalsToAvg;				// average last N arrivals
+  //double	m_forgetFactor;
+  Time m_reorderingTimeExpires;
+
+  bool m_bsrReported;
+
+  bool m_sendBsrWhenPacketTx;
+};
+
+
+} // namespace ns3
+
+#endif // MMWAVE_RLC_UM_H
diff -Naru a/model/lte-rrc-header.cc b/model/lte-rrc-header.cc
--- a/model/lte-rrc-header.cc	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rrc-header.cc	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -19,6 +20,9 @@
  * Modified by:
  *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
  *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/log.h"
@@ -194,6 +198,9 @@
 
       // Serialize logicalChannelConfig
       SerializeLogicalChannelConfig (it->logicalChannelConfig);
+
+      // MmWave MC functionalities: is_mc field
+      SerializeBoolean (it->is_mc);
     }
 }
 
@@ -221,7 +228,7 @@
       // 2 options, selected option 0 (var "explicitValue", of type LogicalChannelConfig)
       SerializeChoice (2,0,false);
 
-      // Serialize LogicalChannelConfig 
+      // Serialize LogicalChannelConfig
       SerializeLogicalChannelConfig (it->logicalChannelConfig);
     }
 }
@@ -462,7 +469,7 @@
   // Serialize plmn-IdentityList
   SerializeSequenceOf (1,6,1);
 
-  // PLMN-IdentityInfo 
+  // PLMN-IdentityInfo
   SerializeSequence (std::bitset<0> (),false);
 
   SerializePlmnIdentity (systemInformationBlockType1.cellAccessRelatedInfo.plmnIdentityInfo.plmnIdentity);
@@ -563,21 +570,21 @@
   // rach-ConfigCommon
   SerializeRachConfigCommon (radioResourceConfigCommonSib.rachConfigCommon);
 
-  // bcch-Config 
+  // bcch-Config
   SerializeSequence (std::bitset<0> (0),false);
   SerializeEnum (4,0); // modificationPeriodCoeff
-  // pcch-Config 
+  // pcch-Config
   SerializeSequence (std::bitset<0> (0),false);
   SerializeEnum (4,0); // defaultPagingCycle
   SerializeEnum (8,0); // nB
-  // prach-Config 
+  // prach-Config
   SerializeSequence (std::bitset<1> (0),false);
   SerializeInteger (0,0,1023); // rootSequenceIndex
-  // pdsch-ConfigCommon 
+  // pdsch-ConfigCommon
   SerializeSequence (std::bitset<0> (0),false);
   SerializeInteger (0,-60,50); // referenceSignalPower
   SerializeInteger (0,0,3); // p-b
-  // pusch-ConfigCommon 
+  // pusch-ConfigCommon
   SerializeSequence (std::bitset<0> (0),false);
   SerializeSequence (std::bitset<0> (0),false); // pusch-ConfigBasic
   SerializeInteger (1,1,4); // n-SB
@@ -589,16 +596,16 @@
   SerializeInteger (0,0,29); // groupAssignmentPUSCH
   SerializeBoolean (false); // sequenceHoppingEnabled
   SerializeInteger (0,0,7); // cyclicShift
-  // pucch-ConfigCommon 
+  // pucch-ConfigCommon
   SerializeSequence (std::bitset<0> (0),false);
   SerializeEnum (3,0); // deltaPUCCH-Shift
   SerializeInteger (0,0,98); // nRB-CQI
   SerializeInteger (0,0,7); // nCS-AN
   SerializeInteger (0,0,2047); // n1PUCCH-AN
-  // soundingRS-UL-ConfigCommon 
+  // soundingRS-UL-ConfigCommon
   SerializeChoice (2,0,false);
   SerializeNull (); // release
-  // uplinkPowerControlCommon 
+  // uplinkPowerControlCommon
   SerializeSequence (std::bitset<0> (0),false);
   SerializeInteger (0,-126,24); // p0-NominalPUSCH
   SerializeEnum (8,0); // alpha
@@ -610,7 +617,7 @@
   SerializeEnum (3,0); // deltaF-PUCCH-Format2a
   SerializeEnum (3,0); // deltaF-PUCCH-Format2b
   SerializeInteger (0,-1,6);
-  // ul-CyclicPrefixLength 
+  // ul-CyclicPrefixLength
   SerializeEnum (2,0);
 }
 
@@ -634,7 +641,29 @@
   // freqInfo
   SerializeSequence (std::bitset<2> (3),false);
   SerializeInteger ((int) systemInformationBlockType2.freqInfo.ulCarrierFreq, 0, MAX_EARFCN);
-  SerializeEnum (6, BandwidthToEnum (systemInformationBlockType2.freqInfo.ulBandwidth));
+  switch (systemInformationBlockType2.freqInfo.ulBandwidth)
+    {
+    case 6:
+      SerializeEnum (6,0);
+      break;
+    case 15:
+      SerializeEnum (6,1);
+      break;
+    case 25:
+      SerializeEnum (6,2);
+      break;
+    case 50:
+      SerializeEnum (6,3);
+      break;
+    case 75:
+      SerializeEnum (6,4);
+      break;
+    case 100:
+      SerializeEnum (6,5);
+      break;
+    default:
+      SerializeEnum (6,0);
+    }
 
   SerializeInteger (29,1,32); // additionalSpectrumEmission
   // timeAlignmentTimerCommon
@@ -759,7 +788,7 @@
               {
                 SerializeInteger (it->rsrqResult,0,34);
               }
-            
+
           }
       }
 }
@@ -781,11 +810,11 @@
       plmnId -= n * pow (10,i);
     }
 
-  // cellReservedForOperatorUse 
+  // cellReservedForOperatorUse
   SerializeEnum (2,0);
 }
 
-void 
+void
 RrcAsn1Header::SerializeRachConfigCommon (LteRrcSap::RachConfigCommon rachConfigCommon) const
 {
   // rach-ConfigCommon
@@ -846,7 +875,7 @@
       SerializeEnum (16,15);
       break;
     default:
-      NS_FATAL_ERROR ("Wrong numberOfRA-Preambles value");
+      SerializeEnum (16,0);
     }
 
   SerializeSequence (std::bitset<0> (0),false); // powerRampingParameters
@@ -1060,11 +1089,11 @@
   measConfigOptional.set (7, !measConfig.reportConfigToAddModList.empty () );
   measConfigOptional.set (6, !measConfig.measIdToRemoveList.empty () );
   measConfigOptional.set (5, !measConfig.measIdToAddModList.empty () );
-  measConfigOptional.set (4, measConfig.haveQuantityConfig ); 
-  measConfigOptional.set (3, measConfig.haveMeasGapConfig ); 
-  measConfigOptional.set (2, measConfig.haveSmeasure ); 
+  measConfigOptional.set (4, measConfig.haveQuantityConfig );
+  measConfigOptional.set (3, measConfig.haveMeasGapConfig );
+  measConfigOptional.set (2, measConfig.haveSmeasure );
   measConfigOptional.set (1, false ); // preRegistrationInfoHRPD
-  measConfigOptional.set (0, measConfig.haveSpeedStatePars ); 
+  measConfigOptional.set (0, measConfig.haveSpeedStatePars );
   SerializeSequence (measConfigOptional,true);
 
   if (!measConfig.measObjectToRemoveList.empty ())
@@ -1098,7 +1127,29 @@
           SerializeInteger (it->measObjectEutra.carrierFreq, 0, MAX_EARFCN);
 
           // Serialize  allowedMeasBandwidth
-          SerializeEnum (6, BandwidthToEnum (it->measObjectEutra.allowedMeasBandwidth));
+          switch (it->measObjectEutra.allowedMeasBandwidth)
+            {
+            case 6:
+              SerializeEnum (6,0);
+              break;
+            case 15:
+              SerializeEnum (6,1);
+              break;
+            case 25:
+              SerializeEnum (6,2);
+              break;
+            case 50:
+              SerializeEnum (6,3);
+              break;
+            case 75:
+              SerializeEnum (6,4);
+              break;
+            case 100:
+              SerializeEnum (6,5);
+              break;
+            default:
+              SerializeEnum (6,0);
+            }
 
           SerializeBoolean (it->measObjectEutra.presenceAntennaPort1);
           SerializeBitstring (std::bitset<2> (it->measObjectEutra.neighCellConfig));
@@ -1238,7 +1289,7 @@
           switch (it->reportConfigEutra.triggerType)
             {
             case LteRrcSap::ReportConfigEutra::PERIODICAL:
-              SerializeChoice (2, 1, false); 
+              SerializeChoice (2, 1, false);
               SerializeSequence (std::bitset<0> (),false);
               switch (it->reportConfigEutra.purpose)
                 {
@@ -1251,7 +1302,7 @@
                 }
               break;
             case LteRrcSap::ReportConfigEutra::EVENT:
-            default: 
+            default:
               SerializeChoice (2, 0, false);
               SerializeSequence (std::bitset<0> (),false);
               switch (it->reportConfigEutra.eventId)
@@ -1735,23 +1786,23 @@
 
             SerializeInteger (it->cellIdentification.physCellId,1,65536);
             SerializeInteger (it->cellIdentification.dlCarrierFreq,1,MAX_EARFCN);
-            
+
             //Serialize RadioResourceConfigCommonSCell
             SerializeRadioResourceConfigCommonSCell (it->radioResourceConfigCommonSCell);
-            
+
             if (it->haveRadioResourceConfigDedicatedSCell)
               {
                 //Serialize RadioResourceConfigDedicatedSCell
                 SerializeRadioResourceDedicatedSCell (it->radioResourceConfigDedicateSCell);
               }
-            
+
           }
       }
     else
       {
         //        NS_ASSERT_MSG ( this << "NonCriticalExtension.sCellsToAddModList cannot be empty ", false);
       }
-  
+
   }
   void
   RrcAsn1Header::SerializeRadioResourceConfigCommonSCell (LteRrcSap::RadioResourceConfigCommonSCell rrccsc) const
@@ -1761,7 +1812,7 @@
     radioResourceConfigCommonSCell_r10.set (1,rrccsc.haveNonUlConfiguration); // NonUlConfiguration
     radioResourceConfigCommonSCell_r10.set (0,rrccsc.haveUlConfiguration); // UlConfiguration
     SerializeSequence (radioResourceConfigCommonSCell_r10,false);
-     
+
     if (rrccsc.haveNonUlConfiguration)
       {
         // 5 optional fields. Extension marker not present.
@@ -1773,21 +1824,21 @@
         nonUlConfiguration_r10.set (0,0); // Tdd-Config-r10 Not Implemented
         SerializeSequence (nonUlConfiguration_r10,false);
 
-        SerializeInteger (rrccsc.nonUlConfiguration.dlBandwidth,6,100); 
-        
+        SerializeInteger (rrccsc.nonUlConfiguration.dlBandwidth,6,100);
+
         std::bitset<1> antennaInfoCommon_r10;
         antennaInfoCommon_r10.set (0,1);
         SerializeSequence (antennaInfoCommon_r10,false);
         SerializeInteger (rrccsc.nonUlConfiguration.antennaInfoCommon.antennaPortsCount,0,65536);
-        
+
         std::bitset<2> pdschConfigCommon_r10;
         pdschConfigCommon_r10.set (1,1);
         pdschConfigCommon_r10.set (0,1);
         SerializeSequence (pdschConfigCommon_r10,false);
-        
+
         SerializeInteger (rrccsc.nonUlConfiguration.pdschConfigCommon.referenceSignalPower,-60,50);
-        SerializeInteger (rrccsc.nonUlConfiguration.pdschConfigCommon.pb,0,3); 
-        
+        SerializeInteger (rrccsc.nonUlConfiguration.pdschConfigCommon.pb,0,3);
+
       }
     if (rrccsc.haveUlConfiguration)
       {
@@ -1809,16 +1860,16 @@
          FreqInfo_r10.set (1,1); // UlBandwidth
          FreqInfo_r10.set (0,0); // additionalSpectrumEmissionSCell-r10 Not Implemented
          SerializeSequence (FreqInfo_r10,false);
-         
+
          SerializeInteger (rrccsc.ulConfiguration.ulFreqInfo.ulCarrierFreq,0,MAX_EARFCN);
          SerializeInteger (rrccsc.ulConfiguration.ulFreqInfo.ulBandwidth,6,100);
 
          //Serialize UlPowerControllCommonSCell
          std::bitset<2> UlPowerControlCommonSCell_r10;
-         UlPowerControlCommonSCell_r10.set (1,0); // p0-NominalPUSCH-r10 Not Implemented       
+         UlPowerControlCommonSCell_r10.set (1,0); // p0-NominalPUSCH-r10 Not Implemented
          UlPowerControlCommonSCell_r10.set (0,1); // alpha
          SerializeSequence (UlPowerControlCommonSCell_r10,false);
-         
+
          SerializeInteger (rrccsc.ulConfiguration.ulPowerControlCommonSCell.alpha,0,65536);
 
          //Serialize soundingRs-UlConfigCommon
@@ -1828,10 +1879,10 @@
          std::bitset<1> prachConfigSCell_r10;
          prachConfigSCell_r10.set(0,1);
          SerializeSequence(prachConfigSCell_r10,false);
-         SerializeInteger (rrccsc.ulConfiguration.prachConfigSCell.index,0,256);          
+         SerializeInteger (rrccsc.ulConfiguration.prachConfigSCell.index,0,256);
       }
 
-     
+
   }
   void
   RrcAsn1Header::SerializeRadioResourceDedicatedSCell (LteRrcSap::RadioResourceConfigDedicatedSCell rrcdsc) const
@@ -1844,7 +1895,7 @@
     LteRrcSap::PhysicalConfigDedicatedSCell pcdsc = rrcdsc.physicalConfigDedicatedSCell;
     SerializePhysicalConfigDedicatedSCell (pcdsc);
   }
-  
+
   void
   RrcAsn1Header::SerializePhysicalConfigDedicatedSCell (LteRrcSap::PhysicalConfigDedicatedSCell pcdsc) const
   {
@@ -1862,7 +1913,7 @@
         nulOpt.set (1,0);  // csi-RS-Config-r10 Not Implemented
         nulOpt.set (0, pcdsc.havePdschConfigDedicated); // pdsch-ConfigDedicated-r10
         SerializeSequence (nulOpt,false);
-        
+
         if (pcdsc.haveAntennaInfoDedicated)
           {
             // Serialize antennaInfo choice
@@ -1904,14 +1955,14 @@
         //Serialize Ul Configuration
         std::bitset<7> ulOpt;
         ulOpt.set (6, pcdsc.haveAntennaInfoUlDedicated);// antennaInfoUL-r10
-        ulOpt.set (5,0); // pusch-ConfigDedicatedSCell-r10 not present 
+        ulOpt.set (5,0); // pusch-ConfigDedicatedSCell-r10 not present
         ulOpt.set (4,0); // uplinkPowerControlDedicatedSCell-r10 not present
         ulOpt.set (3,0); // cqi-ReportConfigSCell-r10 not present
         ulOpt.set (2,pcdsc.haveSoundingRsUlConfigDedicated);// soundingRS-UL-ConfigDedicated-r10
         ulOpt.set (1,0);  // soundingRS-UL-ConfigDedicated-v1020 not present
         ulOpt.set (0,0); // soundingRS-UL-ConfigDedicatedAperiodic-r10 not present
         SerializeSequence (ulOpt,false);
-        
+
         if (pcdsc.haveAntennaInfoUlDedicated)
           {
             // Serialize antennaInfo choice
@@ -1974,9 +2025,9 @@
 
                 break;
               }
-              
+
           }
-      
+
 
       }
   }
@@ -2316,6 +2367,8 @@
           bIterator = DeserializeLogicalChannelConfig (&drbToAddMod.logicalChannelConfig,bIterator);
         }
 
+      bIterator = DeserializeBoolean(&drbToAddMod.is_mc,bIterator);
+
       drbToAddModList->insert (drbToAddModList->end (),drbToAddMod);
     }
   return bIterator;
@@ -2573,7 +2626,7 @@
     NS_LOG_FUNCTION (this);
     std::bitset<2> nonCriticalExtension_v890;
     bIterator = DeserializeSequence (&nonCriticalExtension_v890, false,bIterator);
-    
+
     if (nonCriticalExtension_v890[0])
       {
         // Continue to analyze future Release optional fields
@@ -2595,8 +2648,8 @@
             for (int i = 0; i < numElems; i++)
               {
                 std::bitset<4> sCellToAddMod_r10;
-                bIterator = DeserializeSequence (&sCellToAddMod_r10, false, bIterator); 
-                
+                bIterator = DeserializeSequence (&sCellToAddMod_r10, false, bIterator);
+
                 LteRrcSap::SCellToAddMod sctam;
                 // Deserialize sCellIndex
                 NS_ASSERT (sCellToAddMod_r10[3]); // sCellIndex
@@ -2625,7 +2678,7 @@
     return bIterator;
   }
 
-  Buffer::Iterator 
+  Buffer::Iterator
   RrcAsn1Header::DeserializeCellIdentification (LteRrcSap::CellIdentification *ci, Buffer::Iterator bIterator)
   {
     NS_LOG_FUNCTION (this);
@@ -2643,7 +2696,7 @@
     return bIterator;
   }
 
-  Buffer::Iterator 
+  Buffer::Iterator
   RrcAsn1Header::DeserializeRadioResourceConfigCommonSCell (LteRrcSap::RadioResourceConfigCommonSCell *rrccsc, Buffer::Iterator bIterator)
   {
     NS_LOG_FUNCTION (this);
@@ -2675,7 +2728,7 @@
       {
         std::bitset<7> UlConfiguration_r10;
         bIterator = DeserializeSequence (&UlConfiguration_r10,true,bIterator);
-        
+
         std::bitset<3> FreqInfo_r10;
         bIterator = DeserializeSequence (&FreqInfo_r10,false,bIterator);
         int n;
@@ -2688,17 +2741,17 @@
         bIterator = DeserializeSequence (&UlPowerControlCommonSCell_r10,false,bIterator);
         bIterator = DeserializeInteger (&n,0,65536,bIterator);
         rrccsc->ulConfiguration.ulPowerControlCommonSCell.alpha = n;
-         
+
         std::bitset<1> prachConfigSCell_r10;
         bIterator = DeserializeSequence (&prachConfigSCell_r10,false,bIterator);
         bIterator = DeserializeInteger (&n,0,256,bIterator);
         rrccsc->ulConfiguration.prachConfigSCell.index = n;
-      }    
-    
+      }
+
     return bIterator;
   }
 
-  Buffer::Iterator 
+  Buffer::Iterator
   RrcAsn1Header::DeserializeRadioResourceConfigDedicatedSCell (LteRrcSap::RadioResourceConfigDedicatedSCell *rrcdsc, Buffer::Iterator bIterator)
   {
     NS_LOG_FUNCTION (this);
@@ -2709,22 +2762,22 @@
     return bIterator;
   }
 
-  Buffer::Iterator 
+  Buffer::Iterator
   RrcAsn1Header::DeserializePhysicalConfigDedicatedSCell (LteRrcSap::PhysicalConfigDedicatedSCell *pcdsc, Buffer::Iterator bIterator)
   {
     NS_LOG_FUNCTION (this);
     std::bitset<2> pcdscOpt;
     bIterator = DeserializeSequence (&pcdscOpt,true,bIterator);
     pcdsc->haveNonUlConfiguration = pcdscOpt[1];
-    pcdsc->haveUlConfiguration = pcdscOpt[0];    
+    pcdsc->haveUlConfiguration = pcdscOpt[0];
     if (pcdsc->haveNonUlConfiguration)
       {
          std::bitset<4> nulOpt;
          bIterator = DeserializeSequence (&nulOpt,false,bIterator);
-         pcdsc->haveAntennaInfoDedicated = nulOpt[3];  
+         pcdsc->haveAntennaInfoDedicated = nulOpt[3];
          NS_ASSERT(!nulOpt[2]); // crossCarrierSchedulingConfig-r10 Not Implemented
          NS_ASSERT(!nulOpt[1]); // csi-RS-Config-r10 Not Implemented
-         pcdsc->havePdschConfigDedicated = nulOpt[0];  
+         pcdsc->havePdschConfigDedicated = nulOpt[0];
 
          if (pcdsc->haveAntennaInfoDedicated)
            {
@@ -2780,7 +2833,7 @@
 
              bIterator = DeserializeNull (bIterator);
            }
-        
+
       }
     if (pcdsc->haveUlConfiguration)
       {
@@ -2793,7 +2846,7 @@
          pcdsc->haveSoundingRsUlConfigDedicated = ulOpt[2];
          NS_ASSERT(!ulOpt[1]); // soundingRS-UL-ConfigDedicated-v1020 not present
          NS_ASSERT(!ulOpt[0]); // soundingRS-UL-ConfigDedicatedAperiodic-r10 not present
-         
+
          if (pcdsc->haveAntennaInfoUlDedicated)
            {
              // Deserialize antennaInfo
@@ -3398,16 +3451,16 @@
   // rach-ConfigCommon
   bIterator = DeserializeRachConfigCommon (&radioResourceConfigCommonSib->rachConfigCommon, bIterator);
 
-  // bcch-Config 
+  // bcch-Config
   bIterator = DeserializeSequence (&bitset0,false,bIterator);
   bIterator = DeserializeEnum (4,&n,bIterator); // modificationPeriodCoeff
 
-  // pcch-Config 
+  // pcch-Config
   bIterator = DeserializeSequence (&bitset0,false,bIterator);
   bIterator = DeserializeEnum (4,&n,bIterator); // defaultPagingCycle
   bIterator = DeserializeEnum (8,&n,bIterator); // nB
 
-  // prach-Config 
+  // prach-Config
   std::bitset<1> prachConfigInfoPresent;
   bIterator = DeserializeSequence (&prachConfigInfoPresent,false,bIterator);
   // prach-Config -> rootSequenceIndex
@@ -3418,7 +3471,7 @@
       // ...
     }
 
-  // pdsch-ConfigCommon 
+  // pdsch-ConfigCommon
   bIterator = DeserializeSequence (&bitset0,false,bIterator);
   bIterator = DeserializeInteger (&n,-60,50,bIterator); // referenceSignalPower
   bIterator = DeserializeInteger (&n,0,3,bIterator); // p-b
@@ -3442,26 +3495,26 @@
   bool dummyBoolean;
   bIterator = DeserializeBoolean (&dummyBoolean,bIterator);
 
-  // ul-ReferenceSignalsPUSCH 
+  // ul-ReferenceSignalsPUSCH
   bIterator = DeserializeSequence (&bitset0,false,bIterator);
 
-  // groupHoppingEnabled 
+  // groupHoppingEnabled
   bIterator = DeserializeBoolean (&dummyBoolean,bIterator);
 
-  // groupAssignmentPUSCH 
+  // groupAssignmentPUSCH
   bIterator = DeserializeInteger (&n,0,29,bIterator);
 
-  // sequenceHoppingEnabled 
+  // sequenceHoppingEnabled
   bIterator = DeserializeBoolean (&dummyBoolean,bIterator);
 
-  // cyclicShift 
+  // cyclicShift
   bIterator = DeserializeInteger (&n,0,7,bIterator);
 
-  // pucch-ConfigCommon 
-  bIterator = DeserializeEnum (3,&n,bIterator); // deltaPUCCH-Shift 
-  bIterator = DeserializeInteger (&n,0,98,bIterator); // nRB-CQI 
-  bIterator = DeserializeInteger (&n,0,7,bIterator); // nCS-AN 
-  bIterator = DeserializeInteger (&n,0,2047,bIterator); // n1PUCCH-AN 
+  // pucch-ConfigCommon
+  bIterator = DeserializeEnum (3,&n,bIterator); // deltaPUCCH-Shift
+  bIterator = DeserializeInteger (&n,0,98,bIterator); // nRB-CQI
+  bIterator = DeserializeInteger (&n,0,7,bIterator); // nCS-AN
+  bIterator = DeserializeInteger (&n,0,2047,bIterator); // n1PUCCH-AN
 
   // soundingRS-UL-ConfigCommon
   int choice;
@@ -3476,20 +3529,20 @@
       // ...
     }
 
-  // uplinkPowerControlCommon 
+  // uplinkPowerControlCommon
   bIterator = DeserializeSequence (&bitset0,false,bIterator);
   bIterator = DeserializeInteger (&n,-126,24,bIterator); // p0-NominalPUSCH
-  bIterator = DeserializeEnum (8,&n,bIterator); // alpha 
-  bIterator = DeserializeInteger (&n,-127,-96,bIterator); // p0-NominalPUCCH 
-  //deltaFList-PUCCH 
+  bIterator = DeserializeEnum (8,&n,bIterator); // alpha
+  bIterator = DeserializeInteger (&n,-127,-96,bIterator); // p0-NominalPUCCH
+  //deltaFList-PUCCH
   bIterator = DeserializeSequence (&bitset0,false,bIterator);
-  bIterator = DeserializeEnum (3,&n,bIterator); // deltaF-PUCCH-Format1 
-  bIterator = DeserializeEnum (3,&n,bIterator); // deltaF-PUCCH-Format1b 
-  bIterator = DeserializeEnum (4,&n,bIterator); // deltaF-PUCCH-Format2 
-  bIterator = DeserializeEnum (3,&n,bIterator); // deltaF-PUCCH-Format2a 
+  bIterator = DeserializeEnum (3,&n,bIterator); // deltaF-PUCCH-Format1
+  bIterator = DeserializeEnum (3,&n,bIterator); // deltaF-PUCCH-Format1b
+  bIterator = DeserializeEnum (4,&n,bIterator); // deltaF-PUCCH-Format2
+  bIterator = DeserializeEnum (3,&n,bIterator); // deltaF-PUCCH-Format2a
   bIterator = DeserializeEnum (3,&n,bIterator); // deltaF-PUCCH-Format2b
-  bIterator = DeserializeInteger (&n,-1,6,bIterator); // deltaPreambleMsg3 
- 
+  bIterator = DeserializeInteger (&n,-1,6,bIterator); // deltaPreambleMsg3
+
   // ul-CyclicPrefixLength
   bIterator = DeserializeEnum (2,&n,bIterator);
 
@@ -3668,7 +3721,7 @@
              }
            measResults->measScellResultList.measResultScell.push_back (measResultScell);
           }
-        
+
       }
   return bIterator;
 }
@@ -3775,7 +3828,28 @@
 
               // allowedMeasBandwidth
               bIterator = DeserializeEnum (6, &n, bIterator);
-              elem.measObjectEutra.allowedMeasBandwidth = EnumToBandwidth (n);
+              switch (n)
+                {
+                case 0:
+                  elem.measObjectEutra.allowedMeasBandwidth = 6;
+                  break;
+                case 1:
+                  elem.measObjectEutra.allowedMeasBandwidth = 15;
+                  break;
+                case 2:
+                  elem.measObjectEutra.allowedMeasBandwidth = 25;
+                  break;
+                case 3:
+                  elem.measObjectEutra.allowedMeasBandwidth = 50;
+                  break;
+                case 4:
+                  elem.measObjectEutra.allowedMeasBandwidth = 75;
+                  break;
+                case 5:
+                default:
+                  elem.measObjectEutra.allowedMeasBandwidth = 100;
+                  break;
+                }
 
               // presenceAntennaPort1
               bIterator = DeserializeBoolean (&elem.measObjectEutra.presenceAntennaPort1, bIterator);
@@ -4591,7 +4665,7 @@
   SerializeEnum (8,m_establishmentCause);
 
   // Serialize spare : BIT STRING (SIZE (1))
-  SerializeBitstring (std::bitset<1> ());
+  SerializeBitstring (m_spare);
 
   // Finish serialization
   FinalizeSerialization ();
@@ -4600,7 +4674,7 @@
 uint32_t
 RrcConnectionRequestHeader::Deserialize (Buffer::Iterator bIterator)
 {
-  std::bitset<1> dummy;
+  //std::bitset<1> dummy;
   std::bitset<0> optionalOrDefaultMask;
   int selectedOption;
 
@@ -4631,7 +4705,7 @@
   bIterator = DeserializeEnum (8,&selectedOption,bIterator);
 
   // Deserialize spare
-  bIterator = DeserializeBitstring (&dummy,bIterator);
+  bIterator = DeserializeBitstring (&m_spare,bIterator);
 
   return GetSerializedSize ();
 }
@@ -4641,6 +4715,7 @@
 {
   m_mTmsi = std::bitset<32> ((uint32_t)msg.ueIdentity);
   m_mmec = std::bitset<8> ((uint32_t)(msg.ueIdentity >> 32));
+  m_spare = std::bitset<1> (msg.isMc);
   m_isDataSerialized = false;
 }
 
@@ -4649,7 +4724,7 @@
 {
   LteRrcSap::RrcConnectionRequest msg;
   msg.ueIdentity = (((uint64_t) m_mmec.to_ulong ()) << 32) | (m_mTmsi.to_ulong ());
-
+  msg.isMc = (bool) m_spare[0];
   return msg;
 }
 
@@ -4665,16 +4740,167 @@
   return m_mTmsi;
 }
 
+std::bitset<1>
+RrcConnectionRequestHeader::GetIsMc () const
+{
+  return m_spare;
+}
+
+//////////////////// RrcConnectionRequest class ////////////////////////
+
+// Constructor
+RrcConnectToMmWaveHeader::RrcConnectToMmWaveHeader () : RrcDlCcchMessage ()
+{
+  m_mmWaveId = std::bitset<16> (0ul);
+}
+
+// Destructor
+RrcConnectToMmWaveHeader::~RrcConnectToMmWaveHeader ()
+{
+}
+
+TypeId
+RrcConnectToMmWaveHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::RrcConnectToMmWaveHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+  ;
+  return tid;
+}
+
+void
+RrcConnectToMmWaveHeader::Print (std::ostream &os) const
+{
+  os << "MmWaveId:" << m_mmWaveId << std::endl;
+}
+
+void
+RrcConnectToMmWaveHeader::PreSerialize () const
+{
+  m_serializationResult = Buffer ();
+
+  SerializeDlCcchMessage (4);
+
+  // Serialize mmWaveId : MMEC ::= BIT STRING (SIZE (16))
+  SerializeBitstring (m_mmWaveId);
+
+  // Finish serialization
+  FinalizeSerialization ();
+}
+
+uint32_t
+RrcConnectToMmWaveHeader::Deserialize (Buffer::Iterator bIterator)
+{
+
+  bIterator = DeserializeDlCcchMessage (bIterator);
+
+  // Deserialize mmWaveId
+  bIterator = DeserializeBitstring (&m_mmWaveId,bIterator);
+
+  return GetSerializedSize ();
+}
+
+void
+RrcConnectToMmWaveHeader::SetMessage (uint16_t mmWaveId)
+{
+  m_mmWaveId = std::bitset<16> ((uint16_t)mmWaveId);
+  m_isDataSerialized = false;
+}
+
+uint16_t
+RrcConnectToMmWaveHeader::GetMessage () const
+{
+  uint16_t mmWaveId = (uint16_t)(m_mmWaveId.to_ulong ());
+  return mmWaveId;
+}
+
+//////////////////// RrcNotifySecondaryConnectedHeader class ////////////////////////
+
+// Constructor
+RrcNotifySecondaryConnectedHeader::RrcNotifySecondaryConnectedHeader ()
+{
+  m_mmWaveId = std::bitset<16> (0ul);
+  m_mmWaveRnti = std::bitset<16> (0ul);
+}
+
+// Destructor
+RrcNotifySecondaryConnectedHeader::~RrcNotifySecondaryConnectedHeader ()
+{
+}
+
+TypeId
+RrcNotifySecondaryConnectedHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::RrcNotifySecondaryConnectedHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+  ;
+  return tid;
+}
+
+void
+RrcNotifySecondaryConnectedHeader::Print (std::ostream &os) const
+{
+  os << "MmWaveId:" << m_mmWaveId << std::endl;
+  os << "MmWaveRnti:" << m_mmWaveRnti << std::endl;
+}
+
+void
+RrcNotifySecondaryConnectedHeader::PreSerialize () const
+{
+  m_serializationResult = Buffer ();
+
+  SerializeUlDcchMessage (5);
+
+  // Serialize mmWaveId : MMEC ::= BIT STRING (SIZE (16))
+  SerializeBitstring (m_mmWaveId);
+  SerializeBitstring (m_mmWaveRnti);
+
+  // Finish serialization
+  FinalizeSerialization ();
+}
+
+uint32_t
+RrcNotifySecondaryConnectedHeader::Deserialize (Buffer::Iterator bIterator)
+{
+
+  bIterator = DeserializeUlDcchMessage (bIterator);
+
+  // Deserialize mmWaveId
+  bIterator = DeserializeBitstring (&m_mmWaveId,bIterator);
+  bIterator = DeserializeBitstring (&m_mmWaveRnti,bIterator);
+
+  return GetSerializedSize ();
+}
+
+void
+RrcNotifySecondaryConnectedHeader::SetMessage (uint16_t mmWaveId, uint16_t mmWaveRnti)
+{
+  m_mmWaveRnti = std::bitset<16> ((uint16_t)mmWaveRnti);
+  m_mmWaveId = std::bitset<16> ((uint16_t)mmWaveId);
+  m_isDataSerialized = false;
+}
+
+std::pair<uint16_t, uint16_t>
+RrcNotifySecondaryConnectedHeader::GetMessage () const
+{
+  uint16_t mmWaveId = (uint16_t)(m_mmWaveId.to_ulong ());
+  uint16_t mmWaveRnti = (uint16_t)(m_mmWaveRnti.to_ulong ());
+
+  return std::pair<uint16_t, uint16_t>(mmWaveId, mmWaveRnti);
+}
+
 
 //////////////////// RrcConnectionSetup class ////////////////////////
 RrcConnectionSetupHeader::RrcConnectionSetupHeader ()
 {
 }
- 
+
 RrcConnectionSetupHeader::~RrcConnectionSetupHeader ()
 {
 }
- 
+
 void
 RrcConnectionSetupHeader::Print (std::ostream &os) const
 {
@@ -4798,7 +5024,7 @@
 {
   LteRrcSap::RrcConnectionSetup msg;
   msg.rrcTransactionIdentifier = m_rrcTransactionIdentifier;
-  msg.radioResourceConfigDedicated = m_radioResourceConfigDedicated; 
+  msg.radioResourceConfigDedicated = m_radioResourceConfigDedicated;
   return msg;
 }
 
@@ -4824,7 +5050,7 @@
 RrcConnectionSetupHeader::GetDrbToAddModList () const
 {
   return m_radioResourceConfigDedicated.drbToAddModList;
-} 
+}
 
 std::list<uint8_t>
 RrcConnectionSetupHeader::GetDrbToReleaseList () const
@@ -5041,6 +5267,91 @@
   return m_rrcTransactionIdentifier;
 }
 
+//////////////////// RrcConnectionSwitchHeader class ////////////////////////
+
+RrcConnectionSwitchHeader::RrcConnectionSwitchHeader ()
+{
+}
+
+RrcConnectionSwitchHeader::~RrcConnectionSwitchHeader ()
+{
+}
+
+void
+RrcConnectionSwitchHeader::PreSerialize () const
+{
+  m_serializationResult = Buffer ();
+
+  // Serialize DCCH message
+  SerializeDlDcchMessage (6);
+
+  // Serialize rrc-TransactionIdentifier
+  SerializeInteger (m_msg.rrcTransactionIdentifier,0,3);
+
+  // Serialize the number of brbId
+  SerializeInteger(m_msg.drbidList.size(), 0, 255);
+
+  std::vector<uint8_t>::iterator drbIt = m_msg.drbidList.begin();
+  for(; drbIt != m_msg.drbidList.end(); ++drbIt)
+  {
+    SerializeInteger(*drbIt, 0, 255);
+  }
+
+  SerializeInteger(m_msg.useMmWaveConnection, 0, 65535);
+
+  // Finish serialization
+  FinalizeSerialization ();
+}
+
+uint32_t
+RrcConnectionSwitchHeader::Deserialize (Buffer::Iterator bIterator)
+{
+  int n;
+  bIterator = DeserializeDlDcchMessage (bIterator);
+  bIterator = DeserializeInteger (&n,0,3,bIterator);
+  m_msg.rrcTransactionIdentifier = (uint8_t)n;
+
+  bIterator = DeserializeInteger (&n,0,255,bIterator);
+  int listSize = n;
+
+  for(int i = 0; i < listSize; i++)
+  {
+    bIterator = DeserializeInteger (&n,0,255,bIterator);
+    uint8_t drb = (uint8_t)n;
+    m_msg.drbidList.push_back(drb);
+  }
+
+  bIterator = DeserializeInteger (&n,0,65535,bIterator);
+  m_msg.useMmWaveConnection = (uint16_t)n;
+
+  return GetSerializedSize ();
+}
+
+void
+RrcConnectionSwitchHeader::Print (std::ostream &os) const
+{
+  os << "rrcTransactionIdentifier: " << (int) m_msg.rrcTransactionIdentifier << std::endl;
+}
+
+void
+RrcConnectionSwitchHeader::SetMessage (LteRrcSap::RrcConnectionSwitch msg)
+{
+  m_msg = msg;
+  m_isDataSerialized = false;
+}
+
+LteRrcSap::RrcConnectionSwitch
+RrcConnectionSwitchHeader::GetMessage () const
+{
+  return m_msg;
+}
+
+uint8_t
+RrcConnectionSwitchHeader::GetRrcTransactionIdentifier () const
+{
+  return m_msg.rrcTransactionIdentifier;
+}
+
 //////////////////// RrcConnectionReconfigurationHeader class ////////////////////////
 
 RrcConnectionReconfigurationHeader::RrcConnectionReconfigurationHeader ()
@@ -5154,7 +5465,7 @@
         noncriticalExtension_v890.set (0,m_haveNonCriticalExtension); // Implemented nonCriticalExtension because compatibility with R10 - CA
         //Enable RRCCoonectionReconfiguration-v920-IEs
         SerializeSequence (noncriticalExtension_v890,false);
-  	  
+
         // Serialize NonCriticalExtension RRCConnectionReconfiguration-v920-IEs sequence:
         // 3 optional fields. Extension marker not present.
         std::bitset<3> noncriticalExtension_v920;
@@ -5163,7 +5474,7 @@
         //Enable RRCCoonectionReconfiguration-v1020-IEs
         noncriticalExtension_v920.set (0,m_haveNonCriticalExtension); // Implemented nonCriticalExtension because compatibility with R10 - CA
         SerializeSequence (noncriticalExtension_v920,false);
-  	  
+
         SerializeNonCriticalExtensionConfiguration (m_nonCriticalExtension); //Serializing RRCConnectionReconfiguration-r8-IEs
     }
 
@@ -5651,25 +5962,25 @@
   return m_radioResourceConfigDedicated.havePhysicalConfigDedicated;
 }
 
-std::list<LteRrcSap::SrbToAddMod> 
+std::list<LteRrcSap::SrbToAddMod>
 RrcConnectionReconfigurationHeader::GetSrbToAddModList () const
 {
   return m_radioResourceConfigDedicated.srbToAddModList;
 }
 
-std::list<LteRrcSap::DrbToAddMod> 
+std::list<LteRrcSap::DrbToAddMod>
 RrcConnectionReconfigurationHeader::GetDrbToAddModList () const
 {
   return m_radioResourceConfigDedicated.drbToAddModList;
 }
 
-std::list<uint8_t> 
+std::list<uint8_t>
 RrcConnectionReconfigurationHeader::GetDrbToReleaseList () const
 {
   return m_radioResourceConfigDedicated.drbToReleaseList;
 }
 
-LteRrcSap::PhysicalConfigDedicated 
+LteRrcSap::PhysicalConfigDedicated
 RrcConnectionReconfigurationHeader::GetPhysicalConfigDedicated () const
 {
   return m_radioResourceConfigDedicated.physicalConfigDedicated;
@@ -5745,9 +6056,9 @@
   // Serialize sourceSystemInformationBlockType2
   SerializeSystemInformationBlockType2 (m_asConfig.sourceSystemInformationBlockType2);
 
-  // Serialize AntennaInfoCommon 
+  // Serialize AntennaInfoCommon
   SerializeSequence (std::bitset<0> (0),false);
-  SerializeEnum (4,0); // antennaPortsCount 
+  SerializeEnum (4,0); // antennaPortsCount
 
   // Serialize sourceDlCarrierFreq
   SerializeInteger (m_asConfig.sourceDlCarrierFreq,0,MAX_EARFCN);
@@ -6940,7 +7251,7 @@
   else if (n == 0)
     {
       // Deserialize c1
-      bIterator = DeserializeChoice (2,false,&m_messageType,bIterator);
+      bIterator = DeserializeChoice (3,false,&m_messageType,bIterator);
     }
 
   return bIterator;
@@ -6953,7 +7264,7 @@
   // Choose c1
   SerializeChoice (2,0,false);
   // Choose message type
-  SerializeChoice (2,messageType,false);
+  SerializeChoice (3,messageType,false);
 }
 
 ///////////////////  RrcDlCcchMessage //////////////////////////////////
@@ -7001,7 +7312,7 @@
   else if (n == 0)
     {
       // Deserialize c1
-      bIterator = DeserializeChoice (4,false,&m_messageType,bIterator);
+      bIterator = DeserializeChoice (5,false,&m_messageType,bIterator);
     }
 
   return bIterator;
@@ -7014,8 +7325,7 @@
   // Choose c1
   SerializeChoice (2,0,false);
   // Choose message type
-  SerializeChoice (4,messageType,false);
+  SerializeChoice (5,messageType,false);
 }
 
 } // namespace ns3
-
diff -Naru a/model/lte-rrc-header.h b/model/lte-rrc-header.h
--- a/model/lte-rrc-header.h	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rrc-header.h	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,8 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -19,6 +21,9 @@
  * Modified by:
  *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
  *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef RRC_HEADER_H
@@ -197,7 +202,7 @@
    * \param thresholdEutra LteRrcSap::ThresholdEutra
    */
   void SerializeThresholdEutra (LteRrcSap::ThresholdEutra thresholdEutra) const;
-  
+
   // Deserialization functions
   /**
    * Deserialize DRB to add mod list function
@@ -449,7 +454,7 @@
   RrcUlCcchMessage ();
   ~RrcUlCcchMessage ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
   void PreSerialize () const;
@@ -480,7 +485,7 @@
   RrcDlCcchMessage ();
   ~RrcDlCcchMessage ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
   void PreSerialize () const;
@@ -515,7 +520,7 @@
    * \return the object TypeId
    */
   static TypeId GetTypeId (void);
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -544,6 +549,8 @@
    */
   std::bitset<32> GetMtmsi () const;
 
+  std::bitset<1> GetIsMc () const;
+
 private:
   std::bitset<8> m_mmec; ///< MMEC
   std::bitset<32> m_mTmsi; ///< TMSI
@@ -556,6 +563,77 @@
   std::bitset<1> m_spare; ///< spare bit
 };
 
+class RrcConnectToMmWaveHeader : public RrcDlCcchMessage
+{
+public:
+  RrcConnectToMmWaveHeader();
+  ~RrcConnectToMmWaveHeader();
+
+  // Inherited from RrcAsn1Header
+  static TypeId GetTypeId (void);
+  void PreSerialize () const;
+  uint32_t Deserialize (Buffer::Iterator bIterator);
+  void Print (std::ostream &os) const;
+
+/**
+//TODO doc
+*/
+void SetMessage (uint16_t mmWaveId);
+
+uint16_t GetMessage () const;
+
+private:
+std::bitset<16> m_mmWaveId;
+};
+
+class RrcNotifySecondaryConnectedHeader : public RrcUlDcchMessage
+{
+public:
+RrcNotifySecondaryConnectedHeader();
+~RrcNotifySecondaryConnectedHeader();
+
+// Inherited from RrcAsn1Header
+static TypeId GetTypeId (void);
+void PreSerialize () const;
+uint32_t Deserialize (Buffer::Iterator bIterator);
+void Print (std::ostream &os) const;
+
+/**
+//TODO doc
+*/
+void SetMessage (uint16_t mmWaveId, uint16_t mmWaveRnti);
+
+std::pair<uint16_t, uint16_t> GetMessage () const;
+
+private:
+std::bitset<16> m_mmWaveId;
+std::bitset<16> m_mmWaveRnti;
+};
+
+class RrcConnectionSwitchHeader : public RrcDlDcchMessage
+{
+public:
+RrcConnectionSwitchHeader();
+~RrcConnectionSwitchHeader();
+
+// Inherited from RrcAsn1Header
+static TypeId GetTypeId (void);
+void PreSerialize () const;
+uint32_t Deserialize (Buffer::Iterator bIterator);
+void Print (std::ostream &os) const;
+
+/**
+//TODO doc
+*/
+void SetMessage (LteRrcSap::RrcConnectionSwitch msg);
+
+LteRrcSap::RrcConnectionSwitch GetMessage () const;
+uint8_t GetRrcTransactionIdentifier () const;
+
+private:
+mutable LteRrcSap::RrcConnectionSwitch m_msg;
+};
+
 /**
 * This class manages the serialization/deserialization of RrcConnectionSetup IE
 */
@@ -565,7 +643,7 @@
   RrcConnectionSetupHeader ();
   ~RrcConnectionSetupHeader ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -592,7 +670,7 @@
   * Getter for m_radioResourceConfigDedicated
   * @return m_radioResourceConfigDedicated
   */
-  LteRrcSap::RadioResourceConfigDedicated GetRadioResourceConfigDedicated () const; 
+  LteRrcSap::RadioResourceConfigDedicated GetRadioResourceConfigDedicated () const;
 
   /**
   * Gets m_radioResourceConfigDedicated.havePhysicalConfigDedicated
@@ -638,7 +716,7 @@
   RrcConnectionSetupCompleteHeader ();
   ~RrcConnectionSetupCompleteHeader ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -675,7 +753,7 @@
   RrcConnectionReconfigurationCompleteHeader ();
   ~RrcConnectionReconfigurationCompleteHeader ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -695,7 +773,7 @@
   /**
   * Getter for m_rrcTransactionIdentifier
   * @return m_rrcTransactionIdentifier
-  */ 
+  */
   uint8_t GetRrcTransactionIdentifier () const;
 
 private:
@@ -712,7 +790,7 @@
   RrcConnectionReconfigurationHeader ();
   ~RrcConnectionReconfigurationHeader ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -720,14 +798,14 @@
   /**
   * Receives a RrcConnectionReconfiguration IE and stores the contents into the class attributes
   * @param msg The information element to parse
-  */ 
+  */
   void SetMessage (LteRrcSap::RrcConnectionReconfiguration msg);
 
   /**
   * Returns a RrcConnectionReconfiguration IE from the values in the class attributes
   * @return A RrcConnectionReconfiguration, as defined in LteRrcSap
   */
-  LteRrcSap::RrcConnectionReconfiguration GetMessage () const; 
+  LteRrcSap::RrcConnectionReconfiguration GetMessage () const;
 
   /**
   * Getter for m_haveMeasConfig
@@ -775,7 +853,7 @@
   * Getter for m_radioResourceConfigDedicated
   * @return m_radioResourceConfigDedicated
   */
-  LteRrcSap::RadioResourceConfigDedicated GetRadioResourceConfigDedicated () const; 
+  LteRrcSap::RadioResourceConfigDedicated GetRadioResourceConfigDedicated () const;
 
   /**
   * Getter for m_haveNonCriticalExtension
@@ -787,7 +865,7 @@
   * Getter for m_nonCriticalExtension
   * @return m_nonCriticalExtension
   */
-  LteRrcSap::NonCriticalExtensionConfiguration GetNonCriticalExtensionConfig ();  
+  LteRrcSap::NonCriticalExtensionConfiguration GetNonCriticalExtensionConfig ();
 
   /**
   * Gets m_radioResourceConfigDedicated.havePhysicalConfigDedicated
@@ -839,7 +917,7 @@
 public:
   HandoverPreparationInfoHeader ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -847,7 +925,7 @@
   /**
   * Receives a HandoverPreparationInfo IE and stores the contents into the class attributes
   * @param msg The information element to parse
-  */ 
+  */
   void SetMessage (LteRrcSap::HandoverPreparationInfo msg);
 
   /**
@@ -859,7 +937,7 @@
   /**
   * Getter for m_asConfig
   * @return m_asConfig
-  */ 
+  */
   LteRrcSap::AsConfig GetAsConfig () const;
 
 private:
@@ -875,7 +953,7 @@
   RrcConnectionReestablishmentRequestHeader ();
   ~RrcConnectionReestablishmentRequestHeader ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -883,7 +961,7 @@
   /**
   * Receives a RrcConnectionReestablishmentRequest IE and stores the contents into the class attributes
   * @param msg The information element to parse
-  */ 
+  */
   void SetMessage (LteRrcSap::RrcConnectionReestablishmentRequest msg);
 
   /**
@@ -918,7 +996,7 @@
   RrcConnectionReestablishmentHeader ();
   ~RrcConnectionReestablishmentHeader ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -926,7 +1004,7 @@
   /**
   * Receives a RrcConnectionReestablishment IE and stores the contents into the class attributes
   * @param msg The information element to parse
-  */ 
+  */
   void SetMessage (LteRrcSap::RrcConnectionReestablishment msg);
 
   /**
@@ -960,7 +1038,7 @@
 public:
   RrcConnectionReestablishmentCompleteHeader ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -968,7 +1046,7 @@
   /**
   * Receives a RrcConnectionReestablishmentComplete IE and stores the contents into the class attributes
   * @param msg The information element to parse
-  */ 
+  */
   void SetMessage (LteRrcSap::RrcConnectionReestablishmentComplete msg);
 
   /**
@@ -996,7 +1074,7 @@
   RrcConnectionReestablishmentRejectHeader ();
   ~RrcConnectionReestablishmentRejectHeader ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -1004,7 +1082,7 @@
   /**
   * Receives a RrcConnectionReestablishmentReject IE and stores the contents into the class attributes
   * @param msg The information element to parse
-  */ 
+  */
   void SetMessage (LteRrcSap::RrcConnectionReestablishmentReject msg);
 
   /**
@@ -1026,7 +1104,7 @@
   RrcConnectionReleaseHeader ();
   ~RrcConnectionReleaseHeader ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -1034,7 +1112,7 @@
   /**
   * Receives a RrcConnectionRelease IE and stores the contents into the class attributes
   * @param msg The information element to parse
-  */ 
+  */
   void SetMessage (LteRrcSap::RrcConnectionRelease msg);
 
   /**
@@ -1056,7 +1134,7 @@
   RrcConnectionRejectHeader ();
   ~RrcConnectionRejectHeader ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -1064,7 +1142,7 @@
   /**
   * Receives a RrcConnectionReject IE and stores the contents into the class attributes
   * @param msg The information element to parse
-  */ 
+  */
   void SetMessage (LteRrcSap::RrcConnectionReject msg);
 
   /**
@@ -1086,7 +1164,7 @@
   MeasurementReportHeader ();
   ~MeasurementReportHeader ();
 
-  // Inherited from RrcAsn1Header 
+  // Inherited from RrcAsn1Header
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -1111,4 +1189,3 @@
 } // namespace ns3
 
 #endif // RRC_HEADER_H
-
diff -Naru a/model/lte-rrc-protocol-ideal.cc b/model/lte-rrc-protocol-ideal.cc
--- a/model/lte-rrc-protocol-ideal.cc	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rrc-protocol-ideal.cc	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/fatal-error.h>
@@ -35,13 +39,7 @@
 
 NS_LOG_COMPONENT_DEFINE ("LteRrcProtocolIdeal");
 
-/**
- * \ingroup lte
- *
- */
-
-/// RRC ideal message delay
-static const Time RRC_IDEAL_MSG_DELAY = MilliSeconds (0);
+static const Time RRC_IDEAL_MSG_DELAY = MicroSeconds (500);
 
 NS_OBJECT_ENSURE_REGISTERED (LteUeRrcProtocolIdeal);
 
@@ -75,117 +73,128 @@
   return tid;
 }
 
-void 
+void
 LteUeRrcProtocolIdeal::SetLteUeRrcSapProvider (LteUeRrcSapProvider* p)
 {
   m_ueRrcSapProvider = p;
 }
 
-LteUeRrcSapUser* 
+LteUeRrcSapUser*
 LteUeRrcProtocolIdeal::GetLteUeRrcSapUser ()
 {
   return m_ueRrcSapUser;
 }
 
-void 
+void
 LteUeRrcProtocolIdeal::SetUeRrc (Ptr<LteUeRrc> rrc)
 {
   m_rrc = rrc;
 }
 
-void 
+void
 LteUeRrcProtocolIdeal::DoSetup (LteUeRrcSapUser::SetupParameters params)
 {
   NS_LOG_FUNCTION (this);
   // We don't care about SRB0/SRB1 since we use ideal RRC messages.
 }
 
-void 
+void
 LteUeRrcProtocolIdeal::DoSendRrcConnectionRequest (LteRrcSap::RrcConnectionRequest msg)
 {
   // initialize the RNTI and get the EnbLteRrcSapProvider for the
   // eNB we are currently attached to
   m_rnti = m_rrc->GetRnti ();
   SetEnbRrcSapProvider ();
-    
-  Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+
+  Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
                        &LteEnbRrcSapProvider::RecvRrcConnectionRequest,
                        m_enbRrcSapProvider,
-                       m_rnti, 
+                       m_rnti,
                        msg);
 }
 
-void 
+void
 LteUeRrcProtocolIdeal::DoSendRrcConnectionSetupCompleted (LteRrcSap::RrcConnectionSetupCompleted msg)
 {
-  Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+  Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
 		       &LteEnbRrcSapProvider::RecvRrcConnectionSetupCompleted,
                        m_enbRrcSapProvider,
-		       m_rnti, 
+		       m_rnti,
 		       msg);
 }
 
-void 
+void
 LteUeRrcProtocolIdeal::DoSendRrcConnectionReconfigurationCompleted (LteRrcSap::RrcConnectionReconfigurationCompleted msg)
 {
   // re-initialize the RNTI and get the EnbLteRrcSapProvider for the
   // eNB we are currently attached to
   m_rnti = m_rrc->GetRnti ();
   SetEnbRrcSapProvider ();
-    
-   Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+
+   Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
                         &LteEnbRrcSapProvider::RecvRrcConnectionReconfigurationCompleted,
                         m_enbRrcSapProvider,
-                        m_rnti, 
+                        m_rnti,
                         msg);
 }
 
-void 
+void
 LteUeRrcProtocolIdeal::DoSendRrcConnectionReestablishmentRequest (LteRrcSap::RrcConnectionReestablishmentRequest msg)
 {
-   Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+   Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
 		       &LteEnbRrcSapProvider::RecvRrcConnectionReestablishmentRequest,
                        m_enbRrcSapProvider,
-		       m_rnti, 
+		       m_rnti,
                         msg);
 }
 
-void 
+void
 LteUeRrcProtocolIdeal::DoSendRrcConnectionReestablishmentComplete (LteRrcSap::RrcConnectionReestablishmentComplete msg)
 {
-   Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+   Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
 		       &LteEnbRrcSapProvider::RecvRrcConnectionReestablishmentComplete,
                        m_enbRrcSapProvider,
-		       m_rnti, 
+		       m_rnti,
 msg);
 }
 
-void 
+void
 LteUeRrcProtocolIdeal::DoSendMeasurementReport (LteRrcSap::MeasurementReport msg)
 {
-   Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+   Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
                         &LteEnbRrcSapProvider::RecvMeasurementReport,
                         m_enbRrcSapProvider,
-                        m_rnti, 
+                        m_rnti,
                         msg);
 }
 
-void 
+void
+LteUeRrcProtocolIdeal::DoSendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+   Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
+                        &LteEnbRrcSapProvider::RecvRrcSecondaryCellInitialAccessSuccessful,
+                        m_enbRrcSapProvider,
+                        m_rnti,
+                        mmWaveRnti,
+                        mmWaveCellId);
+}
+
+void
 LteUeRrcProtocolIdeal::SetEnbRrcSapProvider ()
 {
-  uint16_t cellId = m_rrc->GetCellId ();  
+uint16_t cellId = m_rrc->GetCellId ();
 
   // walk list of all nodes to get the peer eNB
   Ptr<LteEnbNetDevice> enbDev;
   NodeList::Iterator listEnd = NodeList::End ();
   bool found = false;
-  for (NodeList::Iterator i = NodeList::Begin (); 
-       (i != listEnd) && (!found); 
+  for (NodeList::Iterator i = NodeList::Begin ();
+       (i != listEnd) && (!found);
        ++i)
     {
       Ptr<Node> node = *i;
       int nDevs = node->GetNDevices ();
-      for (int j = 0; 
+      for (int j = 0;
            (j < nDevs) && (!found);
            j++)
         {
@@ -198,16 +207,17 @@
             {
               if (enbDev->HasCellId (cellId))
                 {
-                  found = true;          
+                  found = true;
                   break;
                 }
             }
         }
     }
   NS_ASSERT_MSG (found, " Unable to find eNB with CellId =" << cellId);
-  m_enbRrcSapProvider = enbDev->GetRrc ()->GetLteEnbRrcSapProvider ();  
+  m_enbRrcSapProvider = enbDev->GetRrc ()->GetLteEnbRrcSapProvider ();
   Ptr<LteEnbRrcProtocolIdeal> enbRrcProtocolIdeal = enbDev->GetRrc ()->GetObject<LteEnbRrcProtocolIdeal> ();
   enbRrcProtocolIdeal->SetUeRrcSapProvider (m_rnti, m_ueRrcSapProvider);
+
 }
 
 
@@ -229,7 +239,7 @@
 LteEnbRrcProtocolIdeal::DoDispose ()
 {
   NS_LOG_FUNCTION (this);
-  delete m_enbRrcSapUser;  
+  delete m_enbRrcSapUser;
 }
 
 TypeId
@@ -243,25 +253,25 @@
   return tid;
 }
 
-void 
+void
 LteEnbRrcProtocolIdeal::SetLteEnbRrcSapProvider (LteEnbRrcSapProvider* p)
 {
   m_enbRrcSapProvider = p;
 }
 
-LteEnbRrcSapUser* 
+LteEnbRrcSapUser*
 LteEnbRrcProtocolIdeal::GetLteEnbRrcSapUser ()
 {
   return m_enbRrcSapUser;
 }
 
-void 
+void
 LteEnbRrcProtocolIdeal::SetCellId (uint16_t cellId)
 {
   m_cellId = cellId;
 }
 
-LteUeRrcSapProvider* 
+LteUeRrcSapProvider*
 LteEnbRrcProtocolIdeal::GetUeRrcSapProvider (uint16_t rnti)
 {
   std::map<uint16_t, LteUeRrcSapProvider*>::const_iterator it;
@@ -270,7 +280,7 @@
   return it->second;
 }
 
-void 
+void
 LteEnbRrcProtocolIdeal::SetUeRrcSapProvider (uint16_t rnti, LteUeRrcSapProvider* p)
 {
   std::map<uint16_t, LteUeRrcSapProvider*>::iterator it;
@@ -279,7 +289,7 @@
   it->second = p;
 }
 
-void 
+void
 LteEnbRrcProtocolIdeal::DoSetupUe (uint16_t rnti, LteEnbRrcSapUser::SetupUeParameters params)
 {
   NS_LOG_FUNCTION (this << rnti);
@@ -303,7 +313,7 @@
   //           {
   //             ueRrc = ueDev->GetRrc ();
   //             if ((ueRrc->GetRnti () == rnti) && (ueRrc->GetCellId () == m_cellId))
-  //               {                 
+  //               {
   //       	  found = true;
   //       	  break;
   //               }
@@ -316,19 +326,19 @@
 
   // just create empty entry, the UeRrcSapProvider will be set by the
   // ue upon connection request or connection reconfiguration
-  // completed 
+  // completed
   m_enbRrcSapProviderMap[rnti] = 0;
 
 }
 
-void 
+void
 LteEnbRrcProtocolIdeal::DoRemoveUe (uint16_t rnti)
 {
   NS_LOG_FUNCTION (this << rnti);
   m_enbRrcSapProviderMap.erase (rnti);
 }
 
-void 
+void
 LteEnbRrcProtocolIdeal::DoSendSystemInformation (uint16_t cellId, LteRrcSap::SystemInformation msg)
 {
   NS_LOG_FUNCTION (this << cellId);
@@ -343,76 +353,94 @@
           Ptr<LteUeNetDevice> ueDev = node->GetDevice (j)->GetObject <LteUeNetDevice> ();
           if (ueDev != 0)
             {
-              Ptr<LteUeRrc> ueRrc = ueDev->GetRrc ();              
+              Ptr<LteUeRrc> ueRrc = ueDev->GetRrc ();
               NS_LOG_LOGIC ("considering UE IMSI " << ueDev->GetImsi () << " that has cellId " << ueRrc->GetCellId ());
               if (ueRrc->GetCellId () == cellId)
-                {       
+                {
                   NS_LOG_LOGIC ("sending SI to IMSI " << ueDev->GetImsi ());
                   ueRrc->GetLteUeRrcSapProvider ()->RecvSystemInformation (msg);
-                  Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+                  Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
                                        &LteUeRrcSapProvider::RecvSystemInformation,
-                                       ueRrc->GetLteUeRrcSapProvider (), 
-                                       msg);          
-                }             
+                                       ueRrc->GetLteUeRrcSapProvider (),
+                                       msg);
+                }
             }
         }
-    } 
+    }
 }
 
-void 
+void
 LteEnbRrcProtocolIdeal::DoSendRrcConnectionSetup (uint16_t rnti, LteRrcSap::RrcConnectionSetup msg)
 {
-  Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+  Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
 		       &LteUeRrcSapProvider::RecvRrcConnectionSetup,
-		       GetUeRrcSapProvider (rnti), 
+		       GetUeRrcSapProvider (rnti),
 		       msg);
 }
 
-void 
+void
 LteEnbRrcProtocolIdeal::DoSendRrcConnectionReconfiguration (uint16_t rnti, LteRrcSap::RrcConnectionReconfiguration msg)
 {
-  Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+  Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
 		       &LteUeRrcSapProvider::RecvRrcConnectionReconfiguration,
-		       GetUeRrcSapProvider (rnti), 
+		       GetUeRrcSapProvider (rnti),
 		       msg);
 }
 
-void 
+void
 LteEnbRrcProtocolIdeal::DoSendRrcConnectionReestablishment (uint16_t rnti, LteRrcSap::RrcConnectionReestablishment msg)
 {
-  Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+  Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
 		       &LteUeRrcSapProvider::RecvRrcConnectionReestablishment,
-		       GetUeRrcSapProvider (rnti), 
+		       GetUeRrcSapProvider (rnti),
 		       msg);
 }
 
-void 
+void
 LteEnbRrcProtocolIdeal::DoSendRrcConnectionReestablishmentReject (uint16_t rnti, LteRrcSap::RrcConnectionReestablishmentReject msg)
 {
-  Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+  Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
 		       &LteUeRrcSapProvider::RecvRrcConnectionReestablishmentReject,
-		       GetUeRrcSapProvider (rnti), 
+		       GetUeRrcSapProvider (rnti),
 		       msg);
 }
 
-void 
+void
 LteEnbRrcProtocolIdeal::DoSendRrcConnectionRelease (uint16_t rnti, LteRrcSap::RrcConnectionRelease msg)
 {
-  Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+  Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
 		       &LteUeRrcSapProvider::RecvRrcConnectionRelease,
-		       GetUeRrcSapProvider (rnti), 
+		       GetUeRrcSapProvider (rnti),
 		       msg);
 }
 
-void 
+void
 LteEnbRrcProtocolIdeal::DoSendRrcConnectionReject (uint16_t rnti, LteRrcSap::RrcConnectionReject msg)
 {
-  Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+  Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
 		       &LteUeRrcSapProvider::RecvRrcConnectionReject,
-		       GetUeRrcSapProvider (rnti), 
+		       GetUeRrcSapProvider (rnti),
 		       msg);
 }
 
+void
+LteEnbRrcProtocolIdeal::DoSendRrcConnectionSwitch (uint16_t rnti, LteRrcSap::RrcConnectionSwitch msg)
+{
+  Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
+           &LteUeRrcSapProvider::RecvRrcConnectionSwitch,
+           GetUeRrcSapProvider (rnti),
+           msg);
+}
+
+void
+LteEnbRrcProtocolIdeal::DoSendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveCellId)
+{
+  Simulator::Schedule (RRC_IDEAL_MSG_DELAY,
+           &LteUeRrcSapProvider::RecvRrcConnectToMmWave,
+           GetUeRrcSapProvider (rnti),
+           mmWaveCellId);
+}
+
 /*
  * The purpose of LteEnbRrcProtocolIdeal is to avoid encoding
  * messages. In order to do so, we need to have some form of encoding for
@@ -422,36 +450,22 @@
  * purpose of LteEnbRrcProtocolIdeal. The workaround is to store the
  * actual message in a global map, so that then we can just encode the
  * key in a header and send that between eNBs over X2.
- * 
+ *
  */
 
-static std::map<uint32_t, LteRrcSap::HandoverPreparationInfo> g_handoverPreparationInfoMsgMap; ///< handover preparation info message map
-static uint32_t g_handoverPreparationInfoMsgIdCounter = 0; ///< handover preparation info message ID counter
+static std::map<uint32_t, LteRrcSap::HandoverPreparationInfo> g_handoverPreparationInfoMsgMap;
+static uint32_t g_handoverPreparationInfoMsgIdCounter = 0;
 
-/**
+/*
  * This header encodes the map key discussed above. We keep this
  * private since it should not be used outside this file.
- * 
+ *
  */
 class IdealHandoverPreparationInfoHeader : public Header
 {
 public:
-  /**
-   * Get the message ID function
-   *
-   * \returns the message ID
-   */
   uint32_t GetMsgId ();
-  /**
-   * Set the message ID function
-   *
-   * \param id the message ID 
-   */
   void SetMsgId (uint32_t id);
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   virtual void Print (std::ostream &os) const;
@@ -460,20 +474,20 @@
   virtual uint32_t Deserialize (Buffer::Iterator start);
 
 private:
-  uint32_t m_msgId; ///< message ID
+  uint32_t m_msgId;
 };
 
-uint32_t 
+uint32_t
 IdealHandoverPreparationInfoHeader::GetMsgId ()
 {
   return m_msgId;
-}  
+}
 
-void 
+void
 IdealHandoverPreparationInfoHeader::SetMsgId (uint32_t id)
 {
   m_msgId = id;
-}  
+}
 
 
 TypeId
@@ -504,7 +518,7 @@
 }
 
 void IdealHandoverPreparationInfoHeader::Serialize (Buffer::Iterator start) const
-{  
+{
   start.WriteU32 (m_msgId);
 }
 
@@ -516,7 +530,7 @@
 
 
 
-Ptr<Packet> 
+Ptr<Packet>
 LteEnbRrcProtocolIdeal::DoEncodeHandoverPreparationInformation (LteRrcSap::HandoverPreparationInfo msg)
 {
   uint32_t msgId = ++g_handoverPreparationInfoMsgIdCounter;
@@ -530,7 +544,7 @@
   return p;
 }
 
-LteRrcSap::HandoverPreparationInfo 
+LteRrcSap::HandoverPreparationInfo
 LteEnbRrcProtocolIdeal::DoDecodeHandoverPreparationInformation (Ptr<Packet> p)
 {
   IdealHandoverPreparationInfoHeader h;
@@ -546,33 +560,19 @@
 
 
 
-static std::map<uint32_t, LteRrcSap::RrcConnectionReconfiguration> g_handoverCommandMsgMap; ///< handover command message map
-static uint32_t g_handoverCommandMsgIdCounter = 0; ///< handover command message ID counter
+static std::map<uint32_t, LteRrcSap::RrcConnectionReconfiguration> g_handoverCommandMsgMap;
+static uint32_t g_handoverCommandMsgIdCounter = 0;
 
-/**
+/*
  * This header encodes the map key discussed above. We keep this
  * private since it should not be used outside this file.
- * 
+ *
  */
 class IdealHandoverCommandHeader : public Header
 {
 public:
-  /**
-   * Get the message ID function
-   *
-   * \returns the message ID
-   */
   uint32_t GetMsgId ();
-  /**
-   * Set the message ID function
-   *
-   * \param id the message ID
-   */
   void SetMsgId (uint32_t id);
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   virtual void Print (std::ostream &os) const;
@@ -581,20 +581,20 @@
   virtual uint32_t Deserialize (Buffer::Iterator start);
 
 private:
-  uint32_t m_msgId; ///< message ID
+  uint32_t m_msgId;
 };
 
-uint32_t 
+uint32_t
 IdealHandoverCommandHeader::GetMsgId ()
 {
   return m_msgId;
-}  
+}
 
-void 
+void
 IdealHandoverCommandHeader::SetMsgId (uint32_t id)
 {
   m_msgId = id;
-}  
+}
 
 
 TypeId
@@ -625,7 +625,7 @@
 }
 
 void IdealHandoverCommandHeader::Serialize (Buffer::Iterator start) const
-{  
+{
   start.WriteU32 (m_msgId);
 }
 
@@ -637,7 +637,7 @@
 
 
 
-Ptr<Packet> 
+Ptr<Packet>
 LteEnbRrcProtocolIdeal::DoEncodeHandoverCommand (LteRrcSap::RrcConnectionReconfiguration msg)
 {
   uint32_t msgId = ++g_handoverCommandMsgIdCounter;
diff -Naru a/model/lte-rrc-protocol-ideal.h b/model/lte-rrc-protocol-ideal.h
--- a/model/lte-rrc-protocol-ideal.h	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rrc-protocol-ideal.h	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -42,8 +46,8 @@
  *
  * Models the transmission of RRC messages from the UE to the eNB in
  * an ideal fashion, without errors and without consuming any radio
- * resources. 
- * 
+ * resources.
+ *
  */
 class LteUeRrcProtocolIdeal : public Object
 {
@@ -75,14 +79,14 @@
    * \returns LTE UE RRC SAP user
    */
   LteUeRrcSapUser* GetLteUeRrcSapUser ();
-  
+
   /**
    * Set LTE UE RRC  function
    *
-   * \param rrc LTE UE RRC 
+   * \param rrc LTE UE RRC
    */
   void SetUeRrc (Ptr<LteUeRrc> rrc);
-  
+
 
 private:
 
@@ -90,45 +94,46 @@
   /**
    * Setup function
    *
-   * \param params LteUeRrcSapUser::SetupParameters 
+   * \param params LteUeRrcSapUser::SetupParameters
    */
   void DoSetup (LteUeRrcSapUser::SetupParameters params);
   /**
    * Send RRC connection request function
    *
-   * \param msg LteRrcSap::RrcConnectionRequest 
+   * \param msg LteRrcSap::RrcConnectionRequest
    */
   void DoSendRrcConnectionRequest (LteRrcSap::RrcConnectionRequest msg);
   /**
    * Send RRC connection setup completed function
    *
-   * \param msg LteRrcSap::RrcConnectionSetupCompleted 
+   * \param msg LteRrcSap::RrcConnectionSetupCompleted
    */
   void DoSendRrcConnectionSetupCompleted (LteRrcSap::RrcConnectionSetupCompleted msg);
   /**
    * Send RRC connection reconfiguration completed function
    *
-   * \param msg LteRrcSap::RrcConnectionReconfigurationCompleted 
+   * \param msg LteRrcSap::RrcConnectionReconfigurationCompleted
    */
   void DoSendRrcConnectionReconfigurationCompleted (LteRrcSap::RrcConnectionReconfigurationCompleted msg);
   /**
    * Send RRC connection reestablishment request function
    *
-   * \param msg LteRrcSap::RrcConnectionReestablishmentRequest 
+   * \param msg LteRrcSap::RrcConnectionReestablishmentRequest
    */
   void DoSendRrcConnectionReestablishmentRequest (LteRrcSap::RrcConnectionReestablishmentRequest msg);
   /**
    * Send RRC connection reestablishment complete function
    *
-   * \param msg LteRrcSap::RrcConnectionReestablishmentRequest 
+   * \param msg LteRrcSap::RrcConnectionReestablishmentRequest
    */
   void DoSendRrcConnectionReestablishmentComplete (LteRrcSap::RrcConnectionReestablishmentComplete msg);
   /**
    * Send measurement report function
    *
-   * \param msg LteRrcSap::MeasurementReport 
+   * \param msg LteRrcSap::MeasurementReport
    */
   void DoSendMeasurementReport (LteRrcSap::MeasurementReport msg);
+  void DoSendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId);
 
   /// Set ENB RRC SAP provider
   void SetEnbRrcSapProvider ();
@@ -138,15 +143,15 @@
   LteUeRrcSapProvider* m_ueRrcSapProvider; ///< the UE RRC SAP provider
   LteUeRrcSapUser* m_ueRrcSapUser; ///< the RRC SAP user
   LteEnbRrcSapProvider* m_enbRrcSapProvider; ///< the ENB RRC SAP provider
-  
+
 };
 
 
 /**
  * Models the transmission of RRC messages from the UE to the eNB in
  * an ideal fashion, without errors and without consuming any radio
- * resources. 
- * 
+ * resources.
+ *
  */
 class LteEnbRrcProtocolIdeal : public Object
 {
@@ -169,7 +174,7 @@
   /**
    * Set LTE ENB RRC SAP provider function
    *
-   * \param p the LTE ENB RRC SAP provider 
+   * \param p the LTE ENB RRC SAP provider
    */
   void SetLteEnbRrcSapProvider (LteEnbRrcSapProvider* p);
   /**
@@ -182,7 +187,7 @@
   /**
    * Set the cell ID function
    *
-   * \param cellId the cell ID 
+   * \param cellId the cell ID
    */
   void SetCellId (uint16_t cellId);
 
@@ -197,7 +202,7 @@
    * Set UE RRC SAP provider function
    *
    * \param rnti the RNTI
-   * \param p the UE RRC SAP provider 
+   * \param p the UE RRC SAP provider
    */
   void SetUeRrcSapProvider (uint16_t rnti, LteUeRrcSapProvider* p);
 
@@ -208,7 +213,7 @@
    * Setup UE function
    *
    * \param rnti the RNTI
-   * \param params LteEnbRrcSapUser::SetupUeParameters 
+   * \param params LteEnbRrcSapUser::SetupUeParameters
    */
   void DoSetupUe (uint16_t rnti, LteEnbRrcSapUser::SetupUeParameters params);
   /**
@@ -272,6 +277,8 @@
    * \param msg LteRrcSap::RrcConnectionReject
    */
   void DoSendRrcConnectionReject (uint16_t rnti, LteRrcSap::RrcConnectionReject msg);
+  void DoSendRrcConnectionSwitch (uint16_t rnti, LteRrcSap::RrcConnectionSwitch msg);
+  void DoSendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveCellId);
   /**
    * Encode handover preparation information function
    *
@@ -307,7 +314,7 @@
   LteEnbRrcSapProvider* m_enbRrcSapProvider; ///< the ENB RRC SAP provider
   LteEnbRrcSapUser* m_enbRrcSapUser; ///< the ENB RRC SAP user
   std::map<uint16_t, LteUeRrcSapProvider*> m_enbRrcSapProviderMap; ///< the LTE UE RRC SAP provider
-  
+
 };
 
 
diff -Naru a/model/lte-rrc-protocol-real.cc b/model/lte-rrc-protocol-real.cc
--- a/model/lte-rrc-protocol-real.cc	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rrc-protocol-real.cc	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Authors: Nicola Baldo <nbaldo@cttc.es>
  *          Lluis Parcerisa <lparcerisa@cttc.cat>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/fatal-error.h>
@@ -36,8 +40,7 @@
 
 NS_LOG_COMPONENT_DEFINE ("LteRrcProtocolReal");
 
-/// RRC real message delay
-const Time RRC_REAL_MSG_DELAY = MilliSeconds (0); 
+const Time RRC_REAL_MSG_DELAY = MicroSeconds (500);
 
 NS_OBJECT_ENSURE_REGISTERED (LteUeRrcProtocolReal);
 
@@ -47,7 +50,7 @@
 {
   m_ueRrcSapUser = new MemberLteUeRrcSapUser<LteUeRrcProtocolReal> (this);
   m_completeSetupParameters.srb0SapUser = new LteRlcSpecificLteRlcSapUser<LteUeRrcProtocolReal> (this);
-  m_completeSetupParameters.srb1SapUser = new LtePdcpSpecificLtePdcpSapUser<LteUeRrcProtocolReal> (this);    
+  m_completeSetupParameters.srb1SapUser = new LtePdcpSpecificLtePdcpSapUser<LteUeRrcProtocolReal> (this);
 }
 
 LteUeRrcProtocolReal::~LteUeRrcProtocolReal ()
@@ -75,35 +78,35 @@
   return tid;
 }
 
-void 
+void
 LteUeRrcProtocolReal::SetLteUeRrcSapProvider (LteUeRrcSapProvider* p)
 {
   m_ueRrcSapProvider = p;
 }
 
-LteUeRrcSapUser* 
+LteUeRrcSapUser*
 LteUeRrcProtocolReal::GetLteUeRrcSapUser ()
 {
   return m_ueRrcSapUser;
 }
 
-void 
+void
 LteUeRrcProtocolReal::SetUeRrc (Ptr<LteUeRrc> rrc)
 {
   m_rrc = rrc;
 }
 
-void 
+void
 LteUeRrcProtocolReal::DoSetup (LteUeRrcSapUser::SetupParameters params)
 {
   NS_LOG_FUNCTION (this);
 
   m_setupParameters.srb0SapProvider = params.srb0SapProvider;
-  m_setupParameters.srb1SapProvider = params.srb1SapProvider; 
+  m_setupParameters.srb1SapProvider = params.srb1SapProvider;
   m_ueRrcSapProvider->CompleteSetup (m_completeSetupParameters);
 }
 
-void 
+void
 LteUeRrcProtocolReal::DoSendRrcConnectionRequest (LteRrcSap::RrcConnectionRequest msg)
 {
   // initialize the RNTI and get the EnbLteRrcSapProvider for the
@@ -111,22 +114,29 @@
   m_rnti = m_rrc->GetRnti ();
   SetEnbRrcSapProvider ();
 
-  Ptr<Packet> packet = Create<Packet> ();
-
-  RrcConnectionRequestHeader rrcConnectionRequestHeader;
-  rrcConnectionRequestHeader.SetMessage (msg);
-
-  packet->AddHeader (rrcConnectionRequestHeader);
-
-  LteRlcSapProvider::TransmitPdcpPduParameters transmitPdcpPduParameters;
-  transmitPdcpPduParameters.pdcpPdu = packet;
-  transmitPdcpPduParameters.rnti = m_rnti;
-  transmitPdcpPduParameters.lcid = 0;
+  Simulator::Schedule (RRC_REAL_MSG_DELAY,
+                       &LteEnbRrcSapProvider::RecvRrcConnectionRequest,
+                       m_enbRrcSapProvider,
+                       m_rnti,
+                       msg);
+
+  // real RRC code
+  // Ptr<Packet> packet = Create<Packet> ();
+
+  // RrcConnectionRequestHeader rrcConnectionRequestHeader;
+  // rrcConnectionRequestHeader.SetMessage (msg);
+
+  // packet->AddHeader (rrcConnectionRequestHeader);
+
+  // LteRlcSapProvider::TransmitPdcpPduParameters transmitPdcpPduParameters;
+  // transmitPdcpPduParameters.pdcpPdu = packet;
+  // transmitPdcpPduParameters.rnti = m_rnti;
+  // transmitPdcpPduParameters.lcid = 0;
 
-  m_setupParameters.srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
+  // m_setupParameters.srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
 }
 
-void 
+void
 LteUeRrcProtocolReal::DoSendRrcConnectionSetupCompleted (LteRrcSap::RrcConnectionSetupCompleted msg)
 {
   Ptr<Packet> packet = Create<Packet> ();
@@ -147,7 +157,7 @@
     }
 }
 
-void 
+void
 LteUeRrcProtocolReal::DoSendRrcConnectionReconfigurationCompleted (LteRrcSap::RrcConnectionReconfigurationCompleted msg)
 {
   // re-initialize the RNTI and get the EnbLteRrcSapProvider for the
@@ -166,11 +176,11 @@
   transmitPdcpSduParameters.pdcpSdu = packet;
   transmitPdcpSduParameters.rnti = m_rnti;
   transmitPdcpSduParameters.lcid = 1;
-
+  NS_LOG_INFO("Tx RRC Connection reconf completed");
   m_setupParameters.srb1SapProvider->TransmitPdcpSdu (transmitPdcpSduParameters);
 }
 
-void 
+void
 LteUeRrcProtocolReal::DoSendMeasurementReport (LteRrcSap::MeasurementReport msg)
 {
   // re-initialize the RNTI and get the EnbLteRrcSapProvider for the
@@ -193,7 +203,29 @@
   m_setupParameters.srb1SapProvider->TransmitPdcpSdu (transmitPdcpSduParameters);
 }
 
-void 
+void
+LteUeRrcProtocolReal::DoSendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+  m_rnti = m_rrc->GetRnti ();
+  SetEnbRrcSapProvider ();
+
+  Ptr<Packet> packet = Create<Packet> ();
+
+  RrcNotifySecondaryConnectedHeader rrcNotifyHeader;
+  rrcNotifyHeader.SetMessage (mmWaveCellId, mmWaveRnti);
+
+  packet->AddHeader (rrcNotifyHeader);
+
+  LtePdcpSapProvider::TransmitPdcpSduParameters transmitPdcpSduParameters;
+  transmitPdcpSduParameters.pdcpSdu = packet;
+  transmitPdcpSduParameters.rnti = m_rnti;
+  transmitPdcpSduParameters.lcid = 1;
+
+  m_setupParameters.srb1SapProvider->TransmitPdcpSdu (transmitPdcpSduParameters);
+}
+
+
+void
 LteUeRrcProtocolReal::DoSendRrcConnectionReestablishmentRequest (LteRrcSap::RrcConnectionReestablishmentRequest msg)
 {
   Ptr<Packet> packet = Create<Packet> ();
@@ -211,7 +243,7 @@
   m_setupParameters.srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
 }
 
-void 
+void
 LteUeRrcProtocolReal::DoSendRrcConnectionReestablishmentComplete (LteRrcSap::RrcConnectionReestablishmentComplete msg)
 {
   Ptr<Packet> packet = Create<Packet> ();
@@ -230,7 +262,7 @@
 }
 
 
-void 
+void
 LteUeRrcProtocolReal::SetEnbRrcSapProvider ()
 {
   uint16_t cellId = m_rrc->GetCellId ();
@@ -239,13 +271,13 @@
   Ptr<LteEnbNetDevice> enbDev;
   NodeList::Iterator listEnd = NodeList::End ();
   bool found = false;
-  for (NodeList::Iterator i = NodeList::Begin (); 
-       (i != listEnd) && (!found); 
+  for (NodeList::Iterator i = NodeList::Begin ();
+       (i != listEnd) && (!found);
        ++i)
     {
       Ptr<Node> node = *i;
       int nDevs = node->GetNDevices ();
-      for (int j = 0; 
+      for (int j = 0;
            (j < nDevs) && (!found);
            j++)
         {
@@ -282,6 +314,7 @@
   RrcConnectionReestablishmentRejectHeader rrcConnectionReestablishmentRejectHeader;
   RrcConnectionSetupHeader rrcConnectionSetupHeader;
   RrcConnectionRejectHeader rrcConnectionRejectHeader;
+  RrcConnectToMmWaveHeader rrcConnectToMmWaveHeader;
 
   // Declare possible messages
   LteRrcSap::RrcConnectionReestablishment rrcConnectionReestablishmentMsg;
@@ -316,6 +349,12 @@
       rrcConnectionSetupMsg = rrcConnectionSetupHeader.GetMessage ();
       m_ueRrcSapProvider->RecvRrcConnectionSetup (rrcConnectionSetupMsg);
       break;
+    case 4:
+      // RrcConnectToMmWave
+      p->RemoveHeader (rrcConnectToMmWaveHeader);
+      uint16_t mmWaveCellId = rrcConnectToMmWaveHeader.GetMessage ();
+      m_ueRrcSapProvider->RecvRrcConnectToMmWave(mmWaveCellId);
+      break;
     }
 }
 
@@ -329,11 +368,12 @@
   // Declare possible headers to receive
   RrcConnectionReconfigurationHeader rrcConnectionReconfigurationHeader;
   RrcConnectionReleaseHeader rrcConnectionReleaseHeader;
+  RrcConnectionSwitchHeader rrcSwitchHeader;
 
   // Declare possible messages to receive
   LteRrcSap::RrcConnectionReconfiguration rrcConnectionReconfigurationMsg;
   LteRrcSap::RrcConnectionRelease rrcConnectionReleaseMsg;
-
+  LteRrcSap::RrcConnectionSwitch rrcConnectionSwitchMsg;
   // Deserialize packet and call member recv function with appropriate structure
   switch ( rrcDlDcchMessage.GetMessageType () )
     {
@@ -347,6 +387,11 @@
       rrcConnectionReleaseMsg = rrcConnectionReleaseHeader.GetMessage ();
       //m_ueRrcSapProvider->RecvRrcConnectionRelease (rrcConnectionReleaseMsg);
       break;
+    case 6:
+      params.pdcpSdu->RemoveHeader (rrcSwitchHeader);
+      rrcConnectionSwitchMsg = rrcSwitchHeader.GetMessage ();
+      m_ueRrcSapProvider->RecvRrcConnectionSwitch (rrcConnectionSwitchMsg);
+      break;
     }
 }
 
@@ -369,11 +414,11 @@
 {
   NS_LOG_FUNCTION (this);
   delete m_enbRrcSapUser;
-  for (std::map<uint16_t, LteEnbRrcSapProvider::CompleteSetupUeParameters>::iterator 
+  for (std::map<uint16_t, LteEnbRrcSapProvider::CompleteSetupUeParameters>::iterator
          it = m_completeSetupUeParametersMap.begin ();
        it != m_completeSetupUeParametersMap.end ();
        ++it)
-    {     
+    {
       delete it->second.srb0SapUser;
       delete it->second.srb1SapUser;
     }
@@ -391,25 +436,25 @@
   return tid;
 }
 
-void 
+void
 LteEnbRrcProtocolReal::SetLteEnbRrcSapProvider (LteEnbRrcSapProvider* p)
 {
   m_enbRrcSapProvider = p;
 }
 
-LteEnbRrcSapUser* 
+LteEnbRrcSapUser*
 LteEnbRrcProtocolReal::GetLteEnbRrcSapUser ()
 {
   return m_enbRrcSapUser;
 }
 
-void 
+void
 LteEnbRrcProtocolReal::SetCellId (uint16_t cellId)
 {
   m_cellId = cellId;
 }
 
-LteUeRrcSapProvider* 
+LteUeRrcSapProvider*
 LteEnbRrcProtocolReal::GetUeRrcSapProvider (uint16_t rnti)
 {
   std::map<uint16_t, LteUeRrcSapProvider*>::const_iterator it;
@@ -418,7 +463,7 @@
   return it->second;
 }
 
-void 
+void
 LteEnbRrcProtocolReal::SetUeRrcSapProvider (uint16_t rnti, LteUeRrcSapProvider* p)
 {
   std::map<uint16_t, LteUeRrcSapProvider*>::iterator it;
@@ -427,7 +472,7 @@
   it->second = p;
 }
 
-void 
+void
 LteEnbRrcProtocolReal::DoSetupUe (uint16_t rnti, LteEnbRrcSapUser::SetupUeParameters params)
 {
   NS_LOG_FUNCTION (this << rnti);
@@ -463,14 +508,14 @@
 
   // just create empty entry, the UeRrcSapProvider will be set by the
   // ue upon connection request or connection reconfiguration
-  // completed 
+  // completed
   m_enbRrcSapProviderMap[rnti] = 0;
 
   // Store SetupUeParameters
   m_setupUeParametersMap[rnti] = params;
 
   LteEnbRrcSapProvider::CompleteSetupUeParameters completeSetupUeParameters;
-  std::map<uint16_t, LteEnbRrcSapProvider::CompleteSetupUeParameters>::iterator 
+  std::map<uint16_t, LteEnbRrcSapProvider::CompleteSetupUeParameters>::iterator
     csupIt = m_completeSetupUeParametersMap.find (rnti);
   if (csupIt == m_completeSetupUeParametersMap.end ())
     {
@@ -480,7 +525,7 @@
       completeSetupUeParameters.srb0SapUser = srb0SapUser;
       completeSetupUeParameters.srb1SapUser = srb1SapUser;
       // Store LteRlcSapUser, LtePdcpSapUser
-      m_completeSetupUeParametersMap[rnti] = completeSetupUeParameters;      
+      m_completeSetupUeParametersMap[rnti] = completeSetupUeParameters;
     }
   else
     {
@@ -489,11 +534,11 @@
   m_enbRrcSapProvider->CompleteSetupUe (rnti, completeSetupUeParameters);
 }
 
-void 
+void
 LteEnbRrcProtocolReal::DoRemoveUe (uint16_t rnti)
 {
   NS_LOG_FUNCTION (this << rnti);
-  std::map<uint16_t, LteEnbRrcSapProvider::CompleteSetupUeParameters>::iterator 
+  std::map<uint16_t, LteEnbRrcSapProvider::CompleteSetupUeParameters>::iterator
     it = m_completeSetupUeParametersMap.find (rnti);
   NS_ASSERT (it != m_completeSetupUeParametersMap.end ());
   delete it->second.srb0SapUser;
@@ -503,10 +548,10 @@
   m_setupUeParametersMap.erase (rnti);
 }
 
-void 
+void
 LteEnbRrcProtocolReal::DoSendSystemInformation (uint16_t cellId, LteRrcSap::SystemInformation msg)
 {
-  NS_LOG_FUNCTION (this << cellId);
+    NS_LOG_FUNCTION (this << cellId);
   // walk list of all nodes to get UEs with this cellId
   Ptr<LteUeRrc> ueRrc;
   for (NodeList::Iterator i = NodeList::Begin (); i != NodeList::End (); ++i)
@@ -524,17 +569,17 @@
                 {
                   NS_LOG_LOGIC ("sending SI to IMSI " << ueDev->GetImsi ());
                   ueRrc->GetLteUeRrcSapProvider ()->RecvSystemInformation (msg);
-                  Simulator::Schedule (RRC_REAL_MSG_DELAY, 
+                  Simulator::Schedule (RRC_REAL_MSG_DELAY,
                                        &LteUeRrcSapProvider::RecvSystemInformation,
-                                       ueRrc->GetLteUeRrcSapProvider (), 
+                                       ueRrc->GetLteUeRrcSapProvider (),
                                        msg);
                 }
             }
         }
-    } 
+    }
 }
 
-void 
+void
 LteEnbRrcProtocolReal::DoSendRrcConnectionSetup (uint16_t rnti, LteRrcSap::RrcConnectionSetup msg)
 {
   Ptr<Packet> packet = Create<Packet> ();
@@ -549,10 +594,18 @@
   transmitPdcpPduParameters.rnti = rnti;
   transmitPdcpPduParameters.lcid = 0;
 
-  m_setupUeParametersMap.at (rnti).srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
+  if (m_setupUeParametersMap.find (rnti) == m_setupUeParametersMap.end () )
+    {
+      NS_LOG_ERROR("RNTI not found in Enb setup parameters Map!");
+    }
+  else
+    {
+      NS_LOG_INFO("Queue RRC connection setup " << packet << " rnti " << rnti << " cellId " << m_cellId);
+      m_setupUeParametersMap[rnti].srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
+    }
 }
 
-void 
+void
 LteEnbRrcProtocolReal::DoSendRrcConnectionReject (uint16_t rnti, LteRrcSap::RrcConnectionReject msg)
 {
   Ptr<Packet> packet = Create<Packet> ();
@@ -570,7 +623,44 @@
   m_setupUeParametersMap[rnti].srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
 }
 
-void 
+
+void
+LteEnbRrcProtocolReal::DoSendRrcConnectionSwitch (uint16_t rnti, LteRrcSap::RrcConnectionSwitch msg)
+{
+  Ptr<Packet> packet = Create<Packet> ();
+
+  RrcConnectionSwitchHeader rrcSwitchHeader;
+  rrcSwitchHeader.SetMessage (msg);
+
+  packet->AddHeader (rrcSwitchHeader);
+
+  LtePdcpSapProvider::TransmitPdcpSduParameters transmitPdcpSduParameters;
+  transmitPdcpSduParameters.pdcpSdu = packet;
+  transmitPdcpSduParameters.rnti = rnti;
+  transmitPdcpSduParameters.lcid = 1;
+
+  m_setupUeParametersMap[rnti].srb1SapProvider->TransmitPdcpSdu (transmitPdcpSduParameters);
+}
+
+void
+LteEnbRrcProtocolReal::DoSendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveId)
+{
+  Ptr<Packet> packet = Create<Packet> ();
+
+  RrcConnectToMmWaveHeader connectToMmWaveHeader;
+  connectToMmWaveHeader.SetMessage(mmWaveId);
+
+  packet->AddHeader (connectToMmWaveHeader);
+
+  LteRlcSapProvider::TransmitPdcpPduParameters transmitPdcpPduParameters;
+  transmitPdcpPduParameters.pdcpPdu = packet;
+  transmitPdcpPduParameters.rnti = rnti;
+  transmitPdcpPduParameters.lcid = 0;
+
+  m_setupUeParametersMap[rnti].srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
+}
+
+void
 LteEnbRrcProtocolReal::DoSendRrcConnectionReconfiguration (uint16_t rnti, LteRrcSap::RrcConnectionReconfiguration msg)
 {
   Ptr<Packet> packet = Create<Packet> ();
@@ -588,7 +678,7 @@
   m_setupUeParametersMap[rnti].srb1SapProvider->TransmitPdcpSdu (transmitPdcpSduParameters);
 }
 
-void 
+void
 LteEnbRrcProtocolReal::DoSendRrcConnectionReestablishment (uint16_t rnti, LteRrcSap::RrcConnectionReestablishment msg)
 {
   Ptr<Packet> packet = Create<Packet> ();
@@ -606,7 +696,7 @@
   m_setupUeParametersMap[rnti].srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
 }
 
-void 
+void
 LteEnbRrcProtocolReal::DoSendRrcConnectionReestablishmentReject (uint16_t rnti, LteRrcSap::RrcConnectionReestablishmentReject msg)
 {
   Ptr<Packet> packet = Create<Packet> ();
@@ -624,7 +714,7 @@
   m_setupUeParametersMap[rnti].srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
 }
 
-void 
+void
 LteEnbRrcProtocolReal::DoSendRrcConnectionRelease (uint16_t rnti, LteRrcSap::RrcConnectionRelease msg)
 {
   Ptr<Packet> packet = Create<Packet> ();
@@ -683,6 +773,7 @@
   RrcConnectionReconfigurationCompleteHeader rrcConnectionReconfigurationCompleteHeader;
   RrcConnectionReestablishmentCompleteHeader rrcConnectionReestablishmentCompleteHeader;
   RrcConnectionSetupCompleteHeader rrcConnectionSetupCompleteHeader;
+  RrcNotifySecondaryConnectedHeader rrcNotifyHeader;
 
   // Declare possible messages to receive
   LteRrcSap::MeasurementReport measurementReportMsg;
@@ -713,10 +804,16 @@
       rrcConnectionSetupCompletedMsg = rrcConnectionSetupCompleteHeader.GetMessage ();
       m_enbRrcSapProvider->RecvRrcConnectionSetupCompleted (params.rnti, rrcConnectionSetupCompletedMsg);
       break;
+    case 5:
+      params.pdcpSdu->RemoveHeader (rrcNotifyHeader);
+      std::pair<uint16_t, uint16_t> rrcNotifyPair;
+      rrcNotifyPair = rrcNotifyHeader.GetMessage ();
+      m_enbRrcSapProvider->RecvRrcSecondaryCellInitialAccessSuccessful (params.rnti, rrcNotifyPair.second, rrcNotifyPair.first);
+      break;
     }
 }
 
-Ptr<Packet> 
+Ptr<Packet>
 LteEnbRrcProtocolReal::DoEncodeHandoverPreparationInformation (LteRrcSap::HandoverPreparationInfo msg)
 {
   HandoverPreparationInfoHeader h;
@@ -727,7 +824,7 @@
   return p;
 }
 
-LteRrcSap::HandoverPreparationInfo 
+LteRrcSap::HandoverPreparationInfo
 LteEnbRrcProtocolReal::DoDecodeHandoverPreparationInformation (Ptr<Packet> p)
 {
   HandoverPreparationInfoHeader h;
@@ -736,7 +833,7 @@
   return msg;
 }
 
-Ptr<Packet> 
+Ptr<Packet>
 LteEnbRrcProtocolReal::DoEncodeHandoverCommand (LteRrcSap::RrcConnectionReconfiguration msg)
 {
   RrcConnectionReconfigurationHeader h;
diff -Naru a/model/lte-rrc-protocol-real.h b/model/lte-rrc-protocol-real.h
--- a/model/lte-rrc-protocol-real.h	2018-08-03 16:38:46.671806972 +0200
+++ b/model/lte-rrc-protocol-real.h	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Authors: Nicola Baldo <nbaldo@cttc.es>
  *          Lluis Parcerisa <lparcerisa@cttc.cat>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -48,7 +52,7 @@
  * a real fashion, by creating real RRC PDUs and transmitting them
  * over Signaling Radio Bearers using radio resources allocated by the
  * LTE MAC scheduler.
- * 
+ *
  */
 class LteUeRrcProtocolReal : public Object
 {
@@ -74,7 +78,7 @@
   /**
    * Set LTE UE RRC SAP provider function
    *
-   * \param p the LTE UE RRC SAP provider 
+   * \param p the LTE UE RRC SAP provider
    */
   void SetLteUeRrcSapProvider (LteUeRrcSapProvider* p);
   /**
@@ -87,7 +91,7 @@
   /**
    * Set UE RRC function
    *
-   * \param rrc the LTE UE RRC 
+   * \param rrc the LTE UE RRC
    */
   void SetUeRrc (Ptr<LteUeRrc> rrc);
 
@@ -97,58 +101,59 @@
   /**
    * Setup function
    *
-   * \param params LteUeRrcSapUser::SetupParameters 
+   * \param params LteUeRrcSapUser::SetupParameters
    */
   void DoSetup (LteUeRrcSapUser::SetupParameters params);
   /**
    * Send RRC connection request function
    *
-   * \param msg LteRrcSap::RrcConnectionRequest 
+   * \param msg LteRrcSap::RrcConnectionRequest
    */
   void DoSendRrcConnectionRequest (LteRrcSap::RrcConnectionRequest msg);
   /**
    * Send RRC connection setup completed function
    *
-   * \param msg LteRrcSap::RrcConnectionSetupCompleted 
+   * \param msg LteRrcSap::RrcConnectionSetupCompleted
    */
   void DoSendRrcConnectionSetupCompleted (LteRrcSap::RrcConnectionSetupCompleted msg);
   /**
    * Send RRC connection reconfiguration setup completed function
    *
-   * \param msg LteRrcSap::RrcConnectionReconfigurationCompleted 
+   * \param msg LteRrcSap::RrcConnectionReconfigurationCompleted
    */
   void DoSendRrcConnectionReconfigurationCompleted (LteRrcSap::RrcConnectionReconfigurationCompleted msg);
   /**
    * Send RRC connection reestablishment request function
    *
-   * \param msg LteRrcSap::RrcConnectionReestablishmentRequest 
+   * \param msg LteRrcSap::RrcConnectionReestablishmentRequest
    */
   void DoSendRrcConnectionReestablishmentRequest (LteRrcSap::RrcConnectionReestablishmentRequest msg);
   /**
    * Send RRC connection reestablishment complete function
    *
-   * \param msg LteRrcSap::RrcConnectionReestablishmentComplete 
+   * \param msg LteRrcSap::RrcConnectionReestablishmentComplete
    */
   void DoSendRrcConnectionReestablishmentComplete (LteRrcSap::RrcConnectionReestablishmentComplete msg);
   /**
    * Send measurement report function
    *
-   * \param msg LteRrcSap::MeasurementReport 
+   * \param msg LteRrcSap::MeasurementReport
    */
   void DoSendMeasurementReport (LteRrcSap::MeasurementReport msg);
+  void DoSendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId);
 
   /// Set ENB RRC SAP provider
   void SetEnbRrcSapProvider ();
   /**
    * Receive PDCP PDU function
    *
-   * \param p the packet 
+   * \param p the packet
    */
   void DoReceivePdcpPdu (Ptr<Packet> p);
   /**
    * Receive PDCP SDU function
    *
-   * \param params LtePdcpSapUser::ReceivePdcpSduParameters 
+   * \param params LtePdcpSapUser::ReceivePdcpSduParameters
    */
   void DoReceivePdcpSdu (LtePdcpSapUser::ReceivePdcpSduParameters params);
 
@@ -197,20 +202,20 @@
   /**
    * Set LTE ENB RRC SAP provider function
    *
-   * \param p LteEnbRrcSapProvider * 
+   * \param p LteEnbRrcSapProvider *
    */
   void SetLteEnbRrcSapProvider (LteEnbRrcSapProvider* p);
   /**
    * Get LTE ENB RRC SAP user function
    *
-   * \returns LteEnbRrcSapUser * 
+   * \returns LteEnbRrcSapUser *
    */
   LteEnbRrcSapUser* GetLteEnbRrcSapUser ();
 
   /**
    * Set cell ID function
    *
-   * \param cellId the cell ID 
+   * \param cellId the cell ID
    */
   void SetCellId (uint16_t cellId);
 
@@ -218,7 +223,7 @@
    * Get UE RRC SAP provider function
    *
    * \param rnti the RNTI
-   * \returns LteUeRrcSapProvider * 
+   * \returns LteUeRrcSapProvider *
    */
   LteUeRrcSapProvider* GetUeRrcSapProvider (uint16_t rnti);
   /**
@@ -300,6 +305,8 @@
    * \param msg LteRrcSap::RrcConnectionReject
    */
   void DoSendRrcConnectionReject (uint16_t rnti, LteRrcSap::RrcConnectionReject msg);
+  void DoSendRrcConnectionSwitch (uint16_t rnti, LteRrcSap::RrcConnectionSwitch msg);
+  void DoSendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveCellId);
   /**
    * Encode handover preparation information function
    *
@@ -353,6 +360,7 @@
 
 };
 
+///////////////////////////////////////
 
 /// RealProtocolRlcSapUser class
 class RealProtocolRlcSapUser : public LteRlcSapUser
diff -Naru a/model/lte-rrc-sap.h b/model/lte-rrc-sap.h
--- a/model/lte-rrc-sap.h	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-rrc-sap.h	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Authors: Nicola Baldo <nbaldo@cttc.es>
  *          Lluis Parcerisa <lparcerisa@cttc.cat>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -100,7 +104,8 @@
       AM,
       UM_BI_DIRECTIONAL,
       UM_UNI_DIRECTIONAL_UL,
-      UM_UNI_DIRECTIONAL_DL
+      UM_UNI_DIRECTIONAL_DL,
+      UM_BI_DIRECTIONAL_LOWLAT
     } choice; ///< direction choice
   };
 
@@ -239,6 +244,7 @@
     RlcConfig rlcConfig; ///< RLC config
     uint8_t logicalChannelIdentity; ///< logical channel identify
     LogicalChannelConfig logicalChannelConfig; ///< logical channel config
+    bool is_mc;
   };
 
   /// PreambleInfo structure
@@ -685,6 +691,7 @@
   struct RrcConnectionRequest
   {
     uint64_t ueIdentity; ///< UE identity
+    bool isMc;
   };
 
   /// RrcConnectionSetup structure
@@ -719,7 +726,7 @@
   {
     uint16_t alpha; ///< alpha value
   };
-  
+
   /// PrachConfigSCell structure
   struct PrachConfigSCell
   {
@@ -743,10 +750,10 @@
   };
 
   /// UlConfiguration structure
-  struct UlConfiguration 
-  { 
+  struct UlConfiguration
+  {
     FreqInfo ulFreqInfo; ///< UL frequency info
-    UlPowerControlCommonSCell ulPowerControlCommonSCell; ///< 3GPP TS 36.331 v.11.10 R11 pag.223 
+    UlPowerControlCommonSCell ulPowerControlCommonSCell; ///< 3GPP TS 36.331 v.11.10 R11 pag.223
     SoundingRsUlConfigCommon soundingRsUlConfigCommon; ///< sounding RS UL config common
     PrachConfigSCell prachConfigSCell; ///< PRACH config SCell
     //PushConfigCommon pushConfigCommon; //NOT IMPLEMENTED!
@@ -878,6 +885,13 @@
     uint8_t rrcTransactionIdentifier; ///< RRC transaction identifier
   };
 
+  struct RrcConnectionSwitch
+  {
+    uint8_t rrcTransactionIdentifier;
+    std::vector<uint8_t> drbidList;
+    uint16_t useMmWaveConnection;
+  };
+
   /// RrcConnectionReject structure
   struct RrcConnectionReject
   {
@@ -970,6 +984,8 @@
    */
   virtual void SendMeasurementReport (MeasurementReport msg) = 0;
 
+  virtual void SendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId) = 0;
+
 };
 
 
@@ -1051,6 +1067,22 @@
    */
   virtual void RecvRrcConnectionReject (RrcConnectionReject msg) = 0;
 
+  /**
+   * \brief Receive an _RRCConnectionSwitch_ message from the serving eNodeB
+   *        to switch data connection from LTE to MmWave or viceversa
+   *        (added to support MC functionalities)
+   * \param msg the message
+   */
+  virtual void RecvRrcConnectionSwitch (RrcConnectionSwitch msg) = 0;
+
+  /**
+   * \brief Receive an _RRCConnectToMmWave_ message from the serving eNodeB
+   *        during an RRC connection establishment procedure
+   *        (added to support MC functionalities).
+   * \param msg the message
+   */
+  virtual void RecvRrcConnectToMmWave (uint16_t mmWaveCellId) = 0;
+
 };
 
 
@@ -1146,6 +1178,23 @@
   virtual void SendRrcConnectionReject (uint16_t rnti, RrcConnectionReject msg) = 0;
 
   /**
+   * \brief Send an _RRCConnectionSwitch_ message to a UE
+   *        (added to support MC functionalities).
+   * \param rnti the RNTI of the destination UE
+   * \param msg the message
+   */
+  virtual void SendRrcConnectionSwitch (uint16_t rnti, RrcConnectionSwitch msg) = 0;
+
+  /**
+   * \brief Send an _RRCConnectToMmWave_ message to a UE
+   *        during an RRC connection establishment procedure
+   *        (added to support MC functionalities).
+   * \param rnti the RNTI of the destination UE
+   * \param mmWaveCellId the cellId to which connect
+   */
+  virtual void SendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveCellId) = 0;
+
+  /**
    * \brief Encode handover prepration information
    * \param msg HandoverPreparationInfo
    * \returns the packet
@@ -1255,6 +1304,7 @@
    */
   virtual void RecvMeasurementReport (uint16_t rnti, MeasurementReport msg) = 0;
 
+  virtual void RecvRrcSecondaryCellInitialAccessSuccessful (uint16_t rnti, uint16_t mmWaveRnti, uint16_t mmWaveCellId) = 0;
 };
 
 
@@ -1291,6 +1341,7 @@
   virtual void SendRrcConnectionReestablishmentRequest (RrcConnectionReestablishmentRequest msg);
   virtual void SendRrcConnectionReestablishmentComplete (RrcConnectionReestablishmentComplete msg);
   virtual void SendMeasurementReport (MeasurementReport msg);
+  virtual void SendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId);
 
 private:
   MemberLteUeRrcSapUser ();
@@ -1357,6 +1408,13 @@
   m_owner->DoSendMeasurementReport (msg);
 }
 
+template <class C>
+void
+MemberLteUeRrcSapUser<C>::SendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+  m_owner->DoSendNotifySecondaryCellConnected (mmWaveRnti, mmWaveCellId);
+}
+
 /**
  * Template for the implementation of the LteUeRrcSapProvider as a member
  * of an owner class of type C to which all methods are forwarded
@@ -1382,6 +1440,8 @@
   virtual void RecvRrcConnectionReestablishmentReject (RrcConnectionReestablishmentReject msg);
   virtual void RecvRrcConnectionRelease (RrcConnectionRelease msg);
   virtual void RecvRrcConnectionReject (RrcConnectionReject msg);
+  virtual void RecvRrcConnectToMmWave (uint16_t mmWaveCellId);
+  virtual void RecvRrcConnectionSwitch (RrcConnectionSwitch msg);
 
 private:
   MemberLteUeRrcSapProvider ();
@@ -1455,6 +1515,19 @@
   Simulator::ScheduleNow (&C::DoRecvRrcConnectionReject, m_owner, msg);
 }
 
+template <class C>
+void
+MemberLteUeRrcSapProvider<C>::RecvRrcConnectToMmWave (uint16_t mmWaveCellId)
+{
+  Simulator::ScheduleNow (&C::DoRecvRrcConnectToMmWave, m_owner, mmWaveCellId);
+}
+
+template <class C>
+void
+MemberLteUeRrcSapProvider<C>::RecvRrcConnectionSwitch (RrcConnectionSwitch msg)
+{
+  Simulator::ScheduleNow (&C::DoRecvRrcConnectionSwitch, m_owner, msg);
+}
 
 /**
  * Template for the implementation of the LteEnbRrcSapUser as a member
@@ -1476,6 +1549,8 @@
 
   virtual void SetupUe (uint16_t rnti, SetupUeParameters params);
   virtual void RemoveUe (uint16_t rnti);
+  //TODO remove the following declaration
+  //virtual void SendSystemInformation (SystemInformation msg);
   virtual void SendSystemInformation (uint16_t cellId, SystemInformation msg);
   virtual void SendRrcConnectionSetup (uint16_t rnti, RrcConnectionSetup msg);
   virtual void SendRrcConnectionReconfiguration (uint16_t rnti, RrcConnectionReconfiguration msg);
@@ -1483,6 +1558,8 @@
   virtual void SendRrcConnectionReestablishmentReject (uint16_t rnti, RrcConnectionReestablishmentReject msg);
   virtual void SendRrcConnectionRelease (uint16_t rnti, RrcConnectionRelease msg);
   virtual void SendRrcConnectionReject (uint16_t rnti, RrcConnectionReject msg);
+  virtual void SendRrcConnectionSwitch (uint16_t rnti, RrcConnectionSwitch msg);
+  virtual void SendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveCellId);
   virtual Ptr<Packet> EncodeHandoverPreparationInformation (HandoverPreparationInfo msg);
   virtual HandoverPreparationInfo DecodeHandoverPreparationInformation (Ptr<Packet> p);
   virtual Ptr<Packet> EncodeHandoverCommand (RrcConnectionReconfiguration msg);
@@ -1518,6 +1595,15 @@
   m_owner->DoRemoveUe (rnti);
 }
 
+//TODO REMOVE THIS FUNCTION
+/*
+template <class C>
+void
+MemberLteEnbRrcSapUser<C>::SendSystemInformation (SystemInformation msg)
+{
+  m_owner->DoSendSystemInformation (msg);
+}*/
+
 template <class C>
 void
 MemberLteEnbRrcSapUser<C>::SendSystemInformation (uint16_t cellId, SystemInformation msg)
@@ -1568,6 +1654,20 @@
 }
 
 template <class C>
+void
+MemberLteEnbRrcSapUser<C>::SendRrcConnectionSwitch (uint16_t rnti, RrcConnectionSwitch msg)
+{
+  m_owner->DoSendRrcConnectionSwitch (rnti, msg);
+}
+
+template <class C>
+void
+MemberLteEnbRrcSapUser<C>::SendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveCellId)
+{
+  m_owner->DoSendRrcConnectToMmWave (rnti, mmWaveCellId);
+}
+
+template <class C>
 Ptr<Packet>
 MemberLteEnbRrcSapUser<C>::EncodeHandoverPreparationInformation (HandoverPreparationInfo msg)
 {
@@ -1621,6 +1721,7 @@
   virtual void RecvRrcConnectionReestablishmentRequest (uint16_t rnti, RrcConnectionReestablishmentRequest msg);
   virtual void RecvRrcConnectionReestablishmentComplete (uint16_t rnti, RrcConnectionReestablishmentComplete msg);
   virtual void RecvMeasurementReport (uint16_t rnti, MeasurementReport msg);
+  virtual void RecvRrcSecondaryCellInitialAccessSuccessful (uint16_t rnti, uint16_t mmWaveRnti, uint16_t mmWaveCellId);
 
 private:
   MemberLteEnbRrcSapProvider ();
@@ -1687,6 +1788,12 @@
   Simulator::ScheduleNow (&C::DoRecvMeasurementReport, m_owner, rnti, msg);
 }
 
+template <class C>
+void
+MemberLteEnbRrcSapProvider<C>::RecvRrcSecondaryCellInitialAccessSuccessful (uint16_t rnti, uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+  Simulator::ScheduleNow (&C::DoRecvRrcSecondaryCellInitialAccessSuccessful, m_owner, rnti, mmWaveRnti, mmWaveCellId);
+}
 
 
 
@@ -1704,7 +1811,3 @@
 
 
 #endif // LTE_RRC_SAP_H
-
-
-
-
diff -Naru a/model/lte-spectrum-phy.cc b/model/lte-spectrum-phy.cc
--- a/model/lte-spectrum-phy.cc	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-spectrum-phy.cc	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2009, 2011 CTTC
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Nicola Baldo <nbaldo@cttc.es>
  *         Giuseppe Piro  <g.piro@poliba.it>
  *         Marco Miozzo <marco.miozzo@cttc.es> (add physical error model)
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -44,9 +48,9 @@
 NS_LOG_COMPONENT_DEFINE ("LteSpectrumPhy");
 
 
-/// duration of SRS portion of UL subframe  
+/// duration of SRS portion of UL subframe
 /// = 1 symbol for SRS -1ns as margin to avoid overlapping simulator events
-static const Time UL_SRS_DURATION = NanoSeconds (71429 -1);  
+static const Time UL_SRS_DURATION = NanoSeconds (71429 -1);
 
 /// duration of the control portion of a subframe
 /// = 0.001 / 14 * 3 (ctrl fixed to 3 symbols) -1ns as margin to avoid overlapping simulator events
@@ -87,7 +91,7 @@
 
 
 
-  
+
 TbId_t::TbId_t ()
 {
 }
@@ -130,8 +134,8 @@
   : m_state (IDLE),
     m_cellId (0),
     m_componentCarrierId (0),
-    m_transmissionMode (0),
-    m_layersNum (1)
+  m_transmissionMode (0),
+  m_layersNum (1)
 {
   NS_LOG_FUNCTION (this);
   m_random = CreateObject<UniformRandomVariable> ();
@@ -172,7 +176,7 @@
   m_ltePhyUlHarqFeedbackCallback = MakeNullCallback< void, UlInfoListElement_s > ();
   m_ltePhyRxPssCallback = MakeNullCallback< void, uint16_t, Ptr<SpectrumValue> > ();
   SpectrumPhy::DoDispose ();
-} 
+}
 
 /**
  * Output stream output operator
@@ -299,7 +303,7 @@
   m_channel = c;
 }
 
-Ptr<SpectrumChannel> 
+Ptr<SpectrumChannel>
 LteSpectrumPhy::GetChannel ()
 {
   return m_channel;
@@ -331,8 +335,8 @@
   m_interferenceCtrl->SetNoisePowerSpectralDensity (noisePsd);
 }
 
-  
-void 
+
+void
 LteSpectrumPhy::Reset ()
 {
   NS_LOG_FUNCTION (this);
@@ -349,7 +353,7 @@
   m_txControlMessageList.clear ();
   m_rxPacketBurstList.clear ();
   m_txPacketBurst = 0;
-  m_rxSpectrumModel = 0;
+  //m_rxSpectrumModel = 0;
 }
 
 
@@ -447,9 +451,9 @@
 {
   NS_LOG_FUNCTION (this << pb);
   NS_LOG_LOGIC (this << " state: " << m_state);
-  
+
   m_phyTxStartTrace (pb);
-  
+
   switch (m_state)
     {
     case RX_DATA:
@@ -459,11 +463,11 @@
       break;
 
     case TX_DATA:
-    case TX_DL_CTRL:      
+    case TX_DL_CTRL:
     case TX_UL_SRS:
       NS_FATAL_ERROR ("cannot TX while already TX: the MAC should avoid this");
       break;
-      
+
     case IDLE:
     {
       /*
@@ -473,7 +477,7 @@
       */
       NS_ASSERT (m_txPsd);
       m_txPacketBurst = pb;
-      
+
       // we need to convey some PHY meta information to the receiver
       // to be used for simulation purposes (e.g., the CellId). This
       // is done by setting the ctrlMsgList parameter of
@@ -493,7 +497,7 @@
     }
     return false;
     break;
-    
+
     default:
       NS_FATAL_ERROR ("unknown state");
       return true;
@@ -506,7 +510,7 @@
 {
   NS_LOG_FUNCTION (this << " PSS " << (uint16_t)pss);
   NS_LOG_LOGIC (this << " state: " << m_state);
-  
+
   switch (m_state)
   {
     case RX_DATA:
@@ -514,13 +518,13 @@
     case RX_UL_SRS:
       NS_FATAL_ERROR ("cannot TX while RX: according to FDD channel access, the physical layer for transmission cannot be used for reception");
       break;
-      
+
     case TX_DATA:
     case TX_DL_CTRL:
     case TX_UL_SRS:
       NS_FATAL_ERROR ("cannot TX while already TX: the MAC should avoid this");
       break;
-      
+
     case IDLE:
     {
       /*
@@ -529,7 +533,7 @@
       (ii) the power transmission
       */
       NS_ASSERT (m_txPsd);
-      
+
       // we need to convey some PHY meta information to the receiver
       // to be used for simulation purposes (e.g., the CellId). This
       // is done by setting the cellId parameter of
@@ -550,7 +554,7 @@
     }
     return false;
     break;
-    
+
     default:
       NS_FATAL_ERROR ("unknown state");
       return true;
@@ -564,7 +568,7 @@
 {
   NS_LOG_FUNCTION (this);
   NS_LOG_LOGIC (this << " state: " << m_state);
-  
+
   switch (m_state)
     {
     case RX_DATA:
@@ -572,13 +576,13 @@
     case RX_UL_SRS:
       NS_FATAL_ERROR ("cannot TX while RX: according to FDD channel access, the physical layer for transmission cannot be used for reception");
       break;
-      
+
     case TX_DL_CTRL:
     case TX_DATA:
     case TX_UL_SRS:
       NS_FATAL_ERROR ("cannot TX while already TX: the MAC should avoid this");
       break;
-      
+
     case IDLE:
     {
       /*
@@ -588,10 +592,10 @@
       */
       NS_ASSERT (m_txPsd);
       NS_LOG_LOGIC (this << " m_txPsd: " << *m_txPsd);
-      
+
       // we need to convey some PHY meta information to the receiver
       // to be used for simulation purposes (e.g., the CellId). This
-      // is done by setting the cellId parameter of 
+      // is done by setting the cellId parameter of
       // LteSpectrumSignalParametersDlCtrlFrame
       ChangeState (TX_UL_SRS);
       NS_ASSERT (m_channel);
@@ -606,7 +610,7 @@
     }
     return false;
     break;
-    
+
     default:
       NS_FATAL_ERROR ("unknown state");
       return true;
@@ -658,10 +662,10 @@
 {
   NS_LOG_FUNCTION (this << spectrumRxParams);
   NS_LOG_LOGIC (this << " state: " << m_state);
-  
+
   Ptr <const SpectrumValue> rxPsd = spectrumRxParams->psd;
   Time duration = spectrumRxParams->duration;
-  
+
   // the device might start RX only if the signal is of a type
   // understood by this device - in this case, an LTE signal.
   Ptr<LteSpectrumSignalParametersDataFrame> lteDataRxParams = DynamicCast<LteSpectrumSignalParametersDataFrame> (spectrumRxParams);
@@ -687,7 +691,7 @@
       // other type of signal (could be 3G, GSM, whatever) -> interference
       m_interferenceData->AddSignal (rxPsd, duration);
       m_interferenceCtrl->AddSignal (rxPsd, duration);
-    }    
+    }
 }
 
 void
@@ -733,36 +737,36 @@
                   // should occur at the same time and have the same
                   // duration, otherwise the interference calculation
                   // won't be correct
-                  NS_ASSERT ((m_firstRxStart == Simulator::Now ()) 
+                  NS_ASSERT ((m_firstRxStart == Simulator::Now ())
                   && (m_firstRxDuration == params->duration));
                 }
-              
+
               ChangeState (RX_DATA);
               if (params->packetBurst)
                 {
                   m_rxPacketBurstList.push_back (params->packetBurst);
                   m_interferenceData->StartRx (params->psd);
-                  
+
                   m_phyRxStartTrace (params->packetBurst);
                 }
                 NS_LOG_DEBUG (this << " insert msgs " << params->ctrlMsgList.size ());
               m_rxControlMessageList.insert (m_rxControlMessageList.end (), params->ctrlMsgList.begin (), params->ctrlMsgList.end ());
-              
+
               NS_LOG_LOGIC (this << " numSimultaneousRxEvents = " << m_rxPacketBurstList.size ());
             }
           else
             {
-              NS_LOG_LOGIC (this << " not in sync with this signal (cellId=" 
+              NS_LOG_LOGIC (this << " not in sync with this signal (cellId="
               << params->cellId  << ", m_cellId=" << m_cellId << ")");
             }
         }
         break;
-        
+
         default:
           NS_FATAL_ERROR ("unknown state");
           break;
       }
-      
+
    NS_LOG_LOGIC (this << " state: " << m_state);
 }
 
@@ -776,7 +780,7 @@
   // To check if we're synchronized to this signal, we check
   // for the CellId which is reported in the
   // LteSpectrumSignalParametersDlCtrlFrame
-  uint16_t cellId;        
+  uint16_t cellId;
   NS_ASSERT (lteDlCtrlRxParams != 0);
   cellId = lteDlCtrlRxParams->cellId;
 
@@ -801,51 +805,51 @@
               {
                 m_ltePhyRxPssCallback (cellId, lteDlCtrlRxParams->psd);
               }
-        }   
+        }
 
       // differentiated code for the two states
       switch (m_state)
         {
         case RX_DL_CTRL:
           NS_ASSERT_MSG (m_cellId != cellId, "any other DlCtrl should be from a different cell");
-          NS_LOG_LOGIC (this << " ignoring other DlCtrl (cellId=" 
-                        << cellId  << ", m_cellId=" << m_cellId << ")");      
+          NS_LOG_LOGIC (this << " ignoring other DlCtrl (cellId="
+                        << cellId  << ", m_cellId=" << m_cellId << ")");
           break;
-          
+
         case IDLE:
           if (cellId  == m_cellId)
             {
               NS_LOG_LOGIC (this << " synchronized with this signal (cellId=" << cellId << ")");
-              
+
               NS_ASSERT (m_rxControlMessageList.empty ());
               m_firstRxStart = Simulator::Now ();
               m_firstRxDuration = lteDlCtrlRxParams->duration;
               NS_LOG_LOGIC (this << " scheduling EndRx with delay " << lteDlCtrlRxParams->duration);
-              
+
               // store the DCIs
               m_rxControlMessageList = lteDlCtrlRxParams->ctrlMsgList;
               m_endRxDlCtrlEvent = Simulator::Schedule (lteDlCtrlRxParams->duration, &LteSpectrumPhy::EndRxDlCtrl, this);
               ChangeState (RX_DL_CTRL);
-              m_interferenceCtrl->StartRx (lteDlCtrlRxParams->psd);            
+              m_interferenceCtrl->StartRx (lteDlCtrlRxParams->psd);
             }
           else
             {
-              NS_LOG_LOGIC (this << " not synchronizing with this signal (cellId=" 
-                            << cellId  << ", m_cellId=" << m_cellId << ")");          
+              NS_LOG_LOGIC (this << " not synchronizing with this signal (cellId="
+                            << cellId  << ", m_cellId=" << m_cellId << ")");
             }
           break;
-          
+
         default:
           NS_FATAL_ERROR ("unexpected event in state " << m_state);
           break;
         }
       break; // case RX_DL_CTRL or IDLE
-      
+
     default:
       NS_FATAL_ERROR ("unknown state");
       break;
     }
-  
+
   NS_LOG_LOGIC (this << " state: " << m_state);
 }
 
@@ -900,25 +904,25 @@
                 // should occur at the same time and have the same
                 // duration, otherwise the interference calculation
                 // won't be correct
-                NS_ASSERT ((m_firstRxStart == Simulator::Now ()) 
+                NS_ASSERT ((m_firstRxStart == Simulator::Now ())
                            && (m_firstRxDuration == lteUlSrsRxParams->duration));
-              }            
+              }
             ChangeState (RX_UL_SRS);
-            m_interferenceCtrl->StartRx (lteUlSrsRxParams->psd);          
+            m_interferenceCtrl->StartRx (lteUlSrsRxParams->psd);
           }
         else
           {
-            NS_LOG_LOGIC (this << " not in sync with this signal (cellId=" 
-                          << cellId  << ", m_cellId=" << m_cellId << ")");          
+            NS_LOG_LOGIC (this << " not in sync with this signal (cellId="
+                          << cellId  << ", m_cellId=" << m_cellId << ")");
           }
       }
       break;
-      
+
     default:
       NS_FATAL_ERROR ("unknown state");
       break;
     }
-  
+
   NS_LOG_LOGIC (this << " state: " << m_state);
 }
 
@@ -965,12 +969,12 @@
   NS_LOG_DEBUG (this << " No. of burts " << m_rxPacketBurstList.size ());
   NS_LOG_DEBUG (this << " Expected TBs " << m_expectedTbs.size ());
   expectedTbs_t::iterator itTb = m_expectedTbs.begin ();
-  
+
   // apply transmission mode gain
   NS_LOG_DEBUG (this << " txMode " << (uint16_t)m_transmissionMode << " gain " << m_txModeGain.at (m_transmissionMode));
   NS_ASSERT (m_transmissionMode < m_txModeGain.size ());
   m_sinrPerceived *= m_txModeGain.at (m_transmissionMode);
-  
+
   while (itTb!=m_expectedTbs.end ())
     {
       if ((m_dataErrorModelEnabled)&&(m_rxPacketBurstList.size ()>0)) // avoid to check for errors when there is no actual data transmitted
@@ -1020,16 +1024,16 @@
               m_ulPhyReception (params);
             }
        }
-      
+
       itTb++;
     }
     std::map <uint16_t, DlInfoListElement_s> harqDlInfoMap;
-    for (std::list<Ptr<PacketBurst> >::const_iterator i = m_rxPacketBurstList.begin (); 
+    for (std::list<Ptr<PacketBurst> >::const_iterator i = m_rxPacketBurstList.begin ();
     i != m_rxPacketBurstList.end (); ++i)
       {
         for (std::list<Ptr<Packet> >::const_iterator j = (*i)->Begin (); j != (*i)->End (); ++j)
           {
-            // retrieve TB info of this packet 
+            // retrieve TB info of this packet
             LteRadioBearerTag tag;
             (*j)->PeekPacketTag (tag);
             TbId_t tbId;
@@ -1042,7 +1046,7 @@
                 if (!(*itTb).second.corrupt)
                   {
                     m_phyRxEndOkTrace (*j);
-                
+
                     if (!m_ltePhyRxDataEndOkCallback.IsNull ())
                       {
                         m_ltePhyRxDataEndOkCallback (*j);
@@ -1086,7 +1090,7 @@
                         if (itHarq==harqDlInfoMap.end ())
                           {
                             DlInfoListElement_s harqDlInfo;
-                            harqDlInfo.m_harqStatus.resize (m_layersNum, DlInfoListElement_s::ACK);
+                            harqDlInfo.m_harqStatus.resize (m_layersNum, DlInfoListElement_s::NACK);
                             harqDlInfo.m_rnti = tbId.m_rnti;
                             harqDlInfo.m_harqProcessId = (*itTb).second.harqProcessId;
                             if ((*itTb).second.corrupt)
@@ -1155,9 +1159,9 @@
 {
   NS_LOG_FUNCTION (this);
   NS_LOG_LOGIC (this << " state: " << m_state);
-  
+
   NS_ASSERT (m_state == RX_DL_CTRL);
-  
+
   // this will trigger CQI calculation and Error Model evaluation
   // as a side effect, the error model should update the error status of all TBs
   m_interferenceCtrl->EndRx ();
@@ -1207,7 +1211,7 @@
   // nothing to do (used only for SRS at this stage)
 }
 
-void 
+void
 LteSpectrumPhy::SetCellId (uint16_t cellId)
 {
   m_cellId = cellId;
@@ -1255,7 +1259,7 @@
   m_interferenceCtrl->AddSinrChunkProcessor (p);
 }
 
-void 
+void
 LteSpectrumPhy::SetTransmissionMode (uint8_t txMode)
 {
   NS_LOG_FUNCTION (this << (uint16_t) txMode);
@@ -1265,7 +1269,7 @@
 }
 
 
-void 
+void
 LteSpectrumPhy::SetTxModeGain (uint8_t txMode, double gain)
 {
   NS_LOG_FUNCTION (this << " txmode " << (uint16_t)txMode << " gain " << gain);
diff -Naru a/model/lte-spectrum-phy.h b/model/lte-spectrum-phy.h
--- a/model/lte-spectrum-phy.h	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-spectrum-phy.h	2018-08-03 16:39:02.895957709 +0200
@@ -49,7 +49,7 @@
 {
   uint16_t m_rnti; ///< RNTI
   uint8_t m_layer; ///< layer
-  
+
   public:
   TbId_t ();
   /**
@@ -59,12 +59,12 @@
    * \param b layer
    */
   TbId_t (const uint16_t a, const uint8_t b);
-  
+
   friend bool operator == (const TbId_t &a, const TbId_t &b);
   friend bool operator < (const TbId_t &a, const TbId_t &b);
 };
 
-  
+
 /// tbInfo_t structure
 struct tbInfo_t
 {
@@ -90,6 +90,15 @@
 struct LteSpectrumSignalParametersDlCtrlFrame;
 struct LteSpectrumSignalParametersUlSrsFrame;
 
+
+/**
+* this method is invoked by the LteSpectrumPhy to notify the PHY that the
+* transmission of a given packet has been completed.
+*
+* @param packet the Packet whose TX has been completed.
+*/
+typedef Callback< void, Ptr<const Packet> > LtePhyTxEndCallback;
+
 /**
 * This method is used by the LteSpectrumPhy to notify the PHY that a
 * previously started RX attempt has terminated without success
@@ -106,7 +115,7 @@
 
 /**
 * This method is used by the LteSpectrumPhy to notify the PHY that a
-* previously started RX of a control frame attempt has been 
+* previously started RX of a control frame attempt has been
 * successfully completed.
 *
 * @param packet the received Packet
@@ -115,7 +124,7 @@
 
 /**
 * This method is used by the LteSpectrumPhy to notify the PHY that a
-* previously started RX of a control frame attempt has terminated 
+* previously started RX of a control frame attempt has terminated
 * without success.
 */
 typedef Callback< void > LtePhyRxCtrlEndErrorCallback;
@@ -148,7 +157,7 @@
  * The LteSpectrumPhy models the physical layer of LTE
  *
  * It supports a single antenna model instance which is
- * used for both transmission and reception.  
+ * used for both transmission and reception.
  */
 class LteSpectrumPhy : public SpectrumPhy
 {
@@ -217,32 +226,32 @@
    */
   void SetNoisePowerSpectralDensity (Ptr<const SpectrumValue> noisePsd);
 
-  /** 
+  /**
    * reset the internal state
-   * 
+   *
    */
   void Reset ();
- 
+
   /**
    * set the AntennaModel to be used
-   * 
+   *
    * \param a the Antenna Model
    */
   void SetAntenna (Ptr<AntennaModel> a);
-  
+
   /**
   * Start a transmission of data frame in DL and UL
   *
   *
   * @param pb the burst of packets to be transmitted in PDSCH/PUSCH
   * @param ctrlMsgList the list of LteControlMessage to send
-  * @param duration the duration of the data frame 
+  * @param duration the duration of the data frame
   *
   * @return true if an error occurred and the transmission was not
   * started, false otherwise.
   */
   bool StartTxDataFrame (Ptr<PacketBurst> pb, std::list<Ptr<LteControlMessage> > ctrlMsgList, Time duration);
-  
+
   /**
   * Start a transmission of control frame in DL
   *
@@ -254,8 +263,8 @@
   * started, false otherwise.
   */
   bool StartTxDlCtrlFrame (std::list<Ptr<LteControlMessage> > ctrlMsgList, bool pss);
-  
-  
+
+
   /**
   * Start a transmission of control frame in UL
   *
@@ -264,6 +273,15 @@
   */
   bool StartTxUlSrsFrame ();
 
+
+  /**
+   * set the callback for the end of a TX, as part of the
+   * interconnections between the PHY and the MAC
+   *
+   * @param c the callback
+   */
+  void SetLtePhyTxEndCallback (LtePhyTxEndCallback c);
+
   /**
    * set the callback for the end of a RX in error, as part of the
    * interconnections between the PHY and the MAC
@@ -279,17 +297,17 @@
    * @param c the callback
    */
   void SetLtePhyRxDataEndOkCallback (LtePhyRxDataEndOkCallback c);
-  
+
   /**
-  * set the callback for the successful end of a RX ctrl frame, as part 
+  * set the callback for the successful end of a RX ctrl frame, as part
   * of the interconnections between the LteSpectrumPhy and the PHY
   *
   * @param c the callback
   */
   void SetLtePhyRxCtrlEndOkCallback (LtePhyRxCtrlEndOkCallback c);
-  
+
   /**
-  * set the callback for the erroneous end of a RX ctrl frame, as part 
+  * set the callback for the erroneous end of a RX ctrl frame, as part
   * of the interconnections between the LteSpectrumPhy and the PHY
   *
   * @param c the callback
@@ -305,7 +323,7 @@
   void SetLtePhyRxPssCallback (LtePhyRxPssCallback c);
 
   /**
-  * set the callback for the DL HARQ feedback as part of the 
+  * set the callback for the DL HARQ feedback as part of the
   * interconnections between the LteSpectrumPhy and the PHY
   *
   * @param c the callback
@@ -326,9 +344,9 @@
    */
   void SetState (State newState);
 
-  /** 
-   * 
-   * 
+  /**
+   *
+   *
    * \param cellId the Cell Identifier
    */
   void SetCellId (uint16_t cellId);
@@ -346,7 +364,7 @@
   *          processing chain
   */
   void AddRsPowerChunkProcessor (Ptr<LteChunkProcessor> p);
-  
+
   /**
   *
   *
@@ -355,9 +373,9 @@
   */
   void AddDataPowerChunkProcessor (Ptr<LteChunkProcessor> p);
 
-  /** 
-  * 
-  * 
+  /**
+  *
+  *
   * \param p the new LteChunkProcessor to be added to the data processing chain
   */
   void AddDataSinrChunkProcessor (Ptr<LteChunkProcessor> p);
@@ -377,18 +395,18 @@
   * \param p the new LteChunkProcessor to be added to the data processing chain
   */
   void AddInterferenceDataChunkProcessor (Ptr<LteChunkProcessor> p);
-  
-  
-  /** 
-  * 
-  * 
+
+
+  /**
+  *
+  *
   * \param p the new LteChunkProcessor to be added to the ctrl processing chain
   */
   void AddCtrlSinrChunkProcessor (Ptr<LteChunkProcessor> p);
-  
-  /** 
-  * 
-  * 
+
+  /**
+  *
+  *
   * \param rnti the rnti of the source of the TB
   * \param ndi new data indicator flag
   * \param size the size of the TB
@@ -402,30 +420,30 @@
   void AddExpectedTb (uint16_t  rnti, uint8_t ndi, uint16_t size, uint8_t mcs, std::vector<int> map, uint8_t layer, uint8_t harqId, uint8_t rv, bool downlink);
 
 
-  /** 
-  * 
-  * 
+  /**
+  *
+  *
   * \param sinr vector of sinr perceived per each RB
   */
   void UpdateSinrPerceived (const SpectrumValue& sinr);
-  
-  /** 
-  * 
-  * 
+
+  /**
+  *
+  *
   * \param txMode UE transmission mode (SISO, MIMO tx diversity, ...)
   */
   void SetTransmissionMode (uint8_t txMode);
-  
 
-  /** 
-   * 
+
+  /**
+   *
    * \return the previously set channel
    */
   Ptr<SpectrumChannel> GetChannel ();
 
   /// allow LteUePhy class friend access
   friend class LteUePhy;
-  
+
  /**
   * Assign a fixed random variable stream number to the random variables
   * used by this model.  Return the number of streams (possibly zero) that
@@ -437,9 +455,9 @@
   int64_t AssignStreams (int64_t stream);
 
 private:
-  /** 
+  /**
   * \brief Change state function
-  * 
+  *
   * \param newState the new state to set
   */
   void ChangeState (State newState);
@@ -455,15 +473,15 @@
   void EndRxDlCtrl ();
   /// End receive UL SRS function
   void EndRxUlSrs ();
-  
-  /** 
+
+  /**
   * \brief Set transmit mode gain function
-  * 
+  *
   * \param txMode the transmit mode
   * \param gain the gain to set
   */
   void SetTxModeGain (uint8_t txMode, double gain);
-  
+
 
   Ptr<MobilityModel> m_mobility; ///< the modility model
   Ptr<AntennaModel> m_antenna; ///< the antenna model
@@ -475,11 +493,11 @@
   Ptr<SpectrumValue> m_txPsd; ///< the transmit PSD
   Ptr<PacketBurst> m_txPacketBurst; ///< the transmit packet burst
   std::list<Ptr<PacketBurst> > m_rxPacketBurstList; ///< the receive burst list
-  
+
   std::list<Ptr<LteControlMessage> > m_txControlMessageList; ///< the transmit control message list
   std::list<Ptr<LteControlMessage> > m_rxControlMessageList; ///< the receive control message list
-  
-  
+
+
   State m_state; ///< the state
   Time m_firstRxStart; ///< the first receive start
   Time m_firstRxDuration; ///< the first receive duration
@@ -490,9 +508,9 @@
   TracedCallback<Ptr<const Packet> >      m_phyRxEndOkTrace; ///< the phy receive end ok trace callback
   TracedCallback<Ptr<const Packet> >      m_phyRxEndErrorTrace; ///< the phy receive end error trace callback
 
-  LtePhyRxDataEndErrorCallback   m_ltePhyRxDataEndErrorCallback; ///< the LTE phy receive data end error callback 
+  LtePhyRxDataEndErrorCallback   m_ltePhyRxDataEndErrorCallback; ///< the LTE phy receive data end error callback
   LtePhyRxDataEndOkCallback      m_ltePhyRxDataEndOkCallback; ///< the LTE phy receive data end ok callback
-  
+
   LtePhyRxCtrlEndOkCallback     m_ltePhyRxCtrlEndOkCallback; ///< the LTE phy receive control end ok callback
   LtePhyRxCtrlEndErrorCallback  m_ltePhyRxCtrlEndErrorCallback; ///< the LTE phy receive control end error callback
   LtePhyRxPssCallback  m_ltePhyRxPssCallback; ///< the LTE phy receive PSS callback
@@ -501,16 +519,16 @@
   Ptr<LteInterference> m_interferenceCtrl; ///< the control interference
 
   uint16_t m_cellId; ///< the cell ID
-  
+
   uint8_t m_componentCarrierId; ///< the component carrier ID
   expectedTbs_t m_expectedTbs; ///< the expected TBS
-  SpectrumValue m_sinrPerceived; ///< the preceived SINR 
+  SpectrumValue m_sinrPerceived; ///< the preceived SINR
 
   /// Provides uniform random variables.
   Ptr<UniformRandomVariable> m_random;
   bool m_dataErrorModelEnabled; ///< when true (default) the phy error model is enabled
   bool m_ctrlErrorModelEnabled; ///< when true (default) the phy error model is enabled for DL ctrl frame
-  
+
   uint8_t m_transmissionMode; ///< for UEs: store the transmission mode
   uint8_t m_layersNum; ///< layers num
   std::vector <double> m_txModeGain; ///< duplicate value of LteUePhy
@@ -526,7 +544,7 @@
    */
   TracedCallback<PhyReceptionStatParameters> m_dlPhyReception;
 
-  
+
   /**
    * Trace information regarding PHY stats from UL Rx perspective
    * PhyReceptionStatParameters (see lte-common.h)
@@ -537,7 +555,7 @@
   EventId m_endRxDataEvent; ///< end receive data event
   EventId m_endRxDlCtrlEvent; ///< end receive DL control event
   EventId m_endRxUlSrsEvent; ///< end receive UL SRS event
-  
+
 
 };
 
diff -Naru a/model/lte-ue-cmac-sap.h b/model/lte-ue-cmac-sap.h
--- a/model/lte-ue-cmac-sap.h	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-ue-cmac-sap.h	2018-08-03 16:39:02.895957709 +0200
@@ -49,28 +49,28 @@
     uint8_t preambleTransMax; ///< preamble transmit maximum
     uint8_t raResponseWindowSize; ///< RA response window size
   };
-  
-  /** 
-   * Configure RACH function 
+
+  /**
+   * Configure RACH function
    *
    * \param rc the RACH config
    */
   virtual void ConfigureRach (RachConfig rc) = 0;
 
-  /** 
+  /**
    * tell the MAC to start a contention-based random access procedure,
-   * e.g., to perform RRC connection establishment 
-   * 
+   * e.g., to perform RRC connection establishment
+   *
    */
   virtual void StartContentionBasedRandomAccessProcedure () = 0;
 
-  /** 
+  /**
    * tell the MAC to start a non-contention-based random access
    * procedure, e.g., as a consequence of handover
-   * 
+   *
    * \param rnti
    * \param rapId Random Access Preamble Identifier
-   * \param prachMask 
+   * \param prachMask
    */
   virtual void StartNonContentionBasedRandomAccessProcedure (uint16_t rnti, uint8_t rapId, uint8_t prachMask) = 0;
 
@@ -83,29 +83,29 @@
     uint16_t bucketSizeDurationMs; ///< bucket size duration ms
     uint8_t logicalChannelGroup; ///< logical channel group
   };
-  
-  /** 
-   * add a new Logical Channel (LC) 
-   * 
+
+  /**
+   * add a new Logical Channel (LC)
+   *
    * \param lcId the ID of the LC
    * \param lcConfig the LC configuration provided by the RRC
    * \param msu the corresponding LteMacSapUser
    */
   virtual void AddLc (uint8_t lcId, LogicalChannelConfig lcConfig, LteMacSapUser* msu) = 0;
 
-  /** 
+  /**
    * remove an existing LC
-   * 
-   * \param lcId 
+   *
+   * \param lcId
    */
   virtual void RemoveLc (uint8_t lcId) = 0;
 
-  /** 
+  /**
    * reset the MAC
-   * 
+   *
    */
   virtual void Reset () = 0;
-  
+
   /**
    *
    * \param rnti the cell-specific UE identifier
@@ -127,22 +127,22 @@
 
   virtual ~LteUeCmacSapUser ();
 
-  /** 
-   * 
-   * 
+  /**
+   *
+   *
    * \param rnti the T-C-RNTI, which will eventually become the C-RNTI after contention resolution
    */
   virtual void SetTemporaryCellRnti (uint16_t rnti) = 0;
 
-  /** 
+  /**
    * Notify the RRC that the MAC Random Access procedure completed successfully
-   * 
+   *
    */
   virtual void NotifyRandomAccessSuccessful () = 0;
 
-  /** 
+  /**
    * Notify the RRC that the MAC Random Access procedure failed
-   * 
+   *
    */
   virtual void NotifyRandomAccessFailed () = 0;
 };
diff -Naru a/model/lte-ue-cphy-sap.h b/model/lte-ue-cphy-sap.h
--- a/model/lte-ue-cphy-sap.h	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-ue-cphy-sap.h	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011, 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>,
  *         Marco Miozzo <mmiozzo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_UE_CPHY_SAP_H
@@ -42,14 +46,14 @@
 {
 public:
 
-  /** 
+  /**
    * destructor
    */
   virtual ~LteUeCphySapProvider ();
 
-  /** 
+  /**
    * reset the PHY
-   * 
+   *
    */
   virtual void Reset () = 0;
 
@@ -66,7 +70,7 @@
    * and periodically returning measurement reports to RRC via
    * LteUeCphySapUser::ReportUeMeasurements function.
    */
-  virtual void StartCellSearch (uint32_t dlEarfcn) = 0;
+   virtual void StartCellSearch (uint32_t dlEarfcn) = 0;
 
   /**
    * \brief Tell the PHY entity to synchronize with a given eNodeB over the
@@ -108,9 +112,9 @@
    */
   virtual void SetDlBandwidth (uint8_t dlBandwidth) = 0;
 
-  /** 
+  /**
    * \brief Configure uplink (normally done after reception of SIB2)
-   * 
+   *
    * \param ulEarfcn the uplink carrier frequency (EARFCN)
    * \param ulBandwidth the UL bandwidth in number of PRBs
    */
@@ -123,8 +127,8 @@
    */
   virtual void ConfigureReferenceSignalPower (int8_t referenceSignalPower) = 0;
 
-  /** 
-   * 
+  /**
+   *
    * \param rnti the cell-specific UE identifier
    */
   virtual void SetRnti (uint16_t rnti) = 0;
@@ -157,7 +161,7 @@
 {
 public:
 
-  /** 
+  /**
    * destructor
    */
   virtual ~LteUeCphySapUser ();
@@ -186,7 +190,7 @@
    * \brief Relay an MIB message from the PHY entity to the RRC layer.
    * \param cellId the ID of the eNodeB where the message originates from
    * \param mib the Master Information Block message
-   * 
+   *
    * This function is typically called after PHY receives an MIB message over
    * the BCH.
    */
@@ -211,6 +215,8 @@
    */
   virtual void ReportUeMeasurements (UeMeasurementsParameters params) = 0;
 
+  virtual void NotifyRadioLinkFailure (double lastSinrValue) = 0;
+
 };
 
 
@@ -219,7 +225,7 @@
 /**
  * Template for the implementation of the LteUeCphySapProvider as a member
  * of an owner class of type C to which all methods are forwarded
- * 
+ *
  */
 template <class C>
 class MemberLteUeCphySapProvider : public LteUeCphySapProvider
@@ -262,7 +268,7 @@
 }
 
 template <class C>
-void 
+void
 MemberLteUeCphySapProvider<C>::Reset ()
 {
   m_owner->DoReset ();
@@ -297,14 +303,14 @@
 }
 
 template <class C>
-void 
+void
 MemberLteUeCphySapProvider<C>::ConfigureUplink (uint32_t ulEarfcn, uint8_t ulBandwidth)
 {
   m_owner->DoConfigureUplink (ulEarfcn, ulBandwidth);
 }
 
 template <class C>
-void 
+void
 MemberLteUeCphySapProvider<C>::ConfigureReferenceSignalPower (int8_t referenceSignalPower)
 {
   m_owner->DoConfigureReferenceSignalPower (referenceSignalPower);
@@ -318,14 +324,14 @@
 }
 
 template <class C>
-void 
+void
 MemberLteUeCphySapProvider<C>::SetTransmissionMode (uint8_t txMode)
 {
   m_owner->DoSetTransmissionMode (txMode);
 }
 
 template <class C>
-void 
+void
 MemberLteUeCphySapProvider<C>::SetSrsConfigurationIndex (uint16_t srcCi)
 {
   m_owner->DoSetSrsConfigurationIndex (srcCi);
@@ -342,7 +348,7 @@
 /**
  * Template for the implementation of the LteUeCphySapUser as a member
  * of an owner class of type C to which all methods are forwarded
- * 
+ *
  */
 template <class C>
 class MemberLteUeCphySapUser : public LteUeCphySapUser
@@ -362,6 +368,8 @@
                                                 LteRrcSap::SystemInformationBlockType1 sib1);
   virtual void ReportUeMeasurements (LteUeCphySapUser::UeMeasurementsParameters params);
 
+  virtual void NotifyRadioLinkFailure (double lastSinrValue);
+
 private:
   MemberLteUeCphySapUser ();
   C* m_owner; ///< the owner class
@@ -378,8 +386,8 @@
 {
 }
 
-template <class C> 
-void 
+template <class C>
+void
 MemberLteUeCphySapUser<C>::RecvMasterInformationBlock (uint16_t cellId,
                                                        LteRrcSap::MasterInformationBlock mib)
 {
@@ -401,6 +409,14 @@
   m_owner->DoReportUeMeasurements (params);
 }
 
+template <class C>
+void
+MemberLteUeCphySapUser<C>::NotifyRadioLinkFailure (double lastSinrValue)
+{
+  m_owner->DoNotifyRadioLinkFailure(lastSinrValue);
+}
+
+
 
 } // namespace ns3
 
diff -Naru a/model/lte-ue-mac.cc b/model/lte-ue-mac.cc
--- a/model/lte-ue-mac.cc	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-ue-mac.cc	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, 2018, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,12 @@
  *
  * Author: Nicola Baldo  <nbaldo@cttc.es>
  * Author: Marco Miozzo <mmiozzo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
+ *
+ * Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+ *								 Integration of Carrier Aggregation for the mmWave module
  */
 
 
@@ -48,15 +55,10 @@
 // SAP forwarders
 ///////////////////////////////////////////////////////////
 
-/// UeMemberLteUeCmacSapProvider class
+
 class UeMemberLteUeCmacSapProvider : public LteUeCmacSapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param mac the UE MAC
-   */
   UeMemberLteUeCmacSapProvider (LteUeMac* mac);
 
   // inherited from LteUeCmacSapProvider
@@ -69,7 +71,7 @@
   virtual void Reset ();
 
 private:
-  LteUeMac* m_mac; ///< the UE MAC
+  LteUeMac* m_mac;
 };
 
 
@@ -78,29 +80,29 @@
 {
 }
 
-void 
+void
 UeMemberLteUeCmacSapProvider::ConfigureRach (RachConfig rc)
 {
   m_mac->DoConfigureRach (rc);
 }
 
-  void 
+  void
 UeMemberLteUeCmacSapProvider::StartContentionBasedRandomAccessProcedure ()
 {
   m_mac->DoStartContentionBasedRandomAccessProcedure ();
 }
 
- void 
+ void
 UeMemberLteUeCmacSapProvider::StartNonContentionBasedRandomAccessProcedure (uint16_t rnti, uint8_t preambleId, uint8_t prachMask)
 {
   m_mac->DoStartNonContentionBasedRandomAccessProcedure (rnti, preambleId, prachMask);
 }
 
- void
- UeMemberLteUeCmacSapProvider::SetRnti (uint16_t rnti)
- {
-   m_mac->DoSetRnti (rnti);
- }
+void
+UeMemberLteUeCmacSapProvider::SetRnti (uint16_t rnti)
+{
+  m_mac->DoSetRnti (rnti);
+}
 
 void
 UeMemberLteUeCmacSapProvider::AddLc (uint8_t lcId, LogicalChannelConfig lcConfig, LteMacSapUser* msu)
@@ -120,15 +122,9 @@
   m_mac->DoReset ();
 }
 
-/// UeMemberLteMacSapProvider class
 class UeMemberLteMacSapProvider : public LteMacSapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param mac the UE MAC
-   */
   UeMemberLteMacSapProvider (LteUeMac* mac);
 
   // inherited from LteMacSapProvider
@@ -136,7 +132,7 @@
   virtual void ReportBufferStatus (ReportBufferStatusParameters params);
 
 private:
-  LteUeMac* m_mac; ///< the UE MAC
+  LteUeMac* m_mac;
 };
 
 
@@ -160,17 +156,10 @@
 
 
 
-/**
- * UeMemberLteUePhySapUser
- */
+
 class UeMemberLteUePhySapUser : public LteUePhySapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param mac the UE MAC
-   */
   UeMemberLteUePhySapUser (LteUeMac* mac);
 
   // inherited from LtePhySapUser
@@ -179,7 +168,7 @@
   virtual void ReceiveLteControlMessage (Ptr<LteControlMessage> msg);
 
 private:
-  LteUeMac* m_mac; ///< the UE MAC
+  LteUeMac* m_mac;
 };
 
 UeMemberLteUePhySapUser::UeMemberLteUePhySapUser (LteUeMac* mac) : m_mac (mac)
@@ -233,7 +222,7 @@
      m_rnti (0),
      m_rachConfigured (false),
      m_waitingForRaResponse (false)
-  
+
 {
   NS_LOG_FUNCTION (this);
   m_miUlHarqProcessesPacket.resize (HARQ_PERIOD);
@@ -243,7 +232,7 @@
       m_miUlHarqProcessesPacket.at (i) = pb;
     }
   m_miUlHarqProcessesPacketTimer.resize (HARQ_PERIOD, 0);
-   
+
   m_macSapProvider = new UeMemberLteMacSapProvider (this);
   m_cmacSapProvider = new UeMemberLteUeCmacSapProvider (this);
   m_uePhySapUser = new UeMemberLteUePhySapUser (this);
@@ -323,10 +312,10 @@
 LteUeMac::DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params)
 {
   NS_LOG_FUNCTION (this << (uint32_t) params.lcid);
-  
+
   std::map <uint8_t, LteMacSapProvider::ReportBufferStatusParameters>::iterator it;
-  
-  
+
+
   it = m_ulBsrReceived.find (params.lcid);
   if (it != m_ulBsrReceived.end ())
     {
@@ -349,24 +338,25 @@
   if (m_rnti == 0)
     {
       NS_LOG_INFO ("MAC not initialized, BSR deferred");
-      return; 
+      return;
     }
 
   if (m_ulBsrReceived.size () == 0)
     {
       NS_LOG_INFO ("No BSR report to transmit");
-      return; 
+      return;
     }
   MacCeListElement_s bsr;
   bsr.m_rnti = m_rnti;
   bsr.m_macCeType = MacCeListElement_s::BSR;
 
   // BSR is reported for each LCG
-  std::map <uint8_t, LteMacSapProvider::ReportBufferStatusParameters>::iterator it;  
+  std::map <uint8_t, LteMacSapProvider::ReportBufferStatusParameters>::iterator it;
   std::vector<uint32_t> queue (4, 0); // one value per each of the 4 LCGs, initialized to 0
   for (it = m_ulBsrReceived.begin (); it != m_ulBsrReceived.end (); it++)
     {
       uint8_t lcid = it->first;
+      NS_LOG_INFO("LTE lcid of BSR " << (uint16_t)lcid << " queue size " << (*it).second.txQueueSize);
       std::map <uint8_t, LcInfo>::iterator lcInfoMapIt;
       lcInfoMapIt = m_lcInfoMap.find (lcid);
       NS_ASSERT (lcInfoMapIt !=  m_lcInfoMap.end ());
@@ -391,21 +381,22 @@
 
 }
 
-void 
+void
 LteUeMac::RandomlySelectAndSendRaPreamble ()
 {
   NS_LOG_FUNCTION (this);
-  // 3GPP 36.321 5.1.1  
+  // 3GPP 36.321 5.1.1
   NS_ASSERT_MSG (m_rachConfigured, "RACH not configured");
   // assume that there is no Random Access Preambles group B
   m_raPreambleId = m_raPreambleUniformVariable->GetInteger (0, m_rachConfig.numberOfRaPreambles - 1);
   bool contention = true;
   SendRaPreamble (contention);
 }
-   
+
 void
 LteUeMac::SendRaPreamble (bool contention)
 {
+  NS_LOG_INFO("SendRaPreamble " << (uint16_t)m_raPreambleId << " contention " << contention);
   NS_LOG_FUNCTION (this << (uint32_t) m_raPreambleId << contention);
   // Since regular UL LteControlMessages need m_ulConfigured = true in
   // order to be sent by the UE, the rach preamble needs to be sent
@@ -413,26 +404,26 @@
   // m_uePhySapProvider->SendLteControlMessage (msg)) so that it can
   // bypass the m_ulConfigured flag. This is reasonable, since In fact
   // the RACH preamble is sent on 6RB bandwidth so the uplink
-  // bandwidth does not need to be configured. 
+  // bandwidth does not need to be configured.
   NS_ASSERT (m_subframeNo > 0); // sanity check for subframe starting at 1
   m_raRnti = m_subframeNo - 1;
   m_uePhySapProvider->SendRachPreamble (m_raPreambleId, m_raRnti);
   NS_LOG_INFO (this << " sent preamble id " << (uint32_t) m_raPreambleId << ", RA-RNTI " << (uint32_t) m_raRnti);
-  // 3GPP 36.321 5.1.4 
-  Time raWindowBegin = MilliSeconds (3); 
+  // 3GPP 36.321 5.1.4
+  Time raWindowBegin = MilliSeconds (3);
   Time raWindowEnd = MilliSeconds (3 + m_rachConfig.raResponseWindowSize);
   Simulator::Schedule (raWindowBegin, &LteUeMac::StartWaitingForRaResponse, this);
   m_noRaResponseReceivedEvent = Simulator::Schedule (raWindowEnd, &LteUeMac::RaResponseTimeout, this, contention);
 }
 
-void 
+void
 LteUeMac::StartWaitingForRaResponse ()
 {
    NS_LOG_FUNCTION (this);
    m_waitingForRaResponse = true;
 }
 
-void 
+void
 LteUeMac::RecvRaResponse (BuildRarListElement_s raResponse)
 {
   NS_LOG_FUNCTION (this);
@@ -456,19 +447,19 @@
   if ((lc0BsrIt != m_ulBsrReceived.end ())
       && (lc0BsrIt->second.txQueueSize > 0))
     {
-      NS_ASSERT_MSG (raResponse.m_grant.m_tbSize > lc0BsrIt->second.txQueueSize, 
+      NS_ASSERT_MSG (raResponse.m_grant.m_tbSize > lc0BsrIt->second.txQueueSize,
                      "segmentation of Message 3 is not allowed");
-      // this function can be called only from primary carrier
-      if (m_componentCarrierId > 0)
-        {
-          NS_FATAL_ERROR ("Function called on wrong componentCarrier");
-        }
-      lc0InfoIt->second.macSapUser->NotifyTxOpportunity (raResponse.m_grant.m_tbSize, 0, 0, m_componentCarrierId, m_rnti, lc0Lcid); 
+       // this function can be called only from primary carrier
+       if (m_componentCarrierId > 0)
+         {
+           NS_FATAL_ERROR ("Function called on wrong componentCarrier");
+         }
+      lc0InfoIt->second.macSapUser->NotifyTxOpportunity (raResponse.m_grant.m_tbSize, 0, 0, m_componentCarrierId, m_rnti, lc0Lcid);
       lc0BsrIt->second.txQueueSize = 0;
     }
 }
 
-void 
+void
 LteUeMac::RaResponseTimeout (bool contention)
 {
   NS_LOG_FUNCTION (this << contention);
@@ -494,7 +485,7 @@
     }
 }
 
-void 
+void
 LteUeMac::DoConfigureRach (LteUeCmacSapProvider::RachConfig rc)
 {
   NS_LOG_FUNCTION (this);
@@ -502,7 +493,7 @@
   m_rachConfigured = true;
 }
 
-void 
+void
 LteUeMac::DoStartContentionBasedRandomAccessProcedure ()
 {
   NS_LOG_FUNCTION (this);
@@ -522,7 +513,7 @@
 }
 
 
-void 
+void
 LteUeMac::DoStartNonContentionBasedRandomAccessProcedure (uint16_t rnti, uint8_t preambleId, uint8_t prachMask)
 {
   NS_LOG_FUNCTION (this << " rnti" << rnti);
@@ -537,8 +528,11 @@
 LteUeMac::DoAddLc (uint8_t lcId,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu)
 {
   NS_LOG_FUNCTION (this << " lcId" << (uint32_t) lcId);
-  NS_ASSERT_MSG (m_lcInfoMap.find (lcId) == m_lcInfoMap.end (), "cannot add channel because LCID " << lcId << " is already present");
-  
+
+  // comment this assert in order to allow RLC updates
+  //NS_ASSERT_MSG (m_lcInfoMap.find (lcId) == m_lcInfoMap.end (), "cannot add channel because LCID " << lcId << " is already present");
+
+  NS_LOG_DEBUG("Add LC in " << m_rnti << " lcid " << (uint32_t)lcId);
   LcInfo lcInfo;
   lcInfo.lcConfig = lcConfig;
   lcInfo.macSapUser = msu;
@@ -562,7 +556,7 @@
     {
       // don't delete CCCH)
       if (it->first == 0)
-        {          
+        {
           ++it;
         }
       else
@@ -583,6 +577,7 @@
 {
   LteRadioBearerTag tag;
   p->RemovePacketTag (tag);
+  NS_LOG_INFO("LteUeMac ReceivePhyPdu");
   if (tag.GetRnti () == m_rnti)
     {
       // packet is for the current user
@@ -596,6 +591,10 @@
           NS_LOG_WARN ("received packet with unknown lcid " << (uint32_t) tag.GetLcid ());
         }
     }
+  else
+  {
+    NS_LOG_WARN("received packet with unknown rnti " << (uint32_t) tag.GetRnti ());
+  }
 }
 
 
@@ -607,6 +606,8 @@
     {
       Ptr<UlDciLteControlMessage> msg2 = DynamicCast<UlDciLteControlMessage> (msg);
       UlDciListElement_s dci = msg2->GetDci ();
+      NS_LOG_INFO("LTE UE MAC " << (uint32_t)m_componentCarrierId << " received UL-DCI size " << (uint32_t)dci.m_tbSize);
+
       if (dci.m_ndi == 1)
         {
           // New transmission -> empty pkt buffer queue (for deleting eventual pkts not acked )
@@ -620,15 +621,19 @@
             {
               if (((*itBsr).second.statusPduSize > 0) || ((*itBsr).second.retxQueueSize > 0) || ((*itBsr).second.txQueueSize > 0))
                 {
-                  activeLcs++;
-                  if (((*itBsr).second.statusPduSize != 0)&&((*itBsr).second.statusPduSize < statusPduMinSize))
-                    {
-                      statusPduMinSize = (*itBsr).second.statusPduSize;
-                    }
-                  if (((*itBsr).second.statusPduSize != 0)&&(statusPduMinSize == 0))
-                    {
-                      statusPduMinSize = (*itBsr).second.statusPduSize;
-                    }
+                  // check if this LC is active in this LteUeMac instance
+                  if(m_lcInfoMap.find(itBsr->first) != m_lcInfoMap.end())
+                  {
+                    activeLcs++;
+                    if (((*itBsr).second.statusPduSize != 0)&&((*itBsr).second.statusPduSize < statusPduMinSize))
+                      {
+                        statusPduMinSize = (*itBsr).second.statusPduSize;
+                      }
+                    if (((*itBsr).second.statusPduSize != 0)&&(statusPduMinSize == 0))
+                      {
+                        statusPduMinSize = (*itBsr).second.statusPduSize;
+                      }
+                  }
                 }
             }
           if (activeLcs == 0)
@@ -684,7 +689,7 @@
                               NS_FATAL_ERROR ("Insufficient Tx Opportunity for sending a status message");
                             }
                         }
-                        
+
                       if ((bytesForThisLc > 7)    // 7 is the min TxOpportunity useful for Rlc
                           && (((*itBsr).second.retxQueueSize > 0)
                               || ((*itBsr).second.txQueueSize > 0)))
@@ -711,8 +716,8 @@
                                   // for SRB1 (using RLC AM) it's better to
                                   // overestimate RLC overhead rather than
                                   // underestimate it and risk unneeded
-                                  // segmentation which increases delay 
-                                  rlcOverhead = 4;                                  
+                                  // segmentation which increases delay
+                                  rlcOverhead = 4;
                                 }
                               else
                                 {
@@ -733,7 +738,7 @@
                         }
                       else
                         {
-                          if ( ((*itBsr).second.retxQueueSize > 0) || ((*itBsr).second.txQueueSize > 0)) 
+                          if ( ((*itBsr).second.retxQueueSize > 0) || ((*itBsr).second.txQueueSize > 0))
                             {
                               // resend BSR info for updating eNB peer MAC
                               m_freshUlBsr = true;
@@ -755,7 +760,7 @@
               Ptr<Packet> pkt = (*j)->Copy ();
               m_uePhySapProvider->SendMacPdu (pkt);
             }
-          m_miUlHarqProcessesPacketTimer.at (m_harqProcessId) = HARQ_PERIOD;          
+          m_miUlHarqProcessesPacketTimer.at (m_harqProcessId) = HARQ_PERIOD;
         }
 
     }
@@ -792,7 +797,7 @@
 void
 LteUeMac::RefreshHarqProcessesPacketBuffer (void)
 {
-  NS_LOG_FUNCTION (this);
+  //NS_LOG_FUNCTION (this);
 
   for (uint16_t i = 0; i < m_miUlHarqProcessesPacketTimer.size (); i++)
     {
@@ -817,13 +822,16 @@
 void
 LteUeMac::DoSubframeIndication (uint32_t frameNo, uint32_t subframeNo)
 {
-  NS_LOG_FUNCTION (this);
+  //NS_LOG_FUNCTION (this);
   m_frameNo = frameNo;
   m_subframeNo = subframeNo;
   RefreshHarqProcessesPacketBuffer ();
   if ((Simulator::Now () >= m_bsrLast + m_bsrPeriodicity) && (m_freshUlBsr == true))
     {
-      SendReportBufferStatus ();
+      if(m_componentCarrierId == 0) // only the Primary CC sends BSRs
+      {
+        SendReportBufferStatus ();
+      }
       m_bsrLast = Simulator::Now ();
       m_freshUlBsr = false;
     }
diff -Naru a/model/lte-ue-mac.h b/model/lte-ue-mac.h
--- a/model/lte-ue-mac.h	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-ue-mac.h	2018-08-03 16:39:02.895957709 +0200
@@ -75,7 +75,7 @@
   * \return a pointer to the LTE CMAC SAP provider
   */
   LteUeCmacSapProvider*  GetLteUeCmacSapProvider (void);
-  
+
   /**
   * \brief Set the component carried ID
   * \param index the component carrier ID
@@ -93,7 +93,7 @@
   * \param s a pointer to the PHY SAP Provider
   */
   void SetLteUePhySapProvider (LteUePhySapProvider* s);
-  
+
   /**
   * \brief Forwarded from LteUePhySapUser: trigger the start from a new frame
   *
@@ -138,12 +138,12 @@
   * Start contention based random access procedure function
   */
   void DoStartContentionBasedRandomAccessProcedure ();
- /**
-  * Set RNTI
-  *
-  * \param rnti the RNTI
-  */
-  void DoSetRnti (uint16_t rnti);
+  /**
+   * Set RNTI
+   *
+   * \param rnti the RNTI
+   */
+   void DoSetRnti (uint16_t rnti);
  /**
   * Start non contention based random access procedure function
   *
@@ -182,7 +182,7 @@
   * \param msg the LTE control message
   */
   void DoReceiveLteControlMessage (Ptr<LteControlMessage> msg);
-  
+
   // internal methods
   /// Randomly sleect and send RA preamble function
   void RandomlySelectAndSendRaPreamble ();
@@ -232,13 +232,13 @@
 
   LteUePhySapProvider* m_uePhySapProvider; ///< UE Phy SAP provider
   LteUePhySapUser* m_uePhySapUser; ///< UE Phy SAP user
-  
+
   std::map <uint8_t, LteMacSapProvider::ReportBufferStatusParameters> m_ulBsrReceived; ///< BSR received from RLC (the last one)
-  
-  
+
+
   Time m_bsrPeriodicity; ///< BSR periodicity
   Time m_bsrLast; ///< BSR last
-  
+
   bool m_freshUlBsr; ///< true when a BSR has been received in the last TTI
 
   uint8_t m_harqProcessId; ///< HARQ process ID
diff -Naru a/model/lte-ue-net-device.cc b/model/lte-ue-net-device.cc
--- a/model/lte-ue-net-device.cc	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-ue-net-device.cc	2018-08-03 16:39:02.895957709 +0200
@@ -132,7 +132,7 @@
 
   m_rrc->Dispose ();
   m_rrc = 0;
-  
+
   m_nas->Dispose ();
   m_nas = 0;
   for (uint32_t i = 0; i < m_ccMap.size (); i++)
@@ -267,7 +267,7 @@
   m_ccMap = ccm;
 }
 
-void 
+void
 LteUeNetDevice::DoInitialize (void)
 {
   NS_LOG_FUNCTION (this);
@@ -291,7 +291,7 @@
     {
       NS_LOG_INFO ("unsupported protocol " << protocolNumber << ", only IPv4 and IPv6 are supported");
       return true;
-    }  
+    }
   return m_nas->Send (packet);
 }
 
diff -Naru a/model/lte-ue-net-device.h b/model/lte-ue-net-device.h
--- a/model/lte-ue-net-device.h	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-ue-net-device.h	2018-08-03 16:39:02.895957709 +0200
@@ -94,7 +94,7 @@
    * \return the LTE UE NAS
    */
   Ptr<EpcUeNas> GetNas (void) const;
-  
+
   /**
    * \brief Get the componentn carrier manager.
    * \return the LTE UE component carrier manager
diff -Naru a/model/lte-ue-phy.cc b/model/lte-ue-phy.cc
--- a/model/lte-ue-phy.cc	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-ue-phy.cc	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2010 TELEMATICS LAB, DEE - Politecnico di Bari
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Giuseppe Piro  <g.piro@poliba.it>
  *         Marco Miozzo <marco.miozzo@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/object-factory.h>
@@ -55,13 +59,13 @@
  * events. The duration of one symbol is TTI/14 (rounded). In other words,
  * duration of data portion of UL subframe = 1 ms * (13/14) - 1 ns.
  */
-static const Time UL_DATA_DURATION = NanoSeconds (1e6 - 71429 - 1); 
+static const Time UL_DATA_DURATION = NanoSeconds (1e6 - 71429 - 1);
 
 /**
  * Delay from subframe start to transmission of SRS.
  * Equals to "TTI length - 1 symbol for SRS".
  */
-static const Time UL_SRS_DELAY_FROM_SUBFRAME_START = NanoSeconds (1e6 - 71429); 
+static const Time UL_SRS_DELAY_FROM_SUBFRAME_START = NanoSeconds (1e6 - 71429);
 
 
 
@@ -200,7 +204,7 @@
     .AddAttribute ("TxPower",
                    "Transmission power in dBm",
                    DoubleValue (10.0),
-                   MakeDoubleAccessor (&LteUePhy::SetTxPower, 
+                   MakeDoubleAccessor (&LteUePhy::SetTxPower,
                                        &LteUePhy::GetTxPower),
                    MakeDoubleChecker<double> ())
     .AddAttribute ("NoiseFigure",
@@ -212,7 +216,7 @@
                    " are connected to sources at the standard noise temperature T0.\" "
                    "In this model, we consider T0 = 290K.",
                    DoubleValue (9.0),
-                   MakeDoubleAccessor (&LteUePhy::SetNoiseFigure, 
+                   MakeDoubleAccessor (&LteUePhy::SetNoiseFigure,
                                        &LteUePhy::GetNoiseFigure),
                    MakeDoubleChecker<double> ())
     .AddAttribute ("TxMode1Gain",
@@ -325,7 +329,7 @@
   else
     {
       Simulator::ScheduleNow (&LteUePhy::SubframeIndication, this, 1, 1);
-    }  
+    }
   LtePhy::DoInitialize ();
 }
 
@@ -477,7 +481,7 @@
 LteUePhy::GenerateCtrlCqiReport (const SpectrumValue& sinr)
 {
   NS_LOG_FUNCTION (this);
-  
+
   GenerateCqiRsrpRsrq (sinr);
 }
 
@@ -494,7 +498,7 @@
       // check periodic wideband CQI
       if (Simulator::Now () > m_p10CqiLast + m_p10CqiPeriodicity)
         {
-          Ptr<LteUeNetDevice> thisDevice = GetDevice ()->GetObject<LteUeNetDevice> ();
+          //Ptr<LteUeNetDevice> thisDevice = GetDevice ()->GetObject<LteUeNetDevice> ();
           Ptr<DlCqiLteControlMessage> msg = CreateDlCqiFeedbackMessage (sinr);
           if (msg)
             {
@@ -505,7 +509,7 @@
       // check aperiodic high-layer configured subband CQI
       if  (Simulator::Now () > m_a30CqiLast + m_a30CqiPeriodicity)
         {
-          Ptr<LteUeNetDevice> thisDevice = GetDevice ()->GetObject<LteUeNetDevice> ();
+          //Ptr<LteUeNetDevice> thisDevice = GetDevice ()->GetObject<LteUeNetDevice> ();
           Ptr<DlCqiLteControlMessage> msg = CreateDlCqiFeedbackMessage (sinr);
           if (msg)
             {
@@ -527,8 +531,8 @@
       for (it = m_rsReceivedPower.ConstValuesBegin (); it != m_rsReceivedPower.ConstValuesEnd (); it++)
         {
           // convert PSD [W/Hz] to linear power [W] for the single RE
-          // we consider only one RE for the RS since the channel is 
-          // flat within the same RB 
+          // we consider only one RE for the RS since the channel is
+          // flat within the same RB
           double powerTxW = ((*it) * 180000.0) / 12.0;
           sum += powerTxW;
           rbNum++;
@@ -644,13 +648,13 @@
   uint32_t modulo = m_dlBandwidth % rbgSize;
   double avgMixedSinr = 0;
   uint32_t usedRbgNum = 0;
-  for(uint32_t i = 0; i < (m_dlBandwidth-1-modulo); i++) 
+  for(uint32_t i = 0; i < (m_dlBandwidth-1-modulo); i++)
     {
       usedRbgNum++;
       avgMixedSinr+=mixedSinr[i];
     }
   avgMixedSinr = avgMixedSinr/usedRbgNum;
-  for(uint32_t i = 0; i < modulo; i++) 
+  for(uint32_t i = 0; i < modulo; i++)
     {
       mixedSinr[m_dlBandwidth-1-i] = avgMixedSinr;
     }
@@ -731,7 +735,7 @@
               cqiSum += cqi.at (i);
               activeSubChannels++;
             }
-          NS_LOG_DEBUG (this << " subch " << i << " cqi " <<  cqi.at (i));
+          //NS_LOG_DEBUG (this << " subch " << i << " cqi " <<  cqi.at (i));
         }
       dlcqi.m_rnti = m_rnti;
       dlcqi.m_ri = 1; // not yet used
@@ -851,7 +855,7 @@
   SetControlMessages (msg);
 }
 
-void 
+void
 LteUePhy::DoSendRachPreamble (uint32_t raPreambleId, uint32_t raRnti)
 {
   NS_LOG_FUNCTION (this << raPreambleId);
@@ -871,7 +875,6 @@
   NS_LOG_FUNCTION (this);
 
   std::list<Ptr<LteControlMessage> >::iterator it;
-  NS_LOG_DEBUG (this << " I am rnti = " << m_rnti << " and I received msgs " << (uint16_t) msgList.size ());
   for (it = msgList.begin (); it != msgList.end (); it++)
     {
       Ptr<LteControlMessage> msg = (*it);
@@ -915,7 +918,7 @@
 
 
           // send TB info to LteSpectrumPhy
-          NS_LOG_DEBUG (this << " UE " << m_rnti << " DL-DCI " << dci.m_rnti << " bitmap "  << dci.m_rbBitmap);
+          //NS_LOG_DEBUG (this << " UE " << m_rnti << " DL-DCI " << dci.m_rnti << " bitmap "  << dci.m_rbBitmap);
           for (uint8_t i = 0; i < dci.m_tbsSize.size (); i++)
             {
               m_downlinkSpectrumPhy->AddExpectedTb (dci.m_rnti, dci.m_ndi.at (i), dci.m_tbsSize.at (i), dci.m_mcs.at (i), dlRb, i, dci.m_harqProcess, dci.m_rv.at (i), true /* DL */);
@@ -964,6 +967,7 @@
       else if (msg->GetMessageType () == LteControlMessage::RAR)
         {
           Ptr<RarLteControlMessage> rarMsg = DynamicCast<RarLteControlMessage> (msg);
+          NS_LOG_INFO("Rx rar in LteUePhy, rarMsg rnti " << rarMsg->GetRaRnti() << " m_raRnti " << m_raRnti);
           if (rarMsg->GetRaRnti () == m_raRnti)
             {
               for (std::list<RarLteControlMessage::Rar>::const_iterator it = rarMsg->RarListBegin (); it != rarMsg->RarListEnd (); ++it)
@@ -1086,6 +1090,8 @@
   NS_LOG_FUNCTION (this << frameNo << subframeNo);
 
   NS_ASSERT_MSG (frameNo > 0, "the SRS index check code assumes that frameNo starts at 1");
+  NS_LOG_INFO ("Lte UE " << m_rnti << " frame " << frameNo << " subframe " << subframeNo);
+
 
   // refresh internal variables
   m_rsReceivedPowerUpdated = false;
@@ -1112,7 +1118,7 @@
           if ((((frameNo-1)*10 + (subframeNo-1)) % m_srsPeriodicity) == m_srsSubframeOffset)
             {
               NS_LOG_INFO ("frame " << frameNo << " subframe " << subframeNo << " sending SRS (offset=" << m_srsSubframeOffset << ", period=" << m_srsPeriodicity << ")");
-              m_sendSrsEvent = Simulator::Schedule (UL_SRS_DELAY_FROM_SUBFRAME_START, 
+              m_sendSrsEvent = Simulator::Schedule (UL_SRS_DELAY_FROM_SUBFRAME_START,
                                                     &LteUePhy::SendSrs,
                                                     this);
             }
@@ -1301,7 +1307,7 @@
 }
 
 
-void 
+void
 LteUePhy::DoConfigureUplink (uint32_t ulEarfcn, uint8_t ulBandwidth)
 {
   m_ulEarfcn = ulEarfcn;
@@ -1315,7 +1321,7 @@
   NS_LOG_FUNCTION (this);
   m_powerControl->ConfigureReferenceSignalPower (referenceSignalPower);
 }
- 
+
 void
 LteUePhy::DoSetRnti (uint16_t rnti)
 {
@@ -1325,7 +1331,7 @@
   m_powerControl->SetCellId (m_cellId);
   m_powerControl->SetRnti (m_rnti);
 }
- 
+
 void
 LteUePhy::DoSetTransmissionMode (uint8_t txMode)
 {
@@ -1345,7 +1351,7 @@
   // a guard time is needed for the case where the SRS periodicity is changed dynamically at run time
   // if we use a static one, we can have a 0ms guard time
   m_srsStartTime = Simulator::Now () + MilliSeconds (0);
-  NS_LOG_DEBUG (this << " UE SRS P " << m_srsPeriodicity << " RNTI " << m_rnti << " offset " << m_srsSubframeOffset << " cellId " << m_cellId << " CI " << srcCi);
+  //NS_LOG_DEBUG (this << " UE SRS P " << m_srsPeriodicity << " RNTI " << m_rnti << " offset " << m_srsSubframeOffset << " cellId " << m_cellId << " CI " << srcCi);
 }
 
 void
@@ -1355,43 +1361,43 @@
   m_paLinear = pow (10,(pa/10));
 }
 
-void 
+void
 LteUePhy::SetTxMode1Gain (double gain)
 {
   SetTxModeGain (1, gain);
 }
 
-void 
+void
 LteUePhy::SetTxMode2Gain (double gain)
 {
   SetTxModeGain (2, gain);
 }
 
-void 
+void
 LteUePhy::SetTxMode3Gain (double gain)
 {
   SetTxModeGain (3, gain);
 }
 
-void 
+void
 LteUePhy::SetTxMode4Gain (double gain)
 {
   SetTxModeGain (4, gain);
 }
 
-void 
+void
 LteUePhy::SetTxMode5Gain (double gain)
 {
   SetTxModeGain (5, gain);
 }
 
-void 
+void
 LteUePhy::SetTxMode6Gain (double gain)
 {
   SetTxModeGain (6, gain);
 }
 
-void 
+void
 LteUePhy::SetTxMode7Gain (double gain)
 {
   SetTxModeGain (7, gain);
diff -Naru a/model/lte-ue-phy.h b/model/lte-ue-phy.h
--- a/model/lte-ue-phy.h	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-ue-phy.h	2018-08-03 16:39:02.895957709 +0200
@@ -92,7 +92,7 @@
 
   /**
    * \brief Get the PHY SAP provider
-   * \return a pointer to the SAP Provider 
+   * \return a pointer to the SAP Provider
    */
   LteUePhySapProvider* GetLteUePhySapProvider ();
 
@@ -287,7 +287,7 @@
    */
   typedef void (* RsrpSinrTracedCallback)
     (uint16_t cellId, uint16_t rnti,
-     double rsrp, double sinr, uint8_t componentCarrierId);
+      double rsrp, double sinr, uint8_t componentCarrierId);
 
   /**
    * TracedCallback signature for cell RSRP and RSRQ.
@@ -363,11 +363,11 @@
   void QueueSubChannelsForTransmission (std::vector <int> rbMap);
 
 
-  /** 
+  /**
    * internal method that takes care of generating CQI reports,
    * calculating the RSRP and RSRQ metrics, and generating RSRP+SINR traces
-   * 
-   * \param sinr 
+   *
+   * \param sinr
    */
   void GenerateCqiRsrpRsrq (const SpectrumValue& sinr);
 
@@ -443,10 +443,10 @@
    */
   void DoSetPa (double pa);
 
-  // UE PHY SAP methods 
+  // UE PHY SAP methods
   virtual void DoSendMacPdu (Ptr<Packet> p);
   /**
-   * Send LTE control message function
+   * Send LTE conrol message function
    * \param msg the LTE control message
    */
   virtual void DoSendLteControlMessage (Ptr<LteControlMessage> msg);
@@ -494,7 +494,7 @@
   LteUeCphySapUser* m_ueCphySapUser; ///< UE CPhy SAP user
 
   uint16_t  m_rnti; ///< the RNTI
- 
+
   uint8_t m_transmissionMode; ///< the transmission mode
   std::vector <double> m_txModeGain; ///< the transmit mode gain
 
@@ -530,7 +530,7 @@
 
   bool m_pssReceived; ///< PSS received?
   /// PssElement structure
-  struct PssElement 
+  struct PssElement
   {
     uint16_t cellId; ///< cell ID
     double pssPsdSum; ///< PSS PSD sum
@@ -605,9 +605,9 @@
    */
   TracedCallback<PhyTransmissionStatParameters> m_ulPhyTransmission;
 
-  
+
   Ptr<SpectrumValue> m_noisePsd; ///< Noise power spectral density for
-                                 ///the configured bandwidth 
+                                 ///the configured bandwidth
 
 }; // end of `class LteUePhy`
 
diff -Naru a/model/lte-ue-phy-sap.h b/model/lte-ue-phy-sap.h
--- a/model/lte-ue-phy-sap.h	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-ue-phy-sap.h	2018-08-03 16:39:02.895957709 +0200
@@ -53,9 +53,9 @@
   */
   virtual void SendLteControlMessage (Ptr<LteControlMessage> msg) = 0;
 
-  /** 
+  /**
    * send a preamble on the PRACH
-   * 
+   *
    * \param prachId the ID of the preamble
    * \param raRnti the RA rnti
    */
diff -Naru a/model/lte-ue-rrc.cc b/model/lte-ue-rrc.cc
--- a/model/lte-ue-rrc.cc	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-ue-rrc.cc	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011, 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, 2018, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -20,6 +21,10 @@
  * Modified by:
  *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
  *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
+ * Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+ *							Integration of Carrier Aggregation for the mmWave module
  */
 
 #include "lte-ue-rrc.h"
@@ -35,7 +40,17 @@
 #include <ns3/lte-rlc-um.h>
 #include <ns3/lte-rlc-am.h>
 #include <ns3/lte-pdcp.h>
+#include <ns3/mc-ue-pdcp.h>
 #include <ns3/lte-radio-bearer-info.h>
+#include <ns3/lte-ue-mac.h>
+#include <ns3/lte-rlc-am-header.h>
+
+#include <ns3/lte-rlc-sdu-status-tag.h>
+#include <ns3/lte-pdcp-header.h>
+#include <ns3/lte-rlc-um-lowlat.h>
+#include "ns3/lte-pdcp-tag.h"
+#include <ns3/lte-rlc-sap.h>
+
 
 #include <cmath>
 
@@ -146,6 +161,7 @@
     m_hasReceivedSib1 (false),
     m_hasReceivedSib2 (false),
     m_csgWhiteList (0),
+    m_ncRaStarted (true),
     m_numberOfComponentCarriers (MIN_NO_CC)
 {
   NS_LOG_FUNCTION (this);
@@ -153,6 +169,8 @@
   m_cmacSapUser.push_back (new UeMemberLteUeCmacSapUser (this));
   m_cphySapProvider.push_back(0);
   m_cmacSapProvider.push_back(0);
+  m_lteCmacSapProvider.push_back(0);
+  m_mmWaveCmacSapProvider.push_back(0);
   m_rrcSapProvider = new MemberLteUeRrcSapProvider<LteUeRrc> (this);
   m_drbPdcpSapUser = new LtePdcpSpecificLtePdcpSapUser<LteUeRrc> (this);
   m_asSapProvider = new MemberLteAsSapProvider<LteUeRrc> (this);
@@ -184,6 +202,7 @@
   m_cmacSapProvider.erase(m_cmacSapProvider.begin(), m_cmacSapProvider.end());
   m_cmacSapProvider.clear();
   m_drbMap.clear ();
+  m_rlcMap.clear ();
 }
 
 TypeId
@@ -197,6 +216,10 @@
                    ObjectMapValue (),
                    MakeObjectMapAccessor (&LteUeRrc::m_drbMap),
                    MakeObjectMapChecker<LteDataRadioBearerInfo> ())
+                   .AddAttribute ("DataRadioRlcMap", "List of UE RLC for Secondary Connection by LCID.",
+                                  ObjectMapValue (),
+                                  MakeObjectMapAccessor (&LteUeRrc::m_rlcMap),
+                                  MakeObjectMapChecker<RlcBearerInfo> ())
     .AddAttribute ("Srb0", "SignalingRadioBearerInfo for SRB0",
                    PointerValue (),
                    MakePointerAccessor (&LteUeRrc::m_srb0),
@@ -277,10 +300,28 @@
                      "trace fired upon failure of a handover procedure",
                      MakeTraceSourceAccessor (&LteUeRrc::m_handoverEndErrorTrace),
                      "ns3::LteUeRrc::ImsiCidRntiTracedCallback")
-    .AddTraceSource ("SCarrierConfigured",
-                     "trace fired after configuring secondary carriers",
-                     MakeTraceSourceAccessor (&LteUeRrc::m_sCarrierConfiguredTrace),
-                     "ns3::LteUeRrc::SCarrierConfiguredTracedCallback")
+     .AddTraceSource ("SCarrierConfigured",
+                      "trace fired after configuring secondary carriers",
+                      MakeTraceSourceAccessor (&LteUeRrc::m_sCarrierConfiguredTrace),
+                      "ns3::LteUeRrc::SCellConfiguredTracedCallback")
+     .AddTraceSource ("SwitchToLte",
+                      "trace fired upon switching to LTE RAT",
+                      MakeTraceSourceAccessor (&LteUeRrc::m_switchToLteTrace),
+                      "ns3::LteUeRrc::ImsiCidRntiTracedCallback")
+     .AddTraceSource ("SwitchToMmWave",
+                      "trace fired upon switching to MmWave RAT",
+                      MakeTraceSourceAccessor (&LteUeRrc::m_switchToMmWaveTrace),
+                      "ns3::LteUeRrc::ImsiCidRntiTracedCallback")
+     .AddAttribute ("SecondaryRRC",
+                      "True if this is the RRC in charge of the secondary cell (MmWaveCell) for a MC device",
+                      BooleanValue (false),
+                      MakeBooleanAccessor (&LteUeRrc::m_isSecondaryRRC),
+                      MakeBooleanChecker ())
+     .AddAttribute ("InterRatHoCapable",
+                      "True if this RRC supports hard handover between LTE and MmWave",
+                      BooleanValue (false),
+                      MakeBooleanAccessor (&LteUeRrc::m_interRatHoCapable),
+                      MakeBooleanChecker ())
   ;
   return tid;
 }
@@ -291,6 +332,7 @@
 {
   NS_LOG_FUNCTION (this << s);
   m_cphySapProvider.at(0) = s;
+  m_lteCphySapProvider.at(0) = s;
 }
 
 void
@@ -299,6 +341,12 @@
   NS_LOG_FUNCTION (this << s);
   m_cphySapProvider.at(index) = s;
 }
+void
+LteUeRrc::SetMmWaveUeCphySapProvider (LteUeCphySapProvider * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_mmWaveCphySapProvider.at(0) = s;
+}
 
 LteUeCphySapUser*
 LteUeRrc::GetLteUeCphySapUser ()
@@ -319,6 +367,7 @@
 {
   NS_LOG_FUNCTION (this << s);
   m_cmacSapProvider.at (0) = s;
+  m_lteCmacSapProvider.at (0) = s;
 }
 
 void
@@ -326,6 +375,21 @@
 {
   NS_LOG_FUNCTION (this << s);
   m_cmacSapProvider.at (index) = s;
+  m_lteCmacSapProvider.at (index) = s;
+}
+
+void
+LteUeRrc::SetMmWaveUeCmacSapProvider (LteUeCmacSapProvider * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_mmWaveCmacSapProvider.at(0) = s;
+}
+
+void
+LteUeRrc::SetMmWaveUeCmacSapProvider (LteUeCmacSapProvider * s, uint8_t index)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_mmWaveCmacSapProvider.at(index) = s;
 }
 
 LteUeCmacSapUser*
@@ -361,6 +425,14 @@
 {
   NS_LOG_FUNCTION (this << s);
   m_macSapProvider = s;
+  m_lteMacSapProvider = s;
+}
+
+void
+LteUeRrc::SetMmWaveMacSapProvider (LteMacSapProvider * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_mmWaveMacSapProvider = s;
 }
 
 void
@@ -383,13 +455,13 @@
   m_asSapUser = s;
 }
 
-LteAsSapProvider* 
+LteAsSapProvider*
 LteUeRrc::GetAsSapProvider ()
 {
   return m_asSapProvider;
 }
 
-void 
+void
 LteUeRrc::SetImsi (uint64_t imsi)
 {
   NS_LOG_FUNCTION (this << imsi);
@@ -416,15 +488,89 @@
   return m_cellId;
 }
 
+void
+LteUeRrc::AddMmWaveCellId(uint16_t cellId)
+{
+  NS_LOG_FUNCTION(this);
+  NS_ASSERT_MSG(m_interRatHoCapable, "Trying to setup unnecessary information on a non interRatHoCapable device");
+  if(m_isMmWaveCellMap.find(cellId) == m_isMmWaveCellMap.end())
+  {
+    m_isMmWaveCellMap.insert(std::pair<uint16_t, bool> (cellId, true));
+  }
+  else // modify
+  {
+    m_isMmWaveCellMap.find(cellId)->second = true;
+  }
+}
 
-uint8_t 
+void
+LteUeRrc::AddLteCellId(uint16_t cellId)
+{
+  NS_LOG_FUNCTION(this);
+  NS_ASSERT_MSG(m_interRatHoCapable, "Trying to setup unnecessary information on a non interRatHoCapable device");
+  if(m_isMmWaveCellMap.find(cellId) == m_isMmWaveCellMap.end())
+  {
+    m_isMmWaveCellMap.insert(std::pair<uint16_t, bool> (cellId, false));
+  }
+  else // modify
+  {
+    m_isMmWaveCellMap.find(cellId)->second = false;
+  }
+}
+
+bool
+LteUeRrc::SwitchLowerLayerProviders (uint16_t cellId)
+{
+  if(m_isMmWaveCellMap.find(cellId) != m_isMmWaveCellMap.end())
+  {
+    if(m_isMmWaveCellMap.find(cellId)->second)
+    {
+      NS_LOG_INFO("Switch SAP to MmWave");
+      //NS_LOG_LOGIC("Before switch " << m_cphySapProvider << m_cmacSapProvider << m_macSapProvider);
+      m_cphySapProvider = m_mmWaveCphySapProvider;
+      m_cmacSapProvider = m_mmWaveCmacSapProvider;
+      m_macSapProvider = m_mmWaveMacSapProvider;
+
+      m_hasReceivedSib2 = false;
+      //NS_LOG_LOGIC("After switch " << m_cphySapProvider << m_cmacSapProvider << m_macSapProvider);
+      return true;
+    }
+    else
+    {
+      NS_LOG_INFO("Switch SAP to LTE");
+      //NS_LOG_LOGIC("Before switch " << m_cphySapProvider << m_cmacSapProvider << m_macSapProvider);
+      m_cphySapProvider = m_lteCphySapProvider;
+      m_cmacSapProvider = m_lteCmacSapProvider;
+      m_macSapProvider = m_lteMacSapProvider;
+
+      m_hasReceivedSib2 = false;
+
+      //NS_LOG_LOGIC("After switch " << m_cphySapProvider << m_cmacSapProvider << m_macSapProvider);
+      return true;
+    }
+  }
+  else
+  {
+    if(m_interRatHoCapable)
+    {
+      NS_FATAL_ERROR("Unkown cell, set it up in the helper!");
+    }
+    else
+    {
+      // do nothing, always use the ones set at the beginning
+      return false;
+    }
+  }
+}
+
+uint8_t
 LteUeRrc::GetUlBandwidth () const
 {
   NS_LOG_FUNCTION (this);
   return m_ulBandwidth;
 }
 
-uint8_t 
+uint8_t
 LteUeRrc::GetDlBandwidth () const
 {
   NS_LOG_FUNCTION (this);
@@ -437,7 +583,7 @@
   return m_dlEarfcn;
 }
 
-uint32_t 
+uint32_t
 LteUeRrc::GetUlEarfcn () const
 {
   NS_LOG_FUNCTION (this);
@@ -452,13 +598,12 @@
 }
 
 void
-LteUeRrc::SetUseRlcSm (bool val) 
+LteUeRrc::SetUseRlcSm (bool val)
 {
   NS_LOG_FUNCTION (this);
   m_useRlcSm = val;
 }
 
-
 void
 LteUeRrc::DoInitialize (void)
 {
@@ -486,7 +631,17 @@
   lcConfig.prioritizedBitRateKbps = 65535; // maximum
   lcConfig.bucketSizeDurationMs = 65535; // maximum
   lcConfig.logicalChannelGroup = 0; // all SRBs mapped to LCG 0
-  m_cmacSapProvider.at(0)->AddLc (lcid, lcConfig, rlc->GetLteMacSapUser ());
+
+
+  if(m_interRatHoCapable)
+  {
+    m_mmWaveCmacSapProvider.at(0)->AddLc (lcid, lcConfig, rlc->GetLteMacSapUser ());
+    m_lteCmacSapProvider.at(0)->AddLc (lcid, lcConfig, rlc->GetLteMacSapUser ());
+  }
+  else
+  {
+    m_cmacSapProvider.at(0)->AddLc (lcid, lcConfig, rlc->GetLteMacSapUser ());
+  }
 }
 
 void
@@ -499,7 +654,7 @@
       // is not set and then an error is raised
       // In this case m_numberOfComponentCarriers is set to 1
       m_numberOfComponentCarriers = MIN_NO_CC;
-    }
+    } 
   if (m_numberOfComponentCarriers > MIN_NO_CC )
     {
       for ( uint16_t i = 1; i < m_numberOfComponentCarriers; i++)
@@ -508,6 +663,16 @@
           m_cmacSapUser.push_back(new UeMemberLteUeCmacSapUser (this));
           m_cphySapProvider.push_back(0);
           m_cmacSapProvider.push_back(0);
+          m_lteCmacSapProvider.push_back(0);
+        }
+    }
+
+  // this is executed if the UE is MC
+  if (m_numberOfMmWaveComponentCarriers > MIN_NO_MMW_CC )
+    {
+      for ( uint16_t i = 1; i < m_numberOfMmWaveComponentCarriers; i++)
+        {
+          m_mmWaveCmacSapProvider.push_back(0);
         }
     }
 }
@@ -574,6 +739,15 @@
 }
 
 void
+LteUeRrc::DoNotifySecondaryCellConnected(uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+  m_mmWaveCellId = mmWaveCellId;
+  m_mmWaveRnti = mmWaveRnti;
+  NS_LOG_FUNCTION(this);
+  m_rrcSapUser->SendNotifySecondaryCellConnected(mmWaveRnti, mmWaveCellId);
+}
+
+void
 LteUeRrc::DoReceivePdcpSdu (LtePdcpSapUser::ReceivePdcpSduParameters params)
 {
   NS_LOG_FUNCTION (this);
@@ -591,6 +765,12 @@
 }
 
 void
+LteUeRrc::DoNotifyRadioLinkFailure (double lastSinrValue)
+{
+  NS_LOG_DEBUG("Rlf");
+}
+
+void
 LteUeRrc::DoNotifyRandomAccessSuccessful ()
 {
   NS_LOG_FUNCTION (this << m_imsi << ToString (m_state));
@@ -601,11 +781,12 @@
     case IDLE_RANDOM_ACCESS:
       {
         // we just received a RAR with a T-C-RNTI and an UL grant
-        // send RRC connection request as message 3 of the random access procedure 
+        // send RRC connection request as message 3 of the random access procedure
         SwitchToState (IDLE_CONNECTING);
         LteRrcSap::RrcConnectionRequest msg;
         msg.ueIdentity = m_imsi;
-        m_rrcSapUser->SendRrcConnectionRequest (msg); 
+        msg.isMc = m_isSecondaryRRC;
+        m_rrcSapUser->SendRrcConnectionRequest (msg);
         m_connectionTimeout = Simulator::Schedule (m_t300,
                                                    &LteUeRrc::ConnectionTimeout,
                                                    this);
@@ -629,12 +810,18 @@
 
         SwitchToState (CONNECTED_NORMALLY);
         m_handoverEndOkTrace (m_imsi, m_cellId, m_rnti);
+        if(m_isSecondaryRRC) // an handover for secondary cells has happened.
+        // this trace is used to keep a consistent trace of the cell to which the UE is connected
+        {
+          NS_LOG_UNCOND("DoNotifyRandomAccessSuccessful at time " << Simulator::Now().GetSeconds());
+          m_switchToMmWaveTrace(m_imsi, m_cellId, m_rnti);
+        }
       }
       break;
 
     default:
       NS_FATAL_ERROR ("unexpected event in state " << ToString (m_state));
-      break; 
+      break;
     }
 }
 
@@ -678,7 +865,7 @@
   m_csgWhiteList = csgId;
 }
 
-void 
+void
 LteUeRrc::DoStartCellSelection (uint32_t dlEarfcn)
 {
   NS_LOG_FUNCTION (this << m_imsi << dlEarfcn);
@@ -689,7 +876,7 @@
   SwitchToState (IDLE_CELL_SEARCH);
 }
 
-void 
+void
 LteUeRrc::DoForceCampedOnEnb (uint16_t cellId, uint32_t dlEarfcn)
 {
   NS_LOG_FUNCTION (this << m_imsi << cellId << dlEarfcn);
@@ -698,6 +885,8 @@
     {
     case IDLE_START:
       m_cellId = cellId;
+      SwitchLowerLayerProviders(m_cellId); // for InterRat HO
+
       m_dlEarfcn = dlEarfcn;
       m_cphySapProvider.at(0)->SynchronizeWithEnb (m_cellId, m_dlEarfcn);
       SwitchToState (IDLE_WAIT_MIB);
@@ -779,7 +968,7 @@
 void
 LteUeRrc::DoRecvMasterInformationBlock (uint16_t cellId,
                                         LteRrcSap::MasterInformationBlock msg)
-{ 
+{
   m_dlBandwidth = msg.dlBandwidth;
   m_cphySapProvider.at(0)->SetDlBandwidth (msg.dlBandwidth);
   m_hasReceivedMib = true;
@@ -861,7 +1050,7 @@
           // in this case the measurement received is related to secondary carriers
           // measurements related to secondary carriers are saved on a different portion of memory
           SaveScellUeMeasurements (newMeasIt->m_cellId, newMeasIt->m_rsrp,
-                                   newMeasIt->m_rsrq, useLayer3Filtering, 
+                                   newMeasIt->m_rsrq, useLayer3Filtering,
                                    params.m_componentCarrierId );
         }
       else
@@ -907,7 +1096,7 @@
 }
 
 
-void 
+void
 LteUeRrc::DoRecvSystemInformation (LteRrcSap::SystemInformation msg)
 {
   NS_LOG_FUNCTION (this << " RNTI " << m_rnti);
@@ -940,6 +1129,12 @@
               NS_ASSERT (m_connectionPending);
               StartConnection ();
             }
+          if (m_state == CONNECTED_HANDOVER && m_interRatHoCapable && !m_ncRaStarted)
+            {
+              m_ncRaStarted = true;
+              NS_LOG_INFO("StartNonContentionBasedRandomAccessProcedure after SIB2 received at time " << Simulator::Now());
+              m_cmacSapProvider.at(0)->StartNonContentionBasedRandomAccessProcedure (m_rnti, m_rachConfigDedicated.raPreambleIndex, m_rachConfigDedicated.raPrachMaskIndex);
+            }
           break;
 
         default: // IDLE_START, IDLE_CELL_SEARCH, IDLE_WAIT_MIB, IDLE_WAIT_MIB_SIB1, IDLE_WAIT_SIB1
@@ -951,7 +1146,7 @@
 }
 
 
-void 
+void
 LteUeRrc::DoRecvRrcConnectionSetup (LteRrcSap::RrcConnectionSetup msg)
 {
   NS_LOG_FUNCTION (this << " RNTI " << m_rnti);
@@ -965,7 +1160,7 @@
         LteRrcSap::RrcConnectionSetupCompleted msg2;
         msg2.rrcTransactionIdentifier = msg.rrcTransactionIdentifier;
         m_rrcSapUser->SendRrcConnectionSetupCompleted (msg2);
-        m_asSapUser->NotifyConnectionSuccessful ();
+        m_asSapUser->NotifyConnectionSuccessful (m_rnti);
         m_connectionEstablishedTrace (m_imsi, m_cellId, m_rnti);
       }
       break;
@@ -977,6 +1172,13 @@
 }
 
 void
+LteUeRrc::DoRecvRrcConnectToMmWave (uint16_t mmWaveCellId)
+{
+  NS_LOG_FUNCTION(this << "cellId "<< mmWaveCellId);
+  m_asSapUser->NotifyConnectToMmWave(mmWaveCellId);
+}
+
+void
 LteUeRrc::DoRecvRrcConnectionReconfiguration (LteRrcSap::RrcConnectionReconfiguration msg)
 {
   NS_LOG_FUNCTION (this << " RNTI " << m_rnti);
@@ -986,22 +1188,32 @@
     case CONNECTED_NORMALLY:
       if (msg.haveMobilityControlInfo)
         {
-          NS_LOG_INFO ("haveMobilityControlInfo == true");
+          NS_LOG_INFO ("UE " << m_rnti << " on cellId " << m_cellId << " haveMobilityControlInfo == true");
           SwitchToState (CONNECTED_HANDOVER);
           const LteRrcSap::MobilityControlInfo& mci = msg.mobilityControlInfo;
           m_handoverStartTrace (m_imsi, m_cellId, m_rnti, mci.targetPhysCellId);
           m_cmacSapProvider.at(0)->Reset ();
           m_cphySapProvider.at(0)->Reset ();
           m_cellId = mci.targetPhysCellId;
+          SwitchLowerLayerProviders(m_cellId); // for InterRat HO
           NS_ASSERT (mci.haveCarrierFreq);
           NS_ASSERT (mci.haveCarrierBandwidth);
           m_cphySapProvider.at(0)->SynchronizeWithEnb (m_cellId, mci.carrierFreq.dlCarrierFreq);
           m_cphySapProvider.at(0)->SetDlBandwidth ( mci.carrierBandwidth.dlBandwidth);
           m_cphySapProvider.at(0)->ConfigureUplink (mci.carrierFreq.ulCarrierFreq, mci.carrierBandwidth.ulBandwidth);
+          uint16_t oldRnti = m_rnti;
           m_rnti = msg.mobilityControlInfo.newUeIdentity;
           m_srb0->m_rlc->SetRnti (m_rnti);
           NS_ASSERT_MSG (mci.haveRachConfigDedicated, "handover is only supported with non-contention-based random access procedure");
-          m_cmacSapProvider.at(0)->StartNonContentionBasedRandomAccessProcedure (m_rnti, mci.rachConfigDedicated.raPreambleIndex, mci.rachConfigDedicated.raPrachMaskIndex);
+          if(m_interRatHoCapable)
+          {
+            m_rachConfigDedicated = mci.rachConfigDedicated;
+            m_ncRaStarted = false;
+          }
+          else
+          {
+            m_cmacSapProvider.at(0)->StartNonContentionBasedRandomAccessProcedure (m_rnti, mci.rachConfigDedicated.raPreambleIndex, mci.rachConfigDedicated.raPrachMaskIndex);
+          }
           m_cphySapProvider.at(0)->SetRnti (m_rnti);
           m_lastRrcTransactionIdentifier = msg.rrcTransactionIdentifier;
           NS_ASSERT (msg.haveRadioResourceConfigDedicated);
@@ -1015,7 +1227,29 @@
           m_srb1 = 0; // new instance will be be created within ApplyRadioResourceConfigDedicated
 
           m_drbMap.clear (); // dispose all DRBs
-          ApplyRadioResourceConfigDedicated (msg.radioResourceConfigDedicated);
+          m_rlcMap.clear (); // dispose all MmWave RLCs
+
+          if(!m_isSecondaryRRC)
+          {
+            ApplyRadioResourceConfigDedicated (msg.radioResourceConfigDedicated);
+          }
+          else
+          {
+            if (msg.haveNonCriticalExtension)
+              {
+                ApplyRadioResourceConfigDedicatedSecondaryCarrier (msg.nonCriticalExtension);
+                NS_LOG_DEBUG ( this << "RNTI " << m_rnti << " Configured for CA" );
+              }
+            // this is the secondary mmWave RRC. When a secondary HO happens,
+            // the primary LTE RRC must be notified in order to update the RLC instances
+            // Forward this message to EpcUeNas and then to LteUeRrc for LTE RRC
+            m_asSapUser->NotifySecondaryCellHandoverStarted(oldRnti, m_rnti, m_cellId, msg.radioResourceConfigDedicated);
+            msg.radioResourceConfigDedicated.drbToAddModList.clear(); // remove the drb list, since no Data RLC must be setup in this RRC
+            // setup SRB1
+            ApplyRadioResourceConfigDedicated (msg.radioResourceConfigDedicated);
+          }
+
+
 
           if (msg.haveMeasConfig)
             {
@@ -1026,7 +1260,7 @@
         }
       else
         {
-          NS_LOG_INFO ("haveMobilityControlInfo == false");
+          NS_LOG_INFO ("UE " << m_rnti << " on cellId " << m_cellId << " haveMobilityControlInfo == false");
           if (msg.haveNonCriticalExtension)
             {
               ApplyRadioResourceConfigDedicatedSecondaryCarrier (msg.nonCriticalExtension);
@@ -1035,7 +1269,7 @@
           if (msg.haveRadioResourceConfigDedicated)
             {
               ApplyRadioResourceConfigDedicated (msg.radioResourceConfigDedicated);
-            } 
+            }
           if (msg.haveMeasConfig)
             {
               ApplyMeasConfig (msg.measConfig);
@@ -1053,7 +1287,7 @@
     }
 }
 
-void 
+void
 LteUeRrc::DoRecvRrcConnectionReestablishment (LteRrcSap::RrcConnectionReestablishment msg)
 {
   NS_LOG_FUNCTION (this << " RNTI " << m_rnti);
@@ -1077,7 +1311,7 @@
     }
 }
 
-void 
+void
 LteUeRrc::DoRecvRrcConnectionReestablishmentReject (LteRrcSap::RrcConnectionReestablishmentReject msg)
 {
   NS_LOG_FUNCTION (this << " RNTI " << m_rnti);
@@ -1099,14 +1333,14 @@
     }
 }
 
-void 
+void
 LteUeRrc::DoRecvRrcConnectionRelease (LteRrcSap::RrcConnectionRelease msg)
 {
   NS_LOG_FUNCTION (this << " RNTI " << m_rnti);
   /// \todo Currently not implemented, see Section 5.3.8 of 3GPP TS 36.331.
 }
 
-void 
+void
 LteUeRrc::DoRecvRrcConnectionReject (LteRrcSap::RrcConnectionReject msg)
 {
   NS_LOG_FUNCTION (this);
@@ -1118,6 +1352,456 @@
   m_asSapUser->NotifyConnectionFailed ();  // inform upper layer
 }
 
+void
+LteUeRrc::DoRecvRrcConnectionSwitch (LteRrcSap::RrcConnectionSwitch msg)
+{
+  NS_LOG_INFO("Recv RRC Connection Switch on rnti " << m_rnti << " of cell " << m_cellId << " m_mmWaveCellId " << m_mmWaveCellId << " in state " << ToString(m_state));
+  std::vector<uint8_t> drbidList = msg.drbidList;
+  for(std::vector<uint8_t>::iterator iter = drbidList.begin(); iter != drbidList.end(); ++iter)
+  {
+    if(m_drbMap.find(*iter) != m_drbMap.end())
+    {
+      Ptr<McUePdcp> pdcp = DynamicCast<McUePdcp>(m_drbMap.find(*iter)->second->m_pdcp);
+      if(pdcp != 0)
+      {
+        pdcp->SwitchConnection(msg.useMmWaveConnection);
+
+        if(msg.useMmWaveConnection) // I was on LTE, now I switch to mmWave
+        {
+          uint8_t lcid = m_drbMap.find(*iter)->second->m_logicalChannelIdentity;
+          //m_cmacSapProvider->RemoveLc (lcid);
+          //Remove LCID
+          for (uint32_t i = 0; i < m_numberOfComponentCarriers; i++)
+           {
+             m_cmacSapProvider.at (i)->RemoveLc (lcid);
+           }
+
+          // before resetting the RLC, forward the content of the LTE RLC to the mmWave RLC
+          // check if this rlc is already in the map
+          if(m_drbMap.find(*iter) != m_drbMap.end())
+          {
+            // get the RLC buffer content and forward it to the m_rlcMap RLC!
+            CopyRlcBuffers(m_drbMap.find(*iter)->second->m_rlc, pdcp, lcid);
+          }
+
+          // reset the LTE RLC
+          TypeId rlcTypeId;
+          if (m_useRlcSm)
+            {
+              rlcTypeId = LteRlcSm::GetTypeId ();
+            }
+          else
+            {
+              switch (m_drbMap.find(*iter)->second->m_rlcConfig.choice)
+                {
+                case LteRrcSap::RlcConfig::AM:
+                  rlcTypeId = LteRlcAm::GetTypeId ();
+                  break;
+
+                case LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL:
+                  rlcTypeId = LteRlcUm::GetTypeId ();
+                  break;
+
+                default:
+                  NS_FATAL_ERROR ("unsupported RLC configuration");
+                  break;
+                }
+            }
+
+          ObjectFactory rlcObjectFactory;
+          rlcObjectFactory.SetTypeId (rlcTypeId);
+          Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+          rlc->SetLteMacSapProvider (m_macSapProvider);
+          rlc->SetRnti (m_rnti);
+          rlc->SetLcId (lcid);
+
+
+          m_drbMap.find(*iter)->second->m_rlc = rlc;
+
+          // we need PDCP only for real RLC, i.e., RLC/UM or RLC/AM
+          // if we are using RLC/SM we don't care of anything above RLC
+          if (rlcTypeId != LteRlcSm::GetTypeId ())
+            {
+              pdcp->SetLteRlcSapProvider (rlc->GetLteRlcSapProvider ());
+              rlc->SetLteRlcSapUser (pdcp->GetLteRlcSapUser ());
+            }
+
+          struct LteUeCmacSapProvider::LogicalChannelConfig lcConfig;
+          lcConfig.priority = m_drbMap.find(*iter)->second->m_logicalChannelConfig.priority;
+          lcConfig.prioritizedBitRateKbps = m_drbMap.find(*iter)->second->m_logicalChannelConfig.prioritizedBitRateKbps;
+          lcConfig.bucketSizeDurationMs =   m_drbMap.find(*iter)->second->m_logicalChannelConfig.bucketSizeDurationMs;
+          lcConfig.logicalChannelGroup =    m_drbMap.find(*iter)->second->m_logicalChannelConfig.logicalChannelGroup;
+
+          //m_cmacSapProvider->AddLc (lcid,
+          //                          lcConfig,
+          //                          rlc->GetLteMacSapUser ());
+          for (uint32_t i = 0; i < m_numberOfComponentCarriers; i++)
+          {
+            m_cmacSapProvider.at (i)->AddLc (lcid,
+                                    lcConfig,
+                                    rlc->GetLteMacSapUser ());
+          }
+          rlc->Initialize ();
+
+        }
+        else // I was on mmWave, and I switch to LTE
+        {
+          //m_mmWaveCmacSapProvider->RemoveLc(m_rlcMap.find(*iter)->second->logicalChannelIdentity);
+          //Remove LCID
+          for (uint32_t i = 0; i < m_numberOfMmWaveComponentCarriers; i++)
+           {
+             m_mmWaveCmacSapProvider.at (i)->RemoveLc (m_rlcMap.find(*iter)->second->logicalChannelIdentity);
+           }
+
+          // before resetting, forward the content of the RLC in m_rlcMap to the RLC in m_drbMap
+          if(m_rlcMap.find(*iter) != m_rlcMap.end())
+          {
+            // get the RLC buffer content and store it in this RLC
+            CopyRlcBuffers(m_rlcMap.find(*iter)->second->m_rlc, pdcp, m_rlcMap.find(*iter)->second->logicalChannelIdentity);
+          }
+
+          // create Rlc
+          TypeId rlcTypeId;
+          if (m_useRlcSm)
+            {
+              rlcTypeId = LteRlcSm::GetTypeId ();
+              NS_LOG_INFO("SM");
+            }
+          else
+            {
+              switch (m_rlcMap.find(*iter)->second->rlcConfig.choice)
+                {
+                case LteRrcSap::RlcConfig::AM:
+                  rlcTypeId = LteRlcAm::GetTypeId ();
+                  NS_LOG_INFO("AM");
+                  break;
+
+                case LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL:
+                  rlcTypeId = LteRlcUm::GetTypeId ();
+                  NS_LOG_INFO("UM");
+                  break;
+
+                default:
+                  NS_FATAL_ERROR ("unsupported RLC configuration");
+                  break;
+                }
+            }
+
+          ObjectFactory rlcObjectFactory;
+          rlcObjectFactory.SetTypeId (rlcTypeId);
+          Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+          rlc->SetLteMacSapProvider (m_mmWaveMacSapProvider);
+          rlc->SetRnti (m_mmWaveRnti);
+          rlc->SetLcId (m_rlcMap.find(*iter)->second->logicalChannelIdentity);
+
+          struct LteUeCmacSapProvider::LogicalChannelConfig lcConfig;
+          lcConfig.priority =               m_rlcMap.find(*iter)->second->logicalChannelConfig.priority;
+          lcConfig.prioritizedBitRateKbps = m_rlcMap.find(*iter)->second->logicalChannelConfig.prioritizedBitRateKbps;
+          lcConfig.bucketSizeDurationMs =   m_rlcMap.find(*iter)->second->logicalChannelConfig.bucketSizeDurationMs;
+          lcConfig.logicalChannelGroup =    m_rlcMap.find(*iter)->second->logicalChannelConfig.logicalChannelGroup;
+
+          //m_mmWaveCmacSapProvider->AddLc (m_rlcMap.find(*iter)->second->logicalChannelIdentity,
+          //                        lcConfig,
+          //                        rlc->GetLteMacSapUser ());
+
+          for (uint32_t i = 0; i < m_numberOfComponentCarriers; i++)
+          {
+            m_mmWaveCmacSapProvider.at (i)->AddLc (m_rlcMap.find(*iter)->second->logicalChannelIdentity,
+                                    lcConfig,
+                                    rlc->GetLteMacSapUser ());
+          }
+
+          if (rlcTypeId != LteRlcSm::GetTypeId ())
+          {
+            pdcp->SetMmWaveRnti (m_mmWaveRnti);
+            pdcp->SetMmWaveRlcSapProvider (rlc->GetLteRlcSapProvider ());
+            rlc->SetLteRlcSapUser (pdcp->GetLteRlcSapUser ());
+          }
+          rlc->Initialize();
+          m_rlcMap.find(*iter)->second->m_rlc = rlc;
+
+        }
+
+        if(msg.useMmWaveConnection)
+        {
+          NS_LOG_INFO("LteUeRrc SwitchToMmWave " << m_imsi << m_cellId << m_rnti << " at time " << Simulator::Now().GetSeconds());
+          m_switchToMmWaveTrace(m_imsi, m_mmWaveCellId, m_mmWaveRnti);
+        }
+        else if(!msg.useMmWaveConnection)
+        {
+          NS_LOG_INFO("LteUeRrc SwitchToLte " << m_imsi << m_cellId << m_rnti << " at time " << Simulator::Now().GetSeconds());
+          m_switchToLteTrace(m_imsi, m_cellId, m_rnti);
+        }
+      }
+      else
+      {
+        NS_FATAL_ERROR("Trying to switch a non MC bearer");
+      }
+    }
+  }
+}
+
+
+/*
+ * Merge 2 buffers of RlcAmPdus into 1 vector with increment order of Pdus
+ */
+std::vector < LteRlcAm::RetxPdu >
+LteUeRrc::MergeBuffers(std::vector < LteRlcAm::RetxPdu > first, std::vector < LteRlcAm::RetxPdu > second)
+{
+  LteRlcAmHeader rlcamHeader_1, rlcamHeader_2;
+  std::vector < LteRlcAm::RetxPdu> result;
+  std::vector < LteRlcAm::RetxPdu>::iterator it_1 = first.begin();
+  std::vector < LteRlcAm::RetxPdu>::iterator it_2 = second.begin();
+  bool end_1_reached = false;
+  bool end_2_reached = false;
+  while (it_1 != first.end() && it_2 != second.end()){
+    while ((*it_1).m_pdu == 0){
+      ++it_1;
+      if(it_1 == first.end())
+      {
+        end_1_reached = true;
+        break;
+      }
+    }
+    while ((*it_2).m_pdu == 0){
+      ++it_2;
+      if(it_2 == second.end())
+      {
+        end_2_reached = true;
+        break;
+      }
+    }
+    if(!end_1_reached && !end_2_reached)
+    {
+      (*it_1).m_pdu->PeekHeader(rlcamHeader_1);
+      (*it_2).m_pdu->PeekHeader(rlcamHeader_2);
+      if (rlcamHeader_1.GetSequenceNumber() > rlcamHeader_2.GetSequenceNumber()){
+        result.push_back((*it_2));
+        ++it_2;
+      }
+      else if (rlcamHeader_2.GetSequenceNumber() > rlcamHeader_1.GetSequenceNumber()){
+        result.push_back((*it_1));
+        ++it_1;
+      }
+      else {
+        result.push_back((*it_1));
+        ++it_1;
+        ++it_2;
+      }
+      NS_LOG_DEBUG ("first,second = " << rlcamHeader_1.GetSequenceNumber() << "," << rlcamHeader_2.GetSequenceNumber());
+    }
+    else
+    {
+      break;
+    }
+  }
+  while (it_1 != first.end()){
+    result.push_back((*it_1));
+    it_1++;
+  }
+  while (it_2 != second.end()){
+    result.push_back((*it_2));
+    it_2++;
+  }
+  return result;
+}
+
+// This code from the LL HO implementation is refactored in a function
+// in order to be used also when switching from LTE to MmWave and back
+void
+LteUeRrc::CopyRlcBuffers(Ptr<LteRlc> rlc, Ptr<LtePdcp> pdcp, uint16_t lcid)
+{
+  // RlcBuffers forwarding only for RlcAm bearers.
+  if (0 != rlc->GetObject<LteRlcAm> ())
+  {
+    //Copy lte-rlc-am.m_txOnBuffer to X2 forwarding buffer.
+    Ptr<LteRlcAm> rlcAm = rlc->GetObject<LteRlcAm>();
+    uint32_t txonBufferSize = rlcAm->GetTxBufferSize();
+    std::vector < Ptr<Packet> > txonBuffer = rlcAm->GetTxBuffer();
+    //m_rlcBufferToBeForwardedSize =  drbIt->second->m_rlc->GetObject<LteRlcAm>()->GetTxBufferSize();
+    //m_rlcBufferToBeForwarded = drbIt->second->m_rlc->GetObject<LteRlcAm>()->GetTxBuffer();
+    uint32_t txedBufferSize = rlcAm->GetTxedBufferSize();
+    std::vector < LteRlcAm::RetxPdu > txedBuffer = rlcAm->GetTxedBuffer();
+    uint32_t retxBufferSize = rlcAm->GetRetxBufferSize();
+    std::vector < LteRlcAm::RetxPdu > retxBuffer = rlcAm->GetRetxBuffer();
+
+    //Translate Pdus in Rlc txed/retx buffer into RLC Sdus
+    //and put these Sdus into rlcAm->m_transmittingRlcSdus.
+    NS_LOG_INFO("UE RRC: retxBuffer size = " << retxBufferSize);
+    NS_LOG_INFO("UE RRC: txedBuffer size = " << txedBufferSize);
+    //Merge txed and retx buffers into a single buffer before doing RlcPdusToRlc.
+    if ( retxBufferSize + txedBufferSize > 0 ){
+      std::vector< LteRlcAm::RetxPdu > sortedTxedRetxBuffer;
+      if (retxBufferSize == 0){
+        sortedTxedRetxBuffer = txedBuffer;
+      }
+      else if (txedBufferSize == 0){
+        sortedTxedRetxBuffer = retxBuffer;
+      }
+      else {
+        sortedTxedRetxBuffer = MergeBuffers(txedBuffer, retxBuffer);
+      }
+      rlcAm->RlcPdusToRlcSdus(sortedTxedRetxBuffer);
+    }
+
+    //Construct the forwarding buffer
+    //Forwarding buffer = retxBuffer + txedBuffer + txonBuffer.
+    //if ( txonBufferSize > 0 )
+    //{
+      LtePdcpHeader pdcpHeader;
+      uint32_t pos = 0;
+      for (std::vector< Ptr<Packet> >::iterator it = txonBuffer.begin(); it != txonBuffer.end(); ++it)
+      {
+        pos++;
+        if((*it)->GetSize() > 3)
+        {
+          (*it)->PeekHeader(pdcpHeader);
+          NS_LOG_DEBUG("UE RRC: txonBuffer SEQ = " << pdcpHeader.GetSequenceNumber() << " Size = " << (*it)->GetSize());
+        }
+        else
+        {
+          NS_LOG_UNCOND("UE RRC: Fragment too small in txonBuffer, pos " << pos);
+        }
+
+      }
+
+      // this cycle adds the SDUs given by the merge of txed and retxed buffers
+      if ( rlcAm->GetTransmittingRlcSduBufferSize() > 0 )
+      { //something inside the RLC AM's transmitting buffer
+        NS_LOG_DEBUG ("UE RRC: ADDING TRANSMITTING SDUS OF RLC AM TO X2FORWARDINGBUFFER... Size = " << rlcAm->GetTransmittingRlcSduBufferSize() );
+        //copy the RlcSdu buffer (map) to forwardingBuffer.
+        std::map < uint32_t, Ptr<Packet> > rlcAmTransmittingBuffer = rlcAm->GetTransmittingRlcSduBuffer();
+        NS_LOG_DEBUG ("UE RRC:  *** SIZE = " << rlcAmTransmittingBuffer.size());
+        for (std::map< uint32_t, Ptr<Packet> >::iterator it = rlcAmTransmittingBuffer.begin(); it != rlcAmTransmittingBuffer.end(); ++it)
+        {
+          if (it->second != 0)
+          {
+            NS_LOG_DEBUG ( this << " add to forwarding buffer SEQ = " << it->first << " Ptr<Packet> = " << it->second );
+            m_rlcBufferToBeForwarded.push_back(it->second);
+          }
+        }
+        NS_LOG_DEBUG(this << "UE RRC:  ADDING TXONBUFFER OF RLC AM " << m_rnti << " Size = " << txonBufferSize) ;
+
+
+        Ptr<Packet> segmentedRlcsdu = rlcAm->GetSegmentedRlcsdu();
+        if (segmentedRlcsdu != NULL){
+          segmentedRlcsdu->PeekHeader(pdcpHeader);
+          NS_LOG_DEBUG(this << "UE RRC: SegmentedRlcSdu = " << segmentedRlcsdu->GetSize() << " SEQ = " << pdcpHeader.GetSequenceNumber());
+          //insert the complete version of the fragmented SDU to the front of txonBuffer.
+          txonBuffer.insert(txonBuffer.begin(),segmentedRlcsdu);
+        }
+        m_rlcBufferToBeForwarded.insert(m_rlcBufferToBeForwarded.end(), txonBuffer.begin(), txonBuffer.end());
+        m_rlcBufferToBeForwardedSize += rlcAm->GetTransmittingRlcSduBufferSize() + txonBufferSize;
+
+        //Get the rlcAm
+        std::vector < Ptr <Packet> > rlcAmTxedSduBuffer = rlcAm->GetTxedRlcSduBuffer();
+        LtePdcpHeader pdcpHeader_1;
+        m_rlcBufferToBeForwarded.at(0)->PeekHeader(pdcpHeader_1);
+        uint16_t i = 0;
+        for (std::vector< Ptr<Packet> >::iterator it = rlcAmTxedSduBuffer.begin(); it != rlcAmTxedSduBuffer.end(); ++it)
+        {
+          if ((*it) != NULL)
+          {
+            (*it)->PeekHeader(pdcpHeader);
+            NS_LOG_DEBUG("UE RRC: rlcAmTxedSduBuffer SEQ = " << pdcpHeader.GetSequenceNumber() << " Size = " << (*it)->GetSize());
+
+            //add the previous SDU of the forwarding buffer to the forwarding buffer.
+            if (pdcpHeader.GetSequenceNumber() >= (pdcpHeader_1.GetSequenceNumber() - 2) && pdcpHeader.GetSequenceNumber() <= (pdcpHeader_1.GetSequenceNumber()) )
+            {
+              NS_LOG_DEBUG("UE RRC: Added previous SDU to forwarding buffer SEQ = " << pdcpHeader.GetSequenceNumber() << " Size = " << (*it)->GetSize());
+              m_rlcBufferToBeForwarded.insert(m_rlcBufferToBeForwarded.begin()+i, (*it)->Copy());
+              ++i;
+            }
+          }
+        }
+
+      }
+      else
+      { //TransmittingBuffer is empty. Only copy TxonBuffer.
+        NS_LOG_DEBUG(this << " UE RRC: ADDING TXONBUFFER OF RLC AM " << m_rnti << " Size = " << txonBufferSize) ;
+        m_rlcBufferToBeForwarded = txonBuffer;
+        m_rlcBufferToBeForwardedSize += txonBufferSize;
+      }
+    //}
+  }
+  //For RlcUM, no forwarding available as the simulator itself (seamless HO).
+  //However, as the LTE-UMTS book, PDCP txbuffer should be forwarded for seamless
+  //HO. Enable this code for txbuffer forwarding in seamless HO (which is believe to
+  //be correct).
+  else if (0 != rlc->GetObject<LteRlcUm> ())
+  {
+    //Copy lte-rlc-um.m_txOnBuffer to X2 forwarding buffer.
+    NS_LOG_DEBUG(this << " UE RRC: Copying txonBuffer from RLC UM " << m_rnti);
+    m_rlcBufferToBeForwarded = rlc->GetObject<LteRlcUm>()->GetTxBuffer();
+    m_rlcBufferToBeForwardedSize =  rlc->GetObject<LteRlcUm>()->GetTxBufferSize();
+  }
+  else if (0 != rlc->GetObject<LteRlcUmLowLat> ())
+  {
+    //Copy lte-rlc-um-low-lat.m_txOnBuffer to X2 forwarding buffer.
+    NS_LOG_DEBUG(this << " UE RRC: Copying txonBuffer from RLC UM " << m_rnti);
+    m_rlcBufferToBeForwarded = rlc->GetObject<LteRlcUmLowLat>()->GetTxBuffer();
+    m_rlcBufferToBeForwardedSize =  rlc->GetObject<LteRlcUmLowLat>()->GetTxBufferSize();
+  }
+  //LteRlcAm m_txBuffer stores PDCP "PDU".
+  NS_LOG_DEBUG(this << " UE RRC: m_x2forw buffer size = " << m_rlcBufferToBeForwardedSize);
+    //Forwarding the packet inside m_rlcBufferToBeForwarded to target eNB.
+
+  while (!m_rlcBufferToBeForwarded.empty())
+  {
+    NS_LOG_DEBUG(this << " UE RRC: Forwarding m_rlcBufferToBeForwarded to target eNB, lcid = " << lcid );
+    //Remove tags to get PDCP SDU from PDCP PDU.
+    //Ptr<Packet> rlcSdu =  (*(m_rlcBufferToBeForwarded.begin()))->Copy();
+    Ptr<Packet> rlcSdu =  m_rlcBufferToBeForwarded.at(0);
+    //Tags to be removed from rlcSdu (from outer to inner)
+    //LteRlcSduStatusTag rlcSduStatusTag;
+    //RlcTag  rlcTag; //rlc layer timestamp
+    //PdcpTag pdcpTag;  //pdcp layer timestamp
+    LtePdcpHeader pdcpHeader;
+
+
+    NS_LOG_DEBUG ("UE RRC: RlcSdu size = " << rlcSdu->GetSize() );
+    //rlcSdu->RemoveHeader(pdcpHeader); //remove pdcp header
+
+    //only forward data PDCP PDUs (1-DATA_PDU,0-CTR_PDU)
+    if(rlcSdu->GetSize() >= 3)
+    {
+      rlcSdu->RemoveHeader(pdcpHeader);
+      if (pdcpHeader.GetDcBit() == 1 )
+      { //ignore control SDU.
+        NS_LOG_LOGIC ("UE RRC: SEQ = " << pdcpHeader.GetSequenceNumber());
+        NS_LOG_LOGIC ("UE RRC: removed pdcp header, size = " << rlcSdu->GetSize());
+
+        rlcSdu->RemoveAllPacketTags(); // this does not remove byte tags
+        NS_LOG_LOGIC ("UE RRC: removed tags, size = " << rlcSdu->GetSize() );
+
+        /*
+        rlcSdu->RemovePacketTag(rlcSduStatusTag); //remove Rlc status tag.
+        NS_LOG_DEBUG ("removed rlc status tag, size = " << rlcSdu->GetSize() );
+        rlcSdu->RemovePacketTag(rlcTag);  //remove Rlc timestamp
+        NS_LOG_DEBUG ("removed rlc timestamp, size = " << rlcSdu->GetSize() );
+        //rlcSdu->RemoveByteTag(pdcpTag); //remove pdcp timestamp
+        //NS_LOG_DEBUG ("removed pdcp timestamp, size = " << rlcSdu->GetSize());
+        */
+
+        // re-inject into PDCP
+        LtePdcpSapProvider::TransmitPdcpSduParameters pdcpParams;
+        pdcpParams.pdcpSdu = rlcSdu;
+        pdcpParams.rnti = m_rnti;
+        pdcpParams.lcid = lcid;
+        pdcp->GetLtePdcpSapProvider()->TransmitPdcpSdu(pdcpParams);
+
+      }
+    }
+    else
+    {
+      NS_LOG_UNCOND("UE RRC: Too small, not forwarded");
+    }
+    m_rlcBufferToBeForwardedSize -= (*(m_rlcBufferToBeForwarded.begin()))->GetSize();
+    m_rlcBufferToBeForwarded.erase (m_rlcBufferToBeForwarded.begin());
+    NS_LOG_LOGIC(this << " UE RRC: After forwarding: buffer size = " << m_rlcBufferToBeForwardedSize );
+  }
+}
+
 
 
 void
@@ -1201,6 +1885,7 @@
   if (isSuitableCell)
     {
       m_cellId = cellId;
+      SwitchLowerLayerProviders(m_cellId); // for InterRat HO
       m_cphySapProvider.at(0)->SynchronizeWithEnb (cellId, m_dlEarfcn);
       m_cphySapProvider.at(0)->SetDlBandwidth (m_dlBandwidth);
       m_initialCellSelectionEndOkTrace (m_imsi, cellId);
@@ -1229,6 +1914,118 @@
 
 } // end of void LteUeRrc::EvaluateCellForSelection ()
 
+void
+LteUeRrc::DoNotifySecondaryCellHandover (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated rrcd)
+{
+  NS_ASSERT_MSG(oldRnti == m_mmWaveRnti, "Wrong RNTI! - unknown device");
+  NS_ASSERT_MSG(!m_isSecondaryRRC, "Trying to modify RLCs in the mmWave RRC (they are instances in the LTE RRC)");
+  m_mmWaveRnti = newRnti;
+  m_mmWaveCellId = mmWaveCellId;
+  std::list<LteRrcSap::DrbToAddMod>::const_iterator dtamIt; // iterate over the
+  for (dtamIt = rrcd.drbToAddModList.begin ();
+       dtamIt != rrcd.drbToAddModList.end ();
+       ++dtamIt)
+    {
+      NS_LOG_INFO (this << " IMSI " << m_imsi << " modifying DRBID " << (uint32_t) dtamIt->drbIdentity << " LC " << (uint32_t) dtamIt->logicalChannelIdentity);
+      NS_ASSERT_MSG (dtamIt->logicalChannelIdentity > 2, "LCID value " << dtamIt->logicalChannelIdentity << " is reserved for SRBs");
+
+      std::map<uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator drbMapIt = m_drbMap.find (dtamIt->drbIdentity);
+      NS_ASSERT_MSG (drbMapIt != m_drbMap.end(), "Trying to modify an unknown bearer");
+
+      Ptr<LteDataRadioBearerInfo> drbInfo = drbMapIt->second;
+      NS_LOG_INFO ("Is MC " << dtamIt->is_mc);
+      if(dtamIt->is_mc == true) // we need to modify the RLC for MmWave communications
+      {
+        Ptr<McUePdcp> pdcp = DynamicCast<McUePdcp> (drbInfo->m_pdcp);
+        if(pdcp !=0)
+        {
+          // create Rlc
+          TypeId rlcTypeId;
+          if (m_useRlcSm)
+            {
+              rlcTypeId = LteRlcSm::GetTypeId ();
+              NS_LOG_INFO("SM");
+            }
+          else
+            {
+              switch (dtamIt->rlcConfig.choice)
+                {
+                case LteRrcSap::RlcConfig::AM:
+                  rlcTypeId = LteRlcAm::GetTypeId ();
+                  NS_LOG_INFO("AM");
+                  break;
+
+                case LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL:
+                  rlcTypeId = LteRlcUm::GetTypeId ();
+                  NS_LOG_INFO("UM");
+                  break;
+
+                default:
+                  NS_FATAL_ERROR ("unsupported RLC configuration");
+                  break;
+                }
+            }
+
+          ObjectFactory rlcObjectFactory;
+          rlcObjectFactory.SetTypeId (rlcTypeId);
+          Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+          rlc->SetLteMacSapProvider (m_mmWaveMacSapProvider);
+          rlc->SetRnti (m_mmWaveRnti);
+          rlc->SetLcId (dtamIt->logicalChannelIdentity);
+
+          struct LteUeCmacSapProvider::LogicalChannelConfig lcConfig;
+          lcConfig.priority = dtamIt->logicalChannelConfig.priority;
+          lcConfig.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+          lcConfig.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+          lcConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;
+
+          //This is executed only if this is a secondary (mmWave) rrc
+          for (uint32_t i = 0; i < m_numberOfMmWaveComponentCarriers; i++)
+          {
+            m_mmWaveCmacSapProvider.at (i)->AddLc (dtamIt->logicalChannelIdentity,
+                                    lcConfig,
+                                    rlc->GetLteMacSapUser ());
+          }
+          if (rlcTypeId != LteRlcSm::GetTypeId ())
+          {
+            pdcp->SetMmWaveRnti (m_mmWaveRnti);
+            pdcp->SetMmWaveRlcSapProvider (rlc->GetLteRlcSapProvider ());
+            rlc->SetLteRlcSapUser (pdcp->GetLteRlcSapUser ());
+          }
+          rlc->Initialize();
+
+          Ptr<RlcBearerInfo> rlcInfo = CreateObject<RlcBearerInfo>();
+          rlcInfo->m_rlc = rlc;
+          rlcInfo->rlcConfig.choice = dtamIt->rlcConfig.choice;
+          rlcInfo->logicalChannelIdentity = dtamIt->logicalChannelIdentity;
+          rlcInfo->mmWaveRnti = m_mmWaveRnti;
+
+          LteRrcSap::LogicalChannelConfig logicalChannelConfig;
+          logicalChannelConfig.priority = dtamIt->logicalChannelConfig.priority;
+          logicalChannelConfig.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+          logicalChannelConfig.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+          logicalChannelConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;
+
+          rlcInfo->logicalChannelConfig = logicalChannelConfig;
+
+          // check if this rlc is already in the map
+          if(m_rlcMap.find(dtamIt->drbIdentity) != m_rlcMap.end())
+          {
+            // get the RLC buffer content and store it in this RLC
+            CopyRlcBuffers(m_rlcMap.find(dtamIt->drbIdentity)->second->m_rlc, drbInfo->m_pdcp, drbInfo->m_logicalChannelIdentity);
+          }
+          m_rlcMap[dtamIt->drbIdentity] = rlcInfo;
+
+          NS_LOG_INFO(this << "LteUeRrc Secondary Cell Handover, created new rlc " << m_imsi << m_mmWaveCellId << m_mmWaveRnti << " at time " << Simulator::Now().GetSeconds());
+        }
+        else
+        {
+          NS_FATAL_ERROR("MC setup on a non MC-capable bearer");
+        }
+      }
+    }
+}
+
 
 void
 LteUeRrc::ApplyRadioResourceConfigDedicatedSecondaryCarrier (LteRrcSap::NonCriticalExtensionConfiguration nonCec)
@@ -1237,6 +2034,7 @@
 
   m_sCellToAddModList = nonCec.sCellsToAddModList;
 
+
   for(std::list<LteRrcSap::SCellToAddMod>::iterator it = nonCec.sCellsToAddModList.begin(); it!=nonCec.sCellsToAddModList.end(); it++)
     {
       LteRrcSap::SCellToAddMod scell = *it;
@@ -1265,10 +2063,10 @@
       m_cphySapProvider.at (ccId)->SetSrsConfigurationIndex (srsIndex);
     }
 
-  m_sCarrierConfiguredTrace (this, m_sCellToAddModList);
+    m_sCarrierConfiguredTrace (this, m_sCellToAddModList);
 }
 
-void 
+void
 LteUeRrc::ApplyRadioResourceConfigDedicated (LteRrcSap::RadioResourceConfigDedicated rrcd)
 {
   NS_LOG_FUNCTION (this);
@@ -1296,8 +2094,9 @@
     {
       if (m_srb1 == 0)
         {
-          // SRB1 not setup yet        
-          NS_ASSERT_MSG ((m_state == IDLE_CONNECTING) || (m_state == CONNECTED_HANDOVER), 
+          NS_LOG_INFO("Setup SBR1 for rnti " << m_rnti << " on cell " << m_cellId);
+          // SRB1 not setup yet
+          NS_ASSERT_MSG ((m_state == IDLE_CONNECTING) || (m_state == CONNECTED_HANDOVER),
                          "unexpected state " << ToString (m_state));
           NS_ASSERT_MSG (stamIt->srbIdentity == 1, "only SRB1 supported");
 
@@ -1306,7 +2105,7 @@
           Ptr<LteRlc> rlc = CreateObject<LteRlcAm> ();
           rlc->SetLteMacSapProvider (m_macSapProvider);
           rlc->SetRnti (m_rnti);
-          rlc->SetLcId (lcid);      
+          rlc->SetLcId (lcid);
 
           Ptr<LtePdcp> pdcp = CreateObject<LtePdcp> ();
           pdcp->SetRnti (m_rnti);
@@ -1319,7 +2118,7 @@
           m_srb1->m_rlc = rlc;
           m_srb1->m_pdcp = pdcp;
           m_srb1->m_srbIdentity = 1;
-          
+
           m_srb1->m_logicalChannelConfig.priority = stamIt->logicalChannelConfig.priority;
           m_srb1->m_logicalChannelConfig.prioritizedBitRateKbps = stamIt->logicalChannelConfig.prioritizedBitRateKbps;
           m_srb1->m_logicalChannelConfig.bucketSizeDurationMs = stamIt->logicalChannelConfig.bucketSizeDurationMs;
@@ -1333,7 +2132,7 @@
           m_cmacSapProvider.at (0)->AddLc (lcid, lcConfig, rlc->GetLteMacSapUser ());
           ++stamIt;
           NS_ASSERT_MSG (stamIt == rrcd.srbToAddModList.end (), "at most one SrbToAdd supported");
-          
+
           LteUeRrcSapUser::SetupParameters ueParams;
           ueParams.srb0SapProvider = m_srb0->m_rlc->GetLteRlcSapProvider ();
           ueParams.srb1SapProvider = m_srb1->m_pdcp->GetLtePdcpSapProvider ();
@@ -1355,11 +2154,19 @@
       NS_LOG_INFO (this << " IMSI " << m_imsi << " adding/modifying DRBID " << (uint32_t) dtamIt->drbIdentity << " LC " << (uint32_t) dtamIt->logicalChannelIdentity);
       NS_ASSERT_MSG (dtamIt->logicalChannelIdentity > 2, "LCID value " << dtamIt->logicalChannelIdentity << " is reserved for SRBs");
 
-      std::map<uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator drbMapIt = m_drbMap.find (dtamIt->drbIdentity);
+      std::map<uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator drbMapIt = m_drbMap.begin();
+      for(; drbMapIt != m_drbMap.end(); ++drbMapIt)
+      {
+        NS_LOG_DEBUG("In m_drbMap " << (uint16_t)drbMapIt->first);
+      }
+
+
+      //std::map<uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator drbMapIt = m_drbMap.find (dtamIt->drbIdentity);
+      drbMapIt = m_drbMap.find (dtamIt->drbIdentity);
       if (drbMapIt == m_drbMap.end ())
         {
           NS_LOG_INFO ("New Data Radio Bearer");
-        
+
           TypeId rlcTypeId;
           if (m_useRlcSm)
             {
@@ -1369,20 +2176,20 @@
             {
               switch (dtamIt->rlcConfig.choice)
                 {
-                case LteRrcSap::RlcConfig::AM: 
+                case LteRrcSap::RlcConfig::AM:
                   rlcTypeId = LteRlcAm::GetTypeId ();
                   break;
-          
-                case LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL: 
+
+                case LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL:
                   rlcTypeId = LteRlcUm::GetTypeId ();
                   break;
-          
+
                 default:
                   NS_FATAL_ERROR ("unsupported RLC configuration");
-                  break;                
+                  break;
                 }
             }
-  
+
           ObjectFactory rlcObjectFactory;
           rlcObjectFactory.SetTypeId (rlcTypeId);
           Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
@@ -1395,12 +2202,13 @@
           drbInfo->m_epsBearerIdentity = dtamIt->epsBearerIdentity;
           drbInfo->m_logicalChannelIdentity = dtamIt->logicalChannelIdentity;
           drbInfo->m_drbIdentity = dtamIt->drbIdentity;
- 
+          drbInfo->m_rlcConfig.choice = dtamIt->rlcConfig.choice;
+
           // we need PDCP only for real RLC, i.e., RLC/UM or RLC/AM
           // if we are using RLC/SM we don't care of anything above RLC
           if (rlcTypeId != LteRlcSm::GetTypeId ())
             {
-              Ptr<LtePdcp> pdcp = CreateObject<LtePdcp> ();
+              Ptr<McUePdcp> pdcp = CreateObject<McUePdcp> ();
               pdcp->SetRnti (m_rnti);
               pdcp->SetLcId (dtamIt->logicalChannelIdentity);
               pdcp->SetLtePdcpSapUser (m_drbPdcpSapUser);
@@ -1410,15 +2218,22 @@
             }
 
           m_bid2DrbidMap[dtamIt->epsBearerIdentity] = dtamIt->drbIdentity;
-  
+
+          struct LteRrcSap::LogicalChannelConfig lcConfigToStore;
+          lcConfigToStore.priority = dtamIt->logicalChannelConfig.priority;
+          lcConfigToStore.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+          lcConfigToStore.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+          lcConfigToStore.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;
+          drbInfo->m_logicalChannelConfig = lcConfigToStore;
+
           m_drbMap.insert (std::pair<uint8_t, Ptr<LteDataRadioBearerInfo> > (dtamIt->drbIdentity, drbInfo));
-  
+
 
           struct LteUeCmacSapProvider::LogicalChannelConfig lcConfig;
           lcConfig.priority = dtamIt->logicalChannelConfig.priority;
           lcConfig.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
           lcConfig.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
-          lcConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;      
+          lcConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;
 
           for (uint32_t i = 0; i < m_numberOfComponentCarriers; i++)
           {
@@ -1432,10 +2247,187 @@
         {
           NS_LOG_INFO ("request to modify existing DRBID");
           Ptr<LteDataRadioBearerInfo> drbInfo = drbMapIt->second;
-          /// \todo currently not implemented. Would need to modify drbInfo, and then propagate changes to the MAC
+          NS_LOG_INFO ("Is MC " << dtamIt->is_mc);
+          if(dtamIt->is_mc == true) // we need to setup the RLC for MmWave communications
+          {
+            Ptr<McUePdcp> pdcp = DynamicCast<McUePdcp> (drbInfo->m_pdcp);
+            if(pdcp !=0)
+            {
+              // create Rlc
+              TypeId rlcTypeId;
+              if (m_useRlcSm)
+                {
+                  rlcTypeId = LteRlcSm::GetTypeId ();
+                  NS_LOG_INFO("SM");
+                }
+              else
+                {
+                  switch (dtamIt->rlcConfig.choice)
+                    {
+                    case LteRrcSap::RlcConfig::AM:
+                      rlcTypeId = LteRlcAm::GetTypeId ();
+                      NS_LOG_INFO("AM");
+                      break;
+
+                    case LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL:
+                      rlcTypeId = LteRlcUm::GetTypeId ();
+                      NS_LOG_INFO("UM");
+                      break;
+
+                    default:
+                      NS_FATAL_ERROR ("unsupported RLC configuration");
+                      break;
+                    }
+                }
+
+              ObjectFactory rlcObjectFactory;
+              rlcObjectFactory.SetTypeId (rlcTypeId);
+              Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+              rlc->SetLteMacSapProvider (m_mmWaveMacSapProvider);
+              rlc->SetRnti (m_mmWaveRnti);
+              rlc->SetLcId (dtamIt->logicalChannelIdentity);
+
+              struct LteUeCmacSapProvider::LogicalChannelConfig lcConfig;
+              lcConfig.priority = dtamIt->logicalChannelConfig.priority;
+              lcConfig.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+              lcConfig.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+              lcConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;
+
+              //This is executed only if this is a secondary (mmWave) rrc
+              for (uint32_t i = 0; i < m_numberOfMmWaveComponentCarriers; i++)
+              {
+                m_mmWaveCmacSapProvider.at (i)->AddLc (dtamIt->logicalChannelIdentity,
+                                        lcConfig,
+                                        rlc->GetLteMacSapUser ());
+              }
+              if (rlcTypeId != LteRlcSm::GetTypeId ())
+              {
+                pdcp->SetMmWaveRnti (m_mmWaveRnti);
+                pdcp->SetMmWaveRlcSapProvider (rlc->GetLteRlcSapProvider ());
+                rlc->SetLteRlcSapUser (pdcp->GetLteRlcSapUser ());
+              }
+              rlc->Initialize();
+
+              Ptr<RlcBearerInfo> rlcInfo = CreateObject<RlcBearerInfo>();
+              rlcInfo->m_rlc = rlc;
+              rlcInfo->rlcConfig.choice = dtamIt->rlcConfig.choice;
+              rlcInfo->logicalChannelIdentity = dtamIt->logicalChannelIdentity;
+              rlcInfo->mmWaveRnti = m_mmWaveRnti;
+
+              LteRrcSap::LogicalChannelConfig logicalChannelConfig;
+              logicalChannelConfig.priority = dtamIt->logicalChannelConfig.priority;
+              logicalChannelConfig.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+              logicalChannelConfig.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+              logicalChannelConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;
+
+              rlcInfo->logicalChannelConfig = logicalChannelConfig;
+
+              // switch to the mmWave RLC
+              bool useMmWaveConnection = true;
+              pdcp->SwitchConnection(useMmWaveConnection);
+              NS_LOG_INFO("LteUeRrc SwitchToMmWave and create new rlc " << m_imsi << m_mmWaveCellId << m_mmWaveRnti << " at time " << Simulator::Now().GetSeconds());
+              m_switchToMmWaveTrace(m_imsi, m_mmWaveCellId, m_mmWaveRnti);
+
+              // check if this rlc is already in the map
+              if(m_rlcMap.find(dtamIt->drbIdentity) != m_rlcMap.end())
+              {
+                // get the RLC buffer content and store it in this RLC
+                CopyRlcBuffers(m_rlcMap.find(dtamIt->drbIdentity)->second->m_rlc, drbInfo->m_pdcp, drbInfo->m_logicalChannelIdentity);
+              }
+              m_rlcMap[dtamIt->drbIdentity] = rlcInfo;
+            }
+            else
+            {
+              NS_FATAL_ERROR("MC setup on a non MC-capable bearer");
+            }
+
+          }
+          else
+          {
+            NS_LOG_INFO ("Modify Data Radio Bearer : not implemented");
+            // TypeId rlcTypeId;
+            // if (m_useRlcSm)
+            //   {
+            //     rlcTypeId = LteRlcSm::GetTypeId ();
+            //   }
+            // else
+            //   {
+            //     switch (dtamIt->rlcConfig.choice)
+            //       {
+            //       case LteRrcSap::RlcConfig::AM:
+            //         rlcTypeId = LteRlcAm::GetTypeId ();
+            //         break;
+
+            //       case LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL:
+            //         rlcTypeId = LteRlcUm::GetTypeId ();
+            //         break;
+
+            //       default:
+            //         NS_FATAL_ERROR ("unsupported RLC configuration");
+            //         break;
+            //       }
+            //   }
+
+            // ObjectFactory rlcObjectFactory;
+            // rlcObjectFactory.SetTypeId (rlcTypeId);
+            // Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+            // rlc->SetLteMacSapProvider (m_macSapProvider);
+            // rlc->SetRnti (m_rnti);
+            // rlc->SetLcId (dtamIt->logicalChannelIdentity);
+
+            // Ptr<LteDataRadioBearerInfo> drbInfo = CreateObject<LteDataRadioBearerInfo> ();
+            // drbInfo->m_rlc = rlc;
+            // drbInfo->m_epsBearerIdentity = dtamIt->epsBearerIdentity;
+            // drbInfo->m_logicalChannelIdentity = dtamIt->logicalChannelIdentity;
+            // drbInfo->m_drbIdentity = dtamIt->drbIdentity;
+            // drbInfo->m_rlcConfig.choice = dtamIt->rlcConfig.choice;
+
+            // // we need PDCP only for real RLC, i.e., RLC/UM or RLC/AM
+            // // if we are using RLC/SM we don't care of anything above RLC
+            // if (rlcTypeId != LteRlcSm::GetTypeId ())
+            //   {
+            //     Ptr<LtePdcp> pdcp = CreateObject<LtePdcp> ();
+            //     pdcp->SetRnti (m_rnti);
+            //     pdcp->SetLcId (dtamIt->logicalChannelIdentity);
+            //     pdcp->SetLtePdcpSapUser (m_drbPdcpSapUser);
+            //     pdcp->SetLteRlcSapProvider (rlc->GetLteRlcSapProvider ());
+            //     rlc->SetLteRlcSapUser (pdcp->GetLteRlcSapUser ());
+            //     drbInfo->m_pdcp = pdcp;
+            //   }
+
+            // m_bid2DrbidMap[dtamIt->epsBearerIdentity] = dtamIt->drbIdentity;
+
+            // struct LteRrcSap::LogicalChannelConfig lcConfigToStore;
+            // lcConfigToStore.priority = dtamIt->logicalChannelConfig.priority;
+            // lcConfigToStore.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+            // lcConfigToStore.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+            // lcConfigToStore.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;
+            // drbInfo->m_logicalChannelConfig = lcConfigToStore;
+
+            // struct LteUeCmacSapProvider::LogicalChannelConfig lcConfig;
+            // lcConfig.priority = dtamIt->logicalChannelConfig.priority;
+            // lcConfig.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+            // lcConfig.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+            // lcConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;
+
+            // rlc->Initialize ();
+
+            // // check if an RLC for this drbid is already in the map
+            // if(m_drbMap.find(dtamIt->drbIdentity) != m_drbMap.end())
+            // {
+            //   // get the RLC buffer content and store it in this RLC
+            //   CopyRlcBuffers(m_drbMap.find(dtamIt->drbIdentity)->second->m_rlc, drbInfo->m_pdcp, drbInfo->m_logicalChannelIdentity);
+            // }
+            // m_drbMap[dtamIt->drbIdentity] = drbInfo;
+
+            // m_cmacSapProvider->AddLc (dtamIt->logicalChannelIdentity,
+            //                           lcConfig,
+            //                           rlc->GetLteMacSapUser ());
+
+          }
         }
     }
-  
+
   std::list<uint8_t>::iterator dtdmIt;
   for (dtdmIt = rrcd.drbToReleaseList.begin ();
        dtdmIt != rrcd.drbToReleaseList.end ();
@@ -1445,7 +2437,7 @@
       NS_LOG_INFO (this << " IMSI " << m_imsi << " releasing DRB " << (uint32_t) drbid << drbid);
       std::map<uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it =   m_drbMap.find (drbid);
       NS_ASSERT_MSG (it != m_drbMap.end (), "could not find bearer with given lcid");
-      m_drbMap.erase (it);      
+      m_drbMap.erase (it);
       m_bid2DrbidMap.erase (drbid);
       //Remove LCID
       for (uint32_t i = 0; i < m_numberOfComponentCarriers; i++)
@@ -1456,12 +2448,12 @@
 }
 
 
-void 
+void
 LteUeRrc::ApplyMeasConfig (LteRrcSap::MeasConfig mc)
 {
   NS_LOG_FUNCTION (this);
 
-  // perform the actions specified in 3GPP TS 36.331 section 5.5.2.1 
+  // perform the actions specified in 3GPP TS 36.331 section 5.5.2.1
 
   // 3GPP TS 36.331 section 5.5.2.4 Measurement object removal
   for (std::list<uint8_t>::iterator it = mc.measObjectToRemoveList.begin ();
@@ -1509,7 +2501,7 @@
         {
           NS_LOG_LOGIC ("measObjectId " << (uint32_t) measObjectId << " exists, updating entry");
           measObjectIt->second = *it;
-          for (std::map<uint8_t, LteRrcSap::MeasIdToAddMod>::iterator measIdIt 
+          for (std::map<uint8_t, LteRrcSap::MeasIdToAddMod>::iterator measIdIt
                  = m_varMeasConfig.measIdList.begin ();
                measIdIt != m_varMeasConfig.measIdList.end ();
                ++measIdIt)
@@ -1573,7 +2565,7 @@
         {
           NS_LOG_LOGIC ("reportConfigId " << (uint32_t) reportConfigId << " exists, updating entry");
           m_varMeasConfig.reportConfigList[reportConfigId] = *it;
-          for (std::map<uint8_t, LteRrcSap::MeasIdToAddMod>::iterator measIdIt 
+          for (std::map<uint8_t, LteRrcSap::MeasIdToAddMod>::iterator measIdIt
                  = m_varMeasConfig.measIdList.begin ();
                measIdIt != m_varMeasConfig.measIdList.end ();
                ++measIdIt)
@@ -2743,17 +3735,17 @@
   CancelLeavingTrigger (measId);
 }
 
-void 
+void
 LteUeRrc::SendMeasurementReport (uint8_t measId)
 {
   NS_LOG_FUNCTION (this << (uint16_t) measId);
   //  3GPP TS 36.331 section 5.5.5 Measurement reporting
 
-  std::map<uint8_t, LteRrcSap::MeasIdToAddMod>::iterator 
+  std::map<uint8_t, LteRrcSap::MeasIdToAddMod>::iterator
     measIdIt = m_varMeasConfig.measIdList.find (measId);
   NS_ASSERT (measIdIt != m_varMeasConfig.measIdList.end ());
 
-  std::map<uint8_t, LteRrcSap::ReportConfigToAddMod>::iterator 
+  std::map<uint8_t, LteRrcSap::ReportConfigToAddMod>::iterator
     reportConfigIt = m_varMeasConfig.reportConfigList.find (measIdIt->second.reportConfigId);
   NS_ASSERT (reportConfigIt != m_varMeasConfig.reportConfigList.end ());
   LteRrcSap::ReportConfigEutra& reportConfigEutra = reportConfigIt->second.reportConfigEutra;
@@ -2762,168 +3754,176 @@
   LteRrcSap::MeasResults& measResults = measurementReport.measResults;
   measResults.measId = measId;
 
-  std::map<uint16_t, MeasValues>::iterator servingMeasIt = m_storedMeasValues.find (m_cellId);
-  NS_ASSERT (servingMeasIt != m_storedMeasValues.end ());
-  measResults.rsrpResult = EutranMeasurementMapping::Dbm2RsrpRange (servingMeasIt->second.rsrp);
-  measResults.rsrqResult = EutranMeasurementMapping::Db2RsrqRange (servingMeasIt->second.rsrq);
-  NS_LOG_INFO (this << " reporting serving cell "
-               "RSRP " << (uint32_t) measResults.rsrpResult << " (" << servingMeasIt->second.rsrp << " dBm) "
-               "RSRQ " << (uint32_t) measResults.rsrqResult << " (" << servingMeasIt->second.rsrq << " dB)");
-  measResults.haveMeasResultNeighCells = false;
-  std::map<uint8_t, VarMeasReport>::iterator measReportIt = m_varMeasReportList.find (measId);
-  if (measReportIt == m_varMeasReportList.end ())
-    {
-      NS_LOG_ERROR ("no entry found in m_varMeasReportList for measId " << (uint32_t) measId);
-    }
-  else
-    {
-      if (!(measReportIt->second.cellsTriggeredList.empty ()))
-        {
-          std::multimap<double, uint16_t> sortedNeighCells;
-          for (std::set<uint16_t>::iterator cellsTriggeredIt = measReportIt->second.cellsTriggeredList.begin ();
-               cellsTriggeredIt != measReportIt->second.cellsTriggeredList.end ();
-               ++cellsTriggeredIt)
-            {
-              uint16_t cellId = *cellsTriggeredIt;
-              if (cellId != m_cellId)
-                {
-                  std::map<uint16_t, MeasValues>::iterator neighborMeasIt = m_storedMeasValues.find (cellId);
-                  double triggerValue;
-                  switch (reportConfigEutra.triggerQuantity)
-                    {
-                    case LteRrcSap::ReportConfigEutra::RSRP:
-                      triggerValue = neighborMeasIt->second.rsrp;
-                      break;
-                    case LteRrcSap::ReportConfigEutra::RSRQ:
-                      triggerValue = neighborMeasIt->second.rsrq;
-                      break;
-                    default:
-                      NS_FATAL_ERROR ("unsupported triggerQuantity");
-                      break;
-                    }
-                  sortedNeighCells.insert (std::pair<double, uint16_t> (triggerValue, cellId));
-                }
-            }
+  bool cellHasMeasures = true; // measurements are available only for LTE cells
+  if(m_isMmWaveCellMap.find(m_cellId) != m_isMmWaveCellMap.end())
+  {
+    cellHasMeasures = !m_isMmWaveCellMap.find(m_cellId)->second;
+  }
+  if(cellHasMeasures)
+  {
+    std::map<uint16_t, MeasValues>::iterator servingMeasIt = m_storedMeasValues.find (m_cellId);
+    NS_ASSERT (servingMeasIt != m_storedMeasValues.end ());
+    measResults.rsrpResult = EutranMeasurementMapping::Dbm2RsrpRange (servingMeasIt->second.rsrp);
+    measResults.rsrqResult = EutranMeasurementMapping::Db2RsrqRange (servingMeasIt->second.rsrq);
+    NS_LOG_INFO (this << " reporting serving cell "
+                 "RSRP " << (uint32_t) measResults.rsrpResult << " (" << servingMeasIt->second.rsrp << " dBm) "
+                 "RSRQ " << (uint32_t) measResults.rsrqResult << " (" << servingMeasIt->second.rsrq << " dB)");
+    measResults.haveMeasResultNeighCells = false;
+    std::map<uint8_t, VarMeasReport>::iterator measReportIt = m_varMeasReportList.find (measId);
+    if (measReportIt == m_varMeasReportList.end ())
+      {
+        NS_LOG_ERROR ("no entry found in m_varMeasReportList for measId " << (uint32_t) measId);
+      }
+    else
+      {
+        if (!(measReportIt->second.cellsTriggeredList.empty ()))
+          {
+            std::multimap<double, uint16_t> sortedNeighCells;
+            for (std::set<uint16_t>::iterator cellsTriggeredIt = measReportIt->second.cellsTriggeredList.begin ();
+                 cellsTriggeredIt != measReportIt->second.cellsTriggeredList.end ();
+                 ++cellsTriggeredIt)
+              {
+                uint16_t cellId = *cellsTriggeredIt;
+                if (cellId != m_cellId)
+                  {
+                    std::map<uint16_t, MeasValues>::iterator neighborMeasIt = m_storedMeasValues.find (cellId);
+                    double triggerValue;
+                    switch (reportConfigEutra.triggerQuantity)
+                      {
+                      case LteRrcSap::ReportConfigEutra::RSRP:
+                        triggerValue = neighborMeasIt->second.rsrp;
+                        break;
+                      case LteRrcSap::ReportConfigEutra::RSRQ:
+                        triggerValue = neighborMeasIt->second.rsrq;
+                        break;
+                      default:
+                        NS_FATAL_ERROR ("unsupported triggerQuantity");
+                        break;
+                      }
+                    sortedNeighCells.insert (std::pair<double, uint16_t> (triggerValue, cellId));
+                  }
+              }
 
-          std::multimap<double, uint16_t>::reverse_iterator sortedNeighCellsIt;
-          uint32_t count;
-          for (sortedNeighCellsIt = sortedNeighCells.rbegin (), count = 0;
-               sortedNeighCellsIt != sortedNeighCells.rend () && count < reportConfigEutra.maxReportCells;
-               ++sortedNeighCellsIt, ++count)
-            {
-              uint16_t cellId = sortedNeighCellsIt->second;
-              std::map<uint16_t, MeasValues>::iterator neighborMeasIt = m_storedMeasValues.find (cellId);
-              NS_ASSERT (neighborMeasIt != m_storedMeasValues.end ());
-              LteRrcSap::MeasResultEutra measResultEutra;
-              measResultEutra.physCellId = cellId;
-              measResultEutra.haveCgiInfo = false;
-              measResultEutra.haveRsrpResult = true;
-              measResultEutra.rsrpResult = EutranMeasurementMapping::Dbm2RsrpRange (neighborMeasIt->second.rsrp);
-              measResultEutra.haveRsrqResult = true;
-              measResultEutra.rsrqResult = EutranMeasurementMapping::Db2RsrqRange (neighborMeasIt->second.rsrq);
-              NS_LOG_INFO (this << " reporting neighbor cell " << (uint32_t) measResultEutra.physCellId 
-                                << " RSRP " << (uint32_t) measResultEutra.rsrpResult
-                                << " (" << neighborMeasIt->second.rsrp << " dBm)"
-                                << " RSRQ " << (uint32_t) measResultEutra.rsrqResult
-                                << " (" << neighborMeasIt->second.rsrq << " dB)");
-              measResults.measResultListEutra.push_back (measResultEutra);
-              measResults.haveMeasResultNeighCells = true;
-            }
-        }
-      else
-        {
-          NS_LOG_WARN (this << " cellsTriggeredList is empty");
-        }
+            std::multimap<double, uint16_t>::reverse_iterator sortedNeighCellsIt;
+            uint32_t count;
+            for (sortedNeighCellsIt = sortedNeighCells.rbegin (), count = 0;
+                 sortedNeighCellsIt != sortedNeighCells.rend () && count < reportConfigEutra.maxReportCells;
+                 ++sortedNeighCellsIt, ++count)
+              {
+                uint16_t cellId = sortedNeighCellsIt->second;
+                std::map<uint16_t, MeasValues>::iterator neighborMeasIt = m_storedMeasValues.find (cellId);
+                NS_ASSERT (neighborMeasIt != m_storedMeasValues.end ());
+                LteRrcSap::MeasResultEutra measResultEutra;
+                measResultEutra.physCellId = cellId;
+                measResultEutra.haveCgiInfo = false;
+                measResultEutra.haveRsrpResult = true;
+                measResultEutra.rsrpResult = EutranMeasurementMapping::Dbm2RsrpRange (neighborMeasIt->second.rsrp);
+                measResultEutra.haveRsrqResult = true;
+                measResultEutra.rsrqResult = EutranMeasurementMapping::Db2RsrqRange (neighborMeasIt->second.rsrq);
+                NS_LOG_INFO (this << " reporting neighbor cell " << (uint32_t) measResultEutra.physCellId
+                                  << " RSRP " << (uint32_t) measResultEutra.rsrpResult
+                                  << " (" << neighborMeasIt->second.rsrp << " dBm)"
+                                  << " RSRQ " << (uint32_t) measResultEutra.rsrqResult
+                                  << " (" << neighborMeasIt->second.rsrq << " dB)");
+                measResults.measResultListEutra.push_back (measResultEutra);
+                measResults.haveMeasResultNeighCells = true;
+              }
+          }
+        else
+          {
+            NS_LOG_WARN (this << " cellsTriggeredList is empty");
+          }
 
-      measResults.haveScellsMeas = false;
-      std::map<uint16_t, MeasValues>::iterator sCellsMeasIt =  m_storedScellMeasValues.begin ();
-      if (sCellsMeasIt != m_storedScellMeasValues.end ())
-        {
-          measResults.haveScellsMeas = true;
-          measResults.measScellResultList.haveMeasurementResultsServingSCells = true;
-          measResults.measScellResultList.haveMeasurementResultsNeighCell = false;
+        measResults.haveScellsMeas = false;
+        std::map<uint16_t, MeasValues>::iterator sCellsMeasIt =  m_storedScellMeasValues.begin ();
+        if (sCellsMeasIt != m_storedScellMeasValues.end ())
+          {
+            measResults.haveScellsMeas = true;
+            measResults.measScellResultList.haveMeasurementResultsServingSCells = true;
+            measResults.measScellResultList.haveMeasurementResultsNeighCell = false;
 
 
-          for ( sCellsMeasIt = m_storedScellMeasValues.begin (); 
-                sCellsMeasIt != m_storedScellMeasValues.end (); ++sCellsMeasIt)
-            {
-              LteRrcSap::MeasResultScell measResultScell;
-              measResultScell.servFreqId = sCellsMeasIt->first;
-              measResultScell.haveRsrpResult =  true;
-              measResultScell.haveRsrqResult =  true;
-              measResultScell.rsrpResult = EutranMeasurementMapping::Dbm2RsrpRange (sCellsMeasIt->second.rsrp);
-              measResultScell.rsrqResult = EutranMeasurementMapping::Db2RsrqRange (sCellsMeasIt->second.rsrq); 
-              measResults.measScellResultList.measResultScell.push_back (measResultScell);
-            }
-        }
+            for ( sCellsMeasIt = m_storedScellMeasValues.begin ();
+                  sCellsMeasIt != m_storedScellMeasValues.end (); ++sCellsMeasIt)
+              {
+                LteRrcSap::MeasResultScell measResultScell;
+                measResultScell.servFreqId = sCellsMeasIt->first;
+                measResultScell.haveRsrpResult =  true;
+                measResultScell.haveRsrqResult =  true;
+                measResultScell.rsrpResult = EutranMeasurementMapping::Dbm2RsrpRange (sCellsMeasIt->second.rsrp);
+                measResultScell.rsrqResult = EutranMeasurementMapping::Db2RsrqRange (sCellsMeasIt->second.rsrq);
+                measResults.measScellResultList.measResultScell.push_back (measResultScell);
+              }
+          }
 
-      /*
-       * The current LteRrcSap implementation is broken in that it does not
-       * allow for infinite values of reportAmount, which is probably the most
-       * reasonable setting. So we just always assume infinite reportAmount.
-       */
-      measReportIt->second.numberOfReportsSent++;
-      measReportIt->second.periodicReportTimer.Cancel ();
+        /*
+         * The current LteRrcSap implementation is broken in that it does not
+         * allow for infinite values of reportAmount, which is probably the most
+         * reasonable setting. So we just always assume infinite reportAmount.
+         */
+        measReportIt->second.numberOfReportsSent++;
+        measReportIt->second.periodicReportTimer.Cancel ();
 
-      Time reportInterval;
-      switch (reportConfigEutra.reportInterval)
-        {
-        case LteRrcSap::ReportConfigEutra::MS120:
-          reportInterval = MilliSeconds (120);
-          break;
-        case LteRrcSap::ReportConfigEutra::MS240:
-          reportInterval = MilliSeconds (240);
-          break;
-        case LteRrcSap::ReportConfigEutra::MS480:
-          reportInterval = MilliSeconds (480);
-          break;
-        case LteRrcSap::ReportConfigEutra::MS640:
-          reportInterval = MilliSeconds (640);
-          break;
-        case LteRrcSap::ReportConfigEutra::MS1024:
-          reportInterval = MilliSeconds (1024);
-          break;
-        case LteRrcSap::ReportConfigEutra::MS2048:
-          reportInterval = MilliSeconds (2048);
-          break;
-        case LteRrcSap::ReportConfigEutra::MS5120:
-          reportInterval = MilliSeconds (5120);
-          break;
-        case LteRrcSap::ReportConfigEutra::MS10240:
-          reportInterval = MilliSeconds (10240);
-          break;
-        case LteRrcSap::ReportConfigEutra::MIN1:
-          reportInterval = Seconds (60);
-          break;
-        case LteRrcSap::ReportConfigEutra::MIN6:
-          reportInterval = Seconds (360);
-          break;
-        case LteRrcSap::ReportConfigEutra::MIN12:
-          reportInterval = Seconds (720);
-          break;
-        case LteRrcSap::ReportConfigEutra::MIN30:
-          reportInterval = Seconds (1800);
-          break;
-        case LteRrcSap::ReportConfigEutra::MIN60:
-          reportInterval = Seconds (3600);
-          break;
-        default:
-          NS_FATAL_ERROR ("Unsupported reportInterval " << (uint16_t) reportConfigEutra.reportInterval);
-          break;
-        }
+        Time reportInterval;
+        switch (reportConfigEutra.reportInterval)
+          {
+          case LteRrcSap::ReportConfigEutra::MS120:
+            reportInterval = MilliSeconds (120);
+            break;
+          case LteRrcSap::ReportConfigEutra::MS240:
+            reportInterval = MilliSeconds (240);
+            break;
+          case LteRrcSap::ReportConfigEutra::MS480:
+            reportInterval = MilliSeconds (480);
+            break;
+          case LteRrcSap::ReportConfigEutra::MS640:
+            reportInterval = MilliSeconds (640);
+            break;
+          case LteRrcSap::ReportConfigEutra::MS1024:
+            reportInterval = MilliSeconds (1024);
+            break;
+          case LteRrcSap::ReportConfigEutra::MS2048:
+            reportInterval = MilliSeconds (2048);
+            break;
+          case LteRrcSap::ReportConfigEutra::MS5120:
+            reportInterval = MilliSeconds (5120);
+            break;
+          case LteRrcSap::ReportConfigEutra::MS10240:
+            reportInterval = MilliSeconds (10240);
+            break;
+          case LteRrcSap::ReportConfigEutra::MIN1:
+            reportInterval = Seconds (60);
+            break;
+          case LteRrcSap::ReportConfigEutra::MIN6:
+            reportInterval = Seconds (360);
+            break;
+          case LteRrcSap::ReportConfigEutra::MIN12:
+            reportInterval = Seconds (720);
+            break;
+          case LteRrcSap::ReportConfigEutra::MIN30:
+            reportInterval = Seconds (1800);
+            break;
+          case LteRrcSap::ReportConfigEutra::MIN60:
+            reportInterval = Seconds (3600);
+            break;
+          default:
+            NS_FATAL_ERROR ("Unsupported reportInterval " << (uint16_t) reportConfigEutra.reportInterval);
+            break;
+          }
 
-      // schedule the next measurement reporting
-      measReportIt->second.periodicReportTimer 
-        = Simulator::Schedule (reportInterval,
-                               &LteUeRrc::SendMeasurementReport,
-                               this, measId);
+        // schedule the next measurement reporting
+        measReportIt->second.periodicReportTimer
+          = Simulator::Schedule (reportInterval,
+                                 &LteUeRrc::SendMeasurementReport,
+                                 this, measId);
 
-      // send the measurement report to eNodeB
-      m_rrcSapUser->SendMeasurementReport (measurementReport);
-    } 
+        // send the measurement report to eNodeB
+        m_rrcSapUser->SendMeasurementReport (measurementReport);
+      }
+  }
 }
 
-void 
+void
 LteUeRrc::StartConnection ()
 {
   NS_LOG_FUNCTION (this << m_imsi);
@@ -2934,7 +3934,7 @@
   m_cmacSapProvider.at (0)->StartContentionBasedRandomAccessProcedure ();
 }
 
-void 
+void
 LteUeRrc::LeaveConnectedMode ()
 {
   NS_LOG_FUNCTION (this << m_imsi);
@@ -2969,7 +3969,7 @@
   m_srb1Old = 0;
 }
 
-uint8_t 
+uint8_t
 LteUeRrc::Bid2Drbid (uint8_t bid)
 {
   std::map<uint8_t, uint8_t>::iterator it = m_bid2DrbidMap.find (bid);
@@ -2984,13 +3984,13 @@
     }
 }
 
-void 
+void
 LteUeRrc::SwitchToState (State newState)
 {
   NS_LOG_FUNCTION (this << ToString (newState));
   State oldState = m_state;
   m_state = newState;
-  NS_LOG_INFO (this << " IMSI " << m_imsi << " RNTI " << m_rnti << " UeRrc "
+  NS_LOG_INFO (this << " IMSI " << m_imsi << " RNTI " << m_rnti << " CellId " << m_cellId << " UeRrc "
                     << ToString (oldState) << " --> " << ToString (newState));
   m_stateTransitionTrace (m_imsi, m_cellId, m_rnti, oldState, newState);
 
@@ -3028,7 +4028,7 @@
     case CONNECTED_PHY_PROBLEM:
     case CONNECTED_REESTABLISHING:
       break;
- 
+
     default:
       break;
     }
@@ -3095,7 +4095,7 @@
                     << ", new RSRQ " << rsrq << " stored " << storedMeasIt->second.rsrq);
       storedMeasIt->second.timestamp = Simulator::Now ();
     }
-  else 
+  else
     {
       NS_LOG_DEBUG (this << " IMSI " << m_imsi << "measurement on SCC from not serving cell ");
     }
@@ -3104,4 +4104,3 @@
 
 
 } // namespace ns3
-
diff -Naru a/model/lte-ue-rrc.h b/model/lte-ue-rrc.h
--- a/model/lte-ue-rrc.h	2018-08-03 16:38:46.675807010 +0200
+++ b/model/lte-ue-rrc.h	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, 2018, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -20,6 +21,10 @@
  * Modified by:
  *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
  *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
+ * Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+ *							Integration of Carrier Aggregation for the mmWave module
  */
 
 #ifndef LTE_UE_RRC_H
@@ -33,15 +38,21 @@
 #include <ns3/lte-ue-cphy-sap.h>
 #include <ns3/lte-rrc-sap.h>
 #include <ns3/traced-callback.h>
+#include <ns3/lte-radio-bearer-info.h>
 #include "ns3/component-carrier-ue.h"
 #include <ns3/lte-ue-ccm-rrc-sap.h>
 #include <vector>
 
 #include <map>
 #include <set>
+#include <ns3/lte-rlc.h>
+#include <ns3/lte-pdcp.h>
+#include <ns3/lte-rlc-am.h>
 
 #define MIN_NO_CC 1
 #define MAX_NO_CC 5 // this is the maximum number of carrier components allowed by 3GPP up to R13
+#define MIN_NO_MMW_CC 1
+#define MAX_NO_MMW_CC 16 // from TR 38.802
 
 namespace ns3 {
 
@@ -98,7 +109,7 @@
 
   /**
    * The states of the UE RRC entity
-   * 
+   *
    */
   enum State
   {
@@ -152,6 +163,7 @@
    * \param s the CPHY SAP Provider
    */
   void SetLteUeCphySapProvider (LteUeCphySapProvider * s);
+  void SetMmWaveUeCphySapProvider (LteUeCphySapProvider * s);
   /**
    * set the CPHY SAP this RRC should use to interact with the PHY
    *
@@ -173,28 +185,34 @@
    */
   LteUeCphySapUser* GetLteUeCphySapUser (uint8_t index);
 
+  void SetMmWaveUeCmacSapProvider (LteUeCmacSapProvider * s);
+
+  void SetMmWaveUeCmacSapProvider (LteUeCmacSapProvider * s, uint8_t index);
+
+
   /**
    * set the CMAC SAP this RRC should interact with
-   * \brief This function is overloaded to maintain backward compatibility 
+   * \brief This function is overloaded to maintain backward compatibility
    * \param s the CMAC SAP Provider to be used by this RRC
    */
   void SetLteUeCmacSapProvider (LteUeCmacSapProvider * s);
+
   /**
    * set the CMAC SAP this RRC should interact with
-   * \brief This function is overloaded to maintain backward compatibility 
+   * \brief This function is overloaded to maintain backward compatibility
    * \param s the CMAC SAP Provider to be used by this RRC
    * \param index the index
    */
   void SetLteUeCmacSapProvider (LteUeCmacSapProvider * s, uint8_t index);
 
   /**
-   * \brief This function is overloaded to maintain backward compatibility 
+   * \brief This function is overloaded to maintain backward compatibility
    * \return s the CMAC SAP User interface offered to the MAC by this RRC
    */
   LteUeCmacSapUser* GetLteUeCmacSapUser ();
   /**
    * \brief This function is overloaded to maintain backward compatibility
-   * \param index the index  
+   * \param index the index
    * \return s the CMAC SAP User interface offered to the MAC by this RRC
    */
   LteUeCmacSapUser* GetLteUeCmacSapUser (uint8_t index);
@@ -222,17 +240,18 @@
    * newly created RLC instances
    */
   void SetLteMacSapProvider (LteMacSapProvider* s);
+  void SetMmWaveMacSapProvider (LteMacSapProvider* s);
 
-  /** 
+  /**
    * Set the AS SAP user to interact with the NAS entity
-   * 
+   *
    * \param s the AS SAP user
    */
   void SetAsSapUser (LteAsSapUser* s);
 
-  /** 
-   * 
-   * 
+  /**
+   *
+   *
    * \return the AS SAP provider exported by this RRC
    */
   LteAsSapProvider* GetAsSapProvider ();
@@ -251,8 +270,8 @@
    */
   LteUeCcmRrcSapUser* GetLteCcmRrcSapUser ();
 
-  /** 
-   * 
+  /**
+   *
    * \param imsi the unique UE identifier
    */
   void SetImsi (uint64_t imsi);
@@ -269,18 +288,31 @@
    */
   uint16_t GetRnti () const;
 
+
+  /**
+   * add an entry to the m_isMmWaveCellMap, respectively
+   * set to 1 or 0
+   */
+  void AddMmWaveCellId (uint16_t cellId);
+  void AddLteCellId (uint16_t cellId);
+
+  /**
+   * Switch lower layers' providers when connecting to a certain CellId
+   */
+  bool SwitchLowerLayerProviders (uint16_t cellId);
+
   /**
    *
    * \return the CellId of the attached Enb
    */
   uint16_t GetCellId () const;
 
-  /** 
+  /**
    * \return the uplink bandwidth in RBs
    */
   uint8_t GetUlBandwidth () const;
 
-  /** 
+  /**
    * \return the downlink bandwidth in RBs
    */
   uint8_t GetDlBandwidth () const;
@@ -290,7 +322,7 @@
    */
   uint32_t GetDlEarfcn () const;
 
-  /** 
+  /**
    * \return the uplink carrier frequency (EARFCN)
    */
   uint32_t GetUlEarfcn () const;
@@ -301,13 +333,14 @@
    */
   State GetState () const;
 
-  /** 
-   * 
-   * 
+  /**
+   *
+   *
    * \param val true if RLC SM is to be used, false if RLC UM/AM are to be used
    */
   void SetUseRlcSm (bool val);
 
+
   /**
    * TracedCallback signature for imsi, cellId and rnti events.
    *
@@ -352,14 +385,14 @@
     (uint64_t imsi, uint16_t cellId, uint16_t rnti,
      State oldState, State newState);
 
-  /**
-    * TracedCallback signature for secondary carrier configuration events.
-    *
-    * \param [in] Pointer to UE RRC
-    * \param [in] List of LteRrcSap::SCellToAddMod
-    */
-  typedef void (* SCarrierConfiguredTracedCallback)
-    (Ptr<LteUeRrc>, std::list<LteRrcSap::SCellToAddMod>);
+   /**
+     * TracedCallback signature for secondary carrier configuration events.
+     *
+     * \param [in] Pointer to UE RRC
+     * \param [in] List of LteRrcSap::SCellToAddMod
+     */
+   typedef void (* SCarrierConfiguredTracedCallback)
+     (Ptr<LteUeRrc>, std::list<LteRrcSap::SCellToAddMod>);
 
 
 private:
@@ -384,7 +417,7 @@
   void DoNotifyRandomAccessSuccessful ();
   /// Notify random access failed function
   void DoNotifyRandomAccessFailed ();
- 
+
   // LTE AS SAP methods
   /**
    * Set CSG white list function
@@ -416,6 +449,9 @@
   void DoSendData (Ptr<Packet> packet, uint8_t bid);
   /// Disconnect function
   void DoDisconnect ();
+  void DoNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId);
+  void DoNotifySecondaryCellHandover (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated rrcd);
+
 
   // CPHY SAP methods
   /**
@@ -440,6 +476,7 @@
    * \param params LteUeCphySapUser::UeMeasurementsParameters
    */
   void DoReportUeMeasurements (LteUeCphySapUser::UeMeasurementsParameters params);
+  void DoNotifyRadioLinkFailure (double lastSinrValue);
 
   // RRC SAP methods
 
@@ -483,6 +520,11 @@
    * \param msg the LteRrcSap::RrcConnectionReject
    */
   void DoRecvRrcConnectionReject (LteRrcSap::RrcConnectionReject msg);
+  /// Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectToMmWave interface.
+  void DoRecvRrcConnectToMmWave (uint16_t mmWaveCellId);
+  /// Part of the RRC protocol. Implement the LteUeRrcSapProvider:;RecvRrcConnectionSwitch interface.
+  void DoRecvRrcConnectionSwitch (LteRrcSap::RrcConnectionSwitch msg);
+
 
   /**
    * RRC CCM SAP USER Method
@@ -490,7 +532,7 @@
    */
   void DoComponentCarrierEnabling (std::vector<uint8_t> res);
 
- 
+
   // INTERNAL METHODS
 
   /**
@@ -613,7 +655,7 @@
    *
    * As for SaveUeMeasurements, this function aims to store the latest measurements
    * related to the secondary component carriers.
-   * in the current implementation it saves only measurements related on the serving 
+   * in the current implementation it saves only measurements related on the serving
    * secondary carriers while, measurements related to the Neighbor Cell are filtered
    */
 
@@ -706,19 +748,41 @@
    */
   void SwitchToState (State s);
 
+  /**
+   * Transfer the content of the buffers of RLC back into the PDCP, so
+   * that if a new RLC is available then the buffer content is not lost
+   * @params rlc the old RLC layer instance
+   * @params pdcp the PDCP instance connected to the new RLC instance
+   * @params lcid
+   */
+  void CopyRlcBuffers(Ptr<LteRlc> rlc, Ptr<LtePdcp> pdcp, uint16_t lcid);
+  //Lossless HO: merge 2 buffers into 1 with increment order.
+  std::vector < LteRlcAm::RetxPdu > MergeBuffers(std::vector < LteRlcAm::RetxPdu > first, std::vector < LteRlcAm::RetxPdu > second);
+
+
   std::map<uint8_t, uint8_t> m_bid2DrbidMap; ///< bid to DR bid map
 
   std::vector<LteUeCphySapUser*> m_cphySapUser; ///< UE CPhy SAP user
   std::vector<LteUeCphySapProvider*> m_cphySapProvider; ///< UE CPhy SAP provider
+  // CphyProviders for InterRat handover between MmWave and LTE
+  std::vector<LteUeCphySapProvider*> m_lteCphySapProvider;
+  std::vector<LteUeCphySapProvider*> m_mmWaveCphySapProvider;
 
   std::vector<LteUeCmacSapUser*> m_cmacSapUser; ///< UE CMac SAP user
   std::vector<LteUeCmacSapProvider*> m_cmacSapProvider; ///< UE CMac SAP provider
+  // CmacProviders for InterRat handover between MmWave and LTE
+  std::vector<LteUeCmacSapProvider*> m_lteCmacSapProvider;
+  std::vector<LteUeCmacSapProvider*> m_mmWaveCmacSapProvider;
 
+  //interfaces for RRC protocol
   LteUeRrcSapUser* m_rrcSapUser; ///< RRC SAP user
   LteUeRrcSapProvider* m_rrcSapProvider; ///< RRC SAP provider
 
   LteMacSapProvider* m_macSapProvider; ///< MAC SAP provider
   LtePdcpSapUser* m_drbPdcpSapUser; ///< DRB PDCP SAP user
+  // MacProviders for InterRat handover between MmWave and LTE
+  LteMacSapProvider* m_lteMacSapProvider;
+  LteMacSapProvider* m_mmWaveMacSapProvider;
 
   LteAsSapProvider* m_asSapProvider; ///< AS SAP provider
   LteAsSapUser* m_asSapUser; ///< AS SAP user
@@ -738,6 +802,7 @@
    * The `C-RNTI` attribute. Cell Radio Network Temporary Identifier.
    */
   uint16_t m_rnti;
+  uint16_t m_mmWaveRnti;
   /**
    * The `CellId` attribute. Serving cell identifier.
    */
@@ -761,6 +826,7 @@
    * Radio Bearers by LCID.
    */
   std::map <uint8_t, Ptr<LteDataRadioBearerInfo> > m_drbMap;
+  std::map <uint8_t, Ptr<RlcBearerInfo> > m_rlcMap;
 
   /**
    * True if RLC SM is to be used, false if RLC UM/AM are to be used.
@@ -859,6 +925,19 @@
    */
   TracedCallback<Ptr<LteUeRrc>, std::list<LteRrcSap::SCellToAddMod> > m_sCarrierConfiguredTrace;
 
+  /**
+   * The `SwitchToLte` trace source. Fired upon receiving a command to
+   * switch to LTE RAT. Exporting IMSI, cellId, RNTI.
+   */
+  TracedCallback<uint64_t, uint16_t, uint16_t> m_switchToLteTrace;
+
+  /**
+   * The `SwitchToMmWave` trace source. Fired upon receiving a command to
+   * switch to MmWave RAT. Exporting IMSI, cellId, RNTI.
+   */
+  TracedCallback<uint64_t, uint16_t, uint16_t> m_switchToMmWaveTrace;
+
+
   /// True if a connection request by upper layers is pending.
   bool m_connectionPending;
   /// True if MIB was received for the current cell.
@@ -1017,7 +1096,7 @@
 
   /**
    * \brief Internal storage of the latest measurement results from all detected
-   *        detected Secondary carrier component, indexed by the carrier component ID 
+   *        detected Secondary carrier component, indexed by the carrier component ID
    *        where the measurement was taken from.
    *
    * Each *measurement result* comprises of RSRP (in dBm) and RSRQ (in dB).
@@ -1027,7 +1106,7 @@
    * applied to the measurement results and they are used by *UE measurements*
    * function:
    * - LteUeRrc::MeasurementReportTriggering: in this case it is not set any
-   *   measurement related to seconday carrier components since the 
+   *   measurement related to seconday carrier components since the
    *   A6 event is not implemented
    * - LteUeRrc::SendMeasurementReport: in this case the report are sent.
    */
@@ -1166,13 +1245,29 @@
    *        connection establishment procedure has failed.
    */
   void ConnectionTimeout ();
+  bool m_isSecondaryRRC;
+  uint16_t m_mmWaveCellId;
+
+  std::map<uint16_t, bool> m_isMmWaveCellMap;
+  bool m_interRatHoCapable;
+  LteRrcSap::RachConfigDedicated m_rachConfigDedicated;
+  bool m_ncRaStarted;
+
+  // lossless HO
+  std::vector < Ptr<Packet> > m_rlcBufferToBeForwarded;
+  uint32_t m_rlcBufferToBeForwardedSize;
 
 public:
-  /** 
+  /**
    * The number of component carriers.
    */
   uint16_t m_numberOfComponentCarriers;
 
+  /**
+   * The number of mmWave component carriers. This is used in McUeDevs.
+   */
+  uint16_t m_numberOfMmWaveComponentCarriers;
+
 }; // end of class LteUeRrc
 
 
diff -Naru a/model/mc-enb-pdcp.cc b/model/mc-enb-pdcp.cc
--- a/model/mc-enb-pdcp.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/mc-enb-pdcp.cc	2018-08-03 16:39:02.895957709 +0200
@@ -0,0 +1,316 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011-2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Manuel Requena <manuel.requena@cttc.es>
+ * Extension to DC devices by Michele Polese <michele.polese@gmail.com>
+ */
+
+#include "ns3/log.h"
+#include "ns3/simulator.h"
+
+#include "ns3/mc-enb-pdcp.h"
+#include "ns3/lte-pdcp-header.h"
+#include "ns3/lte-pdcp-sap.h"
+#include "ns3/lte-pdcp-tag.h"
+#include "ns3/epc-x2-sap.h"
+
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("McEnbPdcp");
+
+class McPdcpSpecificLteRlcSapUser : public LteRlcSapUser
+{
+public:
+  McPdcpSpecificLteRlcSapUser (McEnbPdcp* pdcp);
+
+  // Interface provided to lower RLC entity (implemented from LteRlcSapUser)
+  virtual void ReceivePdcpPdu (Ptr<Packet> p);
+
+private:
+  McPdcpSpecificLteRlcSapUser ();
+  McEnbPdcp* m_pdcp;
+};
+
+McPdcpSpecificLteRlcSapUser::McPdcpSpecificLteRlcSapUser (McEnbPdcp* pdcp)
+  : m_pdcp (pdcp)
+{
+}
+
+McPdcpSpecificLteRlcSapUser::McPdcpSpecificLteRlcSapUser ()
+{
+}
+
+void
+McPdcpSpecificLteRlcSapUser::ReceivePdcpPdu (Ptr<Packet> p)
+{
+  m_pdcp->DoReceivePdu (p);
+}
+
+///////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (McEnbPdcp);
+
+McEnbPdcp::McEnbPdcp ()
+  : m_pdcpSapUser (0),
+    m_rlcSapProvider (0),
+    m_rnti (0),
+    m_lcid (0),
+    m_epcX2PdcpProvider (0),
+    m_txSequenceNumber (0),
+    m_rxSequenceNumber (0),
+    m_useMmWaveConnection (false)
+{
+  NS_LOG_FUNCTION (this);
+  m_pdcpSapProvider = new LtePdcpSpecificLtePdcpSapProvider<McEnbPdcp> (this);
+  m_rlcSapUser = new McPdcpSpecificLteRlcSapUser (this);
+  m_epcX2PdcpUser = new EpcX2PdcpSpecificUser<McEnbPdcp> (this);
+}
+
+McEnbPdcp::~McEnbPdcp ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+TypeId
+McEnbPdcp::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::McEnbPdcp")
+    .SetParent<Object> ()
+    .AddTraceSource ("TxPDU",
+                     "PDU transmission notified to the RLC.",
+                     MakeTraceSourceAccessor (&McEnbPdcp::m_txPdu),
+                     "ns3::McEnbPdcp::PduTxTracedCallback")
+    .AddTraceSource ("RxPDU",
+                     "PDU received.",
+                     MakeTraceSourceAccessor (&McEnbPdcp::m_rxPdu),
+                     "ns3::McEnbPdcp::PduRxTracedCallback")
+    ;
+  return tid;
+}
+
+void
+McEnbPdcp::DoDispose ()
+{
+  NS_LOG_FUNCTION (this);
+  delete (m_pdcpSapProvider);
+  delete (m_rlcSapUser);
+  delete (m_epcX2PdcpUser);
+}
+
+void
+McEnbPdcp::SetEpcX2PdcpProvider (EpcX2PdcpProvider * s)
+{
+  NS_LOG_FUNCTION(this);
+  m_epcX2PdcpProvider = s;
+}
+
+
+EpcX2PdcpUser*
+McEnbPdcp::GetEpcX2PdcpUser ()
+{
+  NS_LOG_FUNCTION(this);
+  return m_epcX2PdcpUser;
+}
+
+void
+McEnbPdcp::SetMmWaveRnti (uint16_t rnti)
+{
+  m_mmWaveRnti = rnti;
+}
+
+void
+McEnbPdcp::SetRnti (uint16_t rnti)
+{
+  NS_LOG_FUNCTION (this << (uint32_t) rnti);
+  m_rnti = rnti;
+}
+
+void
+McEnbPdcp::SetLcId (uint8_t lcId)
+{
+  NS_LOG_FUNCTION (this << (uint32_t) lcId);
+  m_lcid = lcId;
+}
+
+void
+McEnbPdcp::SetLtePdcpSapUser (LtePdcpSapUser * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_pdcpSapUser = s;
+}
+
+LtePdcpSapProvider*
+McEnbPdcp::GetLtePdcpSapProvider ()
+{
+  NS_LOG_FUNCTION (this);
+  return m_pdcpSapProvider;
+}
+
+void
+McEnbPdcp::SetLteRlcSapProvider (LteRlcSapProvider * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  NS_LOG_INFO("Change LteRlcSapProvider");
+  m_rlcSapProvider = s;
+}
+
+LteRlcSapUser*
+McEnbPdcp::GetLteRlcSapUser ()
+{
+  NS_LOG_FUNCTION (this);
+  return m_rlcSapUser;
+}
+
+McEnbPdcp::Status
+McEnbPdcp::GetStatus ()
+{
+  Status s;
+  s.txSn = m_txSequenceNumber;
+  s.rxSn = m_rxSequenceNumber;
+  return s;
+}
+
+void
+McEnbPdcp::SetStatus (Status s)
+{
+  m_txSequenceNumber = s.txSn;
+  m_rxSequenceNumber = s.rxSn;
+}
+
+void
+McEnbPdcp::SetUeDataParams(EpcX2Sap::UeDataParams params)
+{
+  m_ueDataParams = params;
+}
+
+
+////////////////////////////////////////
+
+void
+McEnbPdcp::DoTransmitPdcpSdu (Ptr<Packet> p)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
+
+  LtePdcpHeader pdcpHeader;
+  pdcpHeader.SetSequenceNumber (m_txSequenceNumber);
+
+  m_txSequenceNumber++;
+  if (m_txSequenceNumber > m_maxPdcpSn)
+    {
+      m_txSequenceNumber = 0;
+    }
+
+  pdcpHeader.SetDcBit (LtePdcpHeader::DATA_PDU);
+
+  NS_LOG_LOGIC ("PDCP header: " << pdcpHeader);
+  p->AddHeader (pdcpHeader);
+
+  LteRlcSapProvider::TransmitPdcpPduParameters params;
+  params.rnti = m_rnti;
+  params.lcid = m_lcid;
+
+  if(m_epcX2PdcpProvider == 0 || (!m_useMmWaveConnection))
+  {
+    NS_LOG_INFO(this << " McEnbPdcp: Tx packet to downlink local stack");
+
+    // Sender timestamp. We will use this to measure the delay on top of RLC
+    PdcpTag pdcpTag (Simulator::Now ());
+    p->AddByteTag (pdcpTag);
+    m_txPdu (m_rnti, m_lcid, p->GetSize ());
+    params.pdcpPdu = p;
+
+    NS_LOG_LOGIC("Params.rnti " << params.rnti);
+    NS_LOG_LOGIC("Params.m_lcid " << params.lcid);
+    NS_LOG_LOGIC("Params.pdcpPdu " << params.pdcpPdu);
+
+    m_rlcSapProvider->TransmitPdcpPdu (params);
+  }
+  else if (m_useMmWaveConnection)
+  {
+    // Do not add sender time stamp: we are not interested in adding X2 delay for MC connections
+    NS_LOG_INFO(this << " McEnbPdcp: Tx packet to downlink MmWave stack on remote cell " << m_ueDataParams.targetCellId);
+    m_ueDataParams.ueData = p;
+    m_txPdu (m_rnti, m_lcid, p->GetSize ());
+    m_epcX2PdcpProvider->SendMcPdcpPdu (m_ueDataParams);
+  }
+  else
+  {
+    NS_FATAL_ERROR("Invalid combination");
+  }
+}
+
+void
+McEnbPdcp::DoReceivePdu (Ptr<Packet> p)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
+
+  NS_LOG_INFO(this << " McEnbPdcp received uplink Pdu");
+  // Receiver timestamp
+  PdcpTag pdcpTag;
+  Time delay;
+  if (p->FindFirstMatchingByteTag (pdcpTag))
+    {
+      delay = Simulator::Now() - pdcpTag.GetSenderTimestamp ();
+    }
+  m_rxPdu(m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
+
+  p->RemoveAllByteTags();
+  NS_LOG_LOGIC("ALL BYTE TAGS REMOVED. NetAmin and FlowMonitor won't work");
+
+  LtePdcpHeader pdcpHeader;
+  p->RemoveHeader (pdcpHeader);
+  NS_LOG_LOGIC ("PDCP header: " << pdcpHeader);
+
+  m_rxSequenceNumber = pdcpHeader.GetSequenceNumber () + 1;
+  if (m_rxSequenceNumber > m_maxPdcpSn)
+    {
+      m_rxSequenceNumber = 0;
+    }
+  if(p->GetSize() > 20 + 8 + 12)
+  {
+    LtePdcpSapUser::ReceivePdcpSduParameters params;
+    params.pdcpSdu = p;
+    params.rnti = m_rnti;
+    params.lcid = m_lcid;
+    m_pdcpSapUser->ReceivePdcpSdu (params);
+  }
+}
+
+void
+McEnbPdcp::DoReceiveMcPdcpPdu (EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION(this << m_mmWaveRnti << (uint32_t) m_lcid);
+  DoReceivePdu(params.ueData);
+}
+
+void
+McEnbPdcp::SwitchConnection (bool useMmWaveConnection)
+{
+  m_useMmWaveConnection = useMmWaveConnection;
+}
+
+bool
+McEnbPdcp::GetUseMmWaveConnection() const
+{
+  return m_useMmWaveConnection && (m_epcX2PdcpProvider != 0);
+}
+
+
+
+} // namespace ns3
diff -Naru a/model/mc-enb-pdcp.h b/model/mc-enb-pdcp.h
--- a/model/mc-enb-pdcp.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/mc-enb-pdcp.h	2018-08-03 16:39:02.895957709 +0200
@@ -0,0 +1,243 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011-2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab. 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Manuel Requena <manuel.requena@cttc.es>
+ * Extension to DC devices by Michele Polese <michele.polese@gmail.com>
+ */
+
+#ifndef MC_ENB_PDCP_H
+#define MC_ENB_PDCP_H
+
+#include "ns3/traced-value.h"
+#include "ns3/trace-source-accessor.h"
+
+#include "ns3/object.h"
+
+#include <ns3/epc-x2-sap.h>
+#include <ns3/epc-x2.h>
+#include <ns3/lte-pdcp-sap.h>
+#include <ns3/lte-rlc-sap.h>
+#include <ns3/lte-pdcp.h>
+
+namespace ns3 {
+
+/**
+ * MC eNB PDCP entity. It has 2 interfaces to the 2 RLC layers,
+ * the local and the remote one. The interface to the local is a
+ * Rlc Sap, while the interface to the remote is offered by the 
+ * EpcX2Sap.
+ * Note: there is a single IMSI and lcid (no problem in having the same
+ * in the 2 eNBs), but 2 rnti.
+ */
+class McEnbPdcp : public LtePdcp 
+{
+  friend class McPdcpSpecificLteRlcSapUser;
+  friend class LtePdcpSpecificLtePdcpSapProvider<McEnbPdcp>;
+  friend class EpcX2PdcpSpecificProvider <EpcX2>;
+  friend class EpcX2PdcpSpecificUser <McEnbPdcp>;
+public:
+  McEnbPdcp ();
+  virtual ~McEnbPdcp ();
+  static TypeId GetTypeId (void);
+  virtual void DoDispose ();
+
+  /**
+   * Set the RNTI of the UE in the MmWave eNB
+   *
+   * \param rnti
+   */
+  void SetMmWaveRnti (uint16_t rnti);
+
+  /**
+   * Set the RNTI of the UE in the LTE eNB
+   *
+   * \param rnti
+   */
+  void SetRnti (uint16_t rnti);
+
+  /**
+   * Set the ldid
+   *
+   * \param lcId
+   */
+  void SetLcId (uint8_t lcId);
+
+  /**
+   *
+   *
+   * \param s the EpcX2PDCP Provider to the Epc X2 interface
+   */
+  void SetEpcX2PdcpProvider (EpcX2PdcpProvider * s);
+
+  /**
+   *
+   *
+   * \return the EpcX2PDCP User, given to X2 to access PDCP Receive method
+   */
+  EpcX2PdcpUser* GetEpcX2PdcpUser ();
+
+  /**
+   *
+   *
+   * \param s the PDCP SAP user to be used by this LTE_PDCP
+   */
+  void SetLtePdcpSapUser (LtePdcpSapUser * s);
+
+  /**
+   *
+   *
+   * \return the PDCP SAP Provider interface offered to the RRC by this LTE_PDCP
+   */
+  LtePdcpSapProvider* GetLtePdcpSapProvider ();
+
+  /**
+   *
+   *
+   * \param s the RLC SAP Provider to be used by this LTE_PDCP
+   */
+  void SetLteRlcSapProvider (LteRlcSapProvider * s);
+
+  /**
+   *
+   *
+   * \return the RLC SAP User interface offered to the RLC by this LTE_PDCP
+   */
+  LteRlcSapUser* GetLteRlcSapUser ();
+
+  static const uint16_t MAX_PDCP_SN = 4096;
+
+  /**
+   * Status variables of the PDCP
+   * 
+   */
+  struct Status
+  {
+    uint16_t txSn; ///< TX sequence number
+    uint16_t rxSn; ///< RX sequence number
+  };
+
+  /** 
+   * 
+   * \return the current status of the PDCP
+   */
+  Status GetStatus ();
+
+  /**
+   * Set the status of the PDCP
+   * 
+   * \param s 
+   */
+  void SetStatus (Status s);
+
+  /**
+   * Set the param needed for X2 tunneling
+   * \param the UeDataParams defined in RRC
+   */
+  void SetUeDataParams(EpcX2Sap::UeDataParams params);
+
+  /**
+   * TracedCallback for PDU transmission event.
+   *
+   * \param [in] rnti The C-RNTI identifying the UE.
+   * \param [in] lcid The logical channel id corresponding to
+   *             the sending RLC instance.
+   * \param [in] size Packet size.
+   */
+  typedef void (* PduTxTracedCallback)
+    (uint16_t rnti, uint8_t lcid, uint32_t size);
+
+  /**
+   * TracedCallback signature for PDU receive event.
+   *
+   * \param [in] rnti The C-RNTI identifying the UE.
+   * \param [in] lcid The logical channel id corresponding to
+   *             the sending RLC instance.
+   * \param [in] size Packet size.
+   * \param [in] delay Delay since packet sent, in ns..
+   */
+  typedef void (* PduRxTracedCallback)
+    (const uint16_t rnti, const uint8_t lcid,
+     const uint32_t size, const uint64_t delay);
+
+  /**
+   * Switch between LTE and MmWave
+   */
+  void SwitchConnection(bool useMmWaveConnection);
+
+  /**
+   * Return true if this PDCP is configured to forward data to the mmWave eNB
+   */
+  bool GetUseMmWaveConnection() const;
+
+protected:
+  // Interface provided to upper RRC entity
+  virtual void DoTransmitPdcpSdu (Ptr<Packet> p);
+
+  LtePdcpSapUser* m_pdcpSapUser;
+  LtePdcpSapProvider* m_pdcpSapProvider;
+
+  // Interface provided to lower RLC entity
+  virtual void DoReceivePdu (Ptr<Packet> p);
+
+  LteRlcSapUser* m_rlcSapUser;
+  LteRlcSapProvider* m_rlcSapProvider;
+
+  uint16_t m_rnti;
+  uint8_t m_lcid;
+  uint16_t m_mmWaveRnti;
+
+  /**
+   * Used to inform of a PDU delivery to the RLC SAP provider.
+   * The parameters are RNTI, LCID and bytes delivered
+   */
+  TracedCallback<uint16_t, uint8_t, uint32_t> m_txPdu;
+  /**
+   * Used to inform of a PDU reception from the RLC SAP user.
+   * The parameters are RNTI, LCID, bytes delivered and delivery delay in nanoseconds. 
+   */
+  TracedCallback<uint16_t, uint8_t, uint32_t, uint64_t> m_rxPdu;
+
+  // Interface provided to EpcX2 entity
+  virtual void DoReceiveMcPdcpPdu(EpcX2Sap::UeDataParams params);
+
+  EpcX2PdcpProvider* m_epcX2PdcpProvider;
+  EpcX2PdcpUser* m_epcX2PdcpUser;
+
+private:
+  /**
+   * State variables. See section 7.1 in TS 36.323
+   */
+  uint16_t m_txSequenceNumber;
+  uint16_t m_rxSequenceNumber;
+
+  // UeDataParams needed to forward data to MmWave
+  EpcX2Sap::UeDataParams m_ueDataParams;
+
+  /**
+   * Constants. See section 7.2 in TS 36.323
+   */
+  static const uint16_t m_maxPdcpSn = 4095;
+
+  bool m_useMmWaveConnection;
+
+};
+
+
+} // namespace ns3
+
+#endif // MC_ENB_PDCP_H
diff -Naru a/model/mc-ue-pdcp.cc b/model/mc-ue-pdcp.cc
--- a/model/mc-ue-pdcp.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/mc-ue-pdcp.cc	2018-08-03 16:39:02.895957709 +0200
@@ -0,0 +1,297 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011-2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Manuel Requena <manuel.requena@cttc.es>
+ * Extension to DC devices by Michele Polese <michele.polese@gmail.com>
+ */
+
+#include "ns3/log.h"
+#include "ns3/simulator.h"
+
+#include "ns3/mc-ue-pdcp.h"
+#include "ns3/lte-pdcp-header.h"
+#include "ns3/lte-pdcp-sap.h"
+#include "ns3/lte-pdcp-tag.h"
+#include "ns3/seq-ts-header.h"
+
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("McUePdcp");
+
+class McUePdcpSpecificLteRlcSapUser : public LteRlcSapUser
+{
+public:
+  McUePdcpSpecificLteRlcSapUser (McUePdcp* pdcp);
+
+  // Interface provided to lower RLC entity (implemented from LteRlcSapUser)
+  virtual void ReceivePdcpPdu (Ptr<Packet> p);
+
+private:
+  McUePdcpSpecificLteRlcSapUser ();
+  McUePdcp* m_pdcp;
+};
+
+McUePdcpSpecificLteRlcSapUser::McUePdcpSpecificLteRlcSapUser (McUePdcp* pdcp)
+  : m_pdcp (pdcp)
+{
+}
+
+McUePdcpSpecificLteRlcSapUser::McUePdcpSpecificLteRlcSapUser ()
+{
+}
+
+void
+McUePdcpSpecificLteRlcSapUser::ReceivePdcpPdu (Ptr<Packet> p)
+{
+  m_pdcp->DoReceivePdu (p);
+}
+
+///////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (McUePdcp);
+
+McUePdcp::McUePdcp ()
+  : m_pdcpSapUser (0),
+    m_rlcSapProvider (0),
+    m_rnti (0),
+    m_lcid (0),
+    m_txSequenceNumber (0),
+    m_rxSequenceNumber (0),
+    m_useMmWaveConnection (false)
+{
+  NS_LOG_FUNCTION (this);
+  m_pdcpSapProvider = new LtePdcpSpecificLtePdcpSapProvider<McUePdcp> (this);
+  m_rlcSapUser = new McUePdcpSpecificLteRlcSapUser (this);
+}
+
+McUePdcp::~McUePdcp ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+TypeId
+McUePdcp::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::McUePdcp")
+    .SetParent<Object> ()
+    .SetGroupName("Lte")
+    .AddTraceSource ("TxPDU",
+                     "PDU transmission notified to the RLC.",
+                     MakeTraceSourceAccessor (&McUePdcp::m_txPdu),
+                     "ns3::McUePdcp::PduTxTracedCallback")
+    .AddTraceSource ("RxPDU",
+                     "PDU received.",
+                     MakeTraceSourceAccessor (&McUePdcp::m_rxPdu),
+                     "ns3::McUePdcp::PduRxTracedCallback")
+    .AddAttribute ("LteUplink",
+                    "Use LTE for uplink",
+                    BooleanValue (false),
+                    MakeBooleanAccessor (&McUePdcp::m_alwaysLteUplink),
+                    MakeBooleanChecker ())
+    ;
+  return tid;
+}
+
+void
+McUePdcp::DoDispose ()
+{
+  NS_LOG_FUNCTION (this);
+  delete (m_pdcpSapProvider);
+  delete (m_rlcSapUser);
+}
+
+
+void
+McUePdcp::SetRnti (uint16_t rnti)
+{
+  NS_LOG_FUNCTION (this << (uint32_t) rnti);
+  m_rnti = rnti;
+}
+
+void
+McUePdcp::SetMmWaveRnti (uint16_t rnti)
+{
+  NS_LOG_FUNCTION (this << (uint32_t) rnti);
+  m_mmWaveRnti = rnti;
+}
+
+void
+McUePdcp::SetLcId (uint8_t lcId)
+{
+  NS_LOG_FUNCTION (this << (uint32_t) lcId);
+  m_lcid = lcId;
+}
+
+void
+McUePdcp::SetLtePdcpSapUser (LtePdcpSapUser * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_pdcpSapUser = s;
+}
+
+LtePdcpSapProvider*
+McUePdcp::GetLtePdcpSapProvider ()
+{
+  NS_LOG_FUNCTION (this);
+  return m_pdcpSapProvider;
+}
+
+void
+McUePdcp::SetLteRlcSapProvider (LteRlcSapProvider * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_rlcSapProvider = s;
+}
+
+void
+McUePdcp::SetMmWaveRlcSapProvider (LteRlcSapProvider * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_mmWaveRlcSapProvider = s;
+}
+
+LteRlcSapUser*
+McUePdcp::GetLteRlcSapUser ()
+{
+  NS_LOG_FUNCTION (this);
+  return m_rlcSapUser;
+}
+
+McUePdcp::Status
+McUePdcp::GetStatus ()
+{
+  Status s;
+  s.txSn = m_txSequenceNumber;
+  s.rxSn = m_rxSequenceNumber;
+  return s;
+}
+
+void
+McUePdcp::SetStatus (Status s)
+{
+  m_txSequenceNumber = s.txSn;
+  m_rxSequenceNumber = s.rxSn;
+}
+
+////////////////////////////////////////
+
+void
+McUePdcp::DoTransmitPdcpSdu (Ptr<Packet> p)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
+
+  LtePdcpHeader pdcpHeader;
+  pdcpHeader.SetSequenceNumber (m_txSequenceNumber);
+
+  m_txSequenceNumber++;
+  if (m_txSequenceNumber > m_maxPdcpSn)
+    {
+      m_txSequenceNumber = 0;
+    }
+
+  pdcpHeader.SetDcBit (LtePdcpHeader::DATA_PDU);
+
+  NS_LOG_LOGIC ("PDCP header: " << pdcpHeader);
+  p->AddHeader (pdcpHeader);
+
+  // Sender timestamp
+  PdcpTag pdcpTag (Simulator::Now ());
+  p->AddByteTag (pdcpTag);
+  m_txPdu (m_rnti, m_lcid, p->GetSize ());
+
+  LteRlcSapProvider::TransmitPdcpPduParameters params;
+  params.rnti = m_rnti;
+  params.lcid = m_lcid;
+  params.pdcpPdu = p;
+
+  // WARN TODO hack: always use LTE for uplink (i.e. TCP acks)
+  if(m_mmWaveRlcSapProvider == 0 || (!m_useMmWaveConnection) || m_alwaysLteUplink)
+  {
+    NS_LOG_INFO(this << " McUePdcp: Tx packet to uplink primary stack");
+    m_rlcSapProvider->TransmitPdcpPdu (params);
+  }
+  else if (m_useMmWaveConnection)
+  {
+    NS_LOG_INFO(this << " McUePdcp: Tx packet to uplink secondary stack");
+    m_mmWaveRlcSapProvider->TransmitPdcpPdu (params);
+  }
+  else
+  {
+    NS_FATAL_ERROR ("Invalid combination");
+  }
+}
+
+void
+McUePdcp::DoReceivePdu (Ptr<Packet> p)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
+
+  NS_LOG_INFO(this << " McUePdcp received dowlink Pdu");
+  // Receiver timestamp
+  PdcpTag pdcpTag;
+  Time delay;
+  if (p->FindFirstMatchingByteTag (pdcpTag))
+    {
+      delay = Simulator::Now() - pdcpTag.GetSenderTimestamp ();
+    }
+  m_rxPdu(m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
+
+  p->RemoveAllByteTags();
+  NS_LOG_LOGIC("ALL BYTE TAGS REMOVED. NetAmin and FlowMonitor won't work");
+
+  if(p->GetSize() > 3)
+  {
+    LtePdcpHeader pdcpHeader;
+    p->RemoveHeader (pdcpHeader);
+    NS_LOG_LOGIC ("PDCP header: " << pdcpHeader);
+
+    // SeqTsHeader seqTs;
+    // p->PeekHeader (seqTs);
+    // NS_LOG_UNCOND("Carrying UDP packet " << (uint32_t)seqTs.GetSeq());
+
+
+    m_rxSequenceNumber = pdcpHeader.GetSequenceNumber () + 1;
+    if (m_rxSequenceNumber > m_maxPdcpSn)
+      {
+        m_rxSequenceNumber = 0;
+      }
+
+    if(p->GetSize() > 20 + 8 + 12)
+    {
+      LtePdcpSapUser::ReceivePdcpSduParameters params;
+      params.pdcpSdu = p;
+      params.rnti = m_rnti;
+      params.lcid = m_lcid;
+      m_pdcpSapUser->ReceivePdcpSdu (params);
+    }
+  }
+  else
+  {
+    NS_LOG_INFO("Packet fragmented, too small!");
+  }
+}
+
+void
+McUePdcp::SwitchConnection (bool useMmWaveConnection)
+{
+  m_useMmWaveConnection = useMmWaveConnection;
+}
+
+
+} // namespace ns3
diff -Naru a/model/mc-ue-pdcp.h b/model/mc-ue-pdcp.h
--- a/model/mc-ue-pdcp.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/mc-ue-pdcp.h	2018-08-03 16:39:02.895957709 +0200
@@ -0,0 +1,214 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011-2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab. 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author of base class: Manuel Requena <manuel.requena@cttc.es>
+ * Extension to DC devices by Michele Polese <michele.polese@gmail.com>
+ */
+
+#ifndef MC_UE_PDCP_H
+#define MC_UE_PDCP_H
+
+#include "ns3/traced-value.h"
+#include "ns3/trace-source-accessor.h"
+
+#include "ns3/object.h"
+
+#include <ns3/lte-pdcp-sap.h>
+#include <ns3/lte-rlc-sap.h>
+#include <ns3/lte-pdcp.h>
+
+namespace ns3 {
+
+/**
+ * MC UE PDCP entity. It has 2 interfaces to the 2 RLC layers
+ * Note: there is a single IMSI and lcid (no problem in having the same
+ * in the 2 eNBs), but 2 rnti.
+ */
+class McUePdcp : public LtePdcp 
+{
+  friend class McUePdcpSpecificLteRlcSapUser;
+  friend class LtePdcpSpecificLtePdcpSapProvider<McUePdcp>;
+
+public:
+  McUePdcp ();
+  virtual ~McUePdcp ();
+  static TypeId GetTypeId (void);
+  virtual void DoDispose ();
+
+  /**
+   * Set the RNTI of the UE in the MmWave eNB
+   *
+   * \param rnti
+   */
+  void SetMmWaveRnti (uint16_t rnti);
+
+  /**
+   * Set the RNTI of the UE in the LTE eNB
+   *
+   * \param rnti
+   */
+  void SetRnti (uint16_t rnti);
+
+  /**
+   * Set the ldid
+   *
+   * \param lcId
+   */
+  void SetLcId (uint8_t lcId);
+
+  /**
+   *
+   *
+   * \param s the PDCP SAP user to be used by this MC_PDCP
+   */
+  void SetLtePdcpSapUser (LtePdcpSapUser * s);
+
+  /**
+   *
+   *
+   * \return the PDCP SAP Provider interface offered to the RRC by this MC_PDCP
+   */
+  LtePdcpSapProvider* GetLtePdcpSapProvider ();
+
+  /**
+   *
+   *
+   * \param s the Lte RLC SAP Provider to be used by this MC_PDCP
+   */
+  void SetLteRlcSapProvider (LteRlcSapProvider * s);
+
+  /**
+   *
+   *
+   * \return the RLC SAP User interface offered to the RLC by this MC_PDCP
+   */
+  LteRlcSapUser* GetLteRlcSapUser ();
+
+  /**
+   *
+   *
+   * \param s the MmWave RLC SAP Provider to be used by this MC_PDCP
+   */
+  void SetMmWaveRlcSapProvider (LteRlcSapProvider * s);
+
+  static const uint16_t MAX_PDCP_SN = 4096;
+
+  /**
+   * Status variables of the PDCP
+   * 
+   */
+  struct Status
+  {
+    uint16_t txSn; ///< TX sequence number
+    uint16_t rxSn; ///< RX sequence number
+  };
+
+  /** 
+   * 
+   * \return the current status of the PDCP
+   */
+  Status GetStatus ();
+
+  /**
+   * Set the status of the PDCP
+   * 
+   * \param s 
+   */
+  void SetStatus (Status s);
+
+  /**
+   * TracedCallback for PDU transmission event.
+   *
+   * \param [in] rnti The C-RNTI identifying the UE.
+   * \param [in] lcid The logical channel id corresponding to
+   *             the sending RLC instance.
+   * \param [in] size Packet size.
+   */
+  typedef void (* PduTxTracedCallback)
+    (uint16_t rnti, uint8_t lcid, uint32_t size);
+
+  /**
+   * TracedCallback signature for PDU receive event.
+   *
+   * \param [in] rnti The C-RNTI identifying the UE.
+   * \param [in] lcid The logical channel id corresponding to
+   *             the sending RLC instance.
+   * \param [in] size Packet size.
+   * \param [in] delay Delay since packet sent, in ns..
+   */
+  typedef void (* PduRxTracedCallback)
+    (const uint16_t rnti, const uint8_t lcid,
+     const uint32_t size, const uint64_t delay);
+
+  /**
+   * Switch between LTE and MmWave
+   */
+  void SwitchConnection(bool useMmWaveConnection);
+
+
+
+protected:
+  // Interface provided to upper RRC entity
+  virtual void DoTransmitPdcpSdu (Ptr<Packet> p);
+
+  LtePdcpSapUser* m_pdcpSapUser;
+  LtePdcpSapProvider* m_pdcpSapProvider;
+
+  // Interface provided to lower RLC entity
+  virtual void DoReceivePdu (Ptr<Packet> p);
+
+  LteRlcSapUser* m_rlcSapUser;
+  LteRlcSapProvider* m_rlcSapProvider;
+  LteRlcSapProvider* m_mmWaveRlcSapProvider;
+
+  uint16_t m_rnti;
+  uint8_t m_lcid;
+  uint16_t m_mmWaveRnti;
+
+  /**
+   * Used to inform of a PDU delivery to the RLC SAP provider.
+   * The parameters are RNTI, LCID and bytes delivered
+   */
+  TracedCallback<uint16_t, uint8_t, uint32_t> m_txPdu;
+  /**
+   * Used to inform of a PDU reception from the RLC SAP user.
+   * The parameters are RNTI, LCID, bytes delivered and delivery delay in nanoseconds. 
+   */
+  TracedCallback<uint16_t, uint8_t, uint32_t, uint64_t> m_rxPdu;
+
+private:
+  /**
+   * State variables. See section 7.1 in TS 36.323
+   */
+  uint16_t m_txSequenceNumber;
+  uint16_t m_rxSequenceNumber;
+
+  /**
+   * Constants. See section 7.2 in TS 36.323
+   */
+  static const uint16_t m_maxPdcpSn = 4095;
+
+  bool m_useMmWaveConnection;
+  bool m_alwaysLteUplink;
+
+};
+
+
+} // namespace ns3
+
+#endif // MC_UE_PDCP_H
diff -Naru a/model/no-op-component-carrier-manager.cc b/model/no-op-component-carrier-manager.cc
--- a/model/no-op-component-carrier-manager.cc	2018-08-03 16:38:46.679807047 +0200
+++ b/model/no-op-component-carrier-manager.cc	2018-08-03 16:39:02.895957709 +0200
@@ -29,7 +29,7 @@
 
 NS_LOG_COMPONENT_DEFINE ("NoOpComponentCarrierManager");
 NS_OBJECT_ENSURE_REGISTERED (NoOpComponentCarrierManager);
-  
+
 NoOpComponentCarrierManager::NoOpComponentCarrierManager ()
 {
   NS_LOG_FUNCTION (this);
@@ -83,7 +83,7 @@
 {
   NS_LOG_FUNCTION (this);
   std::map <uint8_t, LteMacSapProvider*>::iterator it =  m_macSapProvidersMap.find (params.componentCarrierId);
-  NS_ASSERT_MSG (it != m_macSapProvidersMap.end (), "could not find Sap for ComponentCarrier " << params.componentCarrierId);
+  NS_ASSERT_MSG (it != m_macSapProvidersMap.end (), "could not find Sap for ComponentCarrier " << (uint32_t)params.componentCarrierId);
   // with this algorithm all traffic is on Primary Carrier
   it->second->TransmitPdu (params);
 }
@@ -460,7 +460,17 @@
       for ( uint16_t i = 0;  i < numberOfCarriersForUe ; i++)
         {
           NS_ASSERT_MSG (m_macSapProvidersMap.find(i)!=m_macSapProvidersMap.end(), "Mac sap provider does not exist.");
-          m_macSapProvidersMap.find(i)->second->ReportBufferStatus(params);
+          if ( i==0 )
+          {
+            // only the PCC sends STATUS PDUs
+            m_macSapProvidersMap.find(i)->second->ReportBufferStatus(params);
+          }
+          else
+          {
+            LteMacSapProvider::ReportBufferStatusParameters newParams = params;
+            newParams.statusPduSize = 0;
+            m_macSapProvidersMap.find(i)->second->ReportBufferStatus(newParams);
+          }
         }
     }
 }
diff -Naru a/model/no-op-component-carrier-manager.h b/model/no-op-component-carrier-manager.h
--- a/model/no-op-component-carrier-manager.h	2018-08-03 16:38:46.679807047 +0200
+++ b/model/no-op-component-carrier-manager.h	2018-08-03 16:39:02.895957709 +0200
@@ -86,7 +86,7 @@
    * \param lcid the LCID
    * \param lcGroup the LC group
    * \param msu the MSU
-   * \returns std::vector<LteCcmRrcSapProvider::LcsConfig> 
+   * \returns std::vector<LteCcmRrcSapProvider::LcsConfig>
    */
   virtual std::vector<LteCcmRrcSapProvider::LcsConfig> DoSetupDataRadioBearer (EpsBearer bearer, uint8_t bearerId, uint16_t rnti, uint8_t lcid, uint8_t lcGroup, LteMacSapUser* msu);
   /**
diff -Naru a/model/pf-ff-mac-scheduler.cc b/model/pf-ff-mac-scheduler.cc
--- a/model/pf-ff-mac-scheduler.cc	2018-08-03 16:38:46.679807047 +0200
+++ b/model/pf-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -598,7 +598,7 @@
         {
           m_rachAllocationMap.at (i) = (*itRach).m_rnti;
         }
-      
+
       if (m_harqOn == true)
         {
           // generate UL-DCI for HARQ retransmissions
@@ -636,7 +636,7 @@
             }
           (*itDci).second.at (harqId) = uldci;
         }
-      
+
       rbStart = rbStart + rbLen;
       ret.m_buildRarList.push_back (newRar);
     }
@@ -2071,7 +2071,7 @@
               // for SRB1 (using RLC AM) it's better to
               // overestimate RLC overhead rather than
               // underestimate it and risk unneeded
-              // segmentation which increases delay 
+              // segmentation which increases delay
               rlcOverhead = 4;
             }
           else
diff -Naru a/model/pss-ff-mac-scheduler.cc b/model/pss-ff-mac-scheduler.cc
--- a/model/pss-ff-mac-scheduler.cc	2018-08-03 16:38:46.679807047 +0200
+++ b/model/pss-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -285,7 +285,7 @@
 PssFfMacScheduler::DoCschedUeReleaseReq (const struct FfMacCschedSapProvider::CschedUeReleaseReqParameters& params)
 {
   NS_LOG_FUNCTION (this);
-  
+
   m_uesTxMode.erase (params.m_rnti);
   m_dlHarqCurrentProcessId.erase (params.m_rnti);
   m_dlHarqProcessesStatus.erase  (params.m_rnti);
@@ -487,7 +487,7 @@
           if ((*itTimers).second.at (i) == HARQ_DL_TIMEOUT)
             {
               // reset HARQ process
-              
+
               NS_LOG_DEBUG (this << " Reset HARQ proc " << i << " for RNTI " << (*itTimers).first);
               std::map <uint16_t, DlHarqProcessesStatus_t>::iterator itStat = m_dlHarqProcessesStatus.find ((*itTimers).first);
               if (itStat == m_dlHarqProcessesStatus.end ())
@@ -503,7 +503,7 @@
             }
         }
     }
-  
+
 }
 
 
@@ -981,7 +981,7 @@
               }
               continue;
             }
-    
+
           double metric = 0.0;
           if ((*it).second.lastAveragedThroughput < (*it).second.targetThroughput )
             {
@@ -1037,34 +1037,34 @@
                 {
                   wbCqi = (*itCqi).second;
                 }
-    
+
               if (wbCqi > 0)
                 {
                   if (LcActivePerFlow ((*it).first) > 0)
                     {
                       // this UE has data to transmit
                       double achievableRate = 0.0;
-                      for (uint8_t k = 0; k < nLayer; k++) 
+                      for (uint8_t k = 0; k < nLayer; k++)
                         {
-                          uint8_t mcs = 0; 
+                          uint8_t mcs = 0;
                           mcs = m_amc->GetMcsFromCqi (wbCqi);
                           achievableRate += ((m_amc->GetDlTbSizeFromMcs (mcs, rbgSize) / 8) / 0.001); // = TB size / TTI
                         }
-    
+
                       metric = achievableRate / (*it).second.lastAveragedThroughput;
                    }
                   ueSet2.push_back(std::pair<double, uint16_t> (metric, (*it).first));
                 } // end of wbCqi
             }
         }// end of ueSet
-    
-    
+
+
       if (ueSet1.size () != 0 || ueSet2.size () != 0)
         {
           // sorting UE in ueSet1 and ueSet1 in descending order based on their metric value
           std::sort (ueSet1.rbegin (), ueSet1.rend ());
           std::sort (ueSet2.rbegin (), ueSet2.rend ());
- 
+
           // select UE set for frequency domain scheduler
           uint32_t nMux;
           if ( m_nMux > 0)
@@ -1081,30 +1081,30 @@
            {
              std::vector <std::pair<double, uint16_t> >::iterator itSet;
              for (itSet = ueSet1.begin (); itSet != ueSet1.end () && nMux != 0; itSet++)
-               {  
+               {
                  std::map <uint16_t, pssFlowPerf_t>::iterator itUe;
                  itUe = m_flowStatsDl.find((*itSet).second);
                  tdUeSet.insert(std::pair<uint16_t, pssFlowPerf_t> ( (*itUe).first, (*itUe).second ) );
                  nMux--;
                }
-           
+
              if (nMux == 0)
                break;
-        
+
              for (itSet = ueSet2.begin (); itSet != ueSet2.end () && nMux != 0; itSet++)
-               {  
+               {
                  std::map <uint16_t, pssFlowPerf_t>::iterator itUe;
                  itUe = m_flowStatsDl.find((*itSet).second);
                  tdUeSet.insert(std::pair<uint16_t, pssFlowPerf_t> ( (*itUe).first, (*itUe).second ) );
                  nMux--;
                }
-        
+
              if (nMux == 0)
                break;
-        
+
            } // end of m_flowStatsDl
-        
-        
+
+
           if ( m_fdSchedulerType.compare("CoItA") == 0)
             {
               // FD scheduler: Carrier over Interference to Average (CoItA)
@@ -1135,36 +1135,36 @@
                         {
                           sbCqis = (*itCqi).second.m_higherLayerSelected.at (i).m_sbCqi;
                         }
-        
+
                       uint8_t cqi1 = sbCqis.at (0);
                       uint8_t cqi2 = 0;
                       if (sbCqis.size () > 1)
                         {
                           cqi2 = sbCqis.at (1);
                         }
-            
+
                       uint8_t sbCqi = 0;
                       if ((cqi1 > 0)||(cqi2 > 0)) // CQI == 0 means "out of range" (see table 7.2.3-1 of 36.213)
                         {
-                          for (uint8_t k = 0; k < nLayer; k++) 
+                          for (uint8_t k = 0; k < nLayer; k++)
                             {
                               if (sbCqis.size () > k)
-                                {                       
+                                {
            	                  sbCqi = sbCqis.at(k);
                                 }
                               else
                                 {
-                                  // no info on this subband 
+                                  // no info on this subband
                                   sbCqi = 0;
                                 }
                               sum += sbCqi;
                             }
                         }   // end if cqi
                     }// end of rbgNum
-              
+
                   sbCqiSum.insert (std::pair<uint16_t, uint8_t> ((*it).first, sum));
                 }// end tdUeSet
-        
+
               for (int i = 0; i < rbgNum; i++)
                 {
                   if (rbgMap.at (i) == true)
@@ -1177,14 +1177,14 @@
                       if ((m_ffrSapProvider->IsDlRbgAvailableForUe (i, (*it).first)) == false)
                         continue;
 
-                      // calculate PF weight 
+                      // calculate PF weight
                       double weight = (*it).second.targetThroughput / (*it).second.lastAveragedThroughput;
                       if (weight < 1.0)
                         weight = 1.0;
-        
+
                       std::map < uint16_t, uint8_t>::iterator itSbCqiSum;
                       itSbCqiSum = sbCqiSum.find((*it).first);
-        
+
                       std::map <uint16_t,SbMeasResult_s>::iterator itCqi;
                       itCqi = m_a30CqiRxed.find ((*it).first);
                       std::map <uint16_t,uint8_t>::iterator itTxMode;
@@ -1206,39 +1206,39 @@
                         {
                           sbCqis = (*itCqi).second.m_higherLayerSelected.at (i).m_sbCqi;
                         }
-        
+
                       uint8_t cqi1 = sbCqis.at( 0);
                       uint8_t cqi2 = 0;
                       if (sbCqis.size () > 1)
                         {
                           cqi2 = sbCqis.at(1);
                         }
-            
+
                       uint8_t sbCqi = 0;
                       double colMetric = 0.0;
                       if ((cqi1 > 0)||(cqi2 > 0)) // CQI == 0 means "out of range" (see table 7.2.3-1 of 36.213)
                         {
-                          for (uint8_t k = 0; k < nLayer; k++) 
+                          for (uint8_t k = 0; k < nLayer; k++)
                             {
                               if (sbCqis.size () > k)
-                                {                       
+                                {
                                   sbCqi = sbCqis.at(k);
                                 }
                               else
                                 {
-                                  // no info on this subband 
+                                  // no info on this subband
                                   sbCqi = 0;
                                 }
                               colMetric += (double)sbCqi / (double)(*itSbCqiSum).second;
-           	                } 
+           	                }
                         }   // end if cqi
-        
+
                       double metric = 0.0;
                       if (colMetric != 0)
                         metric= weight * colMetric;
                       else
                         metric = 1;
-        
+
                       if (metric > metricMax )
                         {
                           metricMax = metric;
@@ -1256,10 +1256,10 @@
                       rbgMap.at (i) = true;
                     }
                 }// end of rbgNum
-        
+
             }// end of CoIta
-        
-        
+
+
           if ( m_fdSchedulerType.compare("PFsch") == 0)
             {
               // FD scheduler: Proportional Fair scheduled (PFsch)
@@ -1274,11 +1274,11 @@
                     {
                       if ((m_ffrSapProvider->IsDlRbgAvailableForUe (i, (*it).first)) == false)
                         continue;
-                      // calculate PF weight 
+                      // calculate PF weight
                       double weight = (*it).second.targetThroughput / (*it).second.lastAveragedThroughput;
                       if (weight < 1.0)
                         weight = 1.0;
-        
+
                       std::map <uint16_t,SbMeasResult_s>::iterator itCqi;
                       itCqi = m_a30CqiRxed.find ((*it).first);
                       std::map <uint16_t,uint8_t>::iterator itTxMode;
@@ -1300,23 +1300,23 @@
                         {
                           sbCqis = (*itCqi).second.m_higherLayerSelected.at (i).m_sbCqi;
                         }
-        
+
                       uint8_t cqi1 = sbCqis.at(0);
                       uint8_t cqi2 = 0;
                       if (sbCqis.size () > 1)
                         {
                           cqi2 = sbCqis.at(1);
                         }
-                
+
                       double schMetric = 0.0;
                       if ((cqi1 > 0)||(cqi2 > 0)) // CQI == 0 means "out of range" (see table 7.2.3-1 of 36.213)
                         {
                           double achievableRate = 0.0;
-                          for (uint8_t k = 0; k < nLayer; k++) 
+                          for (uint8_t k = 0; k < nLayer; k++)
                             {
                               uint8_t mcs = 0;
                               if (sbCqis.size () > k)
-                                {                       
+                                {
                                   mcs = m_amc->GetMcsFromCqi (sbCqis.at (k));
                                 }
                               else
@@ -1328,10 +1328,10 @@
             	  	    }
                           schMetric = achievableRate / (*it).second.secondLastAveragedThroughput;
                         }   // end if cqi
-         
+
                       double metric = 0.0;
                       metric= weight * schMetric;
-         
+
                       if (metric > metricMax )
                         {
                           metricMax = metric;
@@ -1341,20 +1341,20 @@
 
                   if (itMax == tdUeSet.end ())
                     {
-                      // no UE available for downlink 
+                      // no UE available for downlink
                     }
                   else
                     {
                       allocationMap[(*itMax).first].push_back (i);
                       rbgMap.at (i) = true;
                     }
-         
+
                 }// end of rbgNum
-        
+
             } // end of PFsch
 
         } // end if ueSet1 || ueSet2
-    
+
     } // end if ueSet
 
 
@@ -1550,7 +1550,7 @@
   // update UEs stats
   NS_LOG_INFO (this << " Update UEs statistics");
   for (itStats = m_flowStatsDl.begin (); itStats != m_flowStatsDl.end (); itStats++)
-    { 
+    {
       std::map <uint16_t, pssFlowPerf_t>::iterator itUeScheduleted = tdUeSet.end();
       itUeScheduleted = tdUeSet.find((*itStats).first);
       if (itUeScheduleted != tdUeSet.end())
@@ -1577,7 +1577,7 @@
   NS_LOG_FUNCTION (this);
 
   m_rachList = params.m_rachList;
-  
+
   return;
 }
 
@@ -1725,7 +1725,7 @@
     {
       //   Process UL HARQ feedback
       for (uint16_t i = 0; i < params.m_ulInfoList.size (); i++)
-        {        
+        {
           if (params.m_ulInfoList.at (i).m_receptionStatus == UlInfoListElement_s::NotOk)
             {
               // retx correspondent block: retrieve the UL-DCI
@@ -1815,7 +1815,7 @@
           m_allocationMaps.insert (std::pair <uint16_t, std::vector <uint16_t> > (params.m_sfnSf, rbgAllocationMap));
           m_schedSapUser->SchedUlConfigInd (ret);
         }
-        
+
       return;  // no flows to be scheduled
     }
 
@@ -1873,7 +1873,7 @@
           if (rbPerFlow < 3)
             {
               // terminate allocation
-              rbPerFlow = 0;      
+              rbPerFlow = 0;
             }
         }
 
@@ -1924,7 +1924,7 @@
               if (rbPerFlow < 3)
                 {
                   // terminate allocation
-                  rbPerFlow = 0;                 
+                  rbPerFlow = 0;
                 }
             }
         }
@@ -2097,7 +2097,7 @@
               uint8_t bsrId = params.m_macCeList.at (i).m_macCeValue.m_bufferStatus.at (lcg);
               buffer += BufferSizeLevelBsr::BsrId2BufferSize (bsrId);
             }
-          
+
           uint16_t rnti = params.m_macCeList.at (i).m_rnti;
           NS_LOG_LOGIC (this << "RNTI=" << rnti << " buffer=" << buffer);
           it = m_ceBsrRxed.find (rnti);
@@ -2375,8 +2375,8 @@
               // for SRB1 (using RLC AM) it's better to
               // overestimate RLC overhead rather than
               // underestimate it and risk unneeded
-              // segmentation which increases delay 
-              rlcOverhead = 4;                                  
+              // segmentation which increases delay
+              rlcOverhead = 4;
             }
           else
             {
@@ -2389,7 +2389,7 @@
               (*it).second.m_rlcTransmissionQueueSize = 0;
             }
           else
-            {                    
+            {
               (*it).second.m_rlcTransmissionQueueSize -= size - rlcOverhead;
             }
         }
diff -Naru a/model/rr-ff-mac-scheduler.cc b/model/rr-ff-mac-scheduler.cc
--- a/model/rr-ff-mac-scheduler.cc	2018-08-03 16:38:46.679807047 +0200
+++ b/model/rr-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -231,7 +231,7 @@
 RrFfMacScheduler::DoCschedUeReleaseReq (const struct FfMacCschedSapProvider::CschedUeReleaseReqParameters& params)
 {
   NS_LOG_FUNCTION (this << " Release RNTI " << params.m_rnti);
-  
+
   m_uesTxMode.erase (params.m_rnti);
   m_dlHarqCurrentProcessId.erase (params.m_rnti);
   m_dlHarqProcessesStatus.erase  (params.m_rnti);
@@ -264,7 +264,7 @@
     {
       m_nextRntiDl = 0;
     }
-    
+
   return;
 }
 
@@ -1078,7 +1078,7 @@
     }
   while ((*it).m_rnti != m_nextRntiDl);
 
-  ret.m_nrOfPdcchOfdmSymbols = 1;   /// \todo check correct value according the DCIs txed  
+  ret.m_nrOfPdcchOfdmSymbols = 1;   /// \todo check correct value according the DCIs txed
 
   m_schedSapUser->SchedDlConfigInd (ret);
   return;
@@ -1088,7 +1088,7 @@
 RrFfMacScheduler::DoSchedDlRachInfoReq (const struct FfMacSchedSapProvider::SchedDlRachInfoReqParameters& params)
 {
   NS_LOG_FUNCTION (this);
-  
+
   m_rachList = params.m_rachList;
 
   return;
@@ -1313,7 +1313,7 @@
           if (rbPerFlow < 3)
             {
               // terminate allocation
-              rbPerFlow = 0;      
+              rbPerFlow = 0;
             }
         }
       NS_LOG_INFO (this << " try to allocate " << (*it).first);
@@ -1358,7 +1358,7 @@
               if (rbPerFlow < 3)
                 {
                   // terminate allocation
-                  rbPerFlow = 0;                 
+                  rbPerFlow = 0;
                 }
             }
         }
@@ -1458,7 +1458,7 @@
             }
           (*itStat).second.at (harqId) = 0;
         }
-        
+
       NS_LOG_INFO (this << " UL Allocation - UE " << (*it).first << " startPRB " << (uint32_t)uldci.m_rbStart << " nPRB " << (uint32_t)uldci.m_rbLen << " CQI " << cqi << " MCS " << (uint32_t)uldci.m_mcs << " TBsize " << uldci.m_tbSize << " harqId " << (uint16_t)harqId);
 
       it++;
@@ -1777,8 +1777,8 @@
                     // for SRB1 (using RLC AM) it's better to
                     // overestimate RLC overhead rather than
                     // underestimate it and risk unneeded
-                    // segmentation which increases delay 
-                    rlcOverhead = 4;                                  
+                    // segmentation which increases delay
+                    rlcOverhead = 4;
                   }
                 else
                   {
@@ -1791,7 +1791,7 @@
                     (*it).m_rlcTransmissionQueueSize = 0;
                   }
                 else
-                  {                    
+                  {
                     (*it).m_rlcTransmissionQueueSize -= size - rlcOverhead;
                   }
               }
diff -Naru a/model/simple-ue-component-carrier-manager.cc b/model/simple-ue-component-carrier-manager.cc
--- a/model/simple-ue-component-carrier-manager.cc	2018-08-03 16:38:46.679807047 +0200
+++ b/model/simple-ue-component-carrier-manager.cc	2018-08-03 16:39:02.895957709 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
 * Copyright (c) 2015 Danilo Abrignani
+* Copyright (c) 2016, 2018, University of Padova, Dep. of Information Engineering, SIGNET lab
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,8 @@
 *
 * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
 *
+* Modified by: Tommaso Zugno <tommasozugno@gmail.com>
+*								 Integration of Carrier Aggregation for the mmWave module
 */
 
 #include "simple-ue-component-carrier-manager.h"
@@ -39,7 +42,7 @@
 
 /// SimpleUeCcmMacSapProvider class
 class SimpleUeCcmMacSapProvider : public LteMacSapProvider
-{ 
+{
 public:
   /**
    * Constructor
@@ -80,7 +83,7 @@
 
 /// SimpleUeCcmMacSapUser class
 class SimpleUeCcmMacSapUser : public LteMacSapUser
-{ 
+{
 public:
   /**
    * Constructor
@@ -220,19 +223,31 @@
 SimpleUeComponentCarrierManager::DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params)
 {
   NS_LOG_FUNCTION (this);
-  std::map <uint8_t, LteMacSapProvider*>::iterator it =  m_macSapProvidersMap.find (0);
-  NS_ASSERT_MSG (it != m_macSapProvidersMap.end (), "could not find Sap for ComponentCarrier ");
-  it->second->ReportBufferStatus (params);
+  for(std::map <uint8_t, LteMacSapProvider*>::iterator it = m_macSapProvidersMap.begin(); it != m_macSapProvidersMap.end(); it++)
+  {
+    if (it->first == 0)
+    {
+      // report the BSR to the primary CC
+      it->second->ReportBufferStatus (params);
+    }
+    else
+    {
+      // report the BSR to other CCs. Only the PCC sends status PDUs.
+      LteMacSapProvider::ReportBufferStatusParameters newParams = params;
+      newParams.statusPduSize = 0;
+      it->second->ReportBufferStatus (newParams);
+    }
+  }
 }
 
-void 
+void
 SimpleUeComponentCarrierManager::DoNotifyHarqDeliveryFailure ()
 {
  NS_LOG_FUNCTION (this);
 }
 
 
-void 
+void
 SimpleUeComponentCarrierManager::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid)
 {
   NS_LOG_FUNCTION (this);
@@ -275,7 +290,7 @@
     }
   NS_ASSERT_MSG (res.size () != 0, "Not found in the ComponentCarrierManager maps the LCID " << lcid);
 
-  return res; 
+  return res;
 
 }
 
@@ -295,7 +310,7 @@
       elem.lcConfig = &lcConfig;
       elem.msu = m_ccmMacSapUser;
       res.insert (res.end (), elem);
-      
+
       ccLcMapIt = m_componentCarrierLcMap.find (ncc);
       if (ccLcMapIt != m_componentCarrierLcMap.end ())
         {
@@ -312,8 +327,8 @@
           ccLcMapIt->second.insert (std::pair <uint8_t, LteMacSapProvider*> (lcId, m_macSapProvidersMap.at (ncc)));
         }
     }
-  
-  return res;  
+
+  return res;
 }
 
 void
@@ -331,7 +346,7 @@
      //here the code to update all the Lc, since now  those should be mapped on all ComponentCarriers
      m_ccmRrcSapUser->ComponentCarrierEnabling (res);
    }
-  
+
 }
 LteMacSapUser*
 SimpleUeComponentCarrierManager::DoConfigureSignalBearer (uint8_t lcid,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu)
@@ -344,11 +359,11 @@
       // This line will remove the former SignalBearer. It is needed in case of handover
       // since an update of the signal bearer performed.
       // Now it points on the right LteMacSapUser
-      m_lcAttached.erase (it); 
+      m_lcAttached.erase (it);
     }
   m_lcAttached.insert (std::pair<uint8_t, LteMacSapUser*> (lcid, msu));
 
   return m_ccmMacSapUser;
- } 
+ }
 
 } // end of namespace ns3
diff -Naru a/model/tdbet-ff-mac-scheduler.cc b/model/tdbet-ff-mac-scheduler.cc
--- a/model/tdbet-ff-mac-scheduler.cc	2018-08-03 16:38:46.679807047 +0200
+++ b/model/tdbet-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -254,7 +254,7 @@
 TdBetFfMacScheduler::DoCschedUeReleaseReq (const struct FfMacCschedSapProvider::CschedUeReleaseReqParameters& params)
 {
   NS_LOG_FUNCTION (this);
-  
+
   m_uesTxMode.erase (params.m_rnti);
   m_dlHarqCurrentProcessId.erase (params.m_rnti);
   m_dlHarqProcessesStatus.erase  (params.m_rnti);
@@ -456,7 +456,7 @@
           if ((*itTimers).second.at (i) == HARQ_DL_TIMEOUT)
             {
               // reset HARQ process
-              
+
               NS_LOG_DEBUG (this << " Reset HARQ proc " << i << " for RNTI " << (*itTimers).first);
               std::map <uint16_t, DlHarqProcessesStatus_t>::iterator itStat = m_dlHarqProcessesStatus.find ((*itTimers).first);
               if (itStat == m_dlHarqProcessesStatus.end ())
@@ -472,7 +472,7 @@
             }
         }
     }
-  
+
 }
 
 
@@ -927,7 +927,7 @@
 
   if (itMax == m_flowStatsDl.end ())
     {
-      // no UE available for downlink 
+      // no UE available for downlink
       return;
     }
   else
@@ -1118,7 +1118,7 @@
   NS_LOG_FUNCTION (this);
 
   m_rachList = params.m_rachList;
-  
+
   return;
 }
 
@@ -1249,7 +1249,7 @@
     {
       //   Process UL HARQ feedback
       for (uint16_t i = 0; i < params.m_ulInfoList.size (); i++)
-        {        
+        {
           if (params.m_ulInfoList.at (i).m_receptionStatus == UlInfoListElement_s::NotOk)
             {
               // retx correspondent block: retrieve the UL-DCI
@@ -1339,7 +1339,7 @@
           m_allocationMaps.insert (std::pair <uint16_t, std::vector <uint16_t> > (params.m_sfnSf, rbgAllocationMap));
           m_schedSapUser->SchedUlConfigInd (ret);
         }
-        
+
       return;  // no flows to be scheduled
     }
 
@@ -1395,7 +1395,7 @@
           if (rbPerFlow < 3)
             {
               // terminate allocation
-              rbPerFlow = 0;      
+              rbPerFlow = 0;
             }
         }
 
@@ -1439,7 +1439,7 @@
               if (rbPerFlow < 3)
                 {
                   // terminate allocation
-                  rbPerFlow = 0;                 
+                  rbPerFlow = 0;
                 }
             }
         }
@@ -1635,7 +1635,7 @@
               uint8_t bsrId = params.m_macCeList.at (i).m_macCeValue.m_bufferStatus.at (lcg);
               buffer += BufferSizeLevelBsr::BsrId2BufferSize (bsrId);
             }
-          
+
           uint16_t rnti = params.m_macCeList.at (i).m_rnti;
           NS_LOG_LOGIC (this << "RNTI=" << rnti << " buffer=" << buffer);
           it = m_ceBsrRxed.find (rnti);
@@ -1913,8 +1913,8 @@
               // for SRB1 (using RLC AM) it's better to
               // overestimate RLC overhead rather than
               // underestimate it and risk unneeded
-              // segmentation which increases delay 
-              rlcOverhead = 4;                                  
+              // segmentation which increases delay
+              rlcOverhead = 4;
             }
           else
             {
@@ -1927,7 +1927,7 @@
               (*it).second.m_rlcTransmissionQueueSize = 0;
             }
           else
-            {                    
+            {
               (*it).second.m_rlcTransmissionQueueSize -= size - rlcOverhead;
             }
         }
diff -Naru a/model/tdmt-ff-mac-scheduler.cc b/model/tdmt-ff-mac-scheduler.cc
--- a/model/tdmt-ff-mac-scheduler.cc	2018-08-03 16:38:46.679807047 +0200
+++ b/model/tdmt-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -243,7 +243,7 @@
 TdMtFfMacScheduler::DoCschedUeReleaseReq (const struct FfMacCschedSapProvider::CschedUeReleaseReqParameters& params)
 {
   NS_LOG_FUNCTION (this);
-  
+
   m_uesTxMode.erase (params.m_rnti);
   m_dlHarqCurrentProcessId.erase (params.m_rnti);
   m_dlHarqProcessesStatus.erase  (params.m_rnti);
@@ -445,7 +445,7 @@
           if ((*itTimers).second.at (i) == HARQ_DL_TIMEOUT)
             {
               // reset HARQ process
-              
+
               NS_LOG_DEBUG (this << " Reset HARQ proc " << i << " for RNTI " << (*itTimers).first);
               std::map <uint16_t, DlHarqProcessesStatus_t>::iterator itStat = m_dlHarqProcessesStatus.find ((*itTimers).first);
               if (itStat == m_dlHarqProcessesStatus.end ())
@@ -461,7 +461,7 @@
             }
         }
     }
-  
+
 }
 
 
@@ -892,7 +892,7 @@
        {
          wbCqi = 1; // lowest value for trying a transmission
        }
-     
+
      if (wbCqi != 0)
        {
           // CQI == 0 means "out of range" (see table 7.2.3-1 of 36.213)
@@ -900,9 +900,9 @@
             {
               // this UE has data to transmit
               double achievableRate = 0.0;
-              for (uint8_t k = 0; k < nLayer; k++) 
+              for (uint8_t k = 0; k < nLayer; k++)
                 {
-                  uint8_t mcs = 0; 
+                  uint8_t mcs = 0;
                   mcs = m_amc->GetMcsFromCqi (wbCqi);
                   achievableRate += ((m_amc->GetDlTbSizeFromMcs (mcs, rbgSize) / 8) / 0.001); // = TB size / TTI
 
@@ -924,7 +924,7 @@
 
   if (itMax == m_flowStatsDl.end ())
     {
-      // no UE available for downlink 
+      // no UE available for downlink
       NS_LOG_INFO (this << " any UE found");
     }
   else
@@ -1085,7 +1085,7 @@
   NS_LOG_FUNCTION (this);
 
   m_rachList = params.m_rachList;
-  
+
   return;
 }
 
@@ -1216,7 +1216,7 @@
     {
       //   Process UL HARQ feedback
       for (uint16_t i = 0; i < params.m_ulInfoList.size (); i++)
-        {        
+        {
           if (params.m_ulInfoList.at (i).m_receptionStatus == UlInfoListElement_s::NotOk)
             {
               // retx correspondent block: retrieve the UL-DCI
@@ -1306,7 +1306,7 @@
           m_allocationMaps.insert (std::pair <uint16_t, std::vector <uint16_t> > (params.m_sfnSf, rbgAllocationMap));
           m_schedSapUser->SchedUlConfigInd (ret);
         }
-        
+
       return;  // no flows to be scheduled
     }
 
@@ -1361,7 +1361,7 @@
           if (rbPerFlow < 3)
             {
               // terminate allocation
-              rbPerFlow = 0;      
+              rbPerFlow = 0;
             }
         }
 
@@ -1405,7 +1405,7 @@
               if (rbPerFlow < 3)
                 {
                   // terminate allocation
-                  rbPerFlow = 0;                 
+                  rbPerFlow = 0;
                 }
             }
         }
@@ -1579,7 +1579,7 @@
               uint8_t bsrId = params.m_macCeList.at (i).m_macCeValue.m_bufferStatus.at (lcg);
               buffer += BufferSizeLevelBsr::BsrId2BufferSize (bsrId);
             }
-          
+
           uint16_t rnti = params.m_macCeList.at (i).m_rnti;
           NS_LOG_LOGIC (this << "RNTI=" << rnti << " buffer=" << buffer);
           it = m_ceBsrRxed.find (rnti);
@@ -1857,8 +1857,8 @@
               // for SRB1 (using RLC AM) it's better to
               // overestimate RLC overhead rather than
               // underestimate it and risk unneeded
-              // segmentation which increases delay 
-              rlcOverhead = 4;                                  
+              // segmentation which increases delay
+              rlcOverhead = 4;
             }
           else
             {
@@ -1871,7 +1871,7 @@
               (*it).second.m_rlcTransmissionQueueSize = 0;
             }
           else
-            {                    
+            {
               (*it).second.m_rlcTransmissionQueueSize -= size - rlcOverhead;
             }
         }
diff -Naru a/model/tdtbfq-ff-mac-scheduler.cc b/model/tdtbfq-ff-mac-scheduler.cc
--- a/model/tdtbfq-ff-mac-scheduler.cc	2018-08-03 16:38:46.679807047 +0200
+++ b/model/tdtbfq-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -301,7 +301,7 @@
 TdTbfqFfMacScheduler::DoCschedUeReleaseReq (const struct FfMacCschedSapProvider::CschedUeReleaseReqParameters& params)
 {
   NS_LOG_FUNCTION (this);
-  
+
   m_uesTxMode.erase (params.m_rnti);
   m_dlHarqCurrentProcessId.erase (params.m_rnti);
   m_dlHarqProcessesStatus.erase  (params.m_rnti);
@@ -503,7 +503,7 @@
           if ((*itTimers).second.at (i) == HARQ_DL_TIMEOUT)
             {
               // reset HARQ process
-              
+
               NS_LOG_DEBUG (this << " Reset HARQ proc " << i << " for RNTI " << (*itTimers).first);
               std::map <uint16_t, DlHarqProcessesStatus_t>::iterator itStat = m_dlHarqProcessesStatus.find ((*itTimers).first);
               if (itStat == m_dlHarqProcessesStatus.end ())
@@ -519,7 +519,7 @@
             }
         }
     }
-  
+
 }
 
 
@@ -966,7 +966,7 @@
   std::map <uint16_t, tdtbfqsFlowPerf_t>::iterator itStats;
   for (itStats = m_flowStatsDl.begin (); itStats != m_flowStatsDl.end (); itStats++)
     {
-      if ( (*itStats).second.tokenGenerationRate / 1000 +  (*itStats).second.tokenPoolSize > (*itStats).second.maxTokenPoolSize )     
+      if ( (*itStats).second.tokenGenerationRate / 1000 +  (*itStats).second.tokenPoolSize > (*itStats).second.maxTokenPoolSize )
         {
           (*itStats).second.counter +=  (*itStats).second.tokenGenerationRate / 1000 - ( (*itStats).second.maxTokenPoolSize -  (*itStats).second.tokenPoolSize );
           (*itStats).second.tokenPoolSize = (*itStats).second.maxTokenPoolSize;
@@ -1039,11 +1039,11 @@
       /*
       if (LcActivePerFlow ((*it).first) == 0)
         {
-          continue;  
+          continue;
         }
       */
 
-      double metric = ( ( (double)(*it).second.counter ) / ( (double)(*it).second.tokenGenerationRate ) );  
+      double metric = ( ( (double)(*it).second.counter ) / ( (double)(*it).second.tokenGenerationRate ) );
 
       if (firstRnti == true)
         {
@@ -1157,7 +1157,7 @@
       for (uint8_t j = 0; j < nLayer; j++)
         {
           newDci.m_mcs.push_back (m_amc->GetMcsFromCqi (worstCqi.at (j)));
-          int tbSize = (m_amc->GetDlTbSizeFromMcs (newDci.m_mcs.at (j), RgbPerRnti * rbgSize) / 8); // (size of TB in bytes according to table 7.1.7.2.1-1 of 36.213) 
+          int tbSize = (m_amc->GetDlTbSizeFromMcs (newDci.m_mcs.at (j), RgbPerRnti * rbgSize) / 8); // (size of TB in bytes according to table 7.1.7.2.1-1 of 36.213)
           newDci.m_tbsSize.push_back (tbSize);
           bytesTxed += tbSize;
         }
@@ -1248,7 +1248,7 @@
           (*itMax).second.tokenPoolSize = 0;
           if (bankSize <= ( bytesTxed -  (*itMax).second.tokenPoolSize ))
             bankSize = 0;
-          else 
+          else
             bankSize = bankSize - ( bytesTxed -  (*itMax).second.tokenPoolSize );
         }
 
@@ -1273,7 +1273,7 @@
   NS_LOG_FUNCTION (this);
 
   m_rachList = params.m_rachList;
-  
+
   return;
 }
 
@@ -1420,7 +1420,7 @@
     {
       //   Process UL HARQ feedback
       for (uint16_t i = 0; i < params.m_ulInfoList.size (); i++)
-        {        
+        {
           if (params.m_ulInfoList.at (i).m_receptionStatus == UlInfoListElement_s::NotOk)
             {
               // retx correspondent block: retrieve the UL-DCI
@@ -1510,7 +1510,7 @@
           m_allocationMaps.insert (std::pair <uint16_t, std::vector <uint16_t> > (params.m_sfnSf, rbgAllocationMap));
           m_schedSapUser->SchedUlConfigInd (ret);
         }
-        
+
       return;  // no flows to be scheduled
     }
 
@@ -1568,7 +1568,7 @@
           if (rbPerFlow < 3)
             {
               // terminate allocation
-              rbPerFlow = 0;      
+              rbPerFlow = 0;
             }
         }
 
@@ -1619,7 +1619,7 @@
               if (rbPerFlow < 3)
                 {
                   // terminate allocation
-                  rbPerFlow = 0;                 
+                  rbPerFlow = 0;
                 }
             }
         }
@@ -1793,7 +1793,7 @@
               uint8_t bsrId = params.m_macCeList.at (i).m_macCeValue.m_bufferStatus.at (lcg);
               buffer += BufferSizeLevelBsr::BsrId2BufferSize (bsrId);
             }
-          
+
           uint16_t rnti = params.m_macCeList.at (i).m_rnti;
           NS_LOG_LOGIC (this << "RNTI=" << rnti << " buffer=" << buffer);
           it = m_ceBsrRxed.find (rnti);
@@ -2071,8 +2071,8 @@
               // for SRB1 (using RLC AM) it's better to
               // overestimate RLC overhead rather than
               // underestimate it and risk unneeded
-              // segmentation which increases delay 
-              rlcOverhead = 4;                                  
+              // segmentation which increases delay
+              rlcOverhead = 4;
             }
           else
             {
@@ -2085,7 +2085,7 @@
               (*it).second.m_rlcTransmissionQueueSize = 0;
             }
           else
-            {                    
+            {
               (*it).second.m_rlcTransmissionQueueSize -= size - rlcOverhead;
             }
         }
diff -Naru a/model/tta-ff-mac-scheduler.cc b/model/tta-ff-mac-scheduler.cc
--- a/model/tta-ff-mac-scheduler.cc	2018-08-03 16:38:46.679807047 +0200
+++ b/model/tta-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -243,7 +243,7 @@
 TtaFfMacScheduler::DoCschedUeReleaseReq (const struct FfMacCschedSapProvider::CschedUeReleaseReqParameters& params)
 {
   NS_LOG_FUNCTION (this);
-  
+
   m_uesTxMode.erase (params.m_rnti);
   m_dlHarqCurrentProcessId.erase (params.m_rnti);
   m_dlHarqProcessesStatus.erase  (params.m_rnti);
@@ -445,7 +445,7 @@
           if ((*itTimers).second.at (i) == HARQ_DL_TIMEOUT)
             {
               // reset HARQ process
-              
+
               NS_LOG_DEBUG (this << " Reset HARQ proc " << i << " for RNTI " << (*itTimers).first);
               std::map <uint16_t, DlHarqProcessesStatus_t>::iterator itStat = m_dlHarqProcessesStatus.find ((*itTimers).first);
               if (itStat == m_dlHarqProcessesStatus.end ())
@@ -461,7 +461,7 @@
             }
         }
     }
-  
+
 }
 
 
@@ -930,7 +930,7 @@
                       double achievableSbRate = 0.0;
                       double achievableWbRate = 0.0;
                       uint8_t sbMcs = 0;
-                      uint8_t wbMcs = 0; 
+                      uint8_t wbMcs = 0;
                       for (uint8_t k = 0; k < nLayer; k++)
                         {
                           if (sbCqi.size () > k)
@@ -956,7 +956,7 @@
                         }
                     }
                 }   // end if cqi
-              
+
             } // end for m_rlcBufferReq
 
           if (itMax == m_flowStatsDl.end ())
@@ -1164,7 +1164,7 @@
   NS_LOG_FUNCTION (this);
 
   m_rachList = params.m_rachList;
-  
+
   return;
 }
 
@@ -1295,7 +1295,7 @@
     {
       //   Process UL HARQ feedback
       for (uint16_t i = 0; i < params.m_ulInfoList.size (); i++)
-        {        
+        {
           if (params.m_ulInfoList.at (i).m_receptionStatus == UlInfoListElement_s::NotOk)
             {
               // retx correspondent block: retrieve the UL-DCI
@@ -1385,7 +1385,7 @@
           m_allocationMaps.insert (std::pair <uint16_t, std::vector <uint16_t> > (params.m_sfnSf, rbgAllocationMap));
           m_schedSapUser->SchedUlConfigInd (ret);
         }
-        
+
       return;  // no flows to be scheduled
     }
 
@@ -1440,7 +1440,7 @@
           if (rbPerFlow < 3)
             {
               // terminate allocation
-              rbPerFlow = 0;      
+              rbPerFlow = 0;
             }
         }
 
@@ -1484,7 +1484,7 @@
               if (rbPerFlow < 3)
                 {
                   // terminate allocation
-                  rbPerFlow = 0;                 
+                  rbPerFlow = 0;
                 }
             }
         }
@@ -1658,7 +1658,7 @@
               uint8_t bsrId = params.m_macCeList.at (i).m_macCeValue.m_bufferStatus.at (lcg);
               buffer += BufferSizeLevelBsr::BsrId2BufferSize (bsrId);
             }
-          
+
           uint16_t rnti = params.m_macCeList.at (i).m_rnti;
           NS_LOG_LOGIC (this << "RNTI=" << rnti << " buffer=" << buffer);
           it = m_ceBsrRxed.find (rnti);
@@ -1936,8 +1936,8 @@
               // for SRB1 (using RLC AM) it's better to
               // overestimate RLC overhead rather than
               // underestimate it and risk unneeded
-              // segmentation which increases delay 
-              rlcOverhead = 4;                                  
+              // segmentation which increases delay
+              rlcOverhead = 4;
             }
           else
             {
@@ -1950,7 +1950,7 @@
               (*it).second.m_rlcTransmissionQueueSize = 0;
             }
           else
-            {                    
+            {
               (*it).second.m_rlcTransmissionQueueSize -= size - rlcOverhead;
             }
         }
diff -Naru a/test/epc-test-run-time.pl b/test/epc-test-run-time.pl
--- a/test/epc-test-run-time.pl	2018-08-03 16:38:46.679807047 +0200
+++ b/test/epc-test-run-time.pl	2018-08-03 16:39:02.895957709 +0200
@@ -14,7 +14,7 @@
 
 
 # Configure and complite first the program to avoid counting compilation time as running time
-my $launch = "CXXFLAGS=\"-O3 -w\" ./waf -d optimized configure --enable-static --enable-examples --enable-modules=lte";
+my $launch = "CXXFLAGS=\"-O3 -w\" ./waf -d optimized configure --enable-static --enable-examples --enable-modules=lte"
 my $out, my $err;
 capture { system($launch ) } \$out, \$err;
 $launch = "./waf --run \'lena-profiling --simTime=0.1 --nUe=1 --nEnb=1 --nFloors=0\'";
@@ -26,10 +26,10 @@
             my $timeStats = Statistics::Descriptive::Full->new();
             for ( my $iteration = 0 ; $iteration < $nIterations ; $iteration++ )
             {
-               $launch = "time -f \"real%E\" ./waf --run 'lena-simple-epc --simTime=$time --numberOfNodes=$node'";
+               $launch = "time ./waf --run \'lena-simple-epc --simTime=$time --numberOfNodes=$node'";
                print "$launch\n";
                capture { system($launch ) } \$out, \$err;
-               $err =~ /real(.+):(.+)/;
+               $err =~ /real(.+)m(.+)s/;
                my $minutes = $1;
                my $seconds = $minutes * 60 + $2;
                $timeStats->add_data($seconds);
diff -Naru a/test/epc-test-s1u-downlink.cc b/test/epc-test-s1u-downlink.cc
--- a/test/epc-test-s1u-downlink.cc	2018-08-03 16:38:46.679807047 +0200
+++ b/test/epc-test-s1u-downlink.cc	2018-08-03 16:39:02.895957709 +0200
@@ -64,7 +64,7 @@
 
   uint32_t numPkts; ///< number of packets
   uint32_t pktSize; ///< packet size
- 
+
   Ptr<PacketSink> serverApp; ///< Server application
   Ptr<Application> clientApp; ///< Client application
 };
@@ -79,7 +79,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Custom structure for testing eNodeB downlink data, contains 
+ * \brief Custom structure for testing eNodeB downlink data, contains
  * the list of data structures for UEs
  */
 struct EnbDlTestData
@@ -109,7 +109,9 @@
 
 private:
   virtual void DoRun (void);
+  void InitialMsg (Ptr<EpcEnbApplication> epcApp, uint64_t imsi);
   std::vector<EnbDlTestData> m_enbDlTestData; ///< ENB DL test data
+  std::vector<Ptr<EpcTestRrc>> rrcVector;
 };
 
 
@@ -122,17 +124,26 @@
 EpcS1uDlTestCase::~EpcS1uDlTestCase ()
 {
 }
-void 
+void
+EpcS1uDlTestCase::InitialMsg (Ptr<EpcEnbApplication> enbApp, uint64_t imsi)
+{
+
+  enbApp->GetS1SapProvider ()->InitialUeMessage (imsi, (uint16_t) imsi);
+}
+
+void
 EpcS1uDlTestCase::DoRun ()
 {
+  uint64_t imsi = 0;
   Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper> ();
   Ptr<Node> pgw = epcHelper->GetPgwNode ();
+  epcHelper->SetAttribute("S1apLinkDelay", TimeValue(Seconds(0)));
 
   // allow jumbo packets
   Config::SetDefault ("ns3::CsmaNetDevice::Mtu", UintegerValue (30000));
   Config::SetDefault ("ns3::PointToPointNetDevice::Mtu", UintegerValue (30000));
   epcHelper->SetAttribute ("S1uLinkMtu", UintegerValue (30000));
-  
+
   // Create a single RemoteHost
   NodeContainer remoteHostContainer;
   remoteHostContainer.Create (1);
@@ -143,18 +154,18 @@
   // Create the internet
   PointToPointHelper p2ph;
   p2ph.SetDeviceAttribute ("DataRate",  DataRateValue (DataRate ("100Gb/s")));
-  NetDeviceContainer internetDevices = p2ph.Install (pgw, remoteHost);  
+  NetDeviceContainer internetDevices = p2ph.Install (pgw, remoteHost);
   Ipv4AddressHelper ipv4h;
   ipv4h.SetBase ("1.0.0.0", "255.0.0.0");
   ipv4h.Assign (internetDevices);
-  
+
   // setup default gateway for the remote hosts
   Ipv4StaticRoutingHelper ipv4RoutingHelper;
   Ptr<Ipv4StaticRouting> remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting (remoteHost->GetObject<Ipv4> ());
 
   // hardcoded UE addresses for now
   remoteHostStaticRouting->AddNetworkRouteTo (Ipv4Address ("7.0.0.0"), Ipv4Mask ("255.255.255.0"), 1);
-  
+
 
 
 
@@ -181,22 +192,23 @@
       cell.Add (ues);
       cell.Add (enb);
 
-      CsmaHelper csmaCell;      
+      CsmaHelper csmaCell;
       NetDeviceContainer cellDevices = csmaCell.Install (cell);
 
-      // the eNB's CSMA NetDevice acting as an LTE NetDevice. 
+      // the eNB's CSMA NetDevice acting as an LTE NetDevice.
       Ptr<NetDevice> enbDevice = cellDevices.Get (cellDevices.GetN () - 1);
 
       // Note that the EpcEnbApplication won't care of the actual NetDevice type
-      epcHelper->AddEnb (enb, enbDevice, cellId);      
+      epcHelper->AddEnb (enb, enbDevice, cellId);
 
       // Plug test RRC entity
       Ptr<EpcEnbApplication> enbApp = enb->GetApplication (0)->GetObject<EpcEnbApplication> ();
       NS_ASSERT_MSG (enbApp != 0, "cannot retrieve EpcEnbApplication");
       Ptr<EpcTestRrc> rrc = CreateObject<EpcTestRrc> ();
+      rrcVector.push_back(rrc);
       rrc->SetS1SapProvider (enbApp->GetS1SapProvider ());
       enbApp->SetS1SapUser (rrc->GetS1SapUser ());
-      
+
       // we install the IP stack on UEs only
       InternetStackHelper internet;
       internet.Install (ues);
@@ -211,16 +223,16 @@
 
           // disable IP Forwarding on the UE. This is because we use
           // CSMA broadcast MAC addresses for this test. The problem
-          // won't happen with a LteUeNetDevice. 
+          // won't happen with a LteUeNetDevice.
           ue->GetObject<Ipv4> ()->SetAttribute ("IpForward", BooleanValue (false));
-          
+
           uint16_t port = 1234;
           PacketSinkHelper packetSinkHelper ("ns3::UdpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), port));
           ApplicationContainer apps = packetSinkHelper.Install (ue);
           apps.Start (Seconds (1.0));
           apps.Stop (Seconds (10.0));
           enbit->ues[u].serverApp = apps.Get (0)->GetObject<PacketSink> ();
-          
+
           Time interPacketInterval = Seconds (0.01);
           UdpEchoClientHelper client (ueIpIface.GetAddress (0), port);
           client.SetAttribute ("MaxPackets", UintegerValue (enbit->ues[u].numPkts));
@@ -228,17 +240,19 @@
           client.SetAttribute ("PacketSize", UintegerValue (enbit->ues[u].pktSize));
           apps = client.Install (remoteHost);
           apps.Start (Seconds (2.0));
-          apps.Stop (Seconds (10.0));   
+          apps.Stop (Seconds (10.0));
           enbit->ues[u].clientApp = apps.Get (0);
 
-          uint64_t imsi = u+1;
-          epcHelper->AddUe (ueLteDevice, imsi);
+
+          epcHelper->AddUe (ueLteDevice, ++imsi);
           epcHelper->ActivateEpsBearer (ueLteDevice, imsi, EpcTft::Default (), EpsBearer (EpsBearer::NGBR_VIDEO_TCP_DEFAULT));
-          enbApp->GetS1SapProvider ()->InitialUeMessage (imsi, (uint16_t) imsi);
-        } 
-            
-    } 
-  
+
+          Simulator::Schedule (Seconds(0.01), &EpcS1uDlTestCase::InitialMsg, this, enbApp, imsi);
+
+        }
+
+    }
+
   Simulator::Run ();
 
   for (std::vector<EnbDlTestData>::iterator enbit = m_enbDlTestData.begin ();
@@ -250,9 +264,9 @@
            ++ueit)
         {
           NS_TEST_ASSERT_MSG_EQ (ueit->serverApp->GetTotalRx (), (ueit->numPkts) * (ueit->pktSize), "wrong total received bytes");
-        }      
+        }
     }
-  
+
   Simulator::Destroy ();
 }
 
@@ -267,13 +281,13 @@
 {
 public:
   EpcS1uDlTestSuite ();
-  
+
 } g_epcS1uDlTestSuiteInstance;
 
 EpcS1uDlTestSuite::EpcS1uDlTestSuite ()
   : TestSuite ("epc-s1u-downlink", SYSTEM)
-{  
-  std::vector<EnbDlTestData> v1;  
+{
+  std::vector<EnbDlTestData> v1;
   EnbDlTestData e1;
   UeDlTestData f1 (1, 100);
   e1.ues.push_back (f1);
@@ -281,7 +295,7 @@
   AddTestCase (new EpcS1uDlTestCase ("1 eNB, 1UE", v1), TestCase::QUICK);
 
 
-  std::vector<EnbDlTestData> v2;  
+  std::vector<EnbDlTestData> v2;
   EnbDlTestData e2;
   UeDlTestData f2_1 (1, 100);
   e2.ues.push_back (f2_1);
@@ -291,7 +305,7 @@
   AddTestCase (new EpcS1uDlTestCase ("1 eNB, 2UEs", v2), TestCase::QUICK);
 
 
-  std::vector<EnbDlTestData> v3;  
+  std::vector<EnbDlTestData> v3;
   v3.push_back (e1);
   v3.push_back (e2);
   AddTestCase (new EpcS1uDlTestCase ("2 eNBs", v3), TestCase::QUICK);
@@ -304,38 +318,37 @@
   e3.ues.push_back (f3_2);
   UeDlTestData f3_3 (1, 1);
   e3.ues.push_back (f3_2);
-  std::vector<EnbDlTestData> v4;  
+  std::vector<EnbDlTestData> v4;
   v4.push_back (e3);
   v4.push_back (e1);
   v4.push_back (e2);
   AddTestCase (new EpcS1uDlTestCase ("3 eNBs", v4), TestCase::QUICK);
 
-  std::vector<EnbDlTestData> v5;  
+  std::vector<EnbDlTestData> v5;
   EnbDlTestData e5;
   UeDlTestData f5 (10, 3000);
   e5.ues.push_back (f5);
   v5.push_back (e5);
   AddTestCase (new EpcS1uDlTestCase ("1 eNB, 10 pkts 3000 bytes each", v5), TestCase::QUICK);
 
-  std::vector<EnbDlTestData> v6;  
+  std::vector<EnbDlTestData> v6;
   EnbDlTestData e6;
   UeDlTestData f6 (50, 3000);
   e6.ues.push_back (f6);
   v6.push_back (e6);
   AddTestCase (new EpcS1uDlTestCase ("1 eNB, 50 pkts 3000 bytes each", v6), TestCase::QUICK);
-  
-  std::vector<EnbDlTestData> v7;  
+
+  std::vector<EnbDlTestData> v7;
   EnbDlTestData e7;
   UeDlTestData f7 (10, 15000);
   e7.ues.push_back (f7);
   v7.push_back (e7);
   AddTestCase (new EpcS1uDlTestCase ("1 eNB, 10 pkts 15000 bytes each", v7), TestCase::QUICK);
 
-  std::vector<EnbDlTestData> v8;  
+  std::vector<EnbDlTestData> v8;
   EnbDlTestData e8;
   UeDlTestData f8 (100, 15000);
   e8.ues.push_back (f8);
   v8.push_back (e8);
   AddTestCase (new EpcS1uDlTestCase ("1 eNB, 100 pkts 15000 bytes each", v8), TestCase::QUICK);
 }
-
diff -Naru a/test/epc-test-s1u-uplink.cc b/test/epc-test-s1u-uplink.cc
--- a/test/epc-test-s1u-uplink.cc	2018-08-03 16:38:46.679807047 +0200
+++ b/test/epc-test-s1u-uplink.cc	2018-08-03 16:39:02.895957709 +0200
@@ -17,9 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * The original version of UdpClient is by  Amine Ismail
- * <amine.ismail@sophia.inria.fr> <amine.ismail@udcast.com> 
+ * <amine.ismail@sophia.inria.fr> <amine.ismail@udcast.com>
  * The rest of the code (including modifying UdpClient into
- *  EpsBearerTagUdpClient) is by Nicola Baldo <nbaldo@cttc.es> 
+ *  EpsBearerTagUdpClient) is by Nicola Baldo <nbaldo@cttc.es>
  */
 
 
@@ -62,7 +62,7 @@
  * uplink. But in this test we don't have the LteEnbNetDevice, because
  * we test the S1-U interface with simpler devices to make sure it
  * just works.
- * 
+ *
  */
 class EpsBearerTagUdpClient : public Application
 {
@@ -77,7 +77,7 @@
   EpsBearerTagUdpClient ();
   /**
    * Constructor
-   * 
+   *
    * \param rnti the RNTI
    * \param bid the BID
    */
@@ -111,9 +111,9 @@
   uint32_t m_count; ///< maximum number of packets to send
   Time m_interval; ///< the time between packets
   uint32_t m_size; ///< the size of packets generated
-  
+
   uint32_t m_sent; ///< number of packets sent
-  Ptr<Socket> m_socket; ///< the socket 
+  Ptr<Socket> m_socket; ///< the socket
   Ipv4Address m_peerAddress; ///< the peer address of the outbound packets
   uint16_t m_peerPort; ///< the destination port of the outbound packets
   EventId m_sendEvent; ///< the send event
@@ -279,7 +279,7 @@
   uint32_t pktSize; ///< the packet size
   uint16_t rnti; ///< the RNTI
   uint8_t bid; ///< the BID
- 
+
   Ptr<PacketSink> serverApp; ///< the server application
   Ptr<Application> clientApp; ///< the client application
 };
@@ -296,7 +296,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Custom structure containing information about data sent in the uplink 
+ * \brief Custom structure containing information about data sent in the uplink
  * of eNodeB. Includes the information of the data sent in the uplink per UE.
  */
 struct EnbUlTestData
@@ -325,7 +325,9 @@
 
 private:
   virtual void DoRun (void);
+  void InitialMsg (Ptr<EpcEnbApplication> epcApp, uint64_t imsi);
   std::vector<EnbUlTestData> m_enbUlTestData; ///< ENB UL test data
+  std::vector<Ptr<EpcTestRrc>> rrcVector;
 };
 
 
@@ -339,7 +341,14 @@
 {
 }
 
-void 
+void
+EpcS1uUlTestCase::InitialMsg (Ptr<EpcEnbApplication> enbApp, uint64_t imsi)
+{
+
+  enbApp->GetS1SapProvider ()->InitialUeMessage (imsi, (uint16_t) imsi);
+}
+
+void
 EpcS1uUlTestCase::DoRun ()
 {
   Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper> ();
@@ -349,7 +358,7 @@
   Config::SetDefault ("ns3::CsmaNetDevice::Mtu", UintegerValue (30000));
   Config::SetDefault ("ns3::PointToPointNetDevice::Mtu", UintegerValue (30000));
   epcHelper->SetAttribute ("S1uLinkMtu", UintegerValue (30000));
-  
+
   // Create a single RemoteHost
   NodeContainer remoteHostContainer;
   remoteHostContainer.Create (1);
@@ -360,22 +369,22 @@
   // Create the internet
   PointToPointHelper p2ph;
   p2ph.SetDeviceAttribute ("DataRate",  DataRateValue (DataRate ("100Gb/s")));
-  NetDeviceContainer internetDevices = p2ph.Install (pgw, remoteHost);  
+  NetDeviceContainer internetDevices = p2ph.Install (pgw, remoteHost);
   Ipv4AddressHelper ipv4h;
   ipv4h.SetBase ("1.0.0.0", "255.0.0.0");
   Ipv4InterfaceContainer internetNodesIpIfaceContainer = ipv4h.Assign (internetDevices);
-  
+
   // setup default gateway for the remote hosts
   Ipv4StaticRoutingHelper ipv4RoutingHelper;
   Ptr<Ipv4StaticRouting> remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting (remoteHost->GetObject<Ipv4> ());
 
   // hardcoded UE addresses for now
   remoteHostStaticRouting->AddNetworkRouteTo (Ipv4Address ("7.0.0.0"), Ipv4Mask ("255.255.255.0"), 1);
-  
+
 
 
   uint16_t udpSinkPort = 1234;
-    
+
   NodeContainer enbs;
   uint16_t cellIdCounter = 0;
 
@@ -384,7 +393,7 @@
        ++enbit)
     {
       Ptr<Node> enb = CreateObject<Node> ();
-      enbs.Add (enb);      
+      enbs.Add (enb);
 
       // we test EPC without LTE, hence we use:
       // 1) a CSMA network to simulate the cell
@@ -399,22 +408,23 @@
       cell.Add (ues);
       cell.Add (enb);
 
-      CsmaHelper csmaCell;      
+      CsmaHelper csmaCell;
       NetDeviceContainer cellDevices = csmaCell.Install (cell);
 
-      // the eNB's CSMA NetDevice acting as an LTE NetDevice. 
+      // the eNB's CSMA NetDevice acting as an LTE NetDevice.
       Ptr<NetDevice> enbDevice = cellDevices.Get (cellDevices.GetN () - 1);
 
       // Note that the EpcEnbApplication won't care of the actual NetDevice type
-      epcHelper->AddEnb (enb, enbDevice, cellId);      
-      
+      epcHelper->AddEnb (enb, enbDevice, cellId);
+
        // Plug test RRC entity
       Ptr<EpcEnbApplication> enbApp = enb->GetApplication (0)->GetObject<EpcEnbApplication> ();
       NS_ASSERT_MSG (enbApp != 0, "cannot retrieve EpcEnbApplication");
       Ptr<EpcTestRrc> rrc = CreateObject<EpcTestRrc> ();
+      rrcVector.push_back(rrc);
       rrc->SetS1SapProvider (enbApp->GetS1SapProvider ());
       enbApp->SetS1SapUser (rrc->GetS1SapUser ());
-      
+
       // we install the IP stack on UEs only
       InternetStackHelper internet;
       internet.Install (ues);
@@ -429,7 +439,7 @@
 
           // disable IP Forwarding on the UE. This is because we use
           // CSMA broadcast MAC addresses for this test. The problem
-          // won't happen with a LteUeNetDevice. 
+          // won't happen with a LteUeNetDevice.
           Ptr<Ipv4> ueIpv4 = ue->GetObject<Ipv4> ();
           ueIpv4->SetAttribute ("IpForward", BooleanValue (false));
 
@@ -443,28 +453,28 @@
           // the eNB uses CSMA but without IP, we fool the UE's ARP
           // cache into thinking that the IP address of the GW can be
           // reached by sending a CSMA packet to the broadcast
-          // address, so the eNB will get it.       
+          // address, so the eNB will get it.
           int32_t ueLteIpv4IfIndex = ueIpv4->GetInterfaceForDevice (ueLteDevice);
           Ptr<Ipv4L3Protocol> ueIpv4L3Protocol = ue->GetObject<Ipv4L3Protocol> ();
           Ptr<Ipv4Interface> ueLteIpv4Iface = ueIpv4L3Protocol->GetInterface (ueLteIpv4IfIndex);
-          Ptr<ArpCache> ueArpCache = ueLteIpv4Iface->GetArpCache (); 
-          ueArpCache->SetAliveTimeout (Seconds (1000));          
+          Ptr<ArpCache> ueArpCache = ueLteIpv4Iface->GetArpCache ();
+          ueArpCache->SetAliveTimeout (Seconds (1000));
           ArpCache::Entry* arpCacheEntry = ueArpCache->Add (gwAddr);
           arpCacheEntry->SetMacAddress (Mac48Address::GetBroadcast ());
           arpCacheEntry->MarkPermanent ();
-  
-          
-          PacketSinkHelper packetSinkHelper ("ns3::UdpSocketFactory", 
-                                             InetSocketAddress (Ipv4Address::GetAny (), udpSinkPort));          
+
+
+          PacketSinkHelper packetSinkHelper ("ns3::UdpSocketFactory",
+                                             InetSocketAddress (Ipv4Address::GetAny (), udpSinkPort));
           ApplicationContainer sinkApp = packetSinkHelper.Install (remoteHost);
           sinkApp.Start (Seconds (1.0));
           sinkApp.Stop (Seconds (10.0));
           enbit->ues[u].serverApp = sinkApp.Get (0)->GetObject<PacketSink> ();
-          
+
           Time interPacketInterval = Seconds (0.01);
           Ptr<EpsBearerTagUdpClient> client = CreateObject<EpsBearerTagUdpClient> (enbit->ues[u].rnti, enbit->ues[u].bid);
           client->SetAttribute ("RemoteAddress", Ipv4AddressValue (internetNodesIpIfaceContainer.GetAddress (1)));
-          client->SetAttribute ("RemotePort", UintegerValue (udpSinkPort));          
+          client->SetAttribute ("RemotePort", UintegerValue (udpSinkPort));
           client->SetAttribute ("MaxPackets", UintegerValue (enbit->ues[u].numPkts));
           client->SetAttribute ("Interval", TimeValue (interPacketInterval));
           client->SetAttribute ("PacketSize", UintegerValue (enbit->ues[u].pktSize));
@@ -472,20 +482,21 @@
           ApplicationContainer clientApp;
           clientApp.Add (client);
           clientApp.Start (Seconds (2.0));
-          clientApp.Stop (Seconds (10.0));   
+          clientApp.Stop (Seconds (10.0));
           enbit->ues[u].clientApp = client;
 
           uint64_t imsi = u+1;
           epcHelper->AddUe (ueLteDevice, imsi);
           epcHelper->ActivateEpsBearer (ueLteDevice, imsi, EpcTft::Default (), EpsBearer (EpsBearer::NGBR_VIDEO_TCP_DEFAULT));
-          enbApp->GetS1SapProvider ()->InitialUeMessage (imsi, (uint16_t) imsi);
-          
+
+          Simulator::Schedule (Seconds(0.01), &EpcS1uUlTestCase::InitialMsg, this, enbApp, imsi);
+
           // need this since all sinks are installed in the same node
-          ++udpSinkPort; 
-        } 
-            
-    } 
-  
+          ++udpSinkPort;
+        }
+
+    }
+
   Simulator::Run ();
 
   for (std::vector<EnbUlTestData>::iterator enbit = m_enbUlTestData.begin ();
@@ -497,9 +508,9 @@
            ++ueit)
         {
           NS_TEST_ASSERT_MSG_EQ (ueit->serverApp->GetTotalRx (), (ueit->numPkts) * (ueit->pktSize), "wrong total received bytes");
-        }      
+        }
     }
-  
+
   Simulator::Destroy ();
 }
 
@@ -514,13 +525,13 @@
 {
 public:
   EpcS1uUlTestSuite ();
-  
+
 } g_epcS1uUlTestSuiteInstance;
 
 EpcS1uUlTestSuite::EpcS1uUlTestSuite ()
   : TestSuite ("epc-s1u-uplink", SYSTEM)
-{  
-  std::vector<EnbUlTestData> v1;  
+{
+  std::vector<EnbUlTestData> v1;
   EnbUlTestData e1;
   UeUlTestData f1 (1, 100, 1, 1);
   e1.ues.push_back (f1);
@@ -528,7 +539,7 @@
   AddTestCase (new EpcS1uUlTestCase ("1 eNB, 1UE", v1), TestCase::QUICK);
 
 
-  std::vector<EnbUlTestData> v2;  
+  std::vector<EnbUlTestData> v2;
   EnbUlTestData e2;
   UeUlTestData f2_1 (1, 100, 1, 1);
   e2.ues.push_back (f2_1);
@@ -538,7 +549,7 @@
   AddTestCase (new EpcS1uUlTestCase ("1 eNB, 2UEs", v2), TestCase::QUICK);
 
 
-  std::vector<EnbUlTestData> v3;  
+  std::vector<EnbUlTestData> v3;
   v3.push_back (e1);
   v3.push_back (e2);
   AddTestCase (new EpcS1uUlTestCase ("2 eNBs", v3), TestCase::QUICK);
@@ -551,38 +562,38 @@
   e3.ues.push_back (f3_2);
   UeUlTestData f3_3 (1, 1, 3, 1);
   e3.ues.push_back (f3_2);
-  std::vector<EnbUlTestData> v4;  
+  std::vector<EnbUlTestData> v4;
   v4.push_back (e3);
   v4.push_back (e1);
   v4.push_back (e2);
   AddTestCase (new EpcS1uUlTestCase ("3 eNBs", v4), TestCase::QUICK);
 
-  std::vector<EnbUlTestData> v5;  
+  std::vector<EnbUlTestData> v5;
   EnbUlTestData e5;
   UeUlTestData f5 (10, 3000, 1, 1);
   e5.ues.push_back (f5);
   v5.push_back (e5);
   AddTestCase (new EpcS1uUlTestCase ("1 eNB, 10 pkts 3000 bytes each", v5), TestCase::QUICK);
 
-  std::vector<EnbUlTestData> v6;  
+  std::vector<EnbUlTestData> v6;
   EnbUlTestData e6;
   UeUlTestData f6 (50, 3000, 1, 1);
   e6.ues.push_back (f6);
   v6.push_back (e6);
   AddTestCase (new EpcS1uUlTestCase ("1 eNB, 50 pkts 3000 bytes each", v6), TestCase::QUICK);
 
-  std::vector<EnbUlTestData> v7;  
+  std::vector<EnbUlTestData> v7;
   EnbUlTestData e7;
   UeUlTestData f7 (10, 15000, 1, 1);
   e7.ues.push_back (f7);
   v7.push_back (e7);
   AddTestCase (new EpcS1uUlTestCase ("1 eNB, 10 pkts 15000 bytes each", v7), TestCase::QUICK);
 
-  std::vector<EnbUlTestData> v8;  
+  std::vector<EnbUlTestData> v8;
   EnbUlTestData e8;
   UeUlTestData f8 (100, 15000, 1, 1);
   e8.ues.push_back (f8);
   v8.push_back (e8);
   AddTestCase (new EpcS1uUlTestCase ("1 eNB, 100 pkts 15000 bytes each", v8), TestCase::QUICK);
-  
+
 }
diff -Naru a/test/examples-to-run.py b/test/examples-to-run.py
--- a/test/examples-to-run.py	2018-08-03 16:38:46.679807047 +0200
+++ b/test/examples-to-run.py	2018-08-03 16:39:02.895957709 +0200
@@ -42,9 +42,6 @@
     ("lena-simple-epc --simTime=1.1 --ns3::LteHelper::Scheduler=ns3::FdTbfqFfMacScheduler", "options.valgrind", "True"),
     ("lena-simple-epc --simTime=1.1 --ns3::LteHelper::Scheduler=ns3::FdMtFfMacScheduler", "options.valgrind", "True"),
     ("lena-simple-epc --simTime=1.1 --ns3::LteHelper::Scheduler=ns3::FdBetFfMacScheduler", "options.valgrind", "True"),
-    ("lena-ipv6-addr-conf", "True", "True"), 
-    ("lena-ipv6-ue-rh", "True", "True"), 
-    ("lena-ipv6-ue-ue", "True", "True"), 
 ]
 
 # A list of Python examples to run in order to ensure that they remain
diff -Naru a/test/lte-simple-helper.h b/test/lte-simple-helper.h
--- a/test/lte-simple-helper.h	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-simple-helper.h	2018-08-03 16:39:02.895957709 +0200
@@ -40,8 +40,8 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief A simplified version of LteHelper, that 
- * is used for creation and configuration of LTE entities for testing purposes 
+ * \brief A simplified version of LteHelper, that
+ * is used for creation and configuration of LTE entities for testing purposes
  * when just a limited LteHelper functionality is wanted.
  *
  */
@@ -127,7 +127,7 @@
 
 private:
   /**
-   * Install single ENB device 
+   * Install single ENB device
    *
    * \param n the node
    * \returns the device
diff -Naru a/test/lte-test-carrier-aggregation.cc b/test/lte-test-carrier-aggregation.cc
--- a/test/lte-test-carrier-aggregation.cc	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-test-carrier-aggregation.cc	2018-08-03 16:39:02.895957709 +0200
@@ -243,7 +243,7 @@
 
 static TestCarrierAggregationSuite lenaTestRrFfMacSchedulerSuite;
 
-std::string 
+std::string
 CarrierAggregationTestCase::BuildNameString (uint16_t nUser, uint16_t dist, uint32_t dlBandwidth, uint32_t ulBandwidth, uint32_t numberOfComponentCarriers)
 {
   std::ostringstream oss;
@@ -285,12 +285,14 @@
   Config::SetDefault ("ns3::LteSpectrumPhy::DataErrorModelEnabled", BooleanValue (false));
   Config::SetDefault ("ns3::LteHelper::UseIdealRrc", BooleanValue (true));
 
+  Config::SetDefault ("ns3::LteEnbRrc::SrsPeriodicity", UintegerValue (40));
+
   /**
    * Initialize Simulation Scenario: 1 eNB and m_nUser UEs
    */
 
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
-  
+
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
   // Create Nodes: eNodeB and UE
@@ -320,8 +322,8 @@
   enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
   EpsBearer bearer (q);
   lteHelper->ActivateDataRadioBearer (ueDevs, bearer);
-  
- 
+
+
   Ptr<LteEnbNetDevice> lteEnbDev = enbDevs.Get (0)->GetObject<LteEnbNetDevice> ();
   Ptr<LteEnbPhy> enbPhy = lteEnbDev->GetPhy ();
   enbPhy->SetAttribute ("TxPower", DoubleValue (30.0));
@@ -479,4 +481,3 @@
   ulOutFile << m_nUser <<" "<<m_numberOfComponentCarriers <<" "<< ((m_ulThroughput*8)/m_statsDuration)/m_nUser<<std::endl;
   ulOutFile.close ();
 }
-
diff -Naru a/test/lte-test-cell-selection.cc b/test/lte-test-cell-selection.cc
--- a/test/lte-test-cell-selection.cc	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-test-cell-selection.cc	2018-08-03 16:39:02.895957709 +0200
@@ -398,7 +398,7 @@
   LteUeRrc::State oldState, LteUeRrc::State newState)
 {
   NS_LOG_FUNCTION (this << imsi << cellId << rnti << oldState << newState);
-  m_lastState.at (static_cast<unsigned int>(imsi - 1)) = newState;
+  m_lastState.at (static_cast<unsigned int>(imsi - 1)) = newState; 
 }
 
 
diff -Naru a/test/lte-test-cqa-ff-mac-scheduler.cc b/test/lte-test-cqa-ff-mac-scheduler.cc
--- a/test/lte-test-cqa-ff-mac-scheduler.cc	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-test-cqa-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -82,7 +82,7 @@
   // DOWNLINK -> DISTANCE 0 -> MCS 28 -> Itbs 26 (from table 7.1.7.2.1-1 of 36.2    13)
   // Traffic info
   //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
+  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
   // Totol bandwidth: 24 PRB at Itbs 26 -> 2196 -> 2196000 byte/sec
   // 1 user -> 232000 * 1 = 232000 < 2196000 -> throughput = 232000 byte/sec
   // 3 user -> 232000 * 3 = 696000 < 2196000 -> througphut = 232000 byte/sec
@@ -90,85 +90,85 @@
   // 12 user -> 232000 * 12 = 2784000 > 2196000 -> throughput = 2196000 / 12 = 183000 byte/sec
   // UPLINK -> DISTANCE 0 -> MCS 28 -> Itbs 26 (from table 7.1.7.2.1-1 of 36.2    13)
   // 1 user -> 25 PRB at Itbs 26 -> 2292 -> 2292000 > 232000 -> throughput = 232000 bytes/sec
-  // 3 users -> 8 PRB at Itbs 26 -> 749 -> 749000 > 232000 -> throughput = 232000 bytes/sec 
+  // 3 users -> 8 PRB at Itbs 26 -> 749 -> 749000 > 232000 -> throughput = 232000 bytes/sec
   // 6 users -> 4 PRB at Itbs 26 -> 373 -> 373000 > 232000 -> throughput = 232000 bytes/sec
   // 12 users -> 2 PRB at Itbs 26 -> 185 -> 185000 < 232000 -> throughput = 185000 bytes/sec
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (1,0,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (3,0,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (6,0,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
 
-  //AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (12,0,183000,185000,200,1,errorModel));// simulation time = 1.5, otherwise, ul test will fail
+  // //AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (12,0,183000,185000,200,1,errorModel));// simulation time = 1.5, otherwise, ul test will fail
 
-  // DOWNLINK - DISTANCE 4800 -> MCS 22 -> Itbs 20 (from table 7.1.7.2.1-1 of 36.213)
-  // Traffic info
-  //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
-  // Totol bandwidth: 24 PRB at Itbs 20 -> 1383 -> 1383000 byte/sec
-  // 1 user -> 903000 * 1 = 232000 < 1383000 -> throughput = 232000 byte/sec
-  // 3 user -> 232000 * 3 = 696000 < 1383000 -> througphut = 232000 byte/sec
-  // 6 user -> 232000 * 6 = 139200 > 1383000 -> throughput = 1383000 / 6 = 230500 byte/sec
-  // 12 user -> 232000 * 12 = 2784000 > 1383000 -> throughput =  1383000 / 12 = 115250 byte/sec
-  // UPLINK - DISTANCE 4800 -> MCS 14 -> Itbs 13 (from table 7.1.7.2.1-1 of 36.213)
-  // 1 user -> 25 PRB at Itbs 13 -> 807 -> 807000 > 232000 -> throughput = 232000 bytes/sec
-  // 3 users -> 8 PRB at Itbs 13 -> 253 -> 253000 > 232000 -> throughput = 232000 bytes/sec
-  // 6 users -> 4 PRB at Itbs 13 -> 125 -> 125000 < 232000 -> throughput = 125000 bytes/sec
-  // after the patch enforcing min 3 PRBs per UE:
-  // 12 users -> 3 PRB at Itbs 13 -> 93  bytes * 8/12 UE/TTI  -> 62000 < 232000 -> throughput = 62000  bytes/sec
+  // // DOWNLINK - DISTANCE 4800 -> MCS 22 -> Itbs 20 (from table 7.1.7.2.1-1 of 36.213)
+  // // Traffic info
+  // //   UDP traffic: payload size = 200 bytes, interval = 1 ms
+  // //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
+  // // Totol bandwidth: 24 PRB at Itbs 20 -> 1383 -> 1383000 byte/sec
+  // // 1 user -> 903000 * 1 = 232000 < 1383000 -> throughput = 232000 byte/sec
+  // // 3 user -> 232000 * 3 = 696000 < 1383000 -> througphut = 232000 byte/sec
+  // // 6 user -> 232000 * 6 = 139200 > 1383000 -> throughput = 1383000 / 6 = 230500 byte/sec
+  // // 12 user -> 232000 * 12 = 2784000 > 1383000 -> throughput =  1383000 / 12 = 115250 byte/sec
+  // // UPLINK - DISTANCE 4800 -> MCS 14 -> Itbs 13 (from table 7.1.7.2.1-1 of 36.213)
+  // // 1 user -> 25 PRB at Itbs 13 -> 807 -> 807000 > 232000 -> throughput = 232000 bytes/sec
+  // // 3 users -> 8 PRB at Itbs 13 -> 253 -> 253000 > 232000 -> throughput = 232000 bytes/sec
+  // // 6 users -> 4 PRB at Itbs 13 -> 125 -> 125000 < 232000 -> throughput = 125000 bytes/sec
+  // // after the patch enforcing min 3 PRBs per UE:
+  // // 12 users -> 3 PRB at Itbs 13 -> 93  bytes * 8/12 UE/TTI  -> 62000 < 232000 -> throughput = 62000  bytes/sec
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (1,4800,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (3,4800,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (6,4800,230500,125000,200,1,errorModel), TestCase::EXTENSIVE);
-  //AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (12,4800,115250,62000,200,1,errorModel)); // simulation time = 1.5, otherwise, ul test will fail
+  // //AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (12,4800,115250,62000,200,1,errorModel)); // simulation time = 1.5, otherwise, ul test will fail
 
-  // DOWNLINK - DISTANCE 6000 -> MCS 20 -> Itbs 18 (from table 7.1.7.2.1-1 of 36.213)
-  // Traffic info
-  //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
-  // Totol bandwidth: 24 PRB at Itbs 18 -> 1191 -> 1191000 byte/sec
-  // 1 user -> 903000 * 1 = 232000 < 1191000 -> throughput = 232000 byte/sec
-  // 3 user -> 232000 * 3 = 696000 < 1191000 -> througphut = 232000 byte/sec
-  // 6 user -> 232000 * 6 = 1392000 > 1191000 -> throughput = 1191000 / 6 = 198500 byte/sec
-  // 12 user -> 232000 * 12 = 2784000 > 1191000 -> throughput =  1191000 / 12 = 99250 byte/sec
-
-  // UPLINK - DISTANCE 6000 -> MCS 12 -> Itbs 11 (from table 7.1.7.2.1-1 of 36.213)
-  // 1 user -> 25 PRB at Itbs 11 -> 621 -> 621000 > 232000 -> throughput = 232000 bytes/sec
-  // 3 users -> 8 PRB at Itbs 11 -> 201 -> 201000 < 232000 -> throughput = 201000  bytes/sec
-  // 6 users -> 4 PRB at Itbs 11 -> 97 -> 97000 < 232000 -> throughput = 97000 bytes/sec
-  // after the patch enforcing min 3 PRBs per UE:
-  // 12 users -> 3 PRB at Itbs 11 -> 73 bytes * 8/12 UE/TTI -> 48667 < 232000 -> throughput = 48667 bytes/sec
+  // // DOWNLINK - DISTANCE 6000 -> MCS 20 -> Itbs 18 (from table 7.1.7.2.1-1 of 36.213)
+  // // Traffic info
+  // //   UDP traffic: payload size = 200 bytes, interval = 1 ms
+  // //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
+  // // Totol bandwidth: 24 PRB at Itbs 18 -> 1191 -> 1191000 byte/sec
+  // // 1 user -> 903000 * 1 = 232000 < 1191000 -> throughput = 232000 byte/sec
+  // // 3 user -> 232000 * 3 = 696000 < 1191000 -> througphut = 232000 byte/sec
+  // // 6 user -> 232000 * 6 = 1392000 > 1191000 -> throughput = 1191000 / 6 = 198500 byte/sec
+  // // 12 user -> 232000 * 12 = 2784000 > 1191000 -> throughput =  1191000 / 12 = 99250 byte/sec
+
+  // // UPLINK - DISTANCE 6000 -> MCS 12 -> Itbs 11 (from table 7.1.7.2.1-1 of 36.213)
+  // // 1 user -> 25 PRB at Itbs 11 -> 621 -> 621000 > 232000 -> throughput = 232000 bytes/sec
+  // // 3 users -> 8 PRB at Itbs 11 -> 201 -> 201000 < 232000 -> throughput = 201000  bytes/sec
+  // // 6 users -> 4 PRB at Itbs 11 -> 97 -> 97000 < 232000 -> throughput = 97000 bytes/sec
+  // // after the patch enforcing min 3 PRBs per UE:
+  // // 12 users -> 3 PRB at Itbs 11 -> 73 bytes * 8/12 UE/TTI -> 48667 < 232000 -> throughput = 48667 bytes/sec
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (1,6000,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (3,6000,232000,201000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (6,6000,198500,97000,200,1,errorModel), TestCase::EXTENSIVE);
-  //AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (12,6000,99250,48667,200,1, errorModel)); // simulation time = 1.5, otherwise, ul test will fail
+  // //AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (12,6000,99250,48667,200,1, errorModel)); // simulation time = 1.5, otherwise, ul test will fail
 
-  // DOWNLINK - DISTANCE 10000 -> MCS 14 -> Itbs 13 (from table 7.1.7.2.1-1 of 36.213)
-  // Traffic info
-  //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
-  // Totol bandwidth: 24 PRB at Itbs 13 -> 775 -> 775000 byte/sec
-  // 1 user -> 903000 * 1 = 232000 < 775000 -> throughput = 232000 byte/sec
-  // 3 user -> 232000 * 3 = 696000 > 775000 -> througphut = 232000 byte/sec
-  // 6 user -> 232000 * 6 = 139200 > 775000 -> throughput = 775000 / 6 = 129166 byte/sec
-  // 12 user -> 232000 * 12 = 2784000 > 775000 -> throughput =  775000 / 12 = 64583 byte/sec
-  // UPLINK - DISTANCE 10000 -> MCS 8 -> Itbs 8 (from table 7.1.7.2.1-1 of 36.213)
-  // 1 user -> 24 PRB at Itbs 8 -> 437 -> 437000 > 232000 -> throughput = 232000 bytes/sec
-  // 3 users -> 8 PRB at Itbs 8 -> 137 -> 137000 < 232000 -> throughput = 137000 bytes/sec
-  // 6 users -> 4 PRB at Itbs 8 -> 67 -> 67000 < 232000 -> throughput = 67000 bytes/sec
-  // after the patch enforcing min 3 PRBs per UE:
-  // 12 users -> 3 PRB at Itbs 8 -> 49 bytes * 8/12 UE/TTI -> 32667 < 232000 -> throughput = 32667  bytes/sec
+  // // DOWNLINK - DISTANCE 10000 -> MCS 14 -> Itbs 13 (from table 7.1.7.2.1-1 of 36.213)
+  // // Traffic info
+  // //   UDP traffic: payload size = 200 bytes, interval = 1 ms
+  // //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
+  // // Totol bandwidth: 24 PRB at Itbs 13 -> 775 -> 775000 byte/sec
+  // // 1 user -> 903000 * 1 = 232000 < 775000 -> throughput = 232000 byte/sec
+  // // 3 user -> 232000 * 3 = 696000 > 775000 -> througphut = 232000 byte/sec
+  // // 6 user -> 232000 * 6 = 139200 > 775000 -> throughput = 775000 / 6 = 129166 byte/sec
+  // // 12 user -> 232000 * 12 = 2784000 > 775000 -> throughput =  775000 / 12 = 64583 byte/sec
+  // // UPLINK - DISTANCE 10000 -> MCS 8 -> Itbs 8 (from table 7.1.7.2.1-1 of 36.213)
+  // // 1 user -> 24 PRB at Itbs 8 -> 437 -> 437000 > 232000 -> throughput = 232000 bytes/sec
+  // // 3 users -> 8 PRB at Itbs 8 -> 137 -> 137000 < 232000 -> throughput = 137000 bytes/sec
+  // // 6 users -> 4 PRB at Itbs 8 -> 67 -> 67000 < 232000 -> throughput = 67000 bytes/sec
+  // // after the patch enforcing min 3 PRBs per UE:
+  // // 12 users -> 3 PRB at Itbs 8 -> 49 bytes * 8/12 UE/TTI -> 32667 < 232000 -> throughput = 32667  bytes/sec
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (1,10000,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (3,10000,232000,137000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (6,10000,129166,67000,200,1,errorModel), TestCase::EXTENSIVE);
-  //AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (12,10000,64583,32667,200,1,errorModel));// simulation time = 1.5, otherwise, ul test will fail
+  // //AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (12,10000,64583,32667,200,1,errorModel));// simulation time = 1.5, otherwise, ul test will fail
 
 
-  // DOWNLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  // UPLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
+  // // DOWNLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
+  // // UPLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
   AddTestCase (new LenaCqaFfMacSchedulerTestCase1 (1,100000,0,0,200,1,errorModel), TestCase::QUICK);
 
   // Test Case 2: homogeneous flow test in CQA (different distance)
   // Traffic1 info
   //   UDP traffic: payload size = 100 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 132000 byte/rate 
+  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 132000 byte/rate
   // Maximum throughput = 4 / ( 1/2196000 + 1/1191000 + 1/1383000 + 1/775000 ) = 1209046 byte/s
   // 132000 * 4 = 528000 < 1209046 -> estimated throughput in downlink = 132000 byte/sec
   std::vector<double> dist1;
@@ -190,7 +190,7 @@
 
   // Traffic2 info
   //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
+  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
   // Maximum throughput = 4 / ( 1/2196000 + 1/1191000 + 1/1383000 + 1/775000 ) = 1209046 byte/s
   // 232000 * 4 = 928000 < 1209046 -> estimated throughput in downlink = 928000 / 4 = 230000 byte/sec
   std::vector<double> dist2;
@@ -236,7 +236,7 @@
 // --------------- T E S T - C A S E   # 1 ------------------------------
 
 
-std::string 
+std::string
 LenaCqaFfMacSchedulerTestCase1::BuildNameString (uint16_t nUser, double dist)
 {
   std::ostringstream oss;
@@ -314,7 +314,7 @@
 
 //   LogComponentDisableAll (LOG_LEVEL_ALL);
   //LogComponentEnable ("LenaTestCqaFfMacScheduler", LOG_LEVEL_ALL);
-   
+
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
   // Create Nodes: eNodeB and UE
@@ -380,10 +380,10 @@
       qos.gbrUl = (m_packetSize + 32) * (1000 / m_interval) * 8;
       qos.mbrDl = 0;
       qos.mbrUl = 0;
-      
+
       enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
       EpsBearer bearer (q, qos);
-      lteHelper->ActivateDedicatedEpsBearer (ueDevice, bearer, EpcTft::Default ());  
+      lteHelper->ActivateDedicatedEpsBearer (ueDevice, bearer, EpcTft::Default ());
     }
 
   // Install downlink and uplink applications
@@ -439,7 +439,7 @@
       uint64_t imsi = ueDevs.Get (i)->GetObject<LteUeNetDevice> ()->GetImsi ();
       // get the lcId
       uint8_t lcId = 4;
-      uint64_t data = rlcStats->GetDlRxData (imsi, lcId);
+      uint64_t data = rlcStats->GetUlRxData (imsi, lcId);
       dlDataRxed.push_back (data);
       NS_LOG_INFO ("\tUser " << i << " imsi " << imsi << " bytes rxed " << (double)dlDataRxed.at (i) << "  thr " << (double)dlDataRxed.at (i) / statsDuration << " ref " << m_thrRefDl);
     }
@@ -478,7 +478,7 @@
 // --------------- T E S T - C A S E   # 2 ------------------------------
 
 
-std::string 
+std::string
 LenaCqaFfMacSchedulerTestCase2::BuildNameString (uint16_t nUser, std::vector<double> dist)
 {
   std::ostringstream oss;
@@ -518,6 +518,7 @@
     }
 
   Config::SetDefault ("ns3::LteHelper::UseIdealRrc", BooleanValue (true));
+  Config::SetDefault ("ns3::PointToPointEpcHelper::S1apLinkDelay", TimeValue(Seconds(0)));
 
 
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
@@ -552,7 +553,7 @@
 
 //   LogComponentDisableAll (LOG_LEVEL_ALL);
   //LogComponentEnable ("LenaTestCqaFfMacScheduler", LOG_LEVEL_ALL);
-   
+
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
   // Create Nodes: eNodeB and UE
@@ -618,10 +619,10 @@
       qos.gbrUl = (m_packetSize.at (u) + 32) * (1000 / m_interval) * 8;
       qos.mbrDl = qos.gbrDl;
       qos.mbrUl = qos.gbrUl;
-  
+
       enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
       EpsBearer bearer (q, qos);
-      lteHelper->ActivateDedicatedEpsBearer (ueDevice, bearer, EpcTft::Default ());  
+      lteHelper->ActivateDedicatedEpsBearer (ueDevice, bearer, EpcTft::Default ());
     }
 
 
@@ -662,6 +663,7 @@
   Simulator::Stop (Seconds (statsStartTime + statsDuration - 0.0001));
 
   lteHelper->EnableRlcTraces ();
+  lteHelper->EnableMacTraces ();
   Ptr<RadioBearerStatsCalculator> rlcStats = lteHelper->GetRlcStats ();
   rlcStats->SetAttribute ("StartTime", TimeValue (Seconds (statsStartTime)));
   rlcStats->SetAttribute ("EpochDuration", TimeValue (Seconds (statsDuration)));
diff -Naru a/test/lte-test-cqa-ff-mac-scheduler.h b/test/lte-test-cqa-ff-mac-scheduler.h
--- a/test/lte-test-cqa-ff-mac-scheduler.h	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-test-cqa-ff-mac-scheduler.h	2018-08-03 16:39:02.895957709 +0200
@@ -81,7 +81,7 @@
  * \ingroup tests
  *
  * \brief This is a system test program. The test is based on a scenario with single eNB and several UEs.
- *  The goal of the test is validating if the obtained throughput performance is consistent with the definition of 
+ *  The goal of the test is validating if the obtained throughput performance is consistent with the definition of
 *   CQA scheduler when the UEs with different SINRs.
 */
 
diff -Naru a/test/lte-test-cqi-generation.cc b/test/lte-test-cqi-generation.cc
--- a/test/lte-test-cqi-generation.cc	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-test-cqi-generation.cc	2018-08-03 16:39:02.895957709 +0200
@@ -57,7 +57,7 @@
 
 void
 LteTestDlSchedulingCallback2 (LteCqiGenerationDlPowerControlTestCase *testcase, std::string path,
-		                      DlSchedulingCallbackInfo dlInfo)
+                          DlSchedulingCallbackInfo dlInfo)
 {
   testcase->DlScheduling (dlInfo);
 }
@@ -124,7 +124,7 @@
   // need to allow for RRC connection establishment + CQI feedback reception
   if (Simulator::Now () > MilliSeconds (35))
     {
-//	  NS_LOG_UNCOND("DL MSC: " << (uint32_t)mcsTb1 << " expected DL MCS: " << (uint32_t)m_dlMcs);
+//    NS_LOG_UNCOND("DL MSC: " << (uint32_t)mcsTb1 << " expected DL MCS: " << (uint32_t)m_dlMcs);
       NS_TEST_ASSERT_MSG_EQ ((uint32_t)dlInfo.mcsTb1, (uint32_t)m_dlMcs, "Wrong DL MCS ");
     }
 }
@@ -136,7 +136,7 @@
   // need to allow for RRC connection establishment + SRS transmission
   if (Simulator::Now () > MilliSeconds (50))
     {
-//	  NS_LOG_UNCOND("UL MSC: " << (uint32_t)mcs << " expected UL MCS: " << (uint32_t)m_ulMcs);
+//    NS_LOG_UNCOND("UL MSC: " << (uint32_t)mcs << " expected UL MCS: " << (uint32_t)m_ulMcs);
       NS_TEST_ASSERT_MSG_EQ ((uint32_t)mcs, (uint32_t)m_ulMcs, "Wrong UL MCS");
     }
 }
@@ -257,7 +257,7 @@
   // need to allow for RRC connection establishment + CQI feedback reception
   if (Simulator::Now () > MilliSeconds (500))
     {
-//	  NS_LOG_UNCOND("DL MSC: " << (uint32_t)mcsTb1 << " expected DL MCS: " << (uint32_t)m_dlMcs);
+//    NS_LOG_UNCOND("DL MSC: " << (uint32_t)mcsTb1 << " expected DL MCS: " << (uint32_t)m_dlMcs);
       NS_TEST_ASSERT_MSG_EQ ((uint32_t)dlInfo.mcsTb1, (uint32_t)m_dlMcs, "Wrong DL MCS ");
     }
 }
@@ -269,7 +269,7 @@
   // need to allow for RRC connection establishment + SRS transmission
   if (Simulator::Now () > MilliSeconds (500))
     {
-//	  NS_LOG_UNCOND("UL MSC: " << (uint32_t)mcs << " expected UL MCS: " << (uint32_t)m_ulMcs);
+//    NS_LOG_UNCOND("UL MSC: " << (uint32_t)mcs << " expected UL MCS: " << (uint32_t)m_ulMcs);
       NS_TEST_ASSERT_MSG_EQ ((uint32_t)mcs, (uint32_t)m_ulMcs, "Wrong UL MCS");
     }
 }
diff -Naru a/test/lte-test-downlink-power-control.h b/test/lte-test-downlink-power-control.h
--- a/test/lte-test-downlink-power-control.h	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-test-downlink-power-control.h	2018-08-03 16:39:02.895957709 +0200
@@ -57,7 +57,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test SINR calculation in the downlink when power control is used. 
+ * \brief Test SINR calculation in the downlink when power control is used.
  * Test if the difference in power levels are corresponding to the estamated values.
  */
 class LteDownlinkPowerControlSpectrumValueTestCase : public TestCase
@@ -69,7 +69,7 @@
  * \param name the reference name
  * \param earfcn the EARFCN
  * \param bw the bandwidth
- * \param powerTx 
+ * \param powerTx
  * \param powerTxMap
  * \param activeRbs
  * \param expected the expected Tx Power Spectral Density
@@ -92,7 +92,7 @@
  * \ingroup tests
  *
  * \brief Test SINR calculation in the downlink when the power control is used.
- * Test the power control by comparing the downlink data and ctrl power 
+ * Test the power control by comparing the downlink data and ctrl power
  * difference with the estimated value based on the specified change in power.
  */
 class LteDownlinkPowerControlTestCase : public TestCase
@@ -121,9 +121,9 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test if RRC connection reconfiguration messages are properly 
+ * \brief Test if RRC connection reconfiguration messages are properly
  * generated upon the change in the downlink power.
- * 
+ *
  */
 class LteDownlinkPowerControlRrcConnectionReconfigurationTestCase : public TestCase
 {
diff -Naru a/test/lte-test-downlink-sinr.h b/test/lte-test-downlink-sinr.h
--- a/test/lte-test-downlink-sinr.h	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-test-downlink-sinr.h	2018-08-03 16:39:02.895957709 +0200
@@ -46,11 +46,11 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief  Test compares if the generated SINR is equal to estimated SINR 
- *  value. Test generates several calls to LteSpectrumPhy::StartRx corresponding 
+ * \brief  Test compares if the generated SINR is equal to estimated SINR
+ *  value. Test generates several calls to LteSpectrumPhy::StartRx corresponding
  *  to several signals. One will be the signal of interest, i.e., the
  *  LteSpectrumSignalParametersDlCtrlFrame of the first signal will have the
- *  same CellId of the receiving PHY; the others will have a different 
+ *  same CellId of the receiving PHY; the others will have a different
  *  CellId and hence will be the interfering signals.
  */
 class LteDownlinkDataSinrTestCase : public TestCase
@@ -79,12 +79,12 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief  
- *  Test compares if the generated SINR is equal to estimated SINR value. 
- *  Test generates several calls to LteSpectrumPhy::StartRx corresponding 
+ * \brief
+ *  Test compares if the generated SINR is equal to estimated SINR value.
+ *  Test generates several calls to LteSpectrumPhy::StartRx corresponding
  *  to several signals. One will be the signal of interest, i.e., the
  *  LteSpectrumSignalParametersDlCtrlFrame of the first signal will have the
- *  same CellId of the receiving PHY; the others will have a different 
+ *  same CellId of the receiving PHY; the others will have a different
  *  CellId and hence will be the interfering signals.
  */
 class LteDownlinkCtrlSinrTestCase : public TestCase
@@ -99,10 +99,10 @@
    */
     LteDownlinkCtrlSinrTestCase (Ptr<SpectrumValue> sv, Ptr<SpectrumValue> sinr, std::string name);
     virtual ~LteDownlinkCtrlSinrTestCase ();
-  
+
 private:
   virtual void DoRun (void);
-  
+
   Ptr<SpectrumValue> m_sv; ///< the spectrum value
   Ptr<const SpectrumModel> m_sm; ///< the spectrum model
   Ptr<SpectrumValue> m_expectedSinr; ///< the expected SINR
diff -Naru a/test/lte-test-earfcn.cc b/test/lte-test-earfcn.cc
--- a/test/lte-test-earfcn.cc	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-test-earfcn.cc	2018-08-03 16:39:02.895957709 +0200
@@ -33,7 +33,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test case that is testing if the frequency is properly generated 
+ * \brief Test case that is testing if the frequency is properly generated
  * from provided EARFCN frequency.
  */
 
@@ -70,7 +70,7 @@
 {
 }
 
-void 
+void
 LteEarfcnTestCase::DoRun (void)
 {
   double f = LteSpectrumValueHelper::GetCarrierFrequency (m_earfcn);
@@ -81,8 +81,8 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief 
- * Test case that is testing if the downlink frequency is properly 
+ * \brief
+ * Test case that is testing if the downlink frequency is properly
  * converted from provided downlink EARFCN frequency value.
  */
 
@@ -107,7 +107,7 @@
 {
 }
 
-void 
+void
 LteEarfcnDlTestCase::DoRun (void)
 {
 //   LogLevel logLevel = (LogLevel)(LOG_PREFIX_FUNC | LOG_PREFIX_TIME | LOG_LEVEL_ALL);
@@ -123,7 +123,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief  Test case that is testing if the uplink frequency is properly 
+ * \brief  Test case that is testing if the uplink frequency is properly
  * converted from provided uplink EARFCN frequency value.
  */
 
@@ -148,7 +148,7 @@
 {
 }
 
-void 
+void
 LteEarfcnUlTestCase::DoRun (void)
 {
   double f = LteSpectrumValueHelper::GetUplinkCarrierFrequency (m_earfcn);
diff -Naru a/test/lte-test-entities.cc b/test/lte-test-entities.cc
--- a/test/lte-test-entities.cc	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-test-entities.cc	2018-08-03 16:39:02.895957709 +0200
@@ -203,14 +203,14 @@
   p.rnti = 1111;
   p.lcid = 222;
   p.pdcpSdu = Create<Packet> (m_pduSize);
-  
+
   bool haveContext = false;
   Ptr<Node> node;
   if (m_device != 0)
     {
       node = m_device->GetNode ();
       if (node != 0)
-        {                    
+        {
           haveContext = true;
         }
     }
@@ -480,7 +480,7 @@
     {
       node = m_device->GetNode ();
       if (node != 0)
-        {                    
+        {
           haveContext = true;
         }
     }
@@ -492,7 +492,7 @@
     {
       Simulator::Schedule (time, &LteMacSapUser::NotifyTxOpportunity, m_macSapUser, bytes, 0, 0, 0, 0, 0);
     }
-    
+
   if (m_txOpportunityMode == RANDOM_MODE)
   {
     if (m_txOppTime != Seconds (0))
@@ -615,7 +615,7 @@
       for (std::list<EventId>::iterator it = m_nextTxOppList.begin ();
            it != m_nextTxOppList.end ();
            ++it)
-        {          
+        {
           it->Cancel ();
         }
       m_nextTxOppList.clear ();
@@ -624,7 +624,7 @@
       Time time = m_txOppTime;
       while (size > 0)
         {
-          EventId e = Simulator::Schedule (time, 
+          EventId e = Simulator::Schedule (time,
                                            &LteMacSapUser::NotifyTxOpportunity,
                                            m_macSapUser, m_txOppSize, 0, 0, 0, params.rnti, params.lcid);
           m_nextTxOppList.push_back (e);
@@ -688,26 +688,26 @@
   ;
   return tid;
 }
-void 
+void
 EpcTestRrc::SetS1SapProvider (EpcEnbS1SapProvider * s)
 {
   m_s1SapProvider = s;
 }
 
-  
-EpcEnbS1SapUser* 
+
+EpcEnbS1SapUser*
 EpcTestRrc::GetS1SapUser ()
 {
   return m_s1SapUser;
 }
 
-void 
+void
 EpcTestRrc::DoDataRadioBearerSetupRequest (EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters request)
 {
 
 }
-  
-void 
+
+void
 EpcTestRrc::DoPathSwitchRequestAcknowledge (EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters params)
 {
 
@@ -715,4 +715,3 @@
 
 
 } // namespace ns3
-
diff -Naru a/test/lte-test-entities.h b/test/lte-test-entities.h
--- a/test/lte-test-entities.h	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-test-entities.h	2018-08-03 16:39:02.895957709 +0200
@@ -137,7 +137,7 @@
     * \brief Set the device
     * \param device the device
     */
-    void SetDevice (Ptr<NetDevice> device);
+  void SetDevice (Ptr<NetDevice> device);
 
   private:
     /**
@@ -177,7 +177,7 @@
 {
   /// allow LteRlcSpecificLteRlcSapUser<LteTestPdcp> class friend access
   friend class LteRlcSpecificLteRlcSapUser<LteTestPdcp>;
-  
+
   public:
   /**
    * \brief Get the type ID.
@@ -221,12 +221,12 @@
      * Interface forwarded by LteRlcSapUser
      * \param p the PDCP PDU packet received
      */
-    virtual void DoReceivePdcpPdu (Ptr<Packet> p);
+  virtual void DoReceivePdcpPdu (Ptr<Packet> p);
 
     LteRlcSapUser* m_rlcSapUser; ///< RLC SAP user
     LteRlcSapProvider* m_rlcSapProvider; ///< RLC SAP provider
 
-    std::string m_receivedData; ///< the received data 
+    std::string m_receivedData; ///< the received data
 };
 
 /////////////////////////////////////////////////////////////////////
@@ -430,15 +430,15 @@
    */
   static TypeId GetTypeId (void);
 
-  /** 
+  /**
    * Set the S1 SAP Provider
-   * 
+   *
    * \param s the S1 SAP Provider
    */
   void SetS1SapProvider (EpcEnbS1SapProvider* s);
 
-  /** 
-   * 
+  /**
+   *
    * \return the S1 SAP user
    */
   EpcEnbS1SapUser* GetS1SapUser ();
@@ -455,11 +455,11 @@
    * Path switch request acknowledge function
    * \param params EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters
    */
-  void DoPathSwitchRequestAcknowledge (EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters params);  
-  
+  void DoPathSwitchRequestAcknowledge (EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters params);
+
   EpcEnbS1SapProvider* m_s1SapProvider; ///< S1 SAP provider
   EpcEnbS1SapUser* m_s1SapUser; ///< S1 SAP user
-  
+
 
 };
 
diff -Naru a/test/lte-test-fading.cc b/test/lte-test-fading.cc
--- a/test/lte-test-fading.cc	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-test-fading.cc	2018-08-03 16:39:02.895957709 +0200
@@ -38,10 +38,14 @@
 #include <ns3/lte-ue-net-device.h>
 #include <ns3/lte-enb-net-device.h>
 #include <ns3/lte-ue-rrc.h>
+#include <ns3/lte-helper.h>
 #include <ns3/lte-enb-phy.h>
 #include <ns3/lte-ue-phy.h>
 #include "lte-test-sinr-chunk-processor.h"
 
+// #include <ns3/trace-fading-loss-model.h>
+// #include <ns3/spectrum-value.h>
+
 using namespace ns3;
 
 NS_LOG_COMPONENT_DEFINE ("LteFadingTest");
@@ -59,18 +63,18 @@
 LteFadingTestSuite::LteFadingTestSuite ()
 : TestSuite ("lte-fading-model", SYSTEM)
 {
-  
-  
+
+
   // -------------- COMPOUND TESTS ----------------------------------
-  
+
   LogComponentEnable ("LteFadingTest", LOG_LEVEL_ALL);
-  
+
   // NS_LOG_INFO ("Creating LteDownlinkSinrTestSuite");
-  
+
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
-  
+
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::BuildingsPropagationLossModel"));
-  
+
   // Create Nodes: eNodeB, home eNB, UE and home UE (UE attached to HeNB)
   NodeContainer enbNodes;
   NodeContainer henbNodes;
@@ -80,7 +84,7 @@
   henbNodes.Create (2);
   ueNodes.Create (5);
   hueNodes.Create (3);
-  
+
   // Install Mobility Model
   MobilityHelper mobility;
   mobility.SetMobilityModel ("ns3::BuildingsMobilityModel");
@@ -88,7 +92,7 @@
   mobility.Install (henbNodes);
   mobility.Install (ueNodes);
   mobility.Install (hueNodes);
-  
+
   NetDeviceContainer enbDevs;
   NetDeviceContainer henbDevs;
   NetDeviceContainer ueDevs;
@@ -97,27 +101,27 @@
   ueDevs = lteHelper->InstallUeDevice (ueNodes);
   henbDevs = lteHelper->InstallEnbDevice (henbNodes);
   hueDevs = lteHelper->InstallUeDevice (hueNodes);
-  
-  
-  
+
+
+
   lteHelper->Attach (ueDevs, enbDevs.Get (0));
   lteHelper->Attach (hueDevs, henbDevs.Get (0));
-  
+
   // Test #1 Okumura Hata Model (150 < freq < 1500 MHz) (Macro<->UE)
-  
+
   double distance = 2000;
   double hm = 1;
   double hb = 30;
 //   double freq = 869e6; // E_UTRA BAND #5 see table 5.5-1 of 36.101
   Ptr<BuildingsMobilityModel> mm1 = enbNodes.Get (0)->GetObject<BuildingsMobilityModel> ();
   mm1->SetPosition (Vector (0.0, 0.0, hb));
-  
+
   Ptr<BuildingsMobilityModel> mm2 = ueNodes.Get (0)->GetObject<BuildingsMobilityModel> ();
   mm2->SetPosition (Vector (distance, 0.0, hm));
-  
+
   AddTestCase (new LteFadingTestCase (mm1, mm2, 137.93, "OH Urban Large city"), TestCase::QUICK);
-    
-  
+
+
 }
 
 static LteFadingTestSuite lteFadingTestSuite;
@@ -143,63 +147,63 @@
 LteFadingTestCase::DoRun (void)
 {
   //   LogLevel logLevel = (LogLevel)(LOG_PREFIX_FUNC | LOG_PREFIX_TIME | LOG_LEVEL_ALL);
-  
+
   //   LogComponentEnable ("LteEnbRrc", logLevel);
   //   LogComponentEnable ("LteUeRrc", logLevel);
   //   LogComponentEnable ("LteEnbMac", logLevel);
   //   LogComponentEnable ("LteUeMac", logLevel);
   //   LogComponentEnable ("LteRlc", logLevel);
   //   LogComponentEnable ("RrPacketScheduler", logLevel);
-  // 
+  //
   //   LogComponentEnable ("LtePhy", logLevel);
   //   LogComponentEnable ("LteEnbPhy", logLevel);
   //   LogComponentEnable ("LteUePhy", logLevel);
-  // 
+  //
   //   LogComponentEnable ("LteSpectrumPhy", logLevel);
   //   LogComponentEnable ("LteInterference", logLevel);
   //   LogComponentEnable ("LteChunkProcessor", logLevel);
-  // 
+  //
   //   LogComponentEnable ("LtePropagationLossModel", logLevel);
   //   LogComponentEnable ("LossModel", logLevel);
   //   LogComponentEnable ("ShadowingLossModel", logLevel);
   //   LogComponentEnable ("PenetrationLossModel", logLevel);
   //   LogComponentEnable ("MultipathLossModel", logLevel);
   //   LogComponentEnable ("PathLossModel", logLevel);
-  // 
+  //
   //   LogComponentEnable ("LteNetDevice", logLevel);
   //   LogComponentEnable ("LteUeNetDevice", logLevel);
   //   LogComponentEnable ("LteEnbNetDevice", logLevel);
-  
+
   LogComponentEnable ("TraceFadingLossModel", LOG_LEVEL_ALL);
 //   LogComponentEnable ("TraceFadingLossModel", LOG_LEVEL_ALL);
 //   LogComponentEnable ("BuildingsPropagationLossModel", LOG_LEVEL_ALL);
   NS_LOG_INFO ("Testing " << GetName());
-  
-  
+
+
   m_fadingModule = CreateObject<TraceFadingLossModel> ();
-  
+
   m_fadingModule->SetAttribute("TraceFilename", StringValue("../../../src/lte/model/fading-traces/fading_trace_EPA_3kmph.fad"));
   //m_fadingModule->SetAttribute("WindowSize", TimeValue(Seconds (0.003)));
-  
+
   m_fadingModule->CreateFadingChannelRealization (m_node1, m_node2);
-  
+
 //   Ptr<SpectrumModel> sm;
-//   
+//
 //   Bands bands;
 //   BandInfo bi;
-//   
+//
 //   bi.fl = 2.400e9;
 //   bi.fc = 2.410e9;
 //   bi.fh = 2.420e9;
 //   bands.push_back (bi);
-//   
+//
 //   bi.fl = 2.420e9;
 //   bi.fc = 2.431e9;
 //   bi.fh = 2.442e9;
 //   bands.push_back (bi);
-//   
+//
 //   sm = Create<SpectrumModel> (bands);
-//   
+//
 //   /**
 //   * TX signal #1: Power Spectral Density (W/Hz) of the signal  = [0 0] dBm and BW = [20 22] MHz
 //   */
@@ -208,7 +212,7 @@
 //   (*inPsd1)[1] = 1.;
 //   Ptr<SpectrumValue> outPsd1 = Create<SpectrumValue> (sm);
 //   outPsd1 = m_fadingModule->CalcRxPowerSpectralDensity (inPsd1, m_node1, m_node2);
-//   
+//
 //   NS_LOG_INFO ("A ver " << (*outPsd1)[0] << " " << (*outPsd1)[1]);
   double samplingInterval = 0.001;
   double time = 0.0;
@@ -249,7 +253,7 @@
       double sigma = sqrt(sumSquared.at (i)/m_fadingSamples.size () - (mean*mean));
       NS_LOG_INFO (" Mean " << mean << " sigma " << sigma);
     }
-  
+
   //   NS_TEST_ASSERT_MSG_EQ_TOL(loss, m_lossRef, 0.1, "Wrong loss !");
 }
 
@@ -258,22 +262,22 @@
 LteFadingTestCase::GetFadingSample ()
 {
   Ptr<SpectrumModel> sm;
-  
+
   Bands bands;
   BandInfo bi;
-  
+
   bi.fl = 2.400e9;
   bi.fc = 2.410e9;
   bi.fh = 2.420e9;
   bands.push_back (bi);
-  
+
   bi.fl = 2.420e9;
   bi.fc = 2.431e9;
   bi.fh = 2.442e9;
   bands.push_back (bi);
-  
+
   sm = Create<SpectrumModel> (bands);
-  
+
   /**
   * TX signal #1: Power Spectral Density (W/Hz) of the signal  = [0 0] dBm and BW = [20 22] MHz
   */
diff -Naru a/test/lte-test-fading.h b/test/lte-test-fading.h
--- a/test/lte-test-fading.h	2018-08-03 16:38:46.683807085 +0200
+++ b/test/lte-test-fading.h	2018-08-03 16:39:02.895957709 +0200
@@ -39,7 +39,7 @@
  * \ingroup tests
  *
  * \brief Test 1.1 fading model
- */
+*/
 
 class LteFadingTestSuite : public TestSuite
 {
@@ -52,8 +52,8 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Fading test case is checking if the pathloss between macro and UE 
- * is equal to the theoretical value when using the Okumura Hata Model 
+ * \brief Fading test case is checking if the pathloss between macro and UE
+ * is equal to the theoretical value when using the Okumura Hata Model
  * (150 < freq < 1500 MHz).
  */
 class LteFadingTestCase : public TestCase
@@ -68,19 +68,19 @@
      */
     LteFadingTestCase (Ptr<BuildingsMobilityModel> m1, Ptr<BuildingsMobilityModel> m2, double refValue, std::string name);
     virtual ~LteFadingTestCase ();
-    
+
   private:
     virtual void DoRun (void);
-    
+
     void GetFadingSample ();
-    
+
     Ptr<BuildingsMobilityModel> m_node1; ///< building mobility model #1
     Ptr<BuildingsMobilityModel> m_node2; ///< building mobility model #2
     Ptr<TraceFadingLossModel> m_fadingModule; ///< fading loss model
     double m_lossRef; ///< loss reference
     std::vector<SpectrumValue> m_fadingSamples; ///< fading samples
-     
-    
+
+
 };
 
 /**
@@ -102,16 +102,17 @@
     LteFadingSystemTestCase (std::string name, double snrDb, double dist, uint16_t mcsIndex);
     LteFadingSystemTestCase ();
     virtual ~LteFadingSystemTestCase ();
-    
+
     /**
      * DL scheduling function
      * \param dlInfo DL scheduling info
      */
-    void DlScheduling (DlSchedulingCallbackInfo dlInfo);
-                       
+    void DlScheduling (uint32_t frameNo, uint32_t subframeNo, uint16_t rnti,
+                       uint8_t mcsTb1, uint16_t sizeTb1, uint8_t mcsTb2, uint16_t sizeTb2);
+
   private:
     virtual void DoRun (void);
-    
+
     double m_snrDb; ///< SNR in DB
     double m_distance; ///< distance
     uint16_t m_mcsIndex; ///< MCS index
diff -Naru a/test/lte-test-fdbet-ff-mac-scheduler.cc b/test/lte-test-fdbet-ff-mac-scheduler.cc
--- a/test/lte-test-fdbet-ff-mac-scheduler.cc	2018-08-03 16:38:46.687807121 +0200
+++ b/test/lte-test-fdbet-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -239,6 +239,11 @@
   NetDeviceContainer enbDevs;
   NetDeviceContainer ueDevs;
   lteHelper->SetSchedulerType ("ns3::FdBetFfMacScheduler");
+
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   enbDevs = lteHelper->InstallEnbDevice (enbNodes);
   ueDevs = lteHelper->InstallUeDevice (ueNodes);
 
@@ -403,6 +408,11 @@
   NetDeviceContainer enbDevs;
   NetDeviceContainer ueDevs;
   lteHelper->SetSchedulerType ("ns3::FdBetFfMacScheduler");
+
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+  
   enbDevs = lteHelper->InstallEnbDevice (enbNodes);
   ueDevs = lteHelper->InstallUeDevice (ueNodes);
 
diff -Naru a/test/lte-test-fdmt-ff-mac-scheduler.cc b/test/lte-test-fdmt-ff-mac-scheduler.cc
--- a/test/lte-test-fdmt-ff-mac-scheduler.cc	2018-08-03 16:38:46.687807121 +0200
+++ b/test/lte-test-fdmt-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -49,6 +49,9 @@
 #include <ns3/boolean.h>
 #include <ns3/enum.h>
 
+
+#include "lte-test-fdmt-ff-mac-scheduler.h"
+
 using namespace ns3;
 
 NS_LOG_COMPONENT_DEFINE ("LenaTestFdMtFfMacScheduler");
@@ -128,7 +131,7 @@
   AddTestCase (new LenaFdMtFfMacSchedulerTestCase (3,10000,775000,137000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaFdMtFfMacSchedulerTestCase (6,10000,775000,67000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaFdMtFfMacSchedulerTestCase (12,10000,775000,32667,errorModel), TestCase::EXTENSIVE);
- 
+
   // DONWLINK - DISTANCE 20000 -> MCS 8 -> Itbs 8 (from table 7.1.7.2.1-1 of 36.213)
   // 1 user -> 24 PRB at Itbs 8 -> 421 -> 421000 bytes/sec for one UE; 0 bytes/sec for other UEs
   // 3 users -> 421000 among 3 users -> 421000 bytes/sec for one UE; 0 bytes/sec for other UEs
@@ -144,10 +147,6 @@
   AddTestCase (new LenaFdMtFfMacSchedulerTestCase (3,20000,421000,41000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaFdMtFfMacSchedulerTestCase (6,20000,421000,22000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaFdMtFfMacSchedulerTestCase (12,20000,421000,12000,errorModel), TestCase::EXTENSIVE);
-
-  // DOWNLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  // UPLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  AddTestCase (new LenaFdMtFfMacSchedulerTestCase (1,100000,0,0,errorModel), TestCase::QUICK);
 }
 
 static LenaTestFdMtFfMacSchedulerSuite lenaTestFdMtFfMacSchedulerSuite;
@@ -155,15 +154,15 @@
 
 // --------------- T E S T - C A S E ------------------------------
 
-std::string 
-LenaFdMtFfMacSchedulerTestCase::BuildNameString (uint16_t nUser, double dist)
+std::string
+LenaFdMtFfMacSchedulerTestCase::BuildNameString (uint16_t nUser, uint16_t dist)
 {
   std::ostringstream oss;
   oss << nUser << " UEs, distance " << dist << " m";
   return oss.str ();
 }
 
-LenaFdMtFfMacSchedulerTestCase::LenaFdMtFfMacSchedulerTestCase (uint16_t nUser, double dist, double thrRefDl, double thrRefUl, bool errorModelEnabled)
+LenaFdMtFfMacSchedulerTestCase::LenaFdMtFfMacSchedulerTestCase (uint16_t nUser, uint16_t dist, double thrRefDl, double thrRefUl, bool errorModelEnabled)
   : TestCase (BuildNameString (nUser, dist)),
     m_nUser (nUser),
     m_dist (dist),
@@ -219,6 +218,11 @@
   NetDeviceContainer enbDevs;
   NetDeviceContainer ueDevs;
   lteHelper->SetSchedulerType ("ns3::FdMtFfMacScheduler");
+
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   enbDevs = lteHelper->InstallEnbDevice (enbNodes);
   ueDevs = lteHelper->InstallUeDevice (ueNodes);
 
@@ -229,8 +233,8 @@
   enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
   EpsBearer bearer (q);
   lteHelper->ActivateDataRadioBearer (ueDevs, bearer);
-  
- 
+
+
   Ptr<LteEnbNetDevice> lteEnbDev = enbDevs.Get (0)->GetObject<LteEnbNetDevice> ();
   Ptr<LteEnbPhy> enbPhy = lteEnbDev->GetPhy ();
   enbPhy->SetAttribute ("TxPower", DoubleValue (30.0));
@@ -314,8 +318,8 @@
     }
   /**
   * Check that the assignation is done in a "proportional fair" manner among users
-  * with equal SINRs: the bandwidth should be distributed according to the 
-  * ratio of the estimated throughput per TTI of each user; therefore equally 
+  * with equal SINRs: the bandwidth should be distributed according to the
+  * ratio of the estimated throughput per TTI of each user; therefore equally
   * partitioning the whole bandwidth achievable from a single users in a TTI
   */
   for (int i = 0; i < m_nUser; i++)
@@ -325,4 +329,3 @@
   Simulator::Destroy ();
 
 }
-
diff -Naru a/test/lte-test-fdmt-ff-mac-scheduler.h b/test/lte-test-fdmt-ff-mac-scheduler.h
--- a/test/lte-test-fdmt-ff-mac-scheduler.h	2018-08-03 16:38:46.687807121 +0200
+++ b/test/lte-test-fdmt-ff-mac-scheduler.h	2018-08-03 16:39:02.895957709 +0200
@@ -34,14 +34,14 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief This system test program creates different test cases with a single eNB and 
- * several UEs, all having the same Radio Bearer specification. In each test 
- * case, the UEs see the same SINR from the eNB; different test cases are 
- * implemented obtained by using different SINR values and different numbers of 
- * UEs. The test consists on checking that the obtained throughput performance 
- * is consistent with the definition of maximum throughput
- * scheduling
- */
+ * \brief This system test program creates different test cases with a single eNB and
+* several UEs, all having the same Radio Bearer specification. In each test
+* case, the UEs see the same SINR from the eNB; different test cases are
+* implemented obtained by using different SINR values and different numbers of
+* UEs. The test consists on checking that the obtained throughput performance
+* is consistent with the definition of maximum throughput
+* scheduling
+*/
 class LenaFdMtFfMacSchedulerTestCase : public TestCase
 {
 public:
@@ -54,7 +54,7 @@
    * \param thrRefUl UL throughput reference
    * \param errorModelEnabled error model enabled?
    */
-  LenaFdMtFfMacSchedulerTestCase (uint16_t nUser, double dist, double thrRefDl, double thrRefUl,bool errorModelEnabled);
+  LenaFdMtFfMacSchedulerTestCase (uint16_t nUser, uint16_t dist, double thrRefDl, double thrRefUl,bool errorModelEnabled);
   virtual ~LenaFdMtFfMacSchedulerTestCase ();
 
 private:
@@ -65,10 +65,10 @@
    * \param dist distance between nodes
    * \returns name string
    */
-  static std::string BuildNameString (uint16_t nUser, double dist);
+  static std::string BuildNameString (uint16_t nUser, uint16_t dist);
   virtual void DoRun (void);
   uint16_t m_nUser; ///< number of UE nodes
-  double m_dist; ///< distance between the nodes
+  uint16_t m_dist; ///< distance between the nodes
   double m_thrRefDl; ///< DL throughput reference
   double m_thrRefUl; ///< UL throughput reference
   bool m_errorModelEnabled; ///< error model enabled?
diff -Naru a/test/lte-test-fdtbfq-ff-mac-scheduler.cc b/test/lte-test-fdtbfq-ff-mac-scheduler.cc
--- a/test/lte-test-fdtbfq-ff-mac-scheduler.cc	2018-08-03 16:38:46.687807121 +0200
+++ b/test/lte-test-fdtbfq-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -268,6 +268,7 @@
       Config::SetDefault ("ns3::LteSpectrumPhy::DataErrorModelEnabled", BooleanValue (false));
     }
 
+  Config::SetDefault ("ns3::LteEnbRrc::SrsPeriodicity", UintegerValue(40));
   Config::SetDefault ("ns3::LteHelper::UseIdealRrc", BooleanValue (true));
 
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
diff -Naru a/test/lte-test-frequency-reuse.cc b/test/lte-test-frequency-reuse.cc
--- a/test/lte-test-frequency-reuse.cc	2018-08-03 16:38:46.687807121 +0200
+++ b/test/lte-test-frequency-reuse.cc	2018-08-03 16:39:02.895957709 +0200
@@ -298,6 +298,11 @@
   NetDeviceContainer enbDevs;
   NetDeviceContainer ueDevs;
   lteHelper->SetSchedulerType (m_schedulerType);
+
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   enbDevs = lteHelper->InstallEnbDevice (enbNodes);
   ueDevs = lteHelper->InstallUeDevice (ueNodes);
 
@@ -407,6 +412,11 @@
   NetDeviceContainer enbDevs;
   NetDeviceContainer ueDevs;
   lteHelper->SetSchedulerType (m_schedulerType);
+
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   enbDevs = lteHelper->InstallEnbDevice (enbNodes);
   ueDevs = lteHelper->InstallUeDevice (ueNodes);
 
@@ -669,6 +679,10 @@
   NetDeviceContainer ueDevs2;
   lteHelper->SetSchedulerType (m_schedulerType);
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   lteHelper->SetFfrAlgorithmType ("ns3::LteFrStrictAlgorithm");
   lteHelper->SetFfrAlgorithmAttribute ("RsrqThreshold", UintegerValue (25));
   lteHelper->SetFfrAlgorithmAttribute ("CenterPowerOffset",
@@ -846,6 +860,10 @@
   NetDeviceContainer ueDevs2;
   lteHelper->SetSchedulerType (m_schedulerType);
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   lteHelper->SetFfrAlgorithmType ("ns3::LteFrSoftAlgorithm");
   lteHelper->SetFfrAlgorithmAttribute ("AllowCenterUeUseEdgeSubBand", BooleanValue (false));
   lteHelper->SetFfrAlgorithmAttribute ("RsrqThreshold", UintegerValue (25));
@@ -1029,6 +1047,10 @@
   NetDeviceContainer ueDevs2;
   lteHelper->SetSchedulerType (m_schedulerType);
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   lteHelper->SetFfrAlgorithmType ("ns3::LteFfrSoftAlgorithm");
   lteHelper->SetFfrAlgorithmAttribute ("CenterRsrqThreshold", UintegerValue (28));
   lteHelper->SetFfrAlgorithmAttribute ("EdgeRsrqThreshold", UintegerValue (18));
diff -Naru a/test/lte-test-frequency-reuse.h b/test/lte-test-frequency-reuse.h
--- a/test/lte-test-frequency-reuse.h	2018-08-03 16:38:46.687807121 +0200
+++ b/test/lte-test-frequency-reuse.h	2018-08-03 16:39:02.895957709 +0200
@@ -47,7 +47,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test frequency reuse algorithm. Test fails if the muted frequencies 
+ * \brief Test frequency reuse algorithm. Test fails if the muted frequencies
  *  are being used.
  */
 class LteFrTestCase : public TestCase
@@ -98,7 +98,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test hard frequency reuse algorithm. Test fails if the muted 
+ * \brief Test hard frequency reuse algorithm. Test fails if the muted
  *  frequencies are being used.
  */
 class LteHardFrTestCase : public LteFrTestCase
@@ -143,7 +143,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test stric frequency reuse algorithm. Test fails if the muted frequencies 
+ * \brief Test stric frequency reuse algorithm. Test fails if the muted frequencies
  *  are being used.
  */
 class LteStrictFrTestCase : public LteFrTestCase
@@ -192,9 +192,9 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test frequency reuse algorithm by teleporing UEs to different 
- * parts of area and checking if the frequency is used according to the 
- * frequency pattern for different parts of area. Test fails if the muted 
+ * \brief Test frequency reuse algorithm by teleporing UEs to different
+ * parts of area and checking if the frequency is used according to the
+ * frequency pattern for different parts of area. Test fails if the muted
  * frequencies for a given part of area are being used by UE.
  */
 class LteFrAreaTestCase : public TestCase
@@ -262,7 +262,7 @@
   virtual void DoRun (void);
 
   std::string m_schedulerType; ///< the scheduler type
- 
+
   uint8_t m_dlBandwidth; ///< the DL bandwidth
   uint8_t m_ulBandwidth; ///< the UL bandwidth
 
diff -Naru a/test/lte-test-harq.cc b/test/lte-test-harq.cc
--- a/test/lte-test-harq.cc	2018-08-03 16:38:46.687807121 +0200
+++ b/test/lte-test-harq.cc	2018-08-03 16:39:02.895957709 +0200
@@ -193,6 +193,9 @@
   lena->SetSchedulerType ("ns3::RrFfMacScheduler");
   lena->SetSchedulerAttribute ("UlCqiFilter", EnumValue (FfMacScheduler::PUSCH_UL_CQI));
 
+  // set DL bandwidth. 
+  lena->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+
   enbDevs = lena->InstallEnbDevice (enbNodes);
   ueDevs = lena->InstallUeDevice (ueNodes);
 
diff -Naru a/test/lte-test-interference.cc b/test/lte-test-interference.cc
--- a/test/lte-test-interference.cc	2018-08-03 16:38:46.687807121 +0200
+++ b/test/lte-test-interference.cc	2018-08-03 16:39:02.895957709 +0200
@@ -46,7 +46,7 @@
 
 void
 LteTestDlSchedulingCallback (LteInterferenceTestCase *testcase, std::string path,
-		                     DlSchedulingCallbackInfo dlInfo)
+                         DlSchedulingCallbackInfo dlInfo)
 {
   testcase->DlScheduling (dlInfo);
 }
@@ -159,6 +159,11 @@
   NetDeviceContainer ueDevs2;
   lteHelper->SetSchedulerType ("ns3::RrFfMacScheduler");
   lteHelper->SetSchedulerAttribute ("UlCqiFilter", EnumValue (FfMacScheduler::PUSCH_UL_CQI));
+
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   enbDevs = lteHelper->InstallEnbDevice (enbNodes);
   ueDevs1 = lteHelper->InstallUeDevice (ueNodes1);
   ueDevs2 = lteHelper->InstallUeDevice (ueNodes2);
diff -Naru a/test/lte-test-interference-fr.cc b/test/lte-test-interference-fr.cc
--- a/test/lte-test-interference-fr.cc	2018-08-03 16:38:46.687807121 +0200
+++ b/test/lte-test-interference-fr.cc	2018-08-03 16:39:02.895957709 +0200
@@ -84,7 +84,8 @@
   : TestCase ("Test: " + name),
     m_d1 (d1),
     m_d2 (d2),
-    m_expectedDlSinrDb (10 * std::log10 (dlSinr))
+    m_expectedDlSinrDb (10 * std::log10 (dlSinr)),
+    m_expectedUlSinrDb (10 * std::log10 (ulSinr))
 {
   NS_LOG_INFO ("Creating LteInterferenceFrTestCase");
 }
@@ -112,6 +113,10 @@
 
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
   NodeContainer ueNodes1;
@@ -245,7 +250,9 @@
     m_d1 (d1),
     m_d2 (d2),
     m_commonDlSinrDb (10 * std::log10 (commonDlSinr)),
+    m_commonUlSinrDb (10 * std::log10 (commonUlSinr)),
     m_edgeDlSinrDb (10 * std::log10 (edgeDlSinr)),
+    m_edgeUlSinrDb (10 * std::log10 (edgeUlSinr)),
     m_rspqThreshold (rspqThreshold)
 {
   NS_LOG_INFO ("Creating LteInterferenceFrTestCase");
@@ -280,6 +287,10 @@
 
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
   NodeContainer ueNodes1;
@@ -319,6 +330,10 @@
   lteHelper->SetSchedulerType ("ns3::PfFfMacScheduler");
   lteHelper->SetSchedulerAttribute ("UlCqiFilter", EnumValue (FfMacScheduler::PUSCH_UL_CQI));
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
 
   lteHelper->SetFfrAlgorithmAttribute ("DlCommonSubBandwidth", UintegerValue (12));
   lteHelper->SetFfrAlgorithmAttribute ("DlEdgeSubBandOffset", UintegerValue (0));
diff -Naru a/test/lte-test-interference-fr.h b/test/lte-test-interference-fr.h
--- a/test/lte-test-interference-fr.h	2018-08-03 16:38:46.687807121 +0200
+++ b/test/lte-test-interference-fr.h	2018-08-03 16:39:02.895957709 +0200
@@ -28,13 +28,12 @@
 
 using namespace ns3;
 
-
 /**
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test suite for the interference test when using different 
- * frequency reuse algorithms.Check if the interfence values correspond to 
+ * \brief Test suite for the interference test when using different
+ * frequency reuse algorithms.Check if the interfence values correspond to
  * theoretical values.
  */
 class LteInterferenceFrTestSuite : public TestSuite
@@ -48,7 +47,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Lte interference test when using hard frequency reuse algorithm. Check 
+ * \brief Lte interference test when using hard frequency reuse algorithm. Check
  * if the interfence values correspond to theoretical values.
  */
 class LteInterferenceHardFrTestCase : public TestCase
@@ -72,6 +71,7 @@
   double m_d1; ///< distance between UE and ENB
   double m_d2; ///< distance between UE and other ENB
   double m_expectedDlSinrDb; ///< expected DL SINR in dB
+  double m_expectedUlSinrDb;
 };
 
 /**
@@ -106,7 +106,9 @@
   double m_d1; ///< distance between UE and ENB
   double m_d2; ///< distance between UE and other ENB
   double m_commonDlSinrDb; ///< expected common DL SINR in dB
+  double m_commonUlSinrDb;
   double m_edgeDlSinrDb; ///< expected edge DL SINR in dB
+  double m_edgeUlSinrDb;
 
   uint32_t m_rspqThreshold; ///< RSPQ threshold
 };
diff -Naru a/test/lte-test-ipv6-routing.cc b/test/lte-test-ipv6-routing.cc
--- a/test/lte-test-ipv6-routing.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-ipv6-routing.cc	2018-08-03 16:39:02.895957709 +0200
@@ -219,6 +219,7 @@
   inputConfig.ConfigureDefaults ();
 
   Ptr<Node> pgw = epcHelper->GetPgwNode ();
+  epcHelper->SetAttribute ("S1apLinkDelay", TimeValue(Seconds(0)));
 
   // Create a single RemoteHost
   NodeContainer remoteHostContainer;
diff -Naru a/test/lte-test-link-adaptation.cc b/test/lte-test-link-adaptation.cc
--- a/test/lte-test-link-adaptation.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-link-adaptation.cc	2018-08-03 16:39:02.895957709 +0200
@@ -176,6 +176,9 @@
   NS_LOG_INFO ("SNR = " << m_snrDb << "  LOSS = " << m_loss);
   lteHelper->SetPathlossModelAttribute ("Loss", DoubleValue (m_loss));
 
+  // set DL bandwidth. 
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
   NodeContainer ueNodes;
diff -Naru a/test/lte-test-mimo.cc b/test/lte-test-mimo.cc
--- a/test/lte-test-mimo.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-mimo.cc	2018-08-03 16:39:02.895957709 +0200
@@ -66,7 +66,7 @@
   // interval 1 : [0.1, 0.2) sec TxMode 0: MCS 20 -> TB size 1191 bytes
   // interval 2 : [0.3, 0.4) sec TxMode 1: MCS 26 -> TB size 1836 bytes
   // interval 3 : [0.5, 0.6) sec TxMode 2: MCS 18 -> TB size  967 bytes (x2 layers)
-  // --> 
+  // -->
   std::vector<uint32_t> estThrDl;
   estThrDl.push_back (119100); // interval 1 : estimated throughput for TxMode 1
   estThrDl.push_back (183600); // interval 2 : estimated throughput for TxMode 2
@@ -80,7 +80,7 @@
 
 static LenaTestMimoSuite lenaTestMimoSuite;
 
-std::string 
+std::string
 LenaMimoTestCase::BuildNameString (uint16_t dist, std::string schedulerType, bool useIdealRrc)
 {
   std::ostringstream oss;
@@ -92,12 +92,12 @@
   else
     {
       oss << ", real RRC";
-    }  
+    }
   return oss.str ();
 }
 
 LenaMimoTestCase::LenaMimoTestCase (uint16_t dist, std::vector<uint32_t> estThrDl, std::string schedulerType, bool useIdealRrc)
-  : TestCase (BuildNameString (dist, schedulerType, useIdealRrc)),              
+  : TestCase (BuildNameString (dist, schedulerType, useIdealRrc)),
     m_dist (dist),
     m_estThrDl (estThrDl),
     m_schedulerType (schedulerType),
@@ -128,15 +128,20 @@
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
   Config::SetDefault ("ns3::RrFfMacScheduler::HarqEnabled", BooleanValue (false));
   Config::SetDefault ("ns3::PfFfMacScheduler::HarqEnabled", BooleanValue (false));
-  
+
 //   lteHelper->SetSchedulerAttribute ("HarqEnabled", BooleanValue (false));
-  
-  
+
+
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::HybridBuildingsPropagationLossModel"));
   lteHelper->SetPathlossModelAttribute ("ShadowSigmaOutdoor", DoubleValue (0.0));
   lteHelper->SetPathlossModelAttribute ("ShadowSigmaIndoor", DoubleValue (0.0));
   lteHelper->SetPathlossModelAttribute ("ShadowSigmaExtWalls", DoubleValue (0.0));
-  
+
+
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
 //   lteHelper->EnableLogComponents ();
 
   // Create Nodes: eNodeB and UE
@@ -160,7 +165,7 @@
   lteHelper->SetSchedulerType (m_schedulerType);
   enbDevs = lteHelper->InstallEnbDevice (enbNodes);
   ueDevs = lteHelper->InstallUeDevice (ueNodes);
-  
+
   // Attach a UE to a eNB
   lteHelper->Attach (ueDevs, enbDevs.Get (0));
 
@@ -168,7 +173,7 @@
   enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
   EpsBearer bearer (q);
   lteHelper->ActivateDataRadioBearer (ueDevs, bearer);
-  
+
 
   Ptr<LteEnbNetDevice> lteEnbDev = enbDevs.Get (0)->GetObject<LteEnbNetDevice> ();
   Ptr<LteEnbPhy> enbPhy = lteEnbDev->GetPhy ();
@@ -184,16 +189,16 @@
   Ptr<LteUePhy> uePhy = lteUeDev->GetPhy ();
   uePhy->SetAttribute ("TxPower", DoubleValue (23.0));
   uePhy->SetAttribute ("NoiseFigure", DoubleValue (9.0));
-  
+
   // need to allow for RRC connection establishment + SRS before enabling traces
   lteHelper->EnableRlcTraces ();
   lteHelper->EnableMacTraces ();
-  double simulationTime = 0.6; 
+  double simulationTime = 0.6;
   double tolerance = 0.1;
-  
+
   uint8_t rnti = 1;
   Ptr<LteEnbNetDevice> enbNetDev = enbDevs.Get (0)->GetObject<LteEnbNetDevice> ();
-  
+
   PointerValue ptrval;
   enbNetDev->GetCcMap()[0]->GetAttribute ("FfMacScheduler", ptrval);
   Ptr<PfFfMacScheduler> pfsched;
@@ -215,7 +220,7 @@
         {
           NS_FATAL_ERROR ("No Pf Scheduler available");
         }
-      
+
       Simulator::Schedule (Seconds (0.2), &PfFfMacScheduler::TransmissionModeConfigurationUpdate, pfsched, rnti, 1);
       Simulator::Schedule (Seconds (0.4), &PfFfMacScheduler::TransmissionModeConfigurationUpdate, pfsched, rnti, 2);
     }
@@ -223,8 +228,8 @@
     {
       NS_FATAL_ERROR ("Scheduler not supported by this test");
     }
-    
-  
+
+
   Ptr<RadioBearerStatsCalculator> rlcStats = lteHelper->GetRlcStats ();
   rlcStats->SetAttribute ("EpochDuration", TimeValue (Seconds (0.1)));
 
diff -Naru a/test/lte-test-mimo.h b/test/lte-test-mimo.h
--- a/test/lte-test-mimo.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-mimo.h	2018-08-03 16:39:02.895957709 +0200
@@ -32,9 +32,9 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief This system test program creates different test cases with a 
- * single eNB and single UE. The traffic is configured to be in saturation 
- * mode. It is checked if the throughput reaches the expected values 
+ * \brief This system test program creates different test cases with a
+ * single eNB and single UE. The traffic is configured to be in saturation
+ * mode. It is checked if the throughput reaches the expected values
  * when MIMO is used.
  */
 class LenaMimoTestCase : public TestCase
@@ -53,7 +53,7 @@
 
 private:
   virtual void DoRun (void);
-  
+
   /**
    * Get RLC buffer sample
    * \param rlcStats Ptr<RadioBearerStatsCalculator>
@@ -61,7 +61,7 @@
    * \param rnti the RNTI
    */
   void GetRlcBufferSample (Ptr<RadioBearerStatsCalculator> rlcStats, uint64_t imsi, uint8_t rnti);
-  
+
   /**
    * Builds the test name string based on provided parameter values
    * \param dist the distance
diff -Naru a/test/lte-test-pathloss-model.cc b/test/lte-test-pathloss-model.cc
--- a/test/lte-test-pathloss-model.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-pathloss-model.cc	2018-08-03 16:39:02.895957709 +0200
@@ -38,6 +38,7 @@
 #include <ns3/lte-ue-net-device.h>
 #include <ns3/lte-enb-net-device.h>
 #include <ns3/lte-ue-rrc.h>
+#include <ns3/lte-helper.h>
 #include <ns3/lte-enb-phy.h>
 #include <ns3/lte-ue-phy.h>
 #include "lte-test-ue-phy.h"
@@ -53,15 +54,16 @@
 
 /**
  * This TestSuite tests the BuildingPathlossModel by reproducing
- * several communication scenarios 
+ * several communication scenarios
  */
 
 
 void
 LteTestPathlossDlSchedCallback (LtePathlossModelSystemTestCase *testcase, std::string path,
-		                        DlSchedulingCallbackInfo dlInfo)
+                             uint32_t frameNo, uint32_t subframeNo, uint16_t rnti,
+                             uint8_t mcsTb1, uint16_t sizeTb1, uint8_t mcsTb2, uint16_t sizeTb2)
 {
-  testcase->DlScheduling (dlInfo);
+  testcase->DlScheduling (frameNo, subframeNo, rnti, mcsTb1, sizeTb1, mcsTb2, sizeTb2);
 }
 
 
@@ -165,7 +167,7 @@
 
 
 
-  
+
 }
 
 static LtePathlossModelTestSuite ltePathlossModelTestSuite;
@@ -180,9 +182,9 @@
 m_mcsIndex (mcsIndex)
 {
   std::ostringstream sstream1, sstream2;
-  sstream1 << " snr=" << snrDb 
+  sstream1 << " snr=" << snrDb
   << " mcs=" << mcsIndex << " distance=" << dist;
-  
+
   NS_LOG_INFO ("Creating LtePathlossModelSystemTestCase: " + sstream1.str ());
 }
 
@@ -207,51 +209,52 @@
 
   // set frequency. This is important because it changes the behavior of the path loss model
   lteHelper->SetEnbDeviceAttribute ("DlEarfcn", UintegerValue (200));
-  lteHelper->SetEnbDeviceAttribute ("UlEarfcn", UintegerValue (18200));
   lteHelper->SetUeDeviceAttribute ("DlEarfcn", UintegerValue (200));
+  // set DL bandwidth. This is important because it changes the value of the noise power in the SINR
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
 
   // remove shadowing component
   lteHelper->SetPathlossModelAttribute ("ShadowSigmaOutdoor", DoubleValue (0.0));
   lteHelper->SetPathlossModelAttribute ("ShadowSigmaIndoor", DoubleValue (0.0));
   lteHelper->SetPathlossModelAttribute ("ShadowSigmaExtWalls", DoubleValue (0.0));
-  
+
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
   NodeContainer ueNodes;
   enbNodes.Create (1);
   ueNodes.Create (1);
   NodeContainer allNodes = NodeContainer ( enbNodes, ueNodes );
-  
+
   // Install Mobility Model
   MobilityHelper mobility;
   mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
   mobility.Install (allNodes);
   BuildingsHelper::Install (allNodes);
 
-  
+
   // Create Devices and install them in the Nodes (eNB and UE)
   NetDeviceContainer enbDevs;
   NetDeviceContainer ueDevs;
   lteHelper->SetSchedulerType ("ns3::RrFfMacScheduler");
   enbDevs = lteHelper->InstallEnbDevice (enbNodes);
   ueDevs = lteHelper->InstallUeDevice (ueNodes);
-  
+
   Ptr<MobilityModel> mm_enb = enbNodes.Get (0)->GetObject<MobilityModel> ();
   mm_enb->SetPosition (Vector (0.0, 0.0, 30.0));
   Ptr<MobilityModel> mm_ue = ueNodes.Get (0)->GetObject<MobilityModel> ();
   mm_ue->SetPosition (Vector (m_distance, 0.0, 1.0));
-  
+
   Ptr<LteEnbNetDevice> lteEnbDev = enbDevs.Get (0)->GetObject<LteEnbNetDevice> ();
   Ptr<LteEnbPhy> enbPhy = lteEnbDev->GetPhy ();
   enbPhy->SetAttribute ("TxPower", DoubleValue (30.0));
   enbPhy->SetAttribute ("NoiseFigure", DoubleValue (5.0));
-  
+
   Ptr<LteUeNetDevice> lteUeDev = ueDevs.Get (0)->GetObject<LteUeNetDevice> ();
   Ptr<LteUePhy> uePhy = lteUeDev->GetPhy ();
   uePhy->SetAttribute ("TxPower", DoubleValue (23.0));
   uePhy->SetAttribute ("NoiseFigure", DoubleValue (9.0));
-  
-  
+
+
   // Attach a UE to a eNB
   lteHelper->Attach (ueDevs, enbDevs.Get (0));
 
@@ -259,7 +262,7 @@
   enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
   EpsBearer bearer (q);
   lteHelper->ActivateDataRadioBearer (ueDevs, bearer);
-  
+
   // Use testing chunk processor in the PHY layer
   // It will be used to test that the SNR is as intended
   //Ptr<LtePhy> uePhy = ueDevs.Get (0)->GetObject<LteUeNetDevice> ()->GetPhy ()->GetObject<LtePhy> ();
@@ -267,13 +270,13 @@
   LteSpectrumValueCatcher sinrCatcher;
   testSinr->AddCallback (MakeCallback (&LteSpectrumValueCatcher::ReportValue, &sinrCatcher));
   uePhy->GetDownlinkSpectrumPhy ()->AddCtrlSinrChunkProcessor (testSinr);
-   
+
 //   Config::Connect ("/NodeList/0/DeviceList/0/LteEnbMac/DlScheduling",
 //                    MakeBoundCallback (&LteTestPathlossDlSchedCallback, this));
-                   
+
   Simulator::Stop (Seconds (0.035));
   Simulator::Run ();
-  
+
   double calculatedSinrDb = 10.0 * std::log10 (sinrCatcher.GetValue ()->operator[] (0));
   NS_LOG_INFO ("Distance " << m_distance << " Calculated SINR " << calculatedSinrDb << " ref " << m_snrDb);
   Simulator::Destroy ();
@@ -282,22 +285,23 @@
 
 
 void
-LtePathlossModelSystemTestCase::DlScheduling (DlSchedulingCallbackInfo dlInfo)
+LtePathlossModelSystemTestCase::DlScheduling (uint32_t frameNo, uint32_t subframeNo, uint16_t rnti,
+                                         uint8_t mcsTb1, uint16_t sizeTb1, uint8_t mcsTb2, uint16_t sizeTb2)
 {
   static bool firstTime = true;
-  
+
   if ( firstTime )
   {
     firstTime = false;
     NS_LOG_INFO ("SNR\tRef_MCS\tCalc_MCS");
   }
-  
-  
+
+
   // need to allow for RRC connection establishment + SRS transmission
   if (Simulator::Now () > MilliSeconds (21))
   {
-    NS_LOG_INFO (m_snrDb << "\t" << m_mcsIndex << "\t" << (uint16_t)dlInfo.mcsTb1);
-    
-    NS_TEST_ASSERT_MSG_EQ ((uint16_t)dlInfo.mcsTb1, m_mcsIndex, "Wrong MCS index");
+    NS_LOG_INFO (m_snrDb << "\t" << m_mcsIndex << "\t" << (uint16_t)mcsTb1);
+
+    NS_TEST_ASSERT_MSG_EQ ((uint16_t)mcsTb1, m_mcsIndex, "Wrong MCS index");
   }
 }
diff -Naru a/test/lte-test-pathloss-model.h b/test/lte-test-pathloss-model.h
--- a/test/lte-test-pathloss-model.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-pathloss-model.h	2018-08-03 16:39:02.895957709 +0200
@@ -48,8 +48,8 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief  Tests that the BuildingPathlossModel works according to 
- * the expected theoretical values. Theoretical reference values 
+ * \brief  Tests that the BuildingPathlossModel works according to
+ * the expected theoretical values. Theoretical reference values
  * are obtained with the octave script src/lte/test/reference/lte_pathloss.m
  */
 class LtePathlossModelSystemTestCase : public TestCase
@@ -66,20 +66,20 @@
     LtePathlossModelSystemTestCase (std::string name, double snrDb, double dist, uint16_t mcsIndex);
     LtePathlossModelSystemTestCase ();
     virtual ~LtePathlossModelSystemTestCase ();
-    
-  /**
-   * \brief DL scheduling function
-   * \param dlInfo the DL info
-   */
-    void DlScheduling (DlSchedulingCallbackInfo dlInfo);
-                       
+
+    /**
+     * \brief DL scheduling function
+     * \param dlInfo the DL info
+     */
+    void DlScheduling (uint32_t frameNo, uint32_t subframeNo, uint16_t rnti,
+                       uint8_t mcsTb1, uint16_t sizeTb1, uint8_t mcsTb2, uint16_t sizeTb2);
+
   private:
     virtual void DoRun (void);
-    
+
     double m_snrDb; ///< the SNR in dB
     double m_distance; ///< the distance
     uint16_t m_mcsIndex; ///< the MCS index
 };
 
 #endif /* LTE_TEST_PATHLOSS_MODEL_H */
-
diff -Naru a/test/lte-test-pf-ff-mac-scheduler.cc b/test/lte-test-pf-ff-mac-scheduler.cc
--- a/test/lte-test-pf-ff-mac-scheduler.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-pf-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -160,14 +160,10 @@
   AddTestCase (new LenaPfFfMacSchedulerTestCase1 (12,20000,35083,12000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaPfFfMacSchedulerTestCase1 (15,20000,28067,9600,errorModel), TestCase::EXTENSIVE);
 
-  // DOWNLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  // UPLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  AddTestCase (new LenaPfFfMacSchedulerTestCase1 (1,100000,0,0,errorModel), TestCase::QUICK);
-
 
   // Test Case 2: fairness check
 
-  std::vector<double> dist;
+  std::vector<uint16_t> dist;
   dist.push_back (0);    // User 0 distance --> MCS 28
   dist.push_back (4800);    // User 1 distance --> MCS 22
   dist.push_back (6000);    // User 2 distance --> MCS 16
@@ -197,14 +193,14 @@
 
 
 std::string 
-LenaPfFfMacSchedulerTestCase1::BuildNameString (uint16_t nUser, double dist)
+LenaPfFfMacSchedulerTestCase1::BuildNameString (uint16_t nUser, uint16_t dist)
 {
   std::ostringstream oss;
   oss << nUser << " UEs, distance " << dist << " m";
   return oss.str ();
 }
 
-LenaPfFfMacSchedulerTestCase1::LenaPfFfMacSchedulerTestCase1 (uint16_t nUser, double dist, double thrRefDl, double thrRefUl, bool errorModelEnabled)
+LenaPfFfMacSchedulerTestCase1::LenaPfFfMacSchedulerTestCase1 (uint16_t nUser, uint16_t dist, double thrRefDl, double thrRefUl, bool errorModelEnabled)
   : TestCase (BuildNameString (nUser, dist)),
     m_nUser (nUser),
     m_dist (dist),
@@ -238,6 +234,10 @@
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
   NodeContainer ueNodes;
@@ -356,11 +356,11 @@
 
 
 std::string 
-LenaPfFfMacSchedulerTestCase2::BuildNameString (uint16_t nUser, std::vector<double> dist)
+LenaPfFfMacSchedulerTestCase2::BuildNameString (uint16_t nUser, std::vector<uint16_t> dist)
 {
   std::ostringstream oss;
   oss << "distances (m) = [ " ;
-  for (std::vector<double>::iterator it = dist.begin (); it != dist.end (); ++it)
+  for (std::vector<uint16_t>::iterator it = dist.begin (); it != dist.end (); ++it)
     {
       oss << *it << " ";
     }
@@ -369,7 +369,7 @@
 }
 
 
-LenaPfFfMacSchedulerTestCase2::LenaPfFfMacSchedulerTestCase2 (std::vector<double> dist, std::vector<uint32_t> estThrPfDl, std::vector<uint32_t> estThrPfUl, bool errorModelEnabled)
+LenaPfFfMacSchedulerTestCase2::LenaPfFfMacSchedulerTestCase2 (std::vector<uint16_t> dist, std::vector<uint32_t> estThrPfDl, std::vector<uint32_t> estThrPfUl, bool errorModelEnabled)
   : TestCase (BuildNameString (dist.size (), dist)),
     m_nUser (dist.size ()),
     m_dist (dist),
@@ -402,6 +402,10 @@
   
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+  
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
   NodeContainer ueNodes;
@@ -446,7 +450,7 @@
       uePhy->SetAttribute ("NoiseFigure", DoubleValue (9.0));
     }
 
-  double statsStartTime = 0.300; // need to allow for RRC connection establishment + SRS
+  double statsStartTime = 0.600; // need to allow for RRC connection establishment + SRS
   double statsDuration = 0.4;
   double tolerance = 0.1;
   Simulator::Stop (Seconds (statsStartTime + statsDuration - 0.000001));
diff -Naru a/test/lte-test-pf-ff-mac-scheduler.h b/test/lte-test-pf-ff-mac-scheduler.h
--- a/test/lte-test-pf-ff-mac-scheduler.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-pf-ff-mac-scheduler.h	2018-08-03 16:39:02.895957709 +0200
@@ -33,14 +33,14 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief This system test program creates different test cases with a single eNB and 
- * several UEs, all having the same Radio Bearer specification. In each test 
- * case, the UEs see the same SINR from the eNB; different test cases are 
- * implemented obtained by using different SINR values and different numbers of 
- * UEs. The test consists on checking that the obtained throughput performance 
- * is equal among users is consistent with the definition of proportional 
- * fair scheduling
- */
+ * \brief This system test program creates different test cases with a single eNB and
+* several UEs, all having the same Radio Bearer specification. In each test
+* case, the UEs see the same SINR from the eNB; different test cases are
+* implemented obtained by using different SINR values and different numbers of
+* UEs. The test consists on checking that the obtained throughput performance
+* is equal among users is consistent with the definition of proportional
+* fair scheduling
+*/
 class LenaPfFfMacSchedulerTestCase1 : public TestCase
 {
 public:
@@ -53,7 +53,7 @@
    * \param thrRefUl the UL throughput reference
    * \param errorModelEnabled if true the error model is enabled
    */
-  LenaPfFfMacSchedulerTestCase1 (uint16_t nUser, double dist, double thrRefDl, double thrRefUl, bool errorModelEnabled);
+  LenaPfFfMacSchedulerTestCase1 (uint16_t nUser, uint16_t dist, double thrRefDl, double thrRefUl, bool errorModelEnabled);
   virtual ~LenaPfFfMacSchedulerTestCase1 ();
 
 private:
@@ -63,10 +63,10 @@
    * \param dist the distnace between nodes
    * \returns the name string
    */
-  static std::string BuildNameString (uint16_t nUser, double dist);
+  static std::string BuildNameString (uint16_t nUser, uint16_t dist);
   virtual void DoRun (void);
   uint16_t m_nUser; ///< number of UE nodes
-  double m_dist; ///< the distance between nodes
+  uint16_t m_dist; ///< the distance between nodes
   double m_thrRefDl; ///< the DL throughput reference
   double m_thrRefUl; ///< the UL throughput reference
   bool m_errorModelEnabled; ///< whether error model is enabled
@@ -90,7 +90,7 @@
    * \param estThrPfUl the estimated UL throughput PF
    * \param errorModelEnabled if true the error model is enabled
    */
-  LenaPfFfMacSchedulerTestCase2 (std::vector<double> dist, std::vector<uint32_t> estThrPfDl, std::vector<uint32_t> estThrPfUl, bool errorModelEnabled);
+  LenaPfFfMacSchedulerTestCase2 (std::vector<uint16_t> dist, std::vector<uint32_t> estThrPfDl, std::vector<uint32_t> estThrPfUl, bool errorModelEnabled);
   virtual ~LenaPfFfMacSchedulerTestCase2 ();
 
 private:
@@ -100,11 +100,11 @@
    * \param dist the distnace between nodes
    * \returns the name string
    */
-  static std::string BuildNameString (uint16_t nUser, std::vector<double> dist);
+  static std::string BuildNameString (uint16_t nUser, std::vector<uint16_t> dist);
   virtual void DoRun (void);
   uint16_t m_nUser; ///< number of UE nodes
-  std::vector<double> m_dist; ///< the distance between nodes
-  std::vector<uint32_t> m_estThrPfDl; ///< the estimated DL throughput 
+  std::vector<uint16_t> m_dist; ///< the distance between nodes
+  std::vector<uint32_t> m_estThrPfDl; ///< the estimated DL throughput
   std::vector<uint32_t> m_estThrPfUl; ///< the estimated UL throughput
   bool m_errorModelEnabled; ///< indicates whether the error model is enabled
 };
diff -Naru a/test/lte-test-phy-error-model.cc b/test/lte-test-phy-error-model.cc
--- a/test/lte-test-phy-error-model.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-phy-error-model.cc	2018-08-03 16:39:02.895957709 +0200
@@ -199,6 +199,10 @@
   lena->SetPathlossModelAttribute ("ShadowSigmaIndoor", DoubleValue (0.0));
   lena->SetPathlossModelAttribute ("ShadowSigmaExtWalls", DoubleValue (0.0));
 
+  // set DL and UL bandwidth
+  lena->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lena->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   // Create Devices and install them in the Nodes (eNB and UE)
   NetDeviceContainer enbDevs;
   NetDeviceContainer ueDevs;
@@ -354,6 +358,10 @@
   lena->SetPathlossModelAttribute ("ShadowSigmaOutdoor", DoubleValue (0.0));
   lena->SetPathlossModelAttribute ("ShadowSigmaIndoor", DoubleValue (0.0));
   lena->SetPathlossModelAttribute ("ShadowSigmaExtWalls", DoubleValue (0.0));
+
+  // set DL and UL bandwidth
+  lena->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lena->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
   
   // Create Devices and install them in the Nodes (eNB and UE)
   NetDeviceContainer enbDevs;
diff -Naru a/test/lte-test-phy-error-model.h b/test/lte-test-phy-error-model.h
--- a/test/lte-test-phy-error-model.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-phy-error-model.h	2018-08-03 16:39:02.895957709 +0200
@@ -33,10 +33,10 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief This system test program creates different test cases with a single eNB and 
- * several UEs, all having the same Radio Bearer specification. In each test 
- * case, the UEs see the same SINR from the eNB; different test cases are 
- * implemented obtained by using different SINR values and different numbers of 
+ * \brief This system test program creates different test cases with a single eNB and
+ * several UEs, all having the same Radio Bearer specification. In each test
+ * case, the UEs see the same SINR from the eNB; different test cases are
+ * implemented obtained by using different SINR values and different numbers of
  * UEs. The test consists on ...
  */
 class LenaDataPhyErrorModelTestCase : public TestCase
@@ -68,7 +68,7 @@
    */
   static std::string BuildNameString (uint16_t nUser, uint16_t dist, uint32_t rngRun);
   uint16_t m_nUser; ///< number of UE nodes
-  double m_dist; ///< the distance between nodes
+  uint16_t m_dist; ///< the distance between nodes
   double m_blerRef; ///< the expected BLER
   uint16_t m_toleranceRxPackets; ///< receive packet tolerance loss
   Time m_statsStartTime; ///< Extra time in the beginning of simulation to allow RRC connection establishment + SRS
@@ -113,7 +113,7 @@
    */
   static std::string BuildNameString (uint16_t nUser, uint16_t dist, uint32_t rngRun);
   uint16_t m_nEnb; ///< the number of ENB nodes
-  double m_dist; ///< the distance between nodes
+  uint16_t m_dist; ///< the distance between nodes
   double m_blerRef; ///< the expected BLER
   uint16_t m_toleranceRxPackets; ///< receive packet tolerance loss
   Time m_statsStartTime; ///< Extra time in the beginning of simulation to allow RRC connection establishment + SRS
diff -Naru a/test/lte-test-pss-ff-mac-scheduler.cc b/test/lte-test-pss-ff-mac-scheduler.cc
--- a/test/lte-test-pss-ff-mac-scheduler.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-pss-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -80,7 +80,7 @@
   // DOWNLINK -> DISTANCE 0 -> MCS 28 -> Itbs 26 (from table 7.1.7.2.1-1 of 36.2    13)
   // Traffic info
   //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
+  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
   // Totol bandwidth: 24 PRB at Itbs 26 -> 2196 -> 2196000 byte/sec
   // 1 user -> 232000 * 1 = 232000 < 2196000 -> throughput = 232000 byte/sec
   // 3 user -> 232000 * 3 = 696000 < 2196000 -> througphut = 232000 byte/sec
@@ -88,86 +88,86 @@
   // 12 user -> 232000 * 12 = 2784000 > 2196000 -> throughput = 2196000 / 12 = 183000 byte/sec
   // UPLINK -> DISTANCE 0 -> MCS 28 -> Itbs 26 (from table 7.1.7.2.1-1 of 36.2    13)
   // 1 user -> 25 PRB at Itbs 26 -> 2292 -> 2292000 > 232000 -> throughput = 232000 bytes/sec
-  // 3 users -> 8 PRB at Itbs 26 -> 749 -> 749000 > 232000 -> throughput = 232000 bytes/sec 
+  // 3 users -> 8 PRB at Itbs 26 -> 749 -> 749000 > 232000 -> throughput = 232000 bytes/sec
   // 6 users -> 4 PRB at Itbs 26 -> 373 -> 373000 > 232000 -> throughput = 232000 bytes/sec
   // 12 users -> 2 PRB at Itbs 26 -> 185 -> 185000 < 232000 -> throughput = 185000 bytes/sec
   AddTestCase (new LenaPssFfMacSchedulerTestCase1 (1,0,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaPssFfMacSchedulerTestCase1 (3,0,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaPssFfMacSchedulerTestCase1 (6,0,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
 
-  //AddTestCase (new LenaPssFfMacSchedulerTestCase1 (12,0,183000,185000,200,1,errorModel));// simulation time = 1.5, otherwise, ul test will fail
+  // //AddTestCase (new LenaPssFfMacSchedulerTestCase1 (12,0,183000,185000,200,1,errorModel));// simulation time = 1.5, otherwise, ul test will fail
 
-  // DOWNLINK - DISTANCE 4800 -> MCS 22 -> Itbs 20 (from table 7.1.7.2.1-1 of 36.213)
-  // Traffic info
-  //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
-  // Totol bandwidth: 24 PRB at Itbs 20 -> 1383 -> 1383000 byte/sec
-  // 1 user -> 903000 * 1 = 232000 < 1383000 -> throughput = 232000 byte/sec
-  // 3 user -> 232000 * 3 = 696000 < 1383000 -> througphut = 232000 byte/sec
-  // 6 user -> 232000 * 6 = 139200 > 1383000 -> throughput = 1383000 / 6 = 230500 byte/sec
-  // 12 user -> 232000 * 12 = 2784000 > 1383000 -> throughput =  1383000 / 12 = 115250 byte/sec
-  // UPLINK - DISTANCE 4800 -> MCS 14 -> Itbs 13 (from table 7.1.7.2.1-1 of 36.213)
-  // 1 user -> 25 PRB at Itbs 13 -> 807 -> 807000 > 232000 -> throughput = 232000 bytes/sec
-  // 3 users -> 8 PRB at Itbs 13 -> 253 -> 253000 > 232000 -> throughput = 232000 bytes/sec
-  // 6 users -> 4 PRB at Itbs 13 -> 125 -> 125000 < 232000 -> throughput = 125000 bytes/sec
-  // after the patch enforcing min 3 PRBs per UE:
-  // 12 users -> 3 PRB at Itbs 13 -> 93  bytes * 8/12 UE/TTI  -> 62000 < 232000 -> throughput = 62000  bytes/sec
+  // // DOWNLINK - DISTANCE 4800 -> MCS 22 -> Itbs 20 (from table 7.1.7.2.1-1 of 36.213)
+  // // Traffic info
+  // //   UDP traffic: payload size = 200 bytes, interval = 1 ms
+  // //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
+  // // Totol bandwidth: 24 PRB at Itbs 20 -> 1383 -> 1383000 byte/sec
+  // // 1 user -> 903000 * 1 = 232000 < 1383000 -> throughput = 232000 byte/sec
+  // // 3 user -> 232000 * 3 = 696000 < 1383000 -> througphut = 232000 byte/sec
+  // // 6 user -> 232000 * 6 = 139200 > 1383000 -> throughput = 1383000 / 6 = 230500 byte/sec
+  // // 12 user -> 232000 * 12 = 2784000 > 1383000 -> throughput =  1383000 / 12 = 115250 byte/sec
+  // // UPLINK - DISTANCE 4800 -> MCS 14 -> Itbs 13 (from table 7.1.7.2.1-1 of 36.213)
+  // // 1 user -> 25 PRB at Itbs 13 -> 807 -> 807000 > 232000 -> throughput = 232000 bytes/sec
+  // // 3 users -> 8 PRB at Itbs 13 -> 253 -> 253000 > 232000 -> throughput = 232000 bytes/sec
+  // // 6 users -> 4 PRB at Itbs 13 -> 125 -> 125000 < 232000 -> throughput = 125000 bytes/sec
+  // // after the patch enforcing min 3 PRBs per UE:
+  // // 12 users -> 3 PRB at Itbs 13 -> 93  bytes * 8/12 UE/TTI  -> 62000 < 232000 -> throughput = 62000  bytes/sec
   AddTestCase (new LenaPssFfMacSchedulerTestCase1 (1,4800,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaPssFfMacSchedulerTestCase1 (3,4800,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaPssFfMacSchedulerTestCase1 (6,4800,230500,125000,200,1,errorModel), TestCase::EXTENSIVE);
   //AddTestCase (new LenaPssFfMacSchedulerTestCase1 (12,4800,115250,62000,200,1,errorModel)); // simulation time = 1.5, otherwise, ul test will fail
 
-  // DOWNLINK - DISTANCE 6000 -> MCS 20 -> Itbs 18 (from table 7.1.7.2.1-1 of 36.213)
-  // Traffic info
-  //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
-  // Totol bandwidth: 24 PRB at Itbs 18 -> 1191 -> 1191000 byte/sec
-  // 1 user -> 903000 * 1 = 232000 < 1191000 -> throughput = 232000 byte/sec
-  // 3 user -> 232000 * 3 = 696000 < 1191000 -> througphut = 232000 byte/sec
-  // 6 user -> 232000 * 6 = 1392000 > 1191000 -> throughput = 1191000 / 6 = 198500 byte/sec
-  // 12 user -> 232000 * 12 = 2784000 > 1191000 -> throughput =  1191000 / 12 = 99250 byte/sec
-
-  // UPLINK - DISTANCE 6000 -> MCS 12 -> Itbs 11 (from table 7.1.7.2.1-1 of 36.213)
-  // 1 user -> 25 PRB at Itbs 11 -> 621 -> 621000 > 232000 -> throughput = 232000 bytes/sec
-  // 3 users -> 8 PRB at Itbs 11 -> 201 -> 201000 < 232000 -> throughput = 201000  bytes/sec
-  // 6 users -> 4 PRB at Itbs 11 -> 97 -> 97000 < 232000 -> throughput = 97000 bytes/sec
-  // after the patch enforcing min 3 PRBs per UE:
-  // 12 users -> 3 PRB at Itbs 11 -> 73 bytes * 8/12 UE/TTI -> 48667 < 232000 -> throughput = 48667 bytes/sec
+  // // DOWNLINK - DISTANCE 6000 -> MCS 20 -> Itbs 18 (from table 7.1.7.2.1-1 of 36.213)
+  // // Traffic info
+  // //   UDP traffic: payload size = 200 bytes, interval = 1 ms
+  // //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
+  // // Totol bandwidth: 24 PRB at Itbs 18 -> 1191 -> 1191000 byte/sec
+  // // 1 user -> 903000 * 1 = 232000 < 1191000 -> throughput = 232000 byte/sec
+  // // 3 user -> 232000 * 3 = 696000 < 1191000 -> througphut = 232000 byte/sec
+  // // 6 user -> 232000 * 6 = 1392000 > 1191000 -> throughput = 1191000 / 6 = 198500 byte/sec
+  // // 12 user -> 232000 * 12 = 2784000 > 1191000 -> throughput =  1191000 / 12 = 99250 byte/sec
+
+  // // UPLINK - DISTANCE 6000 -> MCS 12 -> Itbs 11 (from table 7.1.7.2.1-1 of 36.213)
+  // // 1 user -> 25 PRB at Itbs 11 -> 621 -> 621000 > 232000 -> throughput = 232000 bytes/sec
+  // // 3 users -> 8 PRB at Itbs 11 -> 201 -> 201000 < 232000 -> throughput = 201000  bytes/sec
+  // // 6 users -> 4 PRB at Itbs 11 -> 97 -> 97000 < 232000 -> throughput = 97000 bytes/sec
+  // // after the patch enforcing min 3 PRBs per UE:
+  // // 12 users -> 3 PRB at Itbs 11 -> 73 bytes * 8/12 UE/TTI -> 48667 < 232000 -> throughput = 48667 bytes/sec
   AddTestCase (new LenaPssFfMacSchedulerTestCase1 (1,6000,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaPssFfMacSchedulerTestCase1 (3,6000,232000,201000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaPssFfMacSchedulerTestCase1 (6,6000,198500,97000,200,1,errorModel), TestCase::EXTENSIVE);
   //AddTestCase (new LenaPssFfMacSchedulerTestCase1 (12,6000,99250,48667,200,1, errorModel)); // simulation time = 1.5, otherwise, ul test will fail
 
-  // DOWNLINK - DISTANCE 10000 -> MCS 14 -> Itbs 13 (from table 7.1.7.2.1-1 of 36.213)
-  // Traffic info
-  //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
-  // Totol bandwidth: 24 PRB at Itbs 13 -> 775 -> 775000 byte/sec
-  // 1 user -> 903000 * 1 = 232000 < 775000 -> throughput = 232000 byte/sec
-  // 3 user -> 232000 * 3 = 696000 > 775000 -> througphut = 232000 byte/sec
-  // 6 user -> 232000 * 6 = 139200 > 775000 -> throughput = 775000 / 6 = 129166 byte/sec
-  // 12 user -> 232000 * 12 = 2784000 > 775000 -> throughput =  775000 / 12 = 64583 byte/sec
-  // UPLINK - DISTANCE 10000 -> MCS 8 -> Itbs 8 (from table 7.1.7.2.1-1 of 36.213)
-  // 1 user -> 24 PRB at Itbs 8 -> 437 -> 437000 > 232000 -> throughput = 232000 bytes/sec
-  // 3 users -> 8 PRB at Itbs 8 -> 137 -> 137000 < 232000 -> throughput = 137000 bytes/sec
-  // 6 users -> 4 PRB at Itbs 8 -> 67 -> 67000 < 232000 -> throughput = 67000 bytes/sec
-  // after the patch enforcing min 3 PRBs per UE:
-  // 12 users -> 3 PRB at Itbs 8 -> 49 bytes * 8/12 UE/TTI -> 32667 < 232000 -> throughput = 32667  bytes/sec
+  // // DOWNLINK - DISTANCE 10000 -> MCS 14 -> Itbs 13 (from table 7.1.7.2.1-1 of 36.213)
+  // // Traffic info
+  // //   UDP traffic: payload size = 200 bytes, interval = 1 ms
+  // //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
+  // // Totol bandwidth: 24 PRB at Itbs 13 -> 775 -> 775000 byte/sec
+  // // 1 user -> 903000 * 1 = 232000 < 775000 -> throughput = 232000 byte/sec
+  // // 3 user -> 232000 * 3 = 696000 > 775000 -> througphut = 232000 byte/sec
+  // // 6 user -> 232000 * 6 = 139200 > 775000 -> throughput = 775000 / 6 = 129166 byte/sec
+  // // 12 user -> 232000 * 12 = 2784000 > 775000 -> throughput =  775000 / 12 = 64583 byte/sec
+  // // UPLINK - DISTANCE 10000 -> MCS 8 -> Itbs 8 (from table 7.1.7.2.1-1 of 36.213)
+  // // 1 user -> 24 PRB at Itbs 8 -> 437 -> 437000 > 232000 -> throughput = 232000 bytes/sec
+  // // 3 users -> 8 PRB at Itbs 8 -> 137 -> 137000 < 232000 -> throughput = 137000 bytes/sec
+  // // 6 users -> 4 PRB at Itbs 8 -> 67 -> 67000 < 232000 -> throughput = 67000 bytes/sec
+  // // after the patch enforcing min 3 PRBs per UE:
+  // // 12 users -> 3 PRB at Itbs 8 -> 49 bytes * 8/12 UE/TTI -> 32667 < 232000 -> throughput = 32667  bytes/sec
   AddTestCase (new LenaPssFfMacSchedulerTestCase1 (1,10000,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaPssFfMacSchedulerTestCase1 (3,10000,232000,137000,200,1,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaPssFfMacSchedulerTestCase1 (6,10000,129166,67000,200,1,errorModel), TestCase::EXTENSIVE);
   //AddTestCase (new LenaPssFfMacSchedulerTestCase1 (12,10000,64583,32667,200,1,errorModel));// simulation time = 1.5, otherwise, ul test will fail
 
-  // DOWNLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  // UPLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  AddTestCase (new LenaPssFfMacSchedulerTestCase1 (1,100000,0,0,200,1,errorModel), TestCase::QUICK);
-
-  // Test Case 2: homogeneous flow test in PSS (different distance)
-  // Traffic1 info
-  //   UDP traffic: payload size = 100 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 132000 byte/rate 
-  // Maximum throughput = 4 / ( 1/2196000 + 1/1191000 + 1/1383000 + 1/775000 ) = 1209046 byte/s
-  // 132000 * 4 = 528000 < 1209046 -> estimated throughput in downlink = 132000 byte/sec
+  // // DOWNLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
+  // // UPLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
+  // AddTestCase (new LenaPssFfMacSchedulerTestCase1 (1,100000,0,0,200,1,errorModel), TestCase::QUICK);
+
+  // // Test Case 2: homogeneous flow test in PSS (different distance)
+  // // Traffic1 info
+  // //   UDP traffic: payload size = 100 bytes, interval = 1 ms
+  // //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 132000 byte/rate
+  // // Maximum throughput = 4 / ( 1/2196000 + 1/1191000 + 1/1383000 + 1/775000 ) = 1209046 byte/s
+  // // 132000 * 4 = 528000 < 1209046 -> estimated throughput in downlink = 132000 byte/sec
   std::vector<double> dist1;
   dist1.push_back (0);       // User 0 distance --> MCS 28
   dist1.push_back (4800);    // User 1 distance --> MCS 22
@@ -185,46 +185,46 @@
   estThrPssDl1.push_back (132000); // User 3 estimated TTI throughput from PSS
   AddTestCase (new LenaPssFfMacSchedulerTestCase2 (dist1,estThrPssDl1,packetSize1,1,errorModel), TestCase::QUICK);
 
-  // Traffic2 info
-  //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
-  // Maximum throughput = 4 / ( 1/2196000 + 1/1191000 + 1/1383000 + 1/775000 ) = 1209046 byte/s
-  // 232000 * 4 = 928000 < 1209046 -> estimated throughput in downlink = 928000 / 4 = 230000 byte/sec
-  std::vector<double> dist2;
-  dist2.push_back (0);       // User 0 distance --> MCS 28
-  dist2.push_back (4800);    // User 1 distance --> MCS 22
-  dist2.push_back (6000);    // User 2 distance --> MCS 20
-  dist2.push_back (10000);   // User 3 distance --> MCS 14
-  std::vector<uint16_t> packetSize2;
-  packetSize2.push_back (200);
-  packetSize2.push_back (200);
-  packetSize2.push_back (200);
-  packetSize2.push_back (200);
-  std::vector<uint32_t> estThrPssDl2;
-  estThrPssDl2.push_back (230000); // User 0 estimated TTI throughput from PSS
-  estThrPssDl2.push_back (230000); // User 1 estimated TTI throughput from PSS
-  estThrPssDl2.push_back (230000); // User 2 estimated TTI throughput from PSS
-  estThrPssDl2.push_back (230000); // User 3 estimated TTI throughput from PSS
-  AddTestCase (new LenaPssFfMacSchedulerTestCase2 (dist2,estThrPssDl2,packetSize2,1,errorModel), TestCase::QUICK);
-
-  // Test Case 3: heterogeneous flow test in PSS
-  //   UDP traffic: payload size = [100,200,300] bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> [132000, 232000, 332000] byte/rate
-  // Maximum throughput = 3 / ( 1/2196000 + 1/1191000 + 1/1383000) = 1486569 byte/s
-  // 132000 + 232000 + 332000 = 696000 < 1486569 -> estimated throughput in downlink = [132000, 232000, 332000] byte/sec
-  std::vector<double> dist3;
-  dist3.push_back (0);    // User 0 distance --> MCS 28
-  dist3.push_back (4800);    // User 1 distance --> MCS 22
-  dist3.push_back (6000);    // User 2 distance --> MCS 20
-  std::vector<uint16_t> packetSize3;
-  packetSize3.push_back (100);
-  packetSize3.push_back (200);
-  packetSize3.push_back (300);
-  std::vector<uint32_t> estThrPssDl3;
-  estThrPssDl3.push_back (132000); // User 0 estimated TTI throughput from PSS
-  estThrPssDl3.push_back (232000); // User 1 estimated TTI throughput from PSS
-  estThrPssDl3.push_back (332000); // User 2 estimated TTI throughput from PSS
-  AddTestCase (new LenaPssFfMacSchedulerTestCase2 (dist3,estThrPssDl3,packetSize3,1,errorModel), TestCase::QUICK);
+  // // Traffic2 info
+  // //   UDP traffic: payload size = 200 bytes, interval = 1 ms
+  // //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
+  // // Maximum throughput = 4 / ( 1/2196000 + 1/1191000 + 1/1383000 + 1/775000 ) = 1209046 byte/s
+  // // 232000 * 4 = 928000 < 1209046 -> estimated throughput in downlink = 928000 / 4 = 230000 byte/sec
+  // std::vector<double> dist2;
+  // dist2.push_back (0);       // User 0 distance --> MCS 28
+  // dist2.push_back (4800);    // User 1 distance --> MCS 22
+  // dist2.push_back (6000);    // User 2 distance --> MCS 20
+  // dist2.push_back (10000);   // User 3 distance --> MCS 14
+  // std::vector<uint16_t> packetSize2;
+  // packetSize2.push_back (200);
+  // packetSize2.push_back (200);
+  // packetSize2.push_back (200);
+  // packetSize2.push_back (200);
+  // std::vector<uint32_t> estThrPssDl2;
+  // estThrPssDl2.push_back (230000); // User 0 estimated TTI throughput from PSS
+  // estThrPssDl2.push_back (230000); // User 1 estimated TTI throughput from PSS
+  // estThrPssDl2.push_back (230000); // User 2 estimated TTI throughput from PSS
+  // estThrPssDl2.push_back (230000); // User 3 estimated TTI throughput from PSS
+  // AddTestCase (new LenaPssFfMacSchedulerTestCase2 (dist2,estThrPssDl2,packetSize2,1,errorModel), TestCase::QUICK);
+
+  // // Test Case 3: heterogeneous flow test in PSS
+  // //   UDP traffic: payload size = [100,200,300] bytes, interval = 1 ms
+  // //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> [132000, 232000, 332000] byte/rate
+  // // Maximum throughput = 3 / ( 1/2196000 + 1/1191000 + 1/1383000) = 1486569 byte/s
+  // // 132000 + 232000 + 332000 = 696000 < 1486569 -> estimated throughput in downlink = [132000, 232000, 332000] byte/sec
+  // std::vector<double> dist3;
+  // dist3.push_back (0);    // User 0 distance --> MCS 28
+  // dist3.push_back (4800);    // User 1 distance --> MCS 22
+  // dist3.push_back (6000);    // User 2 distance --> MCS 20
+  // std::vector<uint16_t> packetSize3;
+  // packetSize3.push_back (100);
+  // packetSize3.push_back (200);
+  // packetSize3.push_back (300);
+  // std::vector<uint32_t> estThrPssDl3;
+  // estThrPssDl3.push_back (132000); // User 0 estimated TTI throughput from PSS
+  // estThrPssDl3.push_back (232000); // User 1 estimated TTI throughput from PSS
+  // estThrPssDl3.push_back (332000); // User 2 estimated TTI throughput from PSS
+  // AddTestCase (new LenaPssFfMacSchedulerTestCase2 (dist3,estThrPssDl3,packetSize3,1,errorModel), TestCase::QUICK);
 
 }
 
@@ -233,7 +233,7 @@
 // --------------- T E S T - C A S E   # 1 ------------------------------
 
 
-std::string 
+std::string
 LenaPssFfMacSchedulerTestCase1::BuildNameString (uint16_t nUser, double dist)
 {
   std::ostringstream oss;
@@ -311,9 +311,11 @@
 
 //   LogComponentDisableAll (LOG_LEVEL_ALL);
   //LogComponentEnable ("LenaTestPssFfMacScheduler", LOG_LEVEL_ALL);
-   
-  lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
+  lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
   NodeContainer ueNodes;
@@ -377,10 +379,10 @@
       qos.gbrUl = (m_packetSize + 32) * (1000 / m_interval) * 8;
       qos.mbrDl = 0;
       qos.mbrUl = 0;
-      
+
       enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
       EpsBearer bearer (q, qos);
-      lteHelper->ActivateDedicatedEpsBearer (ueDevice, bearer, EpcTft::Default ());  
+      lteHelper->ActivateDedicatedEpsBearer (ueDevice, bearer, EpcTft::Default ());
     }
 
   // Install downlink and uplink applications
@@ -478,7 +480,7 @@
 // --------------- T E S T - C A S E   # 2 ------------------------------
 
 
-std::string 
+std::string
 LenaPssFfMacSchedulerTestCase2::BuildNameString (uint16_t nUser, std::vector<double> dist)
 {
   std::ostringstream oss;
@@ -519,6 +521,7 @@
 
   Config::SetDefault ("ns3::LteHelper::UseIdealRrc", BooleanValue (true));
 
+  Config::SetDefault ("ns3::PointToPointEpcHelper::S1apLinkDelay", TimeValue(Seconds(0)));
 
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
   Ptr<PointToPointEpcHelper>  epcHelper = CreateObject<PointToPointEpcHelper> ();
@@ -552,8 +555,11 @@
 
 //   LogComponentDisableAll (LOG_LEVEL_ALL);
   //LogComponentEnable ("LenaTestPssFfMacScheduler", LOG_LEVEL_ALL);
-   
+
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
+    // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
 
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
@@ -618,10 +624,10 @@
       qos.gbrUl = (m_packetSize.at (u) + 32) * (1000 / m_interval) * 8;
       qos.mbrDl = qos.gbrDl;
       qos.mbrUl = qos.gbrUl;
-  
+
       enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
       EpsBearer bearer (q, qos);
-      lteHelper->ActivateDedicatedEpsBearer (ueDevice, bearer, EpcTft::Default ());  
+      lteHelper->ActivateDedicatedEpsBearer (ueDevice, bearer, EpcTft::Default ());
     }
 
 
@@ -654,9 +660,9 @@
    }
 
   serverApps.Start (Seconds (0.030));
-  clientApps.Start (Seconds (0.030));
+  clientApps.Start (Seconds (0.50));
 
-  double statsStartTime = 0.04; // need to allow for RRC connection establishment + SRS
+  double statsStartTime = 0.6; // need to allow for RRC connection establishment + SRS
   double statsDuration = 0.5;
   double tolerance = 0.1;
   Simulator::Stop (Seconds (statsStartTime + statsDuration - 0.0001));
diff -Naru a/test/lte-test-rlc-am-e2e.h b/test/lte-test-rlc-am-e2e.h
--- a/test/lte-test-rlc-am-e2e.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-rlc-am-e2e.h	2018-08-03 16:39:02.895957709 +0200
@@ -45,7 +45,7 @@
  * \ingroup tests
  *
  * Test cases used for the test suite lte-rlc-am-e2e. See the testing section of
- * the LTE module documentation for details.  
+ * the LTE module documentation for details.
  */
 class LteRlcAmE2eTestCase : public TestCase
 {
@@ -58,7 +58,7 @@
    * \param losses the error rate
    * \param bulkSduArrival true if bulk SDU arrival
    */
-    LteRlcAmE2eTestCase (std::string name, uint32_t seed, double losses, bool bulkSduArrival);
+  LteRlcAmE2eTestCase (std::string name, uint32_t seed, double losses, bool bulkSduArrival);
     LteRlcAmE2eTestCase ();
     virtual ~LteRlcAmE2eTestCase ();
 
diff -Naru a/test/lte-test-rlc-am-transmitter.h b/test/lte-test-rlc-am-transmitter.h
--- a/test/lte-test-rlc-am-transmitter.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-rlc-am-transmitter.h	2018-08-03 16:39:02.895957709 +0200
@@ -50,9 +50,9 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test case used by LteRlcAmTransmitterOneSduTestCase to create topology 
- * and to implement functionalities and check if data received corresponds to 
- * data sent. 
+ * \brief Test case used by LteRlcAmTransmitterOneSduTestCase to create topology
+ * and to implement functionalities and check if data received corresponds to
+ * data sent.
  */
 class LteRlcAmTransmitterTestCase : public TestCase
 {
@@ -95,7 +95,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test 4.1.1.1 Test that SDU transmitted at PDCP corresponds to PDU 
+ * \brief Test 4.1.1.1 Test that SDU transmitted at PDCP corresponds to PDU
  * received by MAC.
  */
 class LteRlcAmTransmitterOneSduTestCase : public LteRlcAmTransmitterTestCase
@@ -119,7 +119,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test 4.1.1.2 Test the correct functionality of the Segmentation. 
+ * \brief Test 4.1.1.2 Test the correct functionality of the Segmentation.
  * Test check that single SDU is properly segmented to n PDUs.
  */
 class LteRlcAmTransmitterSegmentationTestCase : public LteRlcAmTransmitterTestCase
@@ -167,7 +167,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test 4.1.1.4 Test checks functionality of Report Buffer Status by 
+ * \brief Test 4.1.1.4 Test checks functionality of Report Buffer Status by
  * testing primitive parameters.
  */
 class LteRlcAmTransmitterReportBufferStatusTestCase : public LteRlcAmTransmitterTestCase
diff -Naru a/test/lte-test-rlc-um-transmitter.h b/test/lte-test-rlc-um-transmitter.h
--- a/test/lte-test-rlc-um-transmitter.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-rlc-um-transmitter.h	2018-08-03 16:39:02.895957709 +0200
@@ -49,9 +49,9 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test case used by LteRlcUmTransmitterOneSduTestCase to create topology 
- * and to implement functionalities and check if data received corresponds to 
- * data sent. 
+ * \brief Test case used by LteRlcUmTransmitterOneSduTestCase to create topology
+ * and to implement functionalities and check if data received corresponds to
+ * data sent.
  */
 class LteRlcUmTransmitterTestCase : public TestCase
 {
diff -Naru a/test/lte-test-rr-ff-mac-scheduler.cc b/test/lte-test-rr-ff-mac-scheduler.cc
--- a/test/lte-test-rr-ff-mac-scheduler.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-rr-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -147,23 +147,20 @@
   AddTestCase (new LenaRrFfMacSchedulerTestCase (12,20000,32000,12000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaRrFfMacSchedulerTestCase (15,20000,25600,9600,errorModel), TestCase::EXTENSIVE);
 
-  // DOWNLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  // UPLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  AddTestCase (new LenaRrFfMacSchedulerTestCase (1,100000,0,0,errorModel), TestCase::QUICK);
 }
 
 static LenaTestRrFfMacSchedulerSuite lenaTestRrFfMacSchedulerSuite;
 
 std::string 
-LenaRrFfMacSchedulerTestCase::BuildNameString (uint16_t nUser, double dist)
+LenaRrFfMacSchedulerTestCase::BuildNameString (uint16_t nUser, uint16_t dist)
 {
   std::ostringstream oss;
   oss << nUser << " UEs, distance " << dist << " m";
   return oss.str ();
 }
 
-LenaRrFfMacSchedulerTestCase::LenaRrFfMacSchedulerTestCase (uint16_t nUser, double dist, double thrRefDl, double thrRefUl, bool errorModelEnabled)
-  : TestCase (BuildNameString (nUser, dist)),              
+LenaRrFfMacSchedulerTestCase::LenaRrFfMacSchedulerTestCase (uint16_t nUser, uint16_t dist, double thrRefDl, double thrRefUl, bool errorModelEnabled)
+  : TestCase (BuildNameString (nUser, dist)),
     m_nUser (nUser),
     m_dist (dist),
     m_thrRefDl (thrRefDl),
@@ -198,9 +195,13 @@
    */
 
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
-  
+
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
   NodeContainer ueNodes;
@@ -228,8 +229,8 @@
   enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
   EpsBearer bearer (q);
   lteHelper->ActivateDataRadioBearer (ueDevs, bearer);
-  
- 
+
+
   Ptr<LteEnbNetDevice> lteEnbDev = enbDevs.Get (0)->GetObject<LteEnbNetDevice> ();
   Ptr<LteEnbPhy> enbPhy = lteEnbDev->GetPhy ();
   enbPhy->SetAttribute ("TxPower", DoubleValue (30.0));
diff -Naru a/test/lte-test-rr-ff-mac-scheduler.h b/test/lte-test-rr-ff-mac-scheduler.h
--- a/test/lte-test-rr-ff-mac-scheduler.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-rr-ff-mac-scheduler.h	2018-08-03 16:39:02.895957709 +0200
@@ -32,13 +32,13 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief This system test program creates different test cases with a single eNB and 
- * This system test program creates different test cases with a single eNB and 
- * several UEs, all having the same Radio Bearer specification. In each test 
- * case, the UEs see the same SINR from the eNB; different test cases are 
- * implemented obtained by using different SINR values and different numbers of 
- * UEs. The test consists on checking that the obtained throughput performance 
- * is equal among users and matches a reference throughput value within a given 
+ * \brief This system test program creates different test cases with a single eNB and
+ * This system test program creates different test cases with a single eNB and
+ * several UEs, all having the same Radio Bearer specification. In each test
+ * case, the UEs see the same SINR from the eNB; different test cases are
+ * implemented obtained by using different SINR values and different numbers of
+ * UEs. The test consists on checking that the obtained throughput performance
+ * is equal among users and matches a reference throughput value within a given
  * tolerance.
  */
 class LenaRrFfMacSchedulerTestCase : public TestCase
@@ -53,7 +53,7 @@
    * \param thrRefUl the UL throughput reference
    * \param errorModelEnabled if true the error model is enabled
    */
-  LenaRrFfMacSchedulerTestCase (uint16_t nUser, double dist, double thrRefDl, double thrRefUl, bool errorModelEnabled);
+  LenaRrFfMacSchedulerTestCase (uint16_t nUser, uint16_t dist, double thrRefDl, double thrRefUl, bool errorModelEnabled);
   virtual ~LenaRrFfMacSchedulerTestCase ();
 
 private:
@@ -64,9 +64,9 @@
    * \param dist the distance between UE nodes and eNodeB
    * \returns the name string
    */
-  static std::string BuildNameString (uint16_t nUser, double dist);
+  static std::string BuildNameString (uint16_t nUser, uint16_t dist);
   uint16_t m_nUser; ///< number of UE nodes
-  double m_dist; ///< the distance between nodes
+  uint16_t m_dist; ///< the distance between nodes
   double m_thrRefDl; ///< the DL throughput reference
   double m_thrRefUl; ///< the UL throughput reference
   bool m_errorModelEnabled; ///< indicates whether the error model is enabled
diff -Naru a/test/lte-test-run-time.pl b/test/lte-test-run-time.pl
--- a/test/lte-test-run-time.pl	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-run-time.pl	2018-08-03 16:39:02.895957709 +0200
@@ -32,10 +32,10 @@
             my $timeStats = Statistics::Descriptive::Full->new();
             for ( my $iteration = 0 ; $iteration < $nIterations ; $iteration++ )
             {
-               $launch = "time -f \"real%E\" ./waf --run \'lena-profiling --simTime=$time --nUe=$ue --nEnb=$enb --nFloors=$floor\'";
+               $launch = "time ./waf --run \'lena-profiling --simTime=$time --nUe=$ue --nEnb=$enb --nFloors=$floor\'";
                print "$launch\n";
                capture { system($launch ) } \$out, \$err;
-               $err =~ /real(.+):(.+)/;
+               $err =~ /real(.+)m(.+)s/;
                my $minutes = $1;
                my $seconds = $minutes * 60 + $2;
                $timeStats->add_data($seconds);
diff -Naru a/test/lte-test-secondary-cell-selection.cc b/test/lte-test-secondary-cell-selection.cc
--- a/test/lte-test-secondary-cell-selection.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-secondary-cell-selection.cc	2018-08-03 16:39:02.895957709 +0200
@@ -93,6 +93,8 @@
   NS_LOG_FUNCTION (this << GetName ());
 
   Config::SetGlobal ("RngRun", UintegerValue (m_rngRun));
+  Config::SetDefault ("ns3::LteEnbNetDevice::UlBandwidth", UintegerValue (25));
+  Config::SetDefault ("ns3::LteEnbNetDevice::DlBandwidth", UintegerValue (25));
 
   // Create helpers.
   auto lteHelper = CreateObject<LteHelper> ();
diff -Naru a/test/lte-test-spectrum-value-helper.cc b/test/lte-test-spectrum-value-helper.cc
--- a/test/lte-test-spectrum-value-helper.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-spectrum-value-helper.cc	2018-08-03 16:39:02.895957709 +0200
@@ -34,7 +34,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test checks if lte spectrum model is generated properly. Different 
+ * \brief Test checks if lte spectrum model is generated properly. Different
  * test cases are configured by defining different frequency and banwidth.
  */
 class LteSpectrumModelTestCase : public TestCase
@@ -71,7 +71,7 @@
 {
 }
 
-void 
+void
 LteSpectrumModelTestCase::DoRun (void)
 {
   NS_LOG_FUNCTION (this);
@@ -85,7 +85,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test that the function for creation of LTE noise power spectral 
+ * \brief Test that the function for creation of LTE noise power spectral
  * density is working properly.
  */
 class LteNoisePsdTestCase : public TestCase
@@ -123,7 +123,7 @@
 {
 }
 
-void 
+void
 LteNoisePsdTestCase::DoRun (void)
 {
   NS_TEST_ASSERT_MSG_EQ (m_actual->GetSpectrumModelUid (), m_expected->GetSpectrumModelUid (), "SpectrumModel UID mismatch");
@@ -138,7 +138,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test that the funtcion for the creation of the Lte transmission power 
+ * \brief Test that the funtcion for the creation of the Lte transmission power
  * spectral density is working as expected.
  */
 class LteTxPsdTestCase : public TestCase
@@ -177,7 +177,7 @@
 {
 }
 
-void 
+void
 LteTxPsdTestCase::DoRun (void)
 {
   NS_TEST_ASSERT_MSG_EQ (m_actual->GetSpectrumModelUid (), m_expected->GetSpectrumModelUid (), "SpectrumModel UID mismatch");
@@ -191,7 +191,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test suite for LteSpectrumValueHelper. Test suite is 
+ * \brief Test suite for LteSpectrumValueHelper. Test suite is
  * checking different functionalities of LteSpectrumValueHelper.
  */
 class LteSpectrumValueHelperTestSuite : public TestSuite
@@ -210,7 +210,7 @@
 //   LogComponentEnable ("LteSpectrumValueHelperTestSuite", logLevel);
 //   LogComponentEnable ("LteSpectrumValueHelper", logLevel);
 
- 
+
   NS_LOG_INFO ("Creating LteSpectrumValueHelperTestSuite");
 
 
diff -Naru a/test/lte-test-tdbet-ff-mac-scheduler.cc b/test/lte-test-tdbet-ff-mac-scheduler.cc
--- a/test/lte-test-tdbet-ff-mac-scheduler.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-tdbet-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -86,7 +86,7 @@
   // 1 user -> 24 PRB at Itbs 20 -> 1383 -> 1383000 bytes/sec
   // 3 users -> 1383000 among 3 users ->461000  bytes/sec
   // 6 users -> 1383000 among 6 users ->230500  bytes/sec
-  // 12 users -> 1383000 among 12 users ->115250  bytes/sec 
+  // 12 users -> 1383000 among 12 users ->115250  bytes/sec
   // UPLINK - DISTANCE 4800 -> MCS 14 -> Itbs 13 (from table 7.1.7.2.1-1 of 36.213)
   // 1 user -> 25 PRB at Itbs 13 -> 807 -> 807000 bytes/sec
   // 3 users -> 8 PRB at Itbs 13 -> 253 -> 253000 bytes/sec
@@ -112,7 +112,7 @@
   AddTestCase (new LenaTdBetFfMacSchedulerTestCase1 (3,6000,397000,201000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaTdBetFfMacSchedulerTestCase1 (6,6000,198500,97000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaTdBetFfMacSchedulerTestCase1 (12,6000,99250,48667,errorModel), TestCase::EXTENSIVE);
-  
+
   // DOWNLINK - DISTANCE 10000 -> MCS 14 -> Itbs 13 (from table 7.1.7.2.1-1 of 36.213)
   // 1 user -> 24 PRB at Itbs 13 -> 775 -> 775000 byte/sec
   // 3 users -> 775000 among 3 users -> 258333  bytes/sec
@@ -133,7 +133,7 @@
   // 1 user -> 24 PRB at Itbs 8 -> 421 -> 421000 bytes/sec
   // 3 users -> 421000 among 3 users ->140333  bytes/sec
   // 6 users -> 421000 among 6 users ->70166  bytes/sec
-  // 12 users -> 421000 among 12 users ->35083  bytes/sec 
+  // 12 users -> 421000 among 12 users ->35083  bytes/sec
   // UPLINK - DISTANCE 20000 -> MCS 2 -> Itbs 2 (from table 7.1.7.2.1-1 of 36.213)
   // 1 user -> 25 PRB at Itbs 2 -> 137 -> 137000 bytes/sec
   // 3 users -> 8 PRB at Itbs 2 -> 41 -> 41000 bytes/sec
@@ -178,7 +178,7 @@
 // --------------- T E S T - C A S E   # 1 ------------------------------
 
 
-std::string 
+std::string
 LenaTdBetFfMacSchedulerTestCase1::BuildNameString (uint16_t nUser, double dist)
 {
   std::ostringstream oss;
@@ -219,9 +219,13 @@
    */
 
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
-  
+
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
   NodeContainer ueNodes;
@@ -297,8 +301,8 @@
     }
   /**
   * Check that the assignation is done in a "TD blind equal throughput" manner among users
-  * with equal SINRs: the bandwidth should be distributed according to the 
-  * ratio of the estimated throughput per TTI of each user; therefore equally 
+  * with equal SINRs: the bandwidth should be distributed according to the
+  * ratio of the estimated throughput per TTI of each user; therefore equally
   * partitioning the whole bandwidth achievable from a single users in a TTI
   */
   for (int i = 0; i < m_nUser; i++)
@@ -322,8 +326,8 @@
     }
   /**
   * Check that the assignation is done in a "TD blind equal throughput" manner among users
-  * with equal SINRs: the bandwidth should be distributed according to the 
-  * ratio of the estimated throughput per TTI of each user; therefore equally 
+  * with equal SINRs: the bandwidth should be distributed according to the
+  * ratio of the estimated throughput per TTI of each user; therefore equally
   * partitioning the whole bandwidth achievable from a single users in a TTI
   */
   for (int i = 0; i < m_nUser; i++)
@@ -339,7 +343,7 @@
 // --------------- T E S T - C A S E   # 2 ------------------------------
 
 
-std::string 
+std::string
 LenaTdBetFfMacSchedulerTestCase2::BuildNameString (uint16_t nUser, std::vector<double> dist)
 {
   std::ostringstream oss;
@@ -385,9 +389,13 @@
   */
 
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
-  
+
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
   NodeContainer ueNodes;
@@ -462,7 +470,7 @@
       estTotalThr += 1 / m_achievableRateDl.at (i);
       NS_LOG_INFO ("\tUser " << i << " dist " << m_dist.at (i) << " imsi " << imsi << " bytes rxed " << (double)dlDataRxed.at (i) << "  thr " << (double)dlDataRxed.at (i) / statsDuration << " ref " << m_nUser);
     }
-    
+
   estTotalThr = m_nUser * (1 / estTotalThr);
   estUeThr = estTotalThr / m_nUser;
   /**
diff -Naru a/test/lte-test-tdbet-ff-mac-scheduler.h b/test/lte-test-tdbet-ff-mac-scheduler.h
--- a/test/lte-test-tdbet-ff-mac-scheduler.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-tdbet-ff-mac-scheduler.h	2018-08-03 16:39:02.895957709 +0200
@@ -35,13 +35,13 @@
  * \ingroup tests
  *
  * \brief This system test program creates different test cases with a single eNB and 
- * several UEs, all having the same Radio Bearer specification. In each test 
- * case, the UEs see the same SINR from the eNB; different test cases are 
- * implemented obtained by using different SINR values and different numbers of 
- * UEs. The test consists on checking that the obtained throughput performance 
- * is equal among users is consistent with the definition of blind equal throughput
- * scheduling
- */
+* several UEs, all having the same Radio Bearer specification. In each test
+* case, the UEs see the same SINR from the eNB; different test cases are
+* implemented obtained by using different SINR values and different numbers of
+* UEs. The test consists on checking that the obtained throughput performance
+* is equal among users is consistent with the definition of blind equal throughput
+* scheduling
+*/
 class LenaTdBetFfMacSchedulerTestCase1 : public TestCase
 {
 public:
diff -Naru a/test/lte-test-tdmt-ff-mac-scheduler.cc b/test/lte-test-tdmt-ff-mac-scheduler.cc
--- a/test/lte-test-tdmt-ff-mac-scheduler.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-tdmt-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -49,6 +49,9 @@
 #include <ns3/boolean.h>
 #include <ns3/enum.h>
 
+
+#include "lte-test-tdmt-ff-mac-scheduler.h"
+
 using namespace ns3;
 
 NS_LOG_COMPONENT_DEFINE ("LenaTestTdMtFfMacScheduler");
@@ -79,7 +82,7 @@
   AddTestCase (new LenaTdMtFfMacSchedulerTestCase (3,0,2196000,749000,errorModel), TestCase::QUICK);
   AddTestCase (new LenaTdMtFfMacSchedulerTestCase (6,0,2196000,373000, errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaTdMtFfMacSchedulerTestCase (12,0,2196000,184670, errorModel), TestCase::EXTENSIVE);
-  
+
   // DOWNLINK - DISTANCE 4800 -> MCS 22 -> Itbs 20 (from table 7.1.7.2.1-1 of 36.213)
   // 1 user -> 24 PRB at Itbs 20 -> 1383 -> 1383000 bytes/sec for one UE; 0 bytes/sec for other UEs
   // 3 users -> 1383000 among 3 users -> 1383000 bytes/sec for one UE; 0 bytes/sec for other UEs
@@ -127,7 +130,7 @@
   AddTestCase (new LenaTdMtFfMacSchedulerTestCase (3,10000,775000,137000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaTdMtFfMacSchedulerTestCase (6,10000,775000,67000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaTdMtFfMacSchedulerTestCase (12,10000,775000,32667,errorModel), TestCase::EXTENSIVE);
- 
+
   // DONWLINK - DISTANCE 20000 -> MCS 8 -> Itbs 8 (from table 7.1.7.2.1-1 of 36.213)
   // 1 user -> 24 PRB at Itbs 8 -> 421 -> 421000 bytes/sec for one UE; 0 bytes/sec for other UEs
   // 3 users -> 421000 among 3 users -> 421000 bytes/sec for one UE; 0 bytes/sec for other UEs
@@ -144,9 +147,6 @@
   AddTestCase (new LenaTdMtFfMacSchedulerTestCase (6,20000,421000,22000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaTdMtFfMacSchedulerTestCase (12,20000,421000,12000,errorModel), TestCase::EXTENSIVE);
 
-  // DOWNLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  // UPLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  AddTestCase (new LenaTdMtFfMacSchedulerTestCase (1,100000,0,0,errorModel), TestCase::QUICK);
 }
 
 static LenaTestTdMtFfMacSchedulerSuite lenaTestTdMtFfMacSchedulerSuite;
@@ -154,15 +154,15 @@
 
 // --------------- T E S T - C A S E ------------------------------
 
-std::string 
-LenaTdMtFfMacSchedulerTestCase::BuildNameString (uint16_t nUser, double dist)
+std::string
+LenaTdMtFfMacSchedulerTestCase::BuildNameString (uint16_t nUser, uint16_t dist)
 {
   std::ostringstream oss;
   oss << nUser << " UEs, distance " << dist << " m";
   return oss.str ();
 }
 
-LenaTdMtFfMacSchedulerTestCase::LenaTdMtFfMacSchedulerTestCase (uint16_t nUser, double dist, double thrRefDl, double thrRefUl, bool errorModelEnabled)
+LenaTdMtFfMacSchedulerTestCase::LenaTdMtFfMacSchedulerTestCase (uint16_t nUser, uint16_t dist, double thrRefDl, double thrRefUl, bool errorModelEnabled)
   : TestCase (BuildNameString (nUser, dist)),
     m_nUser (nUser),
     m_dist (dist),
@@ -201,6 +201,10 @@
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
   NodeContainer ueNodes;
@@ -228,8 +232,8 @@
   enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
   EpsBearer bearer (q);
   lteHelper->ActivateDataRadioBearer (ueDevs, bearer);
-  
- 
+
+
   Ptr<LteEnbNetDevice> lteEnbDev = enbDevs.Get (0)->GetObject<LteEnbNetDevice> ();
   Ptr<LteEnbPhy> enbPhy = lteEnbDev->GetPhy ();
   enbPhy->SetAttribute ("TxPower", DoubleValue (30.0));
@@ -313,8 +317,8 @@
     }
   /**
   * Check that the assignation is done in a "proportional fair" manner among users
-  * with equal SINRs: the bandwidth should be distributed according to the 
-  * ratio of the estimated throughput per TTI of each user; therefore equally 
+  * with equal SINRs: the bandwidth should be distributed according to the
+  * ratio of the estimated throughput per TTI of each user; therefore equally
   * partitioning the whole bandwidth achievable from a single users in a TTI
   */
   for (int i = 0; i < m_nUser; i++)
@@ -324,4 +328,3 @@
   Simulator::Destroy ();
 
 }
-
diff -Naru a/test/lte-test-tdmt-ff-mac-scheduler.h b/test/lte-test-tdmt-ff-mac-scheduler.h
--- a/test/lte-test-tdmt-ff-mac-scheduler.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-tdmt-ff-mac-scheduler.h	2018-08-03 16:39:02.895957709 +0200
@@ -34,14 +34,14 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief This system test program creates different test cases with a single eNB and 
- * several UEs, all having the same Radio Bearer specification. In each test 
- * case, the UEs see the same SINR from the eNB; different test cases are 
- * implemented obtained by using different SINR values and different numbers of 
- * UEs. The test consists on checking that the obtained throughput performance 
- * is consistent with the definition of maximum throughput
- * scheduling
- */
+ * \brief This system test program creates different test cases with a single eNB and
+* several UEs, all having the same Radio Bearer specification. In each test
+* case, the UEs see the same SINR from the eNB; different test cases are
+* implemented obtained by using different SINR values and different numbers of
+* UEs. The test consists on checking that the obtained throughput performance
+* is consistent with the definition of maximum throughput
+* scheduling
+*/
 class LenaTdMtFfMacSchedulerTestCase : public TestCase
 {
 public:
@@ -54,7 +54,7 @@
    * \param thrRefUl the UL throughput reference
    * \param errorModelEnabled if true the error model is enabled
    */
-  LenaTdMtFfMacSchedulerTestCase (uint16_t nUser, double dist, double thrRefDl, double thrRefUl,bool errorModelEnabled);
+  LenaTdMtFfMacSchedulerTestCase (uint16_t nUser, uint16_t dist, double thrRefDl, double thrRefUl,bool errorModelEnabled);
   virtual ~LenaTdMtFfMacSchedulerTestCase ();
 
 private:
@@ -64,10 +64,10 @@
    * \param dist the distnace between nodes
    * \returns the name string
    */
-  static std::string BuildNameString (uint16_t nUser, double dist);
+  static std::string BuildNameString (uint16_t nUser, uint16_t dist);
   virtual void DoRun (void);
   uint16_t m_nUser; ///< number of UE nodes
-  double m_dist; ///< the distance between nodes
+  uint16_t m_dist; ///< the distance between nodes
   double m_thrRefDl; ///< the DL throughput reference
   double m_thrRefUl; ///< the UL throughput reference
   bool m_errorModelEnabled; ///< whether the error model is enabled
diff -Naru a/test/lte-test-tdtbfq-ff-mac-scheduler.cc b/test/lte-test-tdtbfq-ff-mac-scheduler.cc
--- a/test/lte-test-tdtbfq-ff-mac-scheduler.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-tdtbfq-ff-mac-scheduler.cc	2018-08-03 16:39:02.895957709 +0200
@@ -80,7 +80,7 @@
   // DOWNLINK -> DISTANCE 0 -> MCS 28 -> Itbs 26 (from table 7.1.7.2.1-1 of 36.2    13)
   // Traffic info
   //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
+  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
   // Totol bandwidth: 24 PRB at Itbs 26 -> 2196 -> 2196000 byte/sec
   // 1 user -> 232000 * 1 = 232000 < 2196000 -> throughput = 232000 byte/sec
   // 3 user -> 232000 * 3 = 696000 < 2196000 -> througphut = 232000 byte/sec
@@ -88,7 +88,7 @@
   // 12 user -> 232000 * 12 = 2784000 > 2196000 -> throughput = 2196000 / 12 = 183000 byte/sec
   // UPLINK -> DISTANCE 0 -> MCS 28 -> Itbs 26 (from table 7.1.7.2.1-1 of 36.2    13)
   // 1 user -> 25 PRB at Itbs 26 -> 2292 -> 2292000 > 232000 -> throughput = 232000 bytes/sec
-  // 3 users -> 8 PRB at Itbs 26 -> 749 -> 749000 > 232000 -> throughput = 232000 bytes/sec 
+  // 3 users -> 8 PRB at Itbs 26 -> 749 -> 749000 > 232000 -> throughput = 232000 bytes/sec
   // 6 users -> 4 PRB at Itbs 26 -> 373 -> 373000 > 232000 -> throughput = 232000 bytes/sec
   // 12 users -> 2 PRB at Itbs 26 -> 185 -> 185000 < 232000 -> throughput = 185000 bytes/sec
   AddTestCase (new LenaTdTbfqFfMacSchedulerTestCase1 (1,0,232000,232000,200,1,errorModel), TestCase::EXTENSIVE);
@@ -99,7 +99,7 @@
   // DOWNLINK - DISTANCE 4800 -> MCS 22 -> Itbs 20 (from table 7.1.7.2.1-1 of 36.213)
   // Traffic info
   //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
+  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
   // Totol bandwidth: 24 PRB at Itbs 20 -> 1383 -> 1383000 byte/sec
   // 1 user -> 903000 * 1 = 232000 < 1383000 -> throughput = 232000 byte/sec
   // 3 user -> 232000 * 3 = 696000 < 1383000 -> througphut = 232000 byte/sec
@@ -119,7 +119,7 @@
   // DOWNLINK - DISTANCE 6000 -> MCS 20 -> Itbs 18 (from table 7.1.7.2.1-1 of 36.213)
   // Traffic info
   //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
+  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
   // Totol bandwidth: 24 PRB at Itbs 18 -> 1191 -> 1191000 byte/sec
   // 1 user -> 903000 * 1 = 232000 < 1191000 -> throughput = 232000 byte/sec
   // 3 user -> 232000 * 3 = 696000 < 1191000 -> througphut = 232000 byte/sec
@@ -140,7 +140,7 @@
   // DOWNLINK - DISTANCE 10000 -> MCS 14 -> Itbs 13 (from table 7.1.7.2.1-1 of 36.213)
   // Traffic info
   //   UDP traffic: payload size = 200 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate 
+  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 232000 byte/rate
   // Totol bandwidth: 24 PRB at Itbs 13 -> 775 -> 775000 byte/sec
   // 1 user -> 903000 * 1 = 232000 < 775000 -> throughput = 232000 byte/sec
   // 3 user -> 232000 * 3 = 696000 < 775000 -> througphut = 232000 byte/sec
@@ -164,7 +164,7 @@
   // Test Case 2: homogeneous flow test in TDTBFQ (different distance)
   // Traffic1 info
   //   UDP traffic: payload size = 100 bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 132000 byte/rate 
+  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> 132000 byte/rate
   // Maximum throughput = 4 / ( 1/2196000 + 1/1383000 + 1/1191000 + 1/775000 ) = 1209000 byte/s
   // 132000 * 4 = 528000 < 1209000 -> estimated throughput in downlink = 132000 byte/sec
   std::vector<double> dist1;
@@ -208,7 +208,7 @@
 
   // Test Case 3: heterogeneous flow test in TDTBFQ
   //   UDP traffic: payload size = [100,200,300] bytes, interval = 1 ms
-  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> [132000, 232000, 332000] byte/rate 
+  //   UDP rate in scheduler: (payload + RLC header + PDCP header + IP header + UDP header) * 1000 byte/sec -> [132000, 232000, 332000] byte/rate
   // Maximum throughput = 3 / ( 1/2196000 + 1/1383000 + 1/1191000 ) = 1486666  byte/s
   // 132000 + 232000 + 332000 = 696000 < 1486666 -> estimated throughput in downlink = [132000, 232000, 332000] byte/sec
   std::vector<double> dist3;
@@ -232,7 +232,7 @@
 // --------------- T E S T - C A S E   # 1 ------------------------------
 
 
-std::string 
+std::string
 LenaTdTbfqFfMacSchedulerTestCase1::BuildNameString (uint16_t nUser, double dist)
 {
   std::ostringstream oss;
@@ -268,6 +268,7 @@
       Config::SetDefault ("ns3::LteSpectrumPhy::DataErrorModelEnabled", BooleanValue (false));
     }
 
+  Config::SetDefault ("ns3::LteEnbRrc::SrsPeriodicity", UintegerValue(40));
   Config::SetDefault ("ns3::LteHelper::UseIdealRrc", BooleanValue (true));
 
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
@@ -310,7 +311,7 @@
 
 //   LogComponentDisableAll (LOG_LEVEL_ALL);
   //LogComponentEnable ("LenaTestTdTbfqFfMacScheduler", LOG_LEVEL_ALL);
-   
+
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
   // Create Nodes: eNodeB and UE
@@ -376,7 +377,7 @@
       qos.gbrUl = 0;
       qos.mbrDl = qos.gbrDl;
       qos.mbrUl = 0;
-      
+
       enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
       EpsBearer bearer (q, qos);
       lteHelper->ActivateDedicatedEpsBearer (ueDevice, bearer, EpcTft::Default ());
@@ -477,7 +478,7 @@
 // --------------- T E S T - C A S E   # 2 ------------------------------
 
 
-std::string 
+std::string
 LenaTdTbfqFfMacSchedulerTestCase2::BuildNameString (uint16_t nUser, std::vector<double> dist)
 {
   std::ostringstream oss;
@@ -551,7 +552,7 @@
 
 //   LogComponentDisableAll (LOG_LEVEL_ALL);
   //LogComponentEnable ("LenaTestTdTbfqFfMacScheduler", LOG_LEVEL_ALL);
-   
+
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
   // Create Nodes: eNodeB and UE
@@ -614,7 +615,7 @@
     {
       mbrDl = mbrDl + m_packetSize.at (u);
     }
-  mbrDl = mbrDl / ueNodes.GetN (); 
+  mbrDl = mbrDl / ueNodes.GetN ();
 
   for (uint32_t u = 0; u < ueNodes.GetN (); ++u)
     {
@@ -624,7 +625,7 @@
       qos.gbrUl = 0;
       qos.mbrDl = qos.gbrDl;
       qos.mbrUl = 0;
-  
+
       enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
       EpsBearer bearer (q, qos);
       lteHelper->ActivateDedicatedEpsBearer (ueDevice, bearer, EpcTft::Default ());
diff -Naru a/test/lte-test-tta-ff-mac-scheduler.cc b/test/lte-test-tta-ff-mac-scheduler.cc
--- a/test/lte-test-tta-ff-mac-scheduler.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-tta-ff-mac-scheduler.cc	2018-08-03 16:39:02.899957745 +0200
@@ -49,6 +49,9 @@
 #include <ns3/boolean.h>
 #include <ns3/enum.h>
 
+
+#include "lte-test-tta-ff-mac-scheduler.h"
+
 using namespace ns3;
 
 NS_LOG_COMPONENT_DEFINE ("LenaTestTtaFfMacScheduler");
@@ -130,7 +133,7 @@
   AddTestCase (new LenaTtaFfMacSchedulerTestCase (3,10000,775000,137000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaTtaFfMacSchedulerTestCase (6,10000,775000,67000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaTtaFfMacSchedulerTestCase (12,10000,775000,32667,errorModel), TestCase::EXTENSIVE);
- 
+
   // DONWLINK - DISTANCE 20000 -> MCS 8 -> Itbs 8 (from table 7.1.7.2.1-1 of 36.213)
   // 1 user -> 24 PRB at Itbs 8 -> 421 -> 421000 bytes/sec for one UE; 0 bytes/sec for other UEs
   // 3 users -> 421000 among 3 users -> 421000 bytes/sec for one UE; 0 bytes/sec for other UEs
@@ -147,9 +150,6 @@
   AddTestCase (new LenaTtaFfMacSchedulerTestCase (6,20000,421000,22000,errorModel), TestCase::EXTENSIVE);
   AddTestCase (new LenaTtaFfMacSchedulerTestCase (12,20000,421000,12000,errorModel), TestCase::EXTENSIVE);
 
-  // DOWNLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  // UPLINK - DISTANCE 100000 -> CQI == 0 -> out of range -> 0 bytes/sec
-  AddTestCase (new LenaTtaFfMacSchedulerTestCase (1,100000,0,0,errorModel), TestCase::QUICK);
 }
 
 static LenaTestTtaFfMacSchedulerSuite lenaTestTtaFfMacSchedulerSuite;
@@ -157,15 +157,15 @@
 
 // --------------- T E S T - C A S E ------------------------------
 
-std::string 
-LenaTtaFfMacSchedulerTestCase::BuildNameString (uint16_t nUser, double dist)
+std::string
+LenaTtaFfMacSchedulerTestCase::BuildNameString (uint16_t nUser, uint16_t dist)
 {
   std::ostringstream oss;
   oss << nUser << " UEs, distance " << dist << " m";
   return oss.str ();
 }
 
-LenaTtaFfMacSchedulerTestCase::LenaTtaFfMacSchedulerTestCase (uint16_t nUser, double dist, double thrRefDl, double thrRefUl, bool errorModelEnabled)
+LenaTtaFfMacSchedulerTestCase::LenaTtaFfMacSchedulerTestCase (uint16_t nUser, uint16_t dist, double thrRefDl, double thrRefUl, bool errorModelEnabled)
   : TestCase (BuildNameString (nUser, dist)),
     m_nUser (nUser),
     m_dist (dist),
@@ -204,6 +204,10 @@
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
   lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   // Create Nodes: eNodeB and UE
   NodeContainer enbNodes;
   NodeContainer ueNodes;
@@ -231,8 +235,8 @@
   enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
   EpsBearer bearer (q);
   lteHelper->ActivateDataRadioBearer (ueDevs, bearer);
-  
- 
+
+
   Ptr<LteEnbNetDevice> lteEnbDev = enbDevs.Get (0)->GetObject<LteEnbNetDevice> ();
   Ptr<LteEnbPhy> enbPhy = lteEnbDev->GetPhy ();
   enbPhy->SetAttribute ("TxPower", DoubleValue (30.0));
@@ -316,8 +320,8 @@
     }
   /**
   * Check that the assignation is done in a "proportional fair" manner among users
-  * with equal SINRs: the bandwidth should be distributed according to the 
-  * ratio of the estimated throughput per TTI of each user; therefore equally 
+  * with equal SINRs: the bandwidth should be distributed according to the
+  * ratio of the estimated throughput per TTI of each user; therefore equally
   * partitioning the whole bandwidth achievable from a single users in a TTI
   */
   for (int i = 0; i < m_nUser; i++)
@@ -327,4 +331,3 @@
   Simulator::Destroy ();
 
 }
-
diff -Naru a/test/lte-test-tta-ff-mac-scheduler.h b/test/lte-test-tta-ff-mac-scheduler.h
--- a/test/lte-test-tta-ff-mac-scheduler.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-tta-ff-mac-scheduler.h	2018-08-03 16:39:02.899957745 +0200
@@ -34,14 +34,14 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief This system test program creates different test cases with a single eNB and 
- * several UEs, all having the same Radio Bearer specification. In each test 
- * case, the UEs see the same SINR from the eNB; different test cases are 
- * implemented obtained by using different SINR values and different numbers of 
- * UEs. The test consists on checking that the obtained throughput performance 
- * is consistent with the definition of throughput to average
- * scheduling
- */
+ * \brief This system test program creates different test cases with a single eNB and
+* several UEs, all having the same Radio Bearer specification. In each test
+* case, the UEs see the same SINR from the eNB; different test cases are
+* implemented obtained by using different SINR values and different numbers of
+* UEs. The test consists on checking that the obtained throughput performance
+* is consistent with the definition of throughput to average
+* scheduling
+*/
 class LenaTtaFfMacSchedulerTestCase : public TestCase
 {
 public:
@@ -54,7 +54,7 @@
    * \param thrRefUl the UL throughput reference
    * \param errorModelEnabled if true the error model is enabled
    */
-  LenaTtaFfMacSchedulerTestCase (uint16_t nUser, double dist, double thrRefDl, double thrRefUl,bool errorModelEnabled);
+  LenaTtaFfMacSchedulerTestCase (uint16_t nUser, uint16_t dist, double thrRefDl, double thrRefUl,bool errorModelEnabled);
   virtual ~LenaTtaFfMacSchedulerTestCase ();
 
 private:
@@ -64,10 +64,10 @@
    * \param dist the distnace between nodes
    * \returns the name string
    */
-  static std::string BuildNameString (uint16_t nUser, double dist);
+  static std::string BuildNameString (uint16_t nUser, uint16_t dist);
   virtual void DoRun (void);
   uint16_t m_nUser; ///< number of UE nodes
-  double m_dist; ///< the distance between nodes
+  uint16_t m_dist; ///< the distance between nodes
   double m_thrRefDl; ///< the DL throughput reference
   double m_thrRefUl; ///< the UL throughput reference
   bool m_errorModelEnabled; ///< is error model enabled?
diff -Naru a/test/lte-test-ue-measurements.cc b/test/lte-test-ue-measurements.cc
--- a/test/lte-test-ue-measurements.cc	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-ue-measurements.cc	2018-08-03 16:39:02.899957745 +0200
@@ -554,6 +554,10 @@
                            StringValue ("ns3::FriisSpectrumPropagationLossModel"));
   lteHelper->SetAttribute ("UseIdealRrc", BooleanValue (true));
 
+  // set DL and UL bandwidth.
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   //Disable Uplink Power Control
   Config::SetDefault ("ns3::LteUePhy::EnableUplinkPowerControl", BooleanValue (false));
 
@@ -1139,6 +1143,10 @@
                            StringValue ("ns3::FriisSpectrumPropagationLossModel"));
   lteHelper->SetAttribute ("UseIdealRrc", BooleanValue (true));
 
+  // set DL and UL bandwidth.
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   //Disable Uplink Power Control
   Config::SetDefault ("ns3::LteUePhy::EnableUplinkPowerControl", BooleanValue (false));
 
@@ -1692,6 +1700,10 @@
                            StringValue ("ns3::FriisSpectrumPropagationLossModel"));
   lteHelper->SetAttribute ("UseIdealRrc", BooleanValue (true));
 
+  // set DL and UL bandwidth
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   //Disable Uplink Power Control
   Config::SetDefault ("ns3::LteUePhy::EnableUplinkPowerControl", BooleanValue (false));
 
@@ -1801,12 +1813,16 @@
   lteHelper->AddX2Interface (enbNodes);
 
   // Connect to trace sources in source eNodeB
-  Config::Connect ("/NodeList/1/DeviceList/0/LteEnbRrc/RecvMeasurementReport",
+  uint16_t sourceEnbId = enbNodes.Get (0)->GetId ();
+  std::string sourceEnbPath = "/NodeList/" + std::to_string (sourceEnbId) + "/DeviceList/0/LteEnbRrc/RecvMeasurementReport";
+  Config::Connect (sourceEnbPath,
                    MakeCallback (&LteUeMeasurementsHandoverTestCase::RecvMeasurementReportCallback,
                                  this));
 
   // Connect to trace sources in target eNodeB
-  Config::Connect ("/NodeList/2/DeviceList/0/LteEnbRrc/RecvMeasurementReport",
+  uint16_t targetEnbId = enbNodes.Get (1)->GetId ();
+  std::string targetEnbPath = "/NodeList/" + std::to_string (targetEnbId) + "/DeviceList/0/LteEnbRrc/RecvMeasurementReport";
+  Config::Connect (targetEnbPath,
                    MakeCallback (&LteUeMeasurementsHandoverTestCase::RecvMeasurementReportCallback,
                                  this));
 
diff -Naru a/test/lte-test-ue-measurements.h b/test/lte-test-ue-measurements.h
--- a/test/lte-test-ue-measurements.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-ue-measurements.h	2018-08-03 16:39:02.899957745 +0200
@@ -62,8 +62,8 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test that UE measurements calculation works properly in a scenario 
- * with 2 eNodeBs and 2UEs. Test that RSRP and RSRQ of the serving cell and of 
+ * \brief Test that UE measurements calculation works properly in a scenario
+ * with 2 eNodeBs and 2UEs. Test that RSRP and RSRQ of the serving cell and of
  * the neighbor cell correspond to the reference values.
  */
 class LteUeMeasurementsTestCase : public TestCase
@@ -138,17 +138,17 @@
  * \ingroup tests
  *
  * \brief Testing UE measurements in LTE with simulation of 1 eNodeB and 1 UE in
- *        piecewise configuration and 120 ms report interval. During the simulation 
- *        the placement of UE is being changed several times. Four different 
- *        cases are considered: UE is very near to eNodeB, UE is near to eNodeB, 
- *        UE is far from eNodeB and UE is very far from eNodeB. Test checks 
- *        if the measurments correspond to the real conditions of the UE, i.e. 
- *        wnen the signal from serving cell becomes weak, the measurements should 
- *        also start to correspond to the new channel conditions. Additionally, it 
- *        is checked if UE detects some neighboring signal, if it does the test 
- *        fails because there is no neighbor in this configuration. Also, test 
- *        checks if the reporting occurs at intervals that it should according to 
- *        the measurements configuration. If it occurs in some different time 
+ *        piecewise configuration and 120 ms report interval. During the simulation
+ *        the placement of UE is being changed several times. Four different
+ *        cases are considered: UE is very near to eNodeB, UE is near to eNodeB,
+ *        UE is far from eNodeB and UE is very far from eNodeB. Test checks
+ *        if the measurments correspond to the real conditions of the UE, i.e.
+ *        wnen the signal from serving cell becomes weak, the measurements should
+ *        also start to correspond to the new channel conditions. Additionally, it
+ *        is checked if UE detects some neighboring signal, if it does the test
+ *        fails because there is no neighbor in this configuration. Also, test
+ *        checks if the reporting occurs at intervals that it should according to
+ *        the measurements configuration. If it occurs in some different time
  *        stamp the test will fail.
  */
 class LteUeMeasurementsPiecewiseTestCase1 : public TestCase
@@ -279,16 +279,16 @@
  * \brief Testing UE measurements in LTE with simulation of 2 eNodeB and 1 UE in
  *        piecewise configuration and 240 ms report interval.
  *        Here is intenisvely test events A1 and A2. A1 event should be triggered
- *        when the serving cell becomes better than a given threshold. A2 shall 
- *        be triggered when the serving cell becomes worse than threshold. A3 
+ *        when the serving cell becomes better than a given threshold. A2 shall
+ *        be triggered when the serving cell becomes worse than threshold. A3
  *        event is triggered when the neighbour becomes offset better than the PCell.
- *        In this test UE is being transported several times during the simulation 
- *        duration. Then the test checks if measurement report contains correct 
- *        RSRP and RSRQ result, than if CQI info is correctly generated, if the 
- *        reporting occurs at the correct time stamp in the simulation and according 
- *        to the measurements configuration. It also checks if the reported values 
+ *        In this test UE is being transported several times during the simulation
+ *        duration. Then the test checks if measurement report contains correct
+ *        RSRP and RSRQ result, than if CQI info is correctly generated, if the
+ *        reporting occurs at the correct time stamp in the simulation and according
+ *        to the measurements configuration. It also checks if the reported values
  *        of RSRP and RSRQ are equal to expected reference values.
- *        
+ *
  */
 class LteUeMeasurementsPiecewiseTestCase2 : public TestCase
 {
@@ -419,15 +419,15 @@
  *        a handover configuration.
  *
  * The simulation will run for the specified duration, while the handover
- * command will be issued exactly at the middle of simulation. Handover 
- * test covers four different scenarios: switch from event A1 to event A2, 
- * from event A2 to event A1, from event A3 to event A4, from event A4 to event 
- * A3, from event A2 to event A3, from event A3 to event A2, from event A4 to 
- * event A5, from event A5 to event A4. Additionally, it tests different 
+ * command will be issued exactly at the middle of simulation. Handover
+ * test covers four different scenarios: switch from event A1 to event A2,
+ * from event A2 to event A1, from event A3 to event A4, from event A4 to event
+ * A3, from event A2 to event A3, from event A3 to event A2, from event A4 to
+ * event A5, from event A5 to event A4. Additionally, it tests different
  * handover threshold configurations, A2 threshold difference, A3 offset difference,
- * A4 and A5 threshold difference. Finally, different handover is tested for 
+ * A4 and A5 threshold difference. Finally, different handover is tested for
  * different time-to-trigger (TTT) configurations.
- * 
+ *
  */
 class LteUeMeasurementsHandoverTestCase : public TestCase
 {
diff -Naru a/test/lte-test-ue-phy.h b/test/lte-test-ue-phy.h
--- a/test/lte-test-ue-phy.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-ue-phy.h	2018-08-03 16:39:02.899957745 +0200
@@ -71,7 +71,7 @@
   virtual Ptr<SpectrumValue> CreateTxPowerSpectralDensity ();
 
   virtual void GenerateCtrlCqiReport (const SpectrumValue& sinr);
-  
+
   virtual void GenerateDataCqiReport (const SpectrumValue& sinr);
 
   virtual void ReportInterference (const SpectrumValue& interf);
diff -Naru a/test/lte-test-uplink-sinr.h b/test/lte-test-uplink-sinr.h
--- a/test/lte-test-uplink-sinr.h	2018-08-03 16:38:46.691807158 +0200
+++ b/test/lte-test-uplink-sinr.h	2018-08-03 16:39:02.899957745 +0200
@@ -48,9 +48,9 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test generation of SINR in the uplink. Test schedules the signal and the interference 
- * signals and it evaluates if the obtained value for SINR corresponds to the theoretical value 
- * in given conditions. 
+ * \brief Test generation of SINR in the uplink. Test schedules the signal and the interference
+ * signals and it evaluates if the obtained value for SINR corresponds to the theoretical value
+ * in given conditions.
  */
 class LteUplinkDataSinrTestCase : public TestCase
 {
@@ -81,10 +81,10 @@
  * \ingroup tests
  *
  * \brief  In this test one signal will be of interest, i.e., the
-  *  SRS of the first signal will have the same CellId of the 
-  *  receiving PHY; the others will have a different 
-  *  CellId and hence will be the interfering signals. The test 
-  *  checks whether the SINR of the signal correspond to the 
+  *  SRS of the first signal will have the same CellId of the
+  *  receiving PHY; the others will have a different
+  *  CellId and hence will be the interfering signals. The test
+  *  checks whether the SINR of the signal correspond to the
   *  theoretical value.
  */
 class LteUplinkSrsSinrTestCase : public TestCase
@@ -100,17 +100,17 @@
    */
     LteUplinkSrsSinrTestCase (Ptr<SpectrumValue> sv1, Ptr<SpectrumValue> sv2, Ptr<SpectrumValue> sinr, std::string name);
     virtual ~LteUplinkSrsSinrTestCase ();
-    
-  /** 
+
+  /**
    * Callback to be connected to an LteChunkProcessor to collect the reported SINR
-   * 
-   * \param sinr 
+   *
+   * \param sinr
    */
   void ReportSinr (const SpectrumValue& sinr);
 
 private:
   virtual void DoRun (void);
-  
+
   Ptr<SpectrumValue> m_sv1; ///< the spectrum value #1
   Ptr<SpectrumValue> m_sv2; ///< the spectrum value #2
   Ptr<const SpectrumModel> m_sm; ///< the spectrum model
diff -Naru a/test/test-asn1-encoding.cc b/test/test-asn1-encoding.cc
--- a/test/test-asn1-encoding.cc	2018-08-03 16:38:46.695807196 +0200
+++ b/test/test-asn1-encoding.cc	2018-08-03 16:39:02.899957745 +0200
@@ -603,7 +603,7 @@
   reportConfigToAddMod.reportConfigEutra.reportQuantity = LteRrcSap::ReportConfigEutra::SAME_AS_TRIGGER_QUANTITY;
   reportConfigToAddMod.reportConfigEutra.maxReportCells = 5;
   reportConfigToAddMod.reportConfigEutra.reportInterval = LteRrcSap::ReportConfigEutra::MIN60;
-  reportConfigToAddMod.reportConfigEutra.reportAmount = 16; 
+  reportConfigToAddMod.reportConfigEutra.reportAmount = 16;
   msg.measConfig.reportConfigToAddModList.push_back (reportConfigToAddMod);
 
   // Set measIdToAddModList
@@ -1145,4 +1145,3 @@
 }
 
 Asn1EncodingSuite asn1EncodingSuite;
-
diff -Naru a/test/test-epc-tft-classifier.cc b/test/test-epc-tft-classifier.cc
--- a/test/test-epc-tft-classifier.cc	2018-08-03 16:38:46.695807196 +0200
+++ b/test/test-epc-tft-classifier.cc	2018-08-03 16:39:02.899957745 +0200
@@ -41,8 +41,8 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test case to check the functionality of the Tft Classifier. Test 
- * consist of defining different TFT configurations, i.e. direction, ports, 
+ * \brief Test case to check the functionality of the Tft Classifier. Test
+ * consist of defining different TFT configurations, i.e. direction, ports,
  * address, and it is checking if the clasiffication of UDP packets is
  * done correctly.
  */
@@ -63,8 +63,8 @@
    */
   EpcTftClassifierTestCase (Ptr<EpcTftClassifier> c,
                             EpcTft::Direction d,
-                            Ipv4Address sa, 
-                            Ipv4Address da, 
+                            Ipv4Address sa,
+                            Ipv4Address da,
                             uint16_t sp,
                             uint16_t dp,
                             uint8_t tos,
@@ -72,7 +72,7 @@
   virtual ~EpcTftClassifierTestCase ();
 
 private:
-  
+
   Ptr<EpcTftClassifier> m_c; ///< the EPC TFT classifier
   EpcTft::Direction m_d; ///< the EPC TFT direction
   uint8_t m_tftId; ///< the TFT ID
@@ -94,8 +94,8 @@
    */
   static std::string BuildNameString (Ptr<EpcTftClassifier> c,
                                       EpcTft::Direction d,
-                                      Ipv4Address sa, 
-                                      Ipv4Address da, 
+                                      Ipv4Address sa,
+                                      Ipv4Address da,
                                       uint16_t sp,
                                       uint16_t dp,
                                       uint8_t tos,
@@ -105,15 +105,15 @@
 
 EpcTftClassifierTestCase::EpcTftClassifierTestCase (Ptr<EpcTftClassifier> c,
                                                     EpcTft::Direction d,
-                                                    Ipv4Address sa, 
-                                                    Ipv4Address da, 
+                                                    Ipv4Address sa,
+                                                    Ipv4Address da,
                                                     uint16_t sp,
                                                     uint16_t dp,
                                                     uint8_t tos,
                                                     uint32_t tftId)
   : TestCase (BuildNameString (c, d, sa, da, sp, dp, tos, tftId)),
     m_c (c),
-    m_d (d),    
+    m_d (d),
     m_tftId (tftId)
 {
   NS_LOG_FUNCTION (this << c << d << sa << da << sp << dp << tos << tftId);
@@ -134,8 +134,8 @@
 std::string
 EpcTftClassifierTestCase::BuildNameString (Ptr<EpcTftClassifier> c,
                                            EpcTft::Direction d,
-                                           Ipv4Address sa, 
-                                           Ipv4Address da, 
+                                           Ipv4Address sa,
+                                           Ipv4Address da,
                                            uint16_t sp,
                                            uint16_t dp,
                                            uint8_t tos,
@@ -149,11 +149,11 @@
       << ", sp = " << sp
       << ", dp = " << dp
       << ", tos = 0x" << std::hex << (int) tos
-      << " --> tftId = " << tftId;  
+      << " --> tftId = " << tftId;
   return oss.str ();
 }
 
-void 
+void
 EpcTftClassifierTestCase::DoRun (void)
 {
   ns3::PacketMetadata::Enable ();
@@ -194,9 +194,9 @@
   // check some TFT matches
   ///////////////////////////
 
-  
+
   Ptr<EpcTftClassifier> c1 = Create<EpcTftClassifier> ();
-  
+
 
   Ptr<EpcTft> tft1_1 = Create<EpcTft> ();
 
@@ -278,7 +278,7 @@
 
 
   ///////////////////////////
-  // check default TFT 
+  // check default TFT
   ///////////////////////////
 
   Ptr<EpcTftClassifier> c2 = Create<EpcTftClassifier> ();
@@ -311,7 +311,7 @@
   AddTestCase (new EpcTftClassifierTestCase (c2, EpcTft::DOWNLINK, Ipv4Address ("9.1.1.1"), Ipv4Address ("8.1.1.1"),  3461,     3461,     0,    1), TestCase::QUICK);
   AddTestCase (new EpcTftClassifierTestCase (c2, EpcTft::DOWNLINK, Ipv4Address ("9.1.1.1"), Ipv4Address ("8.1.1.1"),     9,     3489,     0,    1), TestCase::QUICK);
 
-  
+
 
   ///////////////////////////////////////////
   // check default TFT plus dedicated ones
@@ -357,7 +357,7 @@
 
   Ptr<EpcTftClassifier> c4 = Create<EpcTftClassifier> ();
   Ptr<EpcTft> tft4_1 = Create<EpcTft> ();
-  tft4_1->Add (pf1_2_3);  
+  tft4_1->Add (pf1_2_3);
   c4->Add (tft4_1, 1);
   Ptr<EpcTft> tft4_2 = Create<EpcTft> ();
   tft4_2->Add (pf1_2_4);
diff -Naru a/test/test-lte-antenna.cc b/test/test-lte-antenna.cc
--- a/test/test-lte-antenna.cc	2018-08-03 16:38:46.695807196 +0200
+++ b/test/test-lte-antenna.cc	2018-08-03 16:39:02.899957745 +0200
@@ -161,6 +161,10 @@
   lteHelper->SetEnbAntennaModelAttribute ("Beamwidth",   DoubleValue (m_beamwidthDegrees));
   lteHelper->SetEnbAntennaModelAttribute ("MaxGain",     DoubleValue (0.0));
 
+  // set DL and UL bandwidth. 
+  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
   enbDevs = lteHelper->InstallEnbDevice (enbNodes);
   ueDevs = lteHelper->InstallUeDevice (ueNodes);
 
@@ -220,6 +224,7 @@
         }      
       // remember that propagation loss is 0dB
       double calculatedAntennaGainDbDl = - (enbTxPowerDbm - calculatedSinrDbDl - noisePowerDbm - ueNoiseFigureDb);      
+      NS_LOG_INFO("expected " << m_antennaGainDb << " actual " << calculatedAntennaGainDbDl << " tol " << tolerance);
       NS_TEST_ASSERT_MSG_EQ_TOL (calculatedAntennaGainDbDl, m_antennaGainDb, tolerance, "Wrong DL antenna gain!");
     }
   double expectedSinrUl = ueTxPowerDbm + m_antennaGainDb - noisePowerDbm + enbNoiseFigureDb;
diff -Naru a/test/test-lte-epc-e2e-data.cc b/test/test-lte-epc-e2e-data.cc
--- a/test/test-lte-epc-e2e-data.cc	2018-08-03 16:38:46.695807196 +0200
+++ b/test/test-lte-epc-e2e-data.cc	2018-08-03 16:39:02.899957745 +0200
@@ -69,7 +69,7 @@
   uint32_t numPkts; ///< the number of packets
   uint32_t pktSize; ///< the packet size
   Time interPacketInterval; ///< the inter packet interval time
- 
+
   Ptr<PacketSink> dlServerApp; ///< the DL server app
   Ptr<Application> dlClientApp; ///< the DL client app
 
@@ -101,7 +101,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test that e2e packet flow is correct. Compares the data send and the 
+ * \brief Test that e2e packet flow is correct. Compares the data send and the
  * data received. Test uses mostly the PDCP stats to check the performance.
  */
 
@@ -134,13 +134,13 @@
 {
 }
 
-void 
+void
 LteEpcE2eDataTestCase::DoRun ()
 {
   NS_LOG_FUNCTION (this << GetName ());
   Config::Reset ();
   Config::SetDefault ("ns3::LteSpectrumPhy::CtrlErrorModelEnabled", BooleanValue (false));
-  Config::SetDefault ("ns3::LteSpectrumPhy::DataErrorModelEnabled", BooleanValue (false));  
+  Config::SetDefault ("ns3::LteSpectrumPhy::DataErrorModelEnabled", BooleanValue (false));
   Config::SetDefault ("ns3::LteHelper::UseIdealRrc", BooleanValue (true));
   Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
   Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper> ();
@@ -153,7 +153,7 @@
   epcHelper->SetAttribute ("S1uLinkMtu", UintegerValue (30000));
 
   Ptr<Node> pgw = epcHelper->GetPgwNode ();
-  
+
   // Create a single RemoteHost
   NodeContainer remoteHostContainer;
   remoteHostContainer.Create (1);
@@ -165,20 +165,20 @@
   PointToPointHelper p2ph;
   p2ph.SetDeviceAttribute ("DataRate", DataRateValue (DataRate ("100Gb/s")));
   p2ph.SetDeviceAttribute ("Mtu", UintegerValue (30000)); // jumbo frames here as well
-  p2ph.SetChannelAttribute ("Delay", TimeValue (Seconds (0.010)));  
-  NetDeviceContainer internetDevices = p2ph.Install (pgw, remoteHost);  
+  p2ph.SetChannelAttribute ("Delay", TimeValue (Seconds (0.010)));
+  NetDeviceContainer internetDevices = p2ph.Install (pgw, remoteHost);
   Ipv4AddressHelper ipv4h;
   ipv4h.SetBase ("1.0.0.0", "255.0.0.0");
   Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign (internetDevices);
   Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress (1);
-  
+
   // setup default gateway for the remote hosts
   Ipv4StaticRoutingHelper ipv4RoutingHelper;
   Ptr<Ipv4StaticRouting> remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting (remoteHost->GetObject<Ipv4> ());
 
   // hardcoded UE addresses for now
   remoteHostStaticRouting->AddNetworkRouteTo (Ipv4Address ("7.0.0.0"), Ipv4Mask ("255.255.255.0"), 1);
-  
+
 
   NodeContainer enbs;
   enbs.Create (m_enbTestData.size ());
@@ -194,7 +194,7 @@
   enbMobility.Install (enbs);
   NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice (enbs);
   NetDeviceContainer::Iterator enbLteDevIt = enbLteDevs.Begin ();
-  
+
   uint16_t ulPort = 1000;
 
   for (std::vector<EnbTestData>::iterator enbit = m_enbTestData.begin ();
@@ -202,7 +202,7 @@
        ++enbit, ++enbLteDevIt)
     {
       NS_ABORT_IF (enbLteDevIt ==  enbLteDevs.End ());
-      
+
 
 
       NodeContainer ues;
@@ -216,8 +216,8 @@
       ueMobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
       ueMobility.Install (ues);
       NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice (ues);
-       
-      // we install the IP stack on the UEs 
+
+      // we install the IP stack on the UEs
       InternetStackHelper internet;
       internet.Install (ues);
 
@@ -225,30 +225,30 @@
       for (uint32_t u = 0; u < ues.GetN (); ++u)
         {
 
-          Ptr<Node> ue = ues.Get (u);          
+          Ptr<Node> ue = ues.Get (u);
           Ptr<NetDevice> ueLteDevice = ueLteDevs.Get (u);
           Ipv4InterfaceContainer ueIpIface = epcHelper->AssignUeIpv4Address (NetDeviceContainer (ueLteDevice));
           // set the default gateway for the UE
-          Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting (ue->GetObject<Ipv4> ());          
+          Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting (ue->GetObject<Ipv4> ());
           ueStaticRouting->SetDefaultRoute (epcHelper->GetUeDefaultGatewayAddress (), 1);
 
 
           // we can now attach the UE, which will also activate the default EPS bearer
-          lteHelper->Attach (ueLteDevice, *enbLteDevIt);        
-      
-  
-          uint16_t dlPort = 2000;          
+          lteHelper->Attach (ueLteDevice, *enbLteDevIt);
+
+
+          uint16_t dlPort = 2000;
           for (uint32_t b = 0; b < enbit->ues.at (u).bearers.size (); ++b)
-            {              
+            {
               BearerTestData& bearerTestData = enbit->ues.at (u).bearers.at (b);
-              
+
               { // Downlink
                 ++dlPort;
                 PacketSinkHelper packetSinkHelper ("ns3::UdpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), dlPort));
                 ApplicationContainer apps = packetSinkHelper.Install (ue);
                 apps.Start (Seconds (0.04));
                 bearerTestData.dlServerApp = apps.Get (0)->GetObject<PacketSink> ();
-          
+
                 UdpEchoClientHelper client (ueIpIface.GetAddress (0), dlPort);
                 client.SetAttribute ("MaxPackets", UintegerValue (bearerTestData.numPkts));
                 client.SetAttribute ("Interval", TimeValue (bearerTestData.interPacketInterval));
@@ -264,7 +264,7 @@
                 ApplicationContainer apps = packetSinkHelper.Install (remoteHost);
                 apps.Start (Seconds (0.8));
                 bearerTestData.ulServerApp = apps.Get (0)->GetObject<PacketSink> ();
-          
+
                 UdpEchoClientHelper client (remoteHostAddr, ulPort);
                 client.SetAttribute ("MaxPackets", UintegerValue (bearerTestData.numPkts));
                 client.SetAttribute ("Interval", TimeValue (bearerTestData.interPacketInterval));
@@ -284,14 +284,14 @@
               EpcTft::PacketFilter ulpf;
               ulpf.remotePortStart = ulPort;
               ulpf.remotePortEnd = ulPort;
-              tft->Add (ulpf);                            
- 
+              tft->Add (ulpf);
+
               // all data will go over the dedicated bearer instead of the default EPS bearer
               lteHelper->ActivateDedicatedEpsBearer (ueLteDevice, epsBearer, tft);
             }
-        } 
-            
-    } 
+        }
+
+    }
 
   Config::Set ("/NodeList/*/DeviceList/*/LteEnbRrc/UeMap/*/RadioBearerMap/*/LteRlc/MaxTxBufferSize",
                UintegerValue (2 * 1024 * 1024));
@@ -301,14 +301,14 @@
 
   double statsStartTime = 0.040; // need to allow for RRC connection establishment + SRS
   double statsDuration = 2.0;
-    
+
   lteHelper->EnablePdcpTraces ();
 
   lteHelper->GetPdcpStats ()->SetAttribute ("StartTime", TimeValue (Seconds (statsStartTime)));
   lteHelper->GetPdcpStats ()->SetAttribute ("EpochDuration", TimeValue (Seconds (statsDuration)));
-  
-  
-  Simulator::Stop (Seconds (statsStartTime + statsDuration - 0.0001));  
+
+
+  Simulator::Stop (Seconds (statsStartTime + statsDuration - 0.0001));
   Simulator::Run ();
 
   uint64_t imsiCounter = 0;
@@ -320,7 +320,7 @@
       for (std::vector<UeTestData>::iterator ueit = enbit->ues.begin ();
            ueit < enbit->ues.end ();
            ++ueit)
-        {                    
+        {
           uint64_t imsi = ++imsiCounter;
           for (uint32_t b = 0; b < ueit->bearers.size (); ++b)
             {
@@ -335,32 +335,32 @@
               uint32_t rxPktsPdcpUl = lteHelper->GetPdcpStats ()->GetUlRxPackets (imsi, lcid);
               uint32_t rxBytesDl = ueit->bearers.at (b).dlServerApp->GetTotalRx ();
               uint32_t rxBytesUl = ueit->bearers.at (b).ulServerApp->GetTotalRx ();
-              
-              
-              NS_TEST_ASSERT_MSG_EQ (txPktsPdcpDl, 
-                                     expectedPkts, 
+
+
+              NS_TEST_ASSERT_MSG_EQ (txPktsPdcpDl,
+                                     expectedPkts,
                                      "wrong TX PDCP packets in downlink for IMSI=" << imsi << " LCID=" << (uint16_t) lcid);
-              
-              NS_TEST_ASSERT_MSG_EQ (rxPktsPdcpDl, 
-                                     expectedPkts, 
+
+              NS_TEST_ASSERT_MSG_EQ (rxPktsPdcpDl,
+                                     expectedPkts,
                                      "wrong RX PDCP packets in downlink for IMSI=" << imsi << " LCID=" << (uint16_t) lcid);
-              NS_TEST_ASSERT_MSG_EQ (txPktsPdcpUl, 
-                                     expectedPkts, 
+              NS_TEST_ASSERT_MSG_EQ (txPktsPdcpUl,
+                                     expectedPkts,
                                      "wrong TX PDCP packets in uplink for IMSI=" << imsi << " LCID=" << (uint16_t) lcid);
-              NS_TEST_ASSERT_MSG_EQ (rxPktsPdcpUl, 
-                                     expectedPkts, 
-                                     "wrong RX PDCP packets in uplink for IMSI=" << imsi << " LCID=" << (uint16_t) lcid);        
+              NS_TEST_ASSERT_MSG_EQ (rxPktsPdcpUl,
+                                     expectedPkts,
+                                     "wrong RX PDCP packets in uplink for IMSI=" << imsi << " LCID=" << (uint16_t) lcid);
 
-              NS_TEST_ASSERT_MSG_EQ (rxBytesDl, 
-                                     expectedBytes, 
+              NS_TEST_ASSERT_MSG_EQ (rxBytesDl,
+                                     expectedBytes,
                                      "wrong total received bytes in downlink");
-              NS_TEST_ASSERT_MSG_EQ (rxBytesUl, 
-                                     expectedBytes, 
+              NS_TEST_ASSERT_MSG_EQ (rxBytesUl,
+                                     expectedBytes,
                                      "wrong total received bytes in uplink");
             }
-        }      
+        }
     }
-  
+
   Simulator::Destroy ();
 }
 
@@ -378,13 +378,13 @@
 {
 public:
   LteEpcE2eDataTestSuite ();
-  
+
 } g_lteEpcE2eDataTestSuite; ///< the test suite
 
 LteEpcE2eDataTestSuite::LteEpcE2eDataTestSuite ()
   : TestSuite ("lte-epc-e2e-data", SYSTEM)
-{  
-  std::vector<EnbTestData> v1;  
+{
+  std::vector<EnbTestData> v1;
   EnbTestData e1;
   UeTestData u1;
   BearerTestData f1 (1, 100, 0.01);
@@ -393,7 +393,7 @@
   v1.push_back (e1);
   AddTestCase (new LteEpcE2eDataTestCase ("1 eNB, 1UE", v1), TestCase::QUICK);
 
-  std::vector<EnbTestData> v2;  
+  std::vector<EnbTestData> v2;
   EnbTestData e2;
   UeTestData u2_1;
   BearerTestData f2_1 (1, 100, 0.01);
@@ -406,7 +406,7 @@
   v2.push_back (e2);
   AddTestCase (new LteEpcE2eDataTestCase ("1 eNB, 2UEs", v2), TestCase::EXTENSIVE);
 
-  std::vector<EnbTestData> v3;  
+  std::vector<EnbTestData> v3;
   v3.push_back (e1);
   v3.push_back (e2);
   AddTestCase (new LteEpcE2eDataTestCase ("2 eNBs", v3), TestCase::EXTENSIVE);
@@ -424,7 +424,7 @@
   BearerTestData f4_3 (1, 12, 0.01);
   u4_3.bearers.push_back (f4_3);
   e4.ues.push_back (u4_3);
-  std::vector<EnbTestData> v4;  
+  std::vector<EnbTestData> v4;
   v4.push_back (e4);
   v4.push_back (e1);
   v4.push_back (e2);
diff -Naru a/test/test-lte-handover-delay.cc b/test/test-lte-handover-delay.cc
--- a/test/test-lte-handover-delay.cc	2018-08-03 16:38:46.695807196 +0200
+++ b/test/test-lte-handover-delay.cc	2018-08-03 16:39:02.899957745 +0200
@@ -53,7 +53,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Verifying that the time needed for handover is under a 
+ * \brief Verifying that the time needed for handover is under a
  * specified threshold.
  */
 
@@ -143,6 +143,8 @@
    * Helpers.
    */
   auto epcHelper = CreateObject<PointToPointEpcHelper> ();
+  epcHelper -> SetAttribute("S1apLinkDelay",TimeValue(Seconds(0)));
+  epcHelper -> SetAttribute("S1apLinkDataRate", DataRateValue(DataRate("1Gb/s")));
 
   auto lteHelper = CreateObject<LteHelper> ();
   lteHelper->SetEpcHelper (epcHelper);
@@ -301,7 +303,7 @@
       {
         // arguments: useIdealRrc, handoverTime, delayThreshold, simulationDuration
         AddTestCase (
-            new LteHandoverDelayTestCase (1, false, handoverTime, Seconds (0.020),
+          new LteHandoverDelayTestCase (1, false, handoverTime, Seconds (0.020),
                 Seconds (0.200)), TestCase::QUICK);
       }
   }
diff -Naru a/test/test-lte-rlc-header.cc b/test/test-lte-rlc-header.cc
--- a/test/test-lte-rlc-header.cc	2018-08-03 16:38:46.695807196 +0200
+++ b/test/test-lte-rlc-header.cc	2018-08-03 16:39:02.899957745 +0200
@@ -123,24 +123,24 @@
    * \param nackSnList list of nack sequence numbers
    * \param hex string
    */
-  RlcAmStatusPduTestCase (SequenceNumber10 ackSn, 
+  RlcAmStatusPduTestCase (SequenceNumber10 ackSn,
 			  std::list<SequenceNumber10> nackSnList,
 			  std::string hex);
 
-protected:  
+protected:
   virtual void DoRun (void);
-  
-  SequenceNumber10 m_ackSn; ///< ack sequence number  
+
+  SequenceNumber10 m_ackSn; ///< ack sequence number
   std::list<SequenceNumber10> m_nackSnList; ///< list of nack sequence numbers
   std::string m_hex; ///< hex string
-  
+
 };
 
 
-RlcAmStatusPduTestCase::RlcAmStatusPduTestCase (SequenceNumber10 ackSn, 
+RlcAmStatusPduTestCase::RlcAmStatusPduTestCase (SequenceNumber10 ackSn,
 						std::list<SequenceNumber10> nackSnList ,
 						std::string hex)
-  : TestCase (hex), 
+  : TestCase (hex),
     m_ackSn (ackSn),
     m_nackSnList (nackSnList),
     m_hex (hex)
@@ -153,7 +153,7 @@
 RlcAmStatusPduTestCase::DoRun ()
 {
   NS_LOG_FUNCTION (this);
-  
+
   Ptr<Packet> p = Create<Packet> ();
   LteRlcAmHeader h;
   h.SetControlPdu (LteRlcAmHeader::STATUS_PDU);
@@ -164,17 +164,17 @@
     {
       h.PushNack (it->GetValue ());
     }
-  p->AddHeader (h);  
+  p->AddHeader (h);
 
   TestUtils::LogPacketContents (p);
   std::string hex = TestUtils::sprintPacketContentsHex (p);
   NS_TEST_ASSERT_MSG_EQ (m_hex, hex, "serialized packet content " << hex << " differs from test vector " << m_hex);
-  
+
   LteRlcAmHeader h2;
   p->RemoveHeader (h2);
   SequenceNumber10 ackSn = h2.GetAckSn ();
   NS_TEST_ASSERT_MSG_EQ (ackSn, m_ackSn, "deserialized ACK SN differs from test vector");
-  
+
   for (std::list<SequenceNumber10>::iterator it = m_nackSnList.begin ();
        it != m_nackSnList.end ();
        ++it)
diff -Naru a/test/test-lte-rrc.cc b/test/test-lte-rrc.cc
--- a/test/test-lte-rrc.cc	2018-08-03 16:38:46.695807196 +0200
+++ b/test/test-lte-rrc.cc	2018-08-03 16:39:02.899957745 +0200
@@ -35,13 +35,13 @@
  * \ingroup tests
  *
  * \brief Test rrc connection establishment.
- */ 
+ */
 class LteRrcConnectionEstablishmentTestCase : public TestCase
 {
 public:
   /**
    *
-   * 
+   *
    * \param nUes number of UEs in the test
    * \param nBearers number of bearers to be setup in each connection
    * \param tConnBase connection time base value for all UEs in ms
@@ -69,7 +69,7 @@
 
   /**
    * Build name string function
-   * 
+   *
    * \param nUes number of UEs in the test
    * \param nBearers number of bearers to be setup in each connection
    * \param tConnBase connection time base value for all UEs in ms
@@ -136,7 +136,7 @@
   Ptr<LteHelper> m_lteHelper; ///< LTE helper
 
   /// key: IMSI
-  std::map<uint64_t, bool> m_isConnectionEstablished; 
+  std::map<uint64_t, bool> m_isConnectionEstablished;
 };
 
 
@@ -546,7 +546,7 @@
  * \ingroup tests
  *
  * \brief Lte Rrc Connection Establishment Error Test Case
- */ 
+ */
 class LteRrcConnectionEstablishmentErrorTestCase
   : public LteRrcConnectionEstablishmentTestCase
 {
@@ -733,7 +733,7 @@
  * \ingroup tests
  *
  * \brief Lte Rrc Test Suite
- */ 
+ */
 class LteRrcTestSuite : public TestSuite
 {
 public:
diff -Naru a/test/test-lte-x2-handover.cc b/test/test-lte-x2-handover.cc
--- a/test/test-lte-x2-handover.cc	2018-08-03 16:38:46.695807196 +0200
+++ b/test/test-lte-x2-handover.cc	2018-08-03 16:39:02.899957745 +0200
@@ -36,7 +36,7 @@
  * \ingroup tests
  *
  * \brief HandoverEvent structure
- */ 
+ */
 struct HandoverEvent
 {
   Time startTime; ///< start time
@@ -57,30 +57,30 @@
 {
 public:
 
-  /** 
-   * 
-   * 
+  /**
+   *
+   *
    * \param nUes number of UEs in the test
    * \param nDedicatedBearers number of bearers to be activated per UE
-   * \param handoverEventList 
-   * \param handoverEventListName 
+   * \param handoverEventList
+   * \param handoverEventListName
    * \param useUdp true if UDP is to be used, false if TCP is to be used
    * \param schedulerType the scheduler type
    * \param admitHo
-   * \param useIdealRrc true if the ideal RRC should be used 
+   * \param useIdealRrc true if the ideal RRC should be used
    */
   LteX2HandoverTestCase (uint32_t nUes, uint32_t nDedicatedBearers, std::list<HandoverEvent> handoverEventList, std::string handoverEventListName, bool useUdp, std::string schedulerType, bool admitHo, bool useIdealRrc);
-  
+
 private:
   /**
    * Build name string
    * \param nUes number of UEs in the test
    * \param nDedicatedBearers number of bearers to be activated per UE
-   * \param handoverEventListName 
+   * \param handoverEventListName
    * \param useUdp true if UDP is to be used, false if TCP is to be used
    * \param schedulerType the scheduler type
    * \param admitHo
-   * \param useIdealRrc true if the ideal RRC should be used 
+   * \param useIdealRrc true if the ideal RRC should be used
    * \returns the name string
    */
   static std::string BuildNameString (uint32_t nUes, uint32_t nDedicatedBearers, std::string handoverEventListName, bool useUdp, std::string schedulerType, bool admitHo, bool useIdealRrc);
@@ -103,13 +103,13 @@
   bool     m_useIdealRrc; ///< whether to use the ideal RRC
   Ptr<LteHelper> m_lteHelper; ///< LTE helper
   Ptr<PointToPointEpcHelper> m_epcHelper; ///< EPC helper
-  
+
 /**
  * \ingroup lte-test
  * \ingroup tests
  *
  * \brief BearerData structure
- */ 
+ */
   struct BearerData
   {
     uint32_t bid; ///< BID
@@ -124,7 +124,7 @@
  * \ingroup tests
  *
  * \brief UeData structure
- */ 
+ */
   struct UeData
   {
     uint32_t id; ///< ID
@@ -134,12 +134,12 @@
 /**
  * \brief Save stats after handover function
  * \param ueIndex the index of the UE
- */ 
+ */
   void SaveStatsAfterHandover (uint32_t ueIndex);
 /**
  * \brief Check stats a while after handover function
  * \param ueIndex the index of the UE
- */ 
+ */
   void CheckStatsAWhileAfterHandover (uint32_t ueIndex);
 
   std::vector<UeData> m_ueDataVector; ///< UE data vector
@@ -155,8 +155,8 @@
 std::string LteX2HandoverTestCase::BuildNameString (uint32_t nUes, uint32_t nDedicatedBearers, std::string handoverEventListName, bool useUdp, std::string schedulerType, bool admitHo, bool useIdealRrc)
 {
   std::ostringstream oss;
-  oss << " nUes=" << nUes 
-      << " nDedicatedBearers=" << nDedicatedBearers 
+  oss << " nUes=" << nUes
+      << " nDedicatedBearers=" << nDedicatedBearers
       << " udp=" << useUdp
       << " " << schedulerType
       << " admitHo=" << admitHo
@@ -168,7 +168,7 @@
   else
     {
       oss << ", real RRC";
-    }  
+    }
   return oss.str ();
 }
 
@@ -187,7 +187,7 @@
     m_statsDuration (Seconds (0.1)),
     m_udpClientInterval (Seconds (0.01)),
     m_udpClientPktSize (100)
-    
+
 {
 }
 
@@ -198,20 +198,28 @@
 
   Config::Reset ();
   Config::SetDefault ("ns3::UdpClient::Interval",  TimeValue (m_udpClientInterval));
-  Config::SetDefault ("ns3::UdpClient::MaxPackets", UintegerValue (1000000));  
-  Config::SetDefault ("ns3::UdpClient::PacketSize", UintegerValue (m_udpClientPktSize));  
+  Config::SetDefault ("ns3::UdpClient::MaxPackets", UintegerValue (1000000));
+  Config::SetDefault ("ns3::UdpClient::PacketSize", UintegerValue (m_udpClientPktSize));
 
   //Disable Uplink Power Control
   Config::SetDefault ("ns3::LteUePhy::EnableUplinkPowerControl", BooleanValue (false));
 
+  Config::SetDefault ("ns3::PointToPointEpcHelper::S1apLinkDelay", TimeValue(Seconds(0)));
+
+  Config::SetDefault ("ns3::LteEnbRrc::SrsPeriodicity", UintegerValue (40));
+
   int64_t stream = 1;
-  
+
   m_lteHelper = CreateObject<LteHelper> ();
   m_lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
   m_lteHelper->SetSchedulerType (m_schedulerType);
   m_lteHelper->SetHandoverAlgorithmType ("ns3::NoOpHandoverAlgorithm"); // disable automatic handover
   m_lteHelper->SetAttribute ("UseIdealRrc", BooleanValue (m_useIdealRrc));
-  
+
+  // set DL and UL bandwidth.
+  m_lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (25));
+  m_lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (25));
+
 
   NodeContainer enbNodes;
   enbNodes.Create (2);
@@ -221,7 +229,7 @@
   if (m_epc)
     {
       m_epcHelper = CreateObject<PointToPointEpcHelper> ();
-      m_lteHelper->SetEpcHelper (m_epcHelper);      
+      m_lteHelper->SetEpcHelper (m_epcHelper);
     }
 
   Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
@@ -234,7 +242,7 @@
   MobilityHelper mobility;
   mobility.SetPositionAllocator (positionAlloc);
   mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
-  mobility.Install (enbNodes);  
+  mobility.Install (enbNodes);
   mobility.Install (ueNodes);
 
   NetDeviceContainer enbDevices;
@@ -282,7 +290,7 @@
       Ptr<Ipv4StaticRouting> remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting (remoteHost->GetObject<Ipv4> ());
       remoteHostStaticRouting->AddNetworkRouteTo (Ipv4Address ("7.0.0.0"), Ipv4Mask ("255.0.0.0"), 1);
 
-      // Install the IP stack on the UEs      
+      // Install the IP stack on the UEs
       internet.Install (ueNodes);
       ueIpIfaces = m_epcHelper->AssignUeIpv4Address (NetDeviceContainer (ueDevices));
     }
@@ -290,25 +298,25 @@
   // attachment (needs to be done after IP stack configuration)
   // all UEs attached to eNB 0 at the beginning
   m_lteHelper->Attach (ueDevices, enbDevices.Get (0));
-   
+
   if (m_epc)
     {
       // always true: bool epcDl = true;
       // always true: bool epcUl = true;
       // the rest of this block is copied from lena-dual-stripe
 
-    
+
       // Install and start applications on UEs and remote host
       uint16_t dlPort = 10000;
       uint16_t ulPort = 20000;
 
       // randomize a bit start times to avoid simulation artifacts
       // (e.g., buffer overflows due to packet transmissions happening
-      // exactly at the same time) 
+      // exactly at the same time)
       Ptr<UniformRandomVariable> startTimeSeconds = CreateObject<UniformRandomVariable> ();
       startTimeSeconds->SetAttribute ("Min", DoubleValue (0));
       startTimeSeconds->SetAttribute ("Max", DoubleValue (0.010));
-      startTimeSeconds->SetStream (stream++);      
+      startTimeSeconds->SetStream (stream++);
 
       for (uint32_t u = 0; u < ueNodes.GetN (); ++u)
         {
@@ -318,7 +326,7 @@
           ueStaticRouting->SetDefaultRoute (m_epcHelper->GetUeDefaultGatewayAddress (), 1);
 
           UeData ueData;
-     
+
           for (uint32_t b = 0; b < m_nDedicatedBearers; ++b)
             {
               ++dlPort;
@@ -329,29 +337,29 @@
               BearerData bearerData;
 
               if (m_useUdp)
-                {              
+                {
                   // always true: if (epcDl)
                     {
                       UdpClientHelper dlClientHelper (ueIpIfaces.GetAddress (u), dlPort);
                       clientApps.Add (dlClientHelper.Install (remoteHost));
-                      PacketSinkHelper dlPacketSinkHelper ("ns3::UdpSocketFactory", 
+                      PacketSinkHelper dlPacketSinkHelper ("ns3::UdpSocketFactory",
                                                            InetSocketAddress (Ipv4Address::GetAny (), dlPort));
                       ApplicationContainer sinkContainer = dlPacketSinkHelper.Install (ue);
                       bearerData.dlSink = sinkContainer.Get (0)->GetObject<PacketSink> ();
                       serverApps.Add (sinkContainer);
-                      
+
                     }
                   // always true: if (epcUl)
-                    {      
+                    {
                       UdpClientHelper ulClientHelper (remoteHostAddr, ulPort);
                       clientApps.Add (ulClientHelper.Install (ue));
-                      PacketSinkHelper ulPacketSinkHelper ("ns3::UdpSocketFactory", 
+                      PacketSinkHelper ulPacketSinkHelper ("ns3::UdpSocketFactory",
                                                            InetSocketAddress (Ipv4Address::GetAny (), ulPort));
                       ApplicationContainer sinkContainer = ulPacketSinkHelper.Install (remoteHost);
                       bearerData.ulSink = sinkContainer.Get (0)->GetObject<PacketSink> ();
-                      serverApps.Add (sinkContainer);  
-                    }            
-                }                    
+                      serverApps.Add (sinkContainer);
+                    }
+                }
               else // use TCP
                 {
                   // always true: if (epcDl)
@@ -360,23 +368,23 @@
                                                      InetSocketAddress (ueIpIfaces.GetAddress (u), dlPort));
                       dlClientHelper.SetAttribute ("MaxBytes", UintegerValue (0));
                       clientApps.Add (dlClientHelper.Install (remoteHost));
-                      PacketSinkHelper dlPacketSinkHelper ("ns3::TcpSocketFactory", 
+                      PacketSinkHelper dlPacketSinkHelper ("ns3::TcpSocketFactory",
                                                            InetSocketAddress (Ipv4Address::GetAny (), dlPort));
                       ApplicationContainer sinkContainer = dlPacketSinkHelper.Install (ue);
                       bearerData.dlSink = sinkContainer.Get (0)->GetObject<PacketSink> ();
                       serverApps.Add (sinkContainer);
                     }
                   // always true: if (epcUl)
-                    {     
+                    {
                       BulkSendHelper ulClientHelper ("ns3::TcpSocketFactory",
                                                      InetSocketAddress (remoteHostAddr, ulPort));
-                      ulClientHelper.SetAttribute ("MaxBytes", UintegerValue (0));                  
+                      ulClientHelper.SetAttribute ("MaxBytes", UintegerValue (0));
                       clientApps.Add (ulClientHelper.Install (ue));
-                      PacketSinkHelper ulPacketSinkHelper ("ns3::TcpSocketFactory", 
+                      PacketSinkHelper ulPacketSinkHelper ("ns3::TcpSocketFactory",
                                                            InetSocketAddress (Ipv4Address::GetAny (), ulPort));
                       ApplicationContainer sinkContainer = ulPacketSinkHelper.Install (remoteHost);
                       bearerData.ulSink = sinkContainer.Get (0)->GetObject<PacketSink> ();
-                      serverApps.Add (sinkContainer);  
+                      serverApps.Add (sinkContainer);
                     }
                 } // end if (useUdp)
 
@@ -386,7 +394,7 @@
                   EpcTft::PacketFilter dlpf;
                   dlpf.localPortStart = dlPort;
                   dlpf.localPortEnd = dlPort;
-                  tft->Add (dlpf); 
+                  tft->Add (dlpf);
                 }
               // always true: if (epcUl)
                 {
@@ -412,7 +420,7 @@
           m_ueDataVector.push_back (ueData);
         }
 
-    } 
+    }
   else // (epc == false)
     {
       // for radio bearer activation purposes, consider together home UEs and macro UEs
@@ -435,49 +443,49 @@
   const Time maxRrcConnectionEstablishmentDuration = Seconds (0.080);
   for (NetDeviceContainer::Iterator it = ueDevices.Begin (); it != ueDevices.End (); ++it)
     {
-      Simulator::Schedule (maxRrcConnectionEstablishmentDuration, 
-                           &LteX2HandoverTestCase::CheckConnected, 
+      Simulator::Schedule (maxRrcConnectionEstablishmentDuration,
+                           &LteX2HandoverTestCase::CheckConnected,
                            this, *it, enbDevices.Get (0));
     }
-  
+
   // schedule handover events and corresponding checks
 
-  Time stopTime = Seconds (0);  
+  Time stopTime = Seconds (0);
   for (std::list<HandoverEvent>::iterator hoEventIt = m_handoverEventList.begin ();
        hoEventIt != m_handoverEventList.end ();
        ++hoEventIt)
     {
-      Simulator::Schedule (hoEventIt->startTime, 
-                           &LteX2HandoverTestCase::CheckConnected, 
-                           this, 
-                           ueDevices.Get (hoEventIt->ueDeviceIndex), 
+      Simulator::Schedule (hoEventIt->startTime,
+                           &LteX2HandoverTestCase::CheckConnected,
+                           this,
+                           ueDevices.Get (hoEventIt->ueDeviceIndex),
                            enbDevices.Get (hoEventIt->sourceEnbDeviceIndex));
-      m_lteHelper->HandoverRequest (hoEventIt->startTime, 
+      m_lteHelper->HandoverRequest (hoEventIt->startTime,
                                     ueDevices.Get (hoEventIt->ueDeviceIndex),
                                     enbDevices.Get (hoEventIt->sourceEnbDeviceIndex),
                                     enbDevices.Get (hoEventIt->targetEnbDeviceIndex));
       Time hoEndTime = hoEventIt->startTime + m_maxHoDuration;
-      Simulator::Schedule (hoEndTime, 
-                           &LteX2HandoverTestCase::CheckConnected, 
-                           this, 
-                           ueDevices.Get (hoEventIt->ueDeviceIndex), 
+      Simulator::Schedule (hoEndTime,
+                           &LteX2HandoverTestCase::CheckConnected,
+                           this,
+                           ueDevices.Get (hoEventIt->ueDeviceIndex),
                            enbDevices.Get (m_admitHo ? hoEventIt->targetEnbDeviceIndex : hoEventIt->sourceEnbDeviceIndex));
       Simulator::Schedule (hoEndTime, &LteX2HandoverTestCase::SaveStatsAfterHandover,
                            this, hoEventIt->ueDeviceIndex);
 
       Time checkStatsAfterHoTime = hoEndTime + m_statsDuration;
-      Simulator::Schedule (checkStatsAfterHoTime, &LteX2HandoverTestCase::CheckStatsAWhileAfterHandover, 
-                           this, hoEventIt->ueDeviceIndex);      
+      Simulator::Schedule (checkStatsAfterHoTime, &LteX2HandoverTestCase::CheckStatsAWhileAfterHandover,
+                           this, hoEventIt->ueDeviceIndex);
       if (stopTime <= checkStatsAfterHoTime)
         {
           stopTime = checkStatsAfterHoTime + MilliSeconds (1);
         }
     }
-  
+
   // m_lteHelper->EnableRlcTraces ();
   // m_lteHelper->EnablePdcpTraces();
 
- 
+
   Simulator::Stop (stopTime);
 
   Simulator::Run ();
@@ -486,7 +494,7 @@
 
 }
 
-void 
+void
 LteX2HandoverTestCase::CheckConnected (Ptr<NetDevice> ueDevice, Ptr<NetDevice> enbDevice)
 {
   Ptr<LteUeNetDevice> ueLteDevice = ueDevice->GetObject<LteUeNetDevice> ();
@@ -497,7 +505,7 @@
   Ptr<LteEnbNetDevice> enbLteDevice = enbDevice->GetObject<LteEnbNetDevice> ();
   Ptr<LteEnbRrc> enbRrc = enbLteDevice->GetRrc ();
   uint16_t rnti = ueRrc->GetRnti ();
-  Ptr<UeManager> ueManager = enbRrc->GetUeManager (rnti);  
+  Ptr<UeManager> ueManager = enbRrc->GetUeManager (rnti);
   NS_TEST_ASSERT_MSG_NE (ueManager, 0, "RNTI " << rnti << " not found in eNB");
 
   UeManager::State ueManagerState = ueManager->GetState ();
@@ -526,11 +534,11 @@
 
   ObjectMapValue enbDataRadioBearerMapValue;
   ueManager->GetAttribute ("DataRadioBearerMap", enbDataRadioBearerMapValue);
-  NS_TEST_ASSERT_MSG_EQ (enbDataRadioBearerMapValue.GetN (), m_nDedicatedBearers + 1, "wrong num bearers at eNB");  
+  NS_TEST_ASSERT_MSG_EQ (enbDataRadioBearerMapValue.GetN (), m_nDedicatedBearers + 1, "wrong num bearers at eNB");
 
   ObjectMapValue ueDataRadioBearerMapValue;
   ueRrc->GetAttribute ("DataRadioBearerMap", ueDataRadioBearerMapValue);
-  NS_TEST_ASSERT_MSG_EQ (ueDataRadioBearerMapValue.GetN (), m_nDedicatedBearers + 1, "wrong num bearers at UE"); 
+  NS_TEST_ASSERT_MSG_EQ (ueDataRadioBearerMapValue.GetN (), m_nDedicatedBearers + 1, "wrong num bearers at UE");
 
   ObjectMapValue::Iterator enbBearerIt = enbDataRadioBearerMapValue.Begin ();
   ObjectMapValue::Iterator ueBearerIt = ueDataRadioBearerMapValue.Begin ();
@@ -545,15 +553,15 @@
       //NS_TEST_ASSERT_MSG_EQ (enbDrbInfo->m_rlcConfig, ueDrbInfo->m_rlcConfig, "rlcConfig differs");
       NS_TEST_ASSERT_MSG_EQ ((uint32_t) enbDrbInfo->m_logicalChannelIdentity, (uint32_t) ueDrbInfo->m_logicalChannelIdentity, "logicalChannelIdentity differs");
       //NS_TEST_ASSERT_MSG_EQ (enbDrbInfo->m_logicalChannelConfig, ueDrbInfo->m_logicalChannelConfig, "logicalChannelConfig differs");
- 
+
       ++enbBearerIt;
       ++ueBearerIt;
     }
   NS_ASSERT_MSG (enbBearerIt == enbDataRadioBearerMapValue.End (), "too many bearers at eNB");
-  NS_ASSERT_MSG (ueBearerIt == ueDataRadioBearerMapValue.End (), "too many bearers at UE");  
+  NS_ASSERT_MSG (ueBearerIt == ueDataRadioBearerMapValue.End (), "too many bearers at UE");
 }
 
-void 
+void
 LteX2HandoverTestCase::SaveStatsAfterHandover (uint32_t ueIndex)
 {
   for (std::list<BearerData>::iterator it = m_ueDataVector.at (ueIndex).bearerDataList.begin ();
@@ -565,16 +573,16 @@
     }
 }
 
-void 
+void
 LteX2HandoverTestCase::CheckStatsAWhileAfterHandover (uint32_t ueIndex)
-{      
+{
   uint32_t b = 1;
   for (std::list<BearerData>::iterator it = m_ueDataVector.at (ueIndex).bearerDataList.begin ();
        it != m_ueDataVector.at (ueIndex).bearerDataList.end ();
        ++it)
     {
       uint32_t dlRx = it->dlSink->GetTotalRx () - it->dlOldTotalRx;
-      uint32_t ulRx = it->ulSink->GetTotalRx () - it->ulOldTotalRx;                       
+      uint32_t ulRx = it->ulSink->GetTotalRx () - it->ulOldTotalRx;
       uint32_t expectedBytes = m_udpClientPktSize * (m_statsDuration.GetSeconds () / m_udpClientInterval.GetSeconds ());
       //                           tolerance
       NS_TEST_ASSERT_MSG_GT (dlRx,   0.500 * expectedBytes, "too few RX bytes in DL, ue=" << ueIndex << ", b=" << b);
@@ -589,7 +597,7 @@
  * \ingroup tests
  *
  * \brief Lte X2 Handover Test Suite
- */ 
+ */
 class LteX2HandoverTestSuite : public TestSuite
 {
 public:
@@ -605,31 +613,31 @@
   // bwd means handover from enb 1 to enb 0
 
   HandoverEvent ue1fwd;
-  ue1fwd.startTime = MilliSeconds (100); 
+  ue1fwd.startTime = MilliSeconds (100);
   ue1fwd.ueDeviceIndex = 0;
   ue1fwd.sourceEnbDeviceIndex = 0;
   ue1fwd.targetEnbDeviceIndex = 1;
 
   HandoverEvent ue1bwd;
-  ue1bwd.startTime = MilliSeconds (300); 
+  ue1bwd.startTime = MilliSeconds (300);
   ue1bwd.ueDeviceIndex = 0;
   ue1bwd.sourceEnbDeviceIndex = 1;
   ue1bwd.targetEnbDeviceIndex = 0;
 
   HandoverEvent ue1fwdagain;
-  ue1fwdagain.startTime = MilliSeconds (500); 
+  ue1fwdagain.startTime = MilliSeconds (500);
   ue1fwdagain.ueDeviceIndex = 0;
   ue1fwdagain.sourceEnbDeviceIndex = 0;
   ue1fwdagain.targetEnbDeviceIndex = 1;
 
   HandoverEvent ue2fwd;
-  ue2fwd.startTime = MilliSeconds (110); 
+  ue2fwd.startTime = MilliSeconds (110);
   ue2fwd.ueDeviceIndex = 1;
   ue2fwd.sourceEnbDeviceIndex = 0;
   ue2fwd.targetEnbDeviceIndex = 1;
 
   HandoverEvent ue2bwd;
-  ue2bwd.startTime = MilliSeconds (250); 
+  ue2bwd.startTime = MilliSeconds (250);
   ue2bwd.ueDeviceIndex = 1;
   ue2bwd.sourceEnbDeviceIndex = 1;
   ue2bwd.targetEnbDeviceIndex = 0;
diff -Naru a/test/test-lte-x2-handover-measures.cc b/test/test-lte-x2-handover-measures.cc
--- a/test/test-lte-x2-handover-measures.cc	2018-08-03 16:38:46.695807196 +0200
+++ b/test/test-lte-x2-handover-measures.cc	2018-08-03 16:39:02.899957745 +0200
@@ -53,7 +53,7 @@
    * \param interval the interval time
    * \param ueIndex the UE index
    * \param enbIndex the ENB index
-   */ 
+   */
   CheckPointEvent (Time start, Time stop, Time interval, uint32_t ueIndex, uint32_t enbIndex)
     : checkStartTime (start),
       checkStopTime (stop),
@@ -69,7 +69,7 @@
  * \ingroup lte-test
  * \ingroup tests
  *
- * \brief Test different X2 handover measures and algorithms, e.g. A2A4RsrqHandoverAlgorithm and 
+ * \brief Test different X2 handover measures and algorithms, e.g. A2A4RsrqHandoverAlgorithm and
  * A3RsrpHandoverAlgorithm. Test defines different handover parameters and scenario configurations.
  */
 class LteX2HandoverMeasuresTestCase : public TestCase
@@ -104,12 +104,12 @@
    * \param nEnbs number of eNBs in the test
    * \param nUes number of UEs in the test
    * \param nDedicatedBearers number of bearers to be activated per UE
-   * \param checkPointEventListName 
+   * \param checkPointEventListName
    * \param useUdp true if UDP is to be used, false if TCP is to be used
    * \param schedulerType the scheduler type
    * \param handoverAlgorithmType type of handover algorithm to be used (e.g. "ns3::A3RsrpHandoverAlgorithm")
    * \param admitHo
-   * \param useIdealRrc true if the ideal RRC should be used 
+   * \param useIdealRrc true if the ideal RRC should be used
    * \returns the name string
    */
   static std::string BuildNameString (uint32_t nEnbs, uint32_t nUes, uint32_t nDedicatedBearers,
@@ -144,7 +144,7 @@
  * \ingroup tests
  *
  * \brief BearerData structure
- */ 
+ */
   struct BearerData
   {
     uint32_t bid; ///< BID
@@ -159,7 +159,7 @@
  * \ingroup tests
  *
  * \brief UeData structure
- */ 
+ */
   struct UeData
   {
     uint32_t id; ///< ID
@@ -169,12 +169,12 @@
   /**
    * \brief Save stats  function
    * \param ueIndex the index of the UE
-   */ 
+   */
   void SaveStats (uint32_t ueIndex);
   /**
    * \brief Check stats  function
    * \param ueIndex the index of the UE
-   */ 
+   */
   void CheckStats (uint32_t ueIndex);
 
   std::vector<UeData> m_ueDataVector; ///< UE data vector
@@ -255,6 +255,7 @@
   Config::SetDefault ("ns3::UdpClient::PacketSize", UintegerValue (m_udpClientPktSize));
   Config::SetDefault ("ns3::LteEnbRrc::HandoverJoiningTimeoutDuration", TimeValue (MilliSeconds (200)));
   Config::SetDefault ("ns3::LteEnbPhy::TxPower", DoubleValue (20));
+  Config::SetDefault ("ns3::PointToPointEpcHelper::S1apLinkDelay", TimeValue(Seconds(0)));
 
   //Disable Uplink Power Control
   Config::SetDefault ("ns3::LteUePhy::EnableUplinkPowerControl", BooleanValue (false));
diff -Naru a/wscript b/wscript
--- a/wscript	2018-08-03 16:38:46.695807196 +0200
+++ b/wscript	2018-08-03 16:39:02.899957745 +0200
@@ -90,6 +90,7 @@
         'model/epc-x2-sap.cc',
         'model/epc-x2-header.cc',
         'model/epc-x2.cc',
+        'model/epc-x2-tag.cc',
         'model/epc-tft.cc',
         'model/epc-tft-classifier.cc',
         'model/lte-mi-error-model.cc',
@@ -97,6 +98,7 @@
         'model/epc-enb-s1-sap.cc',
         'model/epc-s1ap-sap.cc',
         'model/epc-s11-sap.cc',
+        'model/epc-s1ap.cc',
         'model/lte-as-sap.cc',
         'model/epc-ue-nas.cc',
         'model/lte-harq-phy.cc',
@@ -122,8 +124,8 @@
         'model/lte-ffr-distributed-algorithm.cc',
         'model/lte-ue-power-control.cc',
         'model/lte-ccm-rrc-sap.cc',
-        'model/lte-ue-ccm-rrc-sap.cc', 
-        'model/lte-ccm-mac-sap.cc', 
+        'model/lte-ue-ccm-rrc-sap.cc',
+        'model/lte-ccm-mac-sap.cc',
         'model/lte-enb-component-carrier-manager.cc',
         'model/lte-ue-component-carrier-manager.cc',
         'model/no-op-component-carrier-manager.cc',
@@ -131,7 +133,14 @@
         'model/component-carrier.cc',
         'helper/cc-helper.cc',
         'model/component-carrier-ue.cc',
-        'model/component-carrier-enb.cc'
+        'model/component-carrier-enb.cc',
+        'model/lte-rlc-um-lowlat.cc',
+        'model/epc-mme-application.cc',
+        'model/epc-s1ap-header.cc',
+        'model/mc-enb-pdcp.cc',
+        'model/mc-ue-pdcp.cc',
+        'helper/retx-stats-calculator.cc',
+        'helper/mac-tx-stats-calculator.cc'
         ]
 
     module_test = bld.create_ns3_module_test_library('lte')
@@ -282,12 +291,15 @@
         'model/epc-x2-sap.h',
         'model/epc-x2-header.h',
         'model/epc-x2.h',
+        'model/epc-x2-tag.h',
         'model/epc-tft.h',
         'model/epc-tft-classifier.h',
         'model/lte-mi-error-model.h',
         'model/epc-enb-s1-sap.h',
         'model/epc-s1ap-sap.h',
         'model/epc-s11-sap.h',
+        'model/epc-s1ap.h',
+        'model/epc-mme-application.h',
         'model/lte-as-sap.h',
         'model/epc-ue-nas.h',
         'model/lte-harq-phy.h',
@@ -312,9 +324,15 @@
         'model/lte-ffr-enhanced-algorithm.h',
         'model/lte-ffr-distributed-algorithm.h',
         'model/lte-ue-power-control.h',
+        'model/lte-rlc-um-lowlat.h',
+        'model/epc-s1ap-header.h',
+        'model/mc-enb-pdcp.h',
+        'model/mc-ue-pdcp.h',
+        'helper/retx-stats-calculator.h',
+        'helper/mac-tx-stats-calculator.h',
         'model/lte-ccm-rrc-sap.h',
-        'model/lte-ue-ccm-rrc-sap.h', 
-        'model/lte-ccm-mac-sap.h', 
+        'model/lte-ue-ccm-rrc-sap.h',
+        'model/lte-ccm-mac-sap.h',
         'model/lte-enb-component-carrier-manager.h',
         'model/lte-ue-component-carrier-manager.h',
         'model/no-op-component-carrier-manager.h',
